// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/clarifai/api/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

///  Split the results into pages.
// @@protoc_insertion_point(message:clarifai.api.Pagination)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pagination {
    // message fields
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.Pagination.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
    // @@protoc_insertion_point(field:clarifai.api.Pagination.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &Pagination| { &m.page },
            |m: &mut Pagination| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &Pagination| { &m.per_page },
            |m: &mut Pagination| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page = is.read_uint32()?;
                },
                16 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.page != 0 {
            os.write_uint32(1, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationRequest
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAnnotationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.annotation_id)
    pub annotation_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationRequest {
    fn default() -> &'a GetAnnotationRequest {
        <GetAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationRequest {
    pub fn new() -> GetAnnotationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationRequest| { &m.user_app_id },
            |m: &mut GetAnnotationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_id",
            |m: &GetAnnotationRequest| { &m.annotation_id },
            |m: &mut GetAnnotationRequest| { &mut m.annotation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetAnnotationRequest| { &m.input_id },
            |m: &mut GetAnnotationRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationRequest>(
            "GetAnnotationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationRequest {
    const NAME: &'static str = "GetAnnotationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(2, &self.annotation_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationRequest {
        GetAnnotationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationRequest {
        static instance: GetAnnotationRequest = GetAnnotationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationsRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List annotations for these IDs
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    ///  List annotations for these Input IDs
    ///  Note that 'ids' are optional but if the are provided the number and order in
    ///  'ids' and 'input_ids' should match
    ///  If you do not specify 'ids' all the annotations for 'input_ids' are returned
    ///  If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these user IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If model_version_ids are also provided these user_ids are OR'd with them as well since
    ///  annotations are either provided by users or model versions and we want the union of any
    ///  provided user or model version annotations in the results of ListAnnotations request.
    ///  If no user_ids are provided then annotations from all users are returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these model version IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If user_ids are also provided these model_versions_ids are OR'd with them as well since
    ///  annotations are either provided by users or model versions and we want the union of any
    ///  provided user or model version annotations in the results of ListAnnotations request.
    ///  If no model_version_ids are provided then annotations from all model versions are returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.model_version_ids)
    pub model_version_ids: ::std::vec::Vec<::std::string::String>,
    ///  Set status to filter by a list of statuses
    ///  If not statuses are provided then annotations with any status will be returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.statuses)
    pub statuses: ::std::vec::Vec<super::status::Status>,
    ///  Set this flag to list both trusted and not trusted annotations
    ///  by default it's listing only trusted annotations
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.list_all_annotations)
    pub list_all_annotations: bool,
    ///  Set this flag to return the model output for model annotations in the response.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.return_model_output)
    pub return_model_output: bool,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.per_page)
    pub per_page: u32,
    ///  Flag to filter annotations by task_id
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.task_id)
    pub task_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationsRequest {
    fn default() -> &'a ListAnnotationsRequest {
        <ListAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationsRequest {
    pub fn new() -> ListAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationsRequest| { &m.user_app_id },
            |m: &mut ListAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListAnnotationsRequest| { &m.ids },
            |m: &mut ListAnnotationsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &ListAnnotationsRequest| { &m.input_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.input_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &ListAnnotationsRequest| { &m.user_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_ids",
            |m: &ListAnnotationsRequest| { &m.model_version_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.model_version_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &ListAnnotationsRequest| { &m.statuses },
            |m: &mut ListAnnotationsRequest| { &mut m.statuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_all_annotations",
            |m: &ListAnnotationsRequest| { &m.list_all_annotations },
            |m: &mut ListAnnotationsRequest| { &mut m.list_all_annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_model_output",
            |m: &ListAnnotationsRequest| { &m.return_model_output },
            |m: &mut ListAnnotationsRequest| { &mut m.return_model_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationsRequest| { &m.page },
            |m: &mut ListAnnotationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationsRequest| { &m.per_page },
            |m: &mut ListAnnotationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &ListAnnotationsRequest| { &m.task_id },
            |m: &mut ListAnnotationsRequest| { &mut m.task_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationsRequest>(
            "ListAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationsRequest {
    const NAME: &'static str = "ListAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                74 => {
                    self.user_ids.push(is.read_string()?);
                },
                82 => {
                    self.model_version_ids.push(is.read_string()?);
                },
                42 => {
                    self.statuses.push(is.read_message()?);
                },
                48 => {
                    self.list_all_annotations = is.read_bool()?;
                },
                96 => {
                    self.return_model_output = is.read_bool()?;
                },
                56 => {
                    self.page = is.read_uint32()?;
                },
                64 => {
                    self.per_page = is.read_uint32()?;
                },
                90 => {
                    self.task_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.model_version_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.list_all_annotations != false {
            my_size += 1 + 1;
        }
        if self.return_model_output != false {
            my_size += 1 + 1;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.per_page);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.user_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.model_version_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.statuses {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.list_all_annotations != false {
            os.write_bool(6, self.list_all_annotations)?;
        }
        if self.return_model_output != false {
            os.write_bool(12, self.return_model_output)?;
        }
        if self.page != 0 {
            os.write_uint32(7, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(8, self.per_page)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(11, &self.task_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationsRequest {
        ListAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.user_ids.clear();
        self.model_version_ids.clear();
        self.statuses.clear();
        self.list_all_annotations = false;
        self.return_model_output = false;
        self.page = 0;
        self.per_page = 0;
        self.task_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationsRequest {
        static instance: ListAnnotationsRequest = ListAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            input_ids: ::std::vec::Vec::new(),
            user_ids: ::std::vec::Vec::new(),
            model_version_ids: ::std::vec::Vec::new(),
            statuses: ::std::vec::Vec::new(),
            list_all_annotations: false,
            return_model_output: false,
            page: 0,
            per_page: 0,
            task_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostAnnotationsRequest
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsRequest.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsRequest {
    fn default() -> &'a PostAnnotationsRequest {
        <PostAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsRequest {
    pub fn new() -> PostAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationsRequest| { &m.user_app_id },
            |m: &mut PostAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &PostAnnotationsRequest| { &m.annotations },
            |m: &mut PostAnnotationsRequest| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationsRequest>(
            "PostAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationsRequest {
    const NAME: &'static str = "PostAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationsRequest {
        PostAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationsRequest {
        static instance: PostAnnotationsRequest = PostAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.action)
    pub action: ::std::string::String,
    ///  If the request is a "remove" action and the annotation is left with empty data,
    ///  then setting delete_if_empty_data to true will delete the annotation,
    ///  if possible (for example, will not delete an input-level annotation).
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.delete_if_empty_data)
    pub delete_if_empty_data: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsRequest {
    fn default() -> &'a PatchAnnotationsRequest {
        <PatchAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsRequest {
    pub fn new() -> PatchAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &PatchAnnotationsRequest| { &m.annotations },
            |m: &mut PatchAnnotationsRequest| { &mut m.annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsRequest| { &m.action },
            |m: &mut PatchAnnotationsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_if_empty_data",
            |m: &PatchAnnotationsRequest| { &m.delete_if_empty_data },
            |m: &mut PatchAnnotationsRequest| { &mut m.delete_if_empty_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsRequest>(
            "PatchAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsRequest {
    const NAME: &'static str = "PatchAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                32 => {
                    self.delete_if_empty_data = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if self.delete_if_empty_data != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if self.delete_if_empty_data != false {
            os.write_bool(4, self.delete_if_empty_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsRequest {
        PatchAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.action.clear();
        self.delete_if_empty_data = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsRequest {
        static instance: PatchAnnotationsRequest = PatchAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            delete_if_empty_data: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsStatusRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsStatusRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Filter by user IDs
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter by task ID
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.task_id)
    pub task_id: ::std::string::String,
    ///  Filter by Status codes
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.status_codes)
    pub status_codes: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::status_code::StatusCode>>,
    ///  'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.action)
    pub action: ::std::string::String,
    ///  Update filtered annotations to this status
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.status_code)
    pub status_code: ::protobuf::EnumOrUnknown<super::status_code::StatusCode>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusRequest {
    fn default() -> &'a PatchAnnotationsStatusRequest {
        <PatchAnnotationsStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusRequest {
    pub fn new() -> PatchAnnotationsStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsStatusRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &PatchAnnotationsStatusRequest| { &m.user_ids },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &PatchAnnotationsStatusRequest| { &m.task_id },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "status_codes",
            |m: &PatchAnnotationsStatusRequest| { &m.status_codes },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_codes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsStatusRequest| { &m.action },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code",
            |m: &PatchAnnotationsStatusRequest| { &m.status_code },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsStatusRequest>(
            "PatchAnnotationsStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusRequest {
    const NAME: &'static str = "PatchAnnotationsStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                34 => {
                    self.task_id = is.read_string()?;
                },
                48 => {
                    self.status_codes.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.status_codes)?
                },
                42 => {
                    self.action = is.read_string()?;
                },
                16 => {
                    self.status_code = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.task_id);
        }
        for value in &self.status_codes {
            my_size += ::protobuf::rt::int32_size(6, value.value());
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.action);
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            my_size += ::protobuf::rt::int32_size(2, self.status_code.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        if !self.task_id.is_empty() {
            os.write_string(4, &self.task_id)?;
        }
        for v in &self.status_codes {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.action.is_empty() {
            os.write_string(5, &self.action)?;
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status_code))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsStatusRequest {
        PatchAnnotationsStatusRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.user_ids.clear();
        self.task_id.clear();
        self.status_codes.clear();
        self.action.clear();
        self.status_code = ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsStatusRequest {
        static instance: PatchAnnotationsStatusRequest = PatchAnnotationsStatusRequest {
            user_app_id: ::protobuf::MessageField::none(),
            user_ids: ::std::vec::Vec::new(),
            task_id: ::std::string::String::new(),
            status_codes: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            status_code: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsStatusResponse
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.updated_count)
    pub updated_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusResponse {
    fn default() -> &'a PatchAnnotationsStatusResponse {
        <PatchAnnotationsStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusResponse {
    pub fn new() -> PatchAnnotationsStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PatchAnnotationsStatusResponse| { &m.status },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &PatchAnnotationsStatusResponse| { &m.user_ids },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_count",
            |m: &PatchAnnotationsStatusResponse| { &m.updated_count },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.updated_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsStatusResponse>(
            "PatchAnnotationsStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusResponse {
    const NAME: &'static str = "PatchAnnotationsStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.user_ids.push(is.read_string()?);
                },
                24 => {
                    self.updated_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.updated_count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.updated_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if self.updated_count != 0 {
            os.write_uint32(3, self.updated_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsStatusResponse {
        PatchAnnotationsStatusResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user_ids.clear();
        self.updated_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsStatusResponse {
        static instance: PatchAnnotationsStatusResponse = PatchAnnotationsStatusResponse {
            status: ::protobuf::MessageField::none(),
            user_ids: ::std::vec::Vec::new(),
            updated_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAnnotationRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.input_id)
    pub input_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.annotation_id)
    pub annotation_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationRequest {
    fn default() -> &'a DeleteAnnotationRequest {
        <DeleteAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationRequest {
    pub fn new() -> DeleteAnnotationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &DeleteAnnotationRequest| { &m.input_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.input_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_id",
            |m: &DeleteAnnotationRequest| { &m.annotation_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.annotation_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationRequest>(
            "DeleteAnnotationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationRequest {
    const NAME: &'static str = "DeleteAnnotationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                26 => {
                    self.annotation_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.annotation_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(3, &self.annotation_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationRequest {
        DeleteAnnotationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.annotation_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationRequest {
        static instance: DeleteAnnotationRequest = DeleteAnnotationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            annotation_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Delete annotations with IDs
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    ///  Delete annotations for these Input IDs
    ///  Note that 'ids' are optional but if the are provided the number and order in
    ///  'ids' and 'input_ids' should match
    ///  If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
    ///  However you need to specify at least one value for 'input_ids'
    ///  i.e. this API does not support deleting all annotations
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationsRequest {
    fn default() -> &'a DeleteAnnotationsRequest {
        <DeleteAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationsRequest {
    pub fn new() -> DeleteAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationsRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteAnnotationsRequest| { &m.ids },
            |m: &mut DeleteAnnotationsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &DeleteAnnotationsRequest| { &m.input_ids },
            |m: &mut DeleteAnnotationsRequest| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationsRequest>(
            "DeleteAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationsRequest {
    const NAME: &'static str = "DeleteAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationsRequest {
        DeleteAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationsRequest {
        static instance: DeleteAnnotationsRequest = DeleteAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAnnotationResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAnnotationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationResponse.annotation)
    pub annotation: ::protobuf::MessageField<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationResponse {
    fn default() -> &'a SingleAnnotationResponse {
        <SingleAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationResponse {
    pub fn new() -> SingleAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAnnotationResponse| { &m.status },
            |m: &mut SingleAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Annotation>(
            "annotation",
            |m: &SingleAnnotationResponse| { &m.annotation },
            |m: &mut SingleAnnotationResponse| { &mut m.annotation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAnnotationResponse>(
            "SingleAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAnnotationResponse {
    const NAME: &'static str = "SingleAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAnnotationResponse {
        SingleAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAnnotationResponse {
        static instance: SingleAnnotationResponse = SingleAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            annotation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationResponse.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationResponse {
    fn default() -> &'a MultiAnnotationResponse {
        <MultiAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationResponse {
    pub fn new() -> MultiAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationResponse| { &m.status },
            |m: &mut MultiAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &MultiAnnotationResponse| { &m.annotations },
            |m: &mut MultiAnnotationResponse| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationResponse>(
            "MultiAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationResponse {
    const NAME: &'static str = "MultiAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationResponse {
        MultiAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationResponse {
        static instance: MultiAnnotationResponse = MultiAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationWorkersRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationWorkersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationWorkersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported: all, names
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  (optional URL parameter) Only list workers that have created trusted annotations.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.trusted_only)
    pub trusted_only: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationWorkersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationWorkersRequest {
    fn default() -> &'a ListAnnotationWorkersRequest {
        <ListAnnotationWorkersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationWorkersRequest {
    pub fn new() -> ListAnnotationWorkersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationWorkersRequest| { &m.user_app_id },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationWorkersRequest| { &m.page },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationWorkersRequest| { &m.per_page },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListAnnotationWorkersRequest| { &m.additional_fields },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trusted_only",
            |m: &ListAnnotationWorkersRequest| { &m.trusted_only },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.trusted_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationWorkersRequest>(
            "ListAnnotationWorkersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationWorkersRequest {
    const NAME: &'static str = "ListAnnotationWorkersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.trusted_only = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.trusted_only != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(4, &v)?;
        };
        if self.trusted_only != false {
            os.write_bool(5, self.trusted_only)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationWorkersRequest {
        ListAnnotationWorkersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.trusted_only = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationWorkersRequest {
        static instance: ListAnnotationWorkersRequest = ListAnnotationWorkersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            trusted_only: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationWorkersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationWorkersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationWorkersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationWorkersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkerResponse
// @@protoc_insertion_point(message:clarifai.api.MultiWorkerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiWorkerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkerResponse.workers)
    pub workers: ::std::vec::Vec<super::resources::Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkerResponse {
    fn default() -> &'a MultiWorkerResponse {
        <MultiWorkerResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkerResponse {
    pub fn new() -> MultiWorkerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkerResponse| { &m.status },
            |m: &mut MultiWorkerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workers",
            |m: &MultiWorkerResponse| { &m.workers },
            |m: &mut MultiWorkerResponse| { &mut m.workers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkerResponse>(
            "MultiWorkerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkerResponse {
    const NAME: &'static str = "MultiWorkerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkerResponse {
        MultiWorkerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkerResponse {
        static instance: MultiWorkerResponse = MultiWorkerResponse {
            status: ::protobuf::MessageField::none(),
            workers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAppRequest
// @@protoc_insertion_point(message:clarifai.api.GetAppRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetAppRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAppRequest {
    fn default() -> &'a GetAppRequest {
        <GetAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppRequest {
    pub fn new() -> GetAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAppRequest| { &m.user_app_id },
            |m: &mut GetAppRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetAppRequest| { &m.additional_fields },
            |m: &mut GetAppRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAppRequest>(
            "GetAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAppRequest {
    const NAME: &'static str = "GetAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAppRequest {
        GetAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAppRequest {
        static instance: GetAppRequest = GetAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAppsRequest
// @@protoc_insertion_point(message:clarifai.api.ListAppsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  If true, we only return apps that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return apps that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.starred_only)
    pub starred_only: bool,
    ///  If true, we only return apps that are marked as a template by the app owner.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.template_only)
    pub template_only: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the application:
    ///    - id
    ///    - name
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.search)
    pub search: ::std::string::String,
    ///  Query various text fields (id, name, description, and notes) that can contain the words in the query string
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the id, name and notes of the app. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.name)
    pub name: ::std::string::String,
    ///  Filter by the user-unique-id of the app. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.id)
    pub id: ::std::string::String,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_apps_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppsRequest {
    fn default() -> &'a ListAppsRequest {
        <ListAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppsRequest {
    pub fn new() -> ListAppsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_name = 6;

    pub fn sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(v))
    }

    // bool sort_by_modified_at = 7;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 12;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 13;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppsRequest| { &m.user_app_id },
            |m: &mut ListAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppsRequest| { &m.page },
            |m: &mut ListAppsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppsRequest| { &m.per_page },
            |m: &mut ListAppsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListAppsRequest| { &m.additional_fields },
            |m: &mut ListAppsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListAppsRequest| { &m.sort_ascending },
            |m: &mut ListAppsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_name",
            ListAppsRequest::has_sort_by_name,
            ListAppsRequest::sort_by_name,
            ListAppsRequest::set_sort_by_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListAppsRequest::has_sort_by_modified_at,
            ListAppsRequest::sort_by_modified_at,
            ListAppsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListAppsRequest::has_sort_by_created_at,
            ListAppsRequest::sort_by_created_at,
            ListAppsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListAppsRequest::has_sort_by_star_count,
            ListAppsRequest::sort_by_star_count,
            ListAppsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListAppsRequest| { &m.featured_only },
            |m: &mut ListAppsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListAppsRequest| { &m.starred_only },
            |m: &mut ListAppsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "template_only",
            |m: &ListAppsRequest| { &m.template_only },
            |m: &mut ListAppsRequest| { &mut m.template_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListAppsRequest| { &m.search },
            |m: &mut ListAppsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListAppsRequest| { &m.query },
            |m: &mut ListAppsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListAppsRequest| { &m.name },
            |m: &mut ListAppsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListAppsRequest| { &m.id },
            |m: &mut ListAppsRequest| { &mut m.id },
        ));
        oneofs.push(list_apps_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppsRequest>(
            "ListAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppsRequest {
    const NAME: &'static str = "ListAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                82 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.sort_ascending = is.read_bool()?;
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                96 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.featured_only = is.read_bool()?;
                },
                88 => {
                    self.starred_only = is.read_bool()?;
                },
                128 => {
                    self.template_only = is.read_bool()?;
                },
                122 => {
                    self.search = is.read_string()?;
                },
                66 => {
                    self.query = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                114 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.featured_only != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.template_only != false {
            my_size += 2 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.search);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.id);
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_apps_request::Sort_by::SortByName(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        if self.template_only != false {
            os.write_bool(16, self.template_only)?;
        }
        if !self.search.is_empty() {
            os.write_string(15, &self.search)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(14, &self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_apps_request::Sort_by::SortByName(v) => {
                    os.write_bool(6, v)?;
                },
                &list_apps_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_apps_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(12, v)?;
                },
                &list_apps_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(13, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppsRequest {
        ListAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.featured_only = false;
        self.starred_only = false;
        self.template_only = false;
        self.search.clear();
        self.query.clear();
        self.name.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppsRequest {
        static instance: ListAppsRequest = ListAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            featured_only: false,
            starred_only: false,
            template_only: false,
            search: ::std::string::String::new(),
            query: ::std::string::String::new(),
            name: ::std::string::String::new(),
            id: ::std::string::String::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListAppsRequest`
pub mod list_apps_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListAppsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_name)
        SortByName(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListAppsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostAppsRequest
// @@protoc_insertion_point(message:clarifai.api.PostAppsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAppsRequest.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppsRequest {
    fn default() -> &'a PostAppsRequest {
        <PostAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsRequest {
    pub fn new() -> PostAppsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppsRequest| { &m.user_app_id },
            |m: &mut PostAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &PostAppsRequest| { &m.apps },
            |m: &mut PostAppsRequest| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppsRequest>(
            "PostAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppsRequest {
    const NAME: &'static str = "PostAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppsRequest {
        PostAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppsRequest {
        static instance: PostAppsRequest = PostAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAppRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteAppRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAppRequest {
    fn default() -> &'a DeleteAppRequest {
        <DeleteAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAppRequest {
    pub fn new() -> DeleteAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAppRequest| { &m.user_app_id },
            |m: &mut DeleteAppRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAppRequest>(
            "DeleteAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAppRequest {
    const NAME: &'static str = "DeleteAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAppRequest {
        DeleteAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAppRequest {
        static instance: DeleteAppRequest = DeleteAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAppsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    ///  The action to perform on the patched App objects except App.Metadata
    ///  Supported values: 'overwrite' and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the app image by setting
    ///  'image.url' in the request to the current value returned for that app.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.action)
    pub action: ::std::string::String,
    ///  The action to perform on the patched App.Metadata
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.metadata_action)
    pub metadata_action: ::protobuf::MessageField<super::resources::PatchAction>,
    ///  If set, the app will be automatically reindexed upon change of its base workflow.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.reindex)
    pub reindex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppsRequest {
    fn default() -> &'a PatchAppsRequest {
        <PatchAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsRequest {
    pub fn new() -> PatchAppsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppsRequest| { &m.user_app_id },
            |m: &mut PatchAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &PatchAppsRequest| { &m.apps },
            |m: &mut PatchAppsRequest| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppsRequest| { &m.action },
            |m: &mut PatchAppsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PatchAction>(
            "metadata_action",
            |m: &PatchAppsRequest| { &m.metadata_action },
            |m: &mut PatchAppsRequest| { &mut m.metadata_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex",
            |m: &PatchAppsRequest| { &m.reindex },
            |m: &mut PatchAppsRequest| { &mut m.reindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppsRequest>(
            "PatchAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppsRequest {
    const NAME: &'static str = "PatchAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata_action)?;
                },
                40 => {
                    self.reindex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reindex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(v) = self.metadata_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppsRequest {
        PatchAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppsRequest {
        static instance: PatchAppsRequest = PatchAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            metadata_action: ::protobuf::MessageField::none(),
            reindex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAppRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    ///  The action to perform on the patched App object except App.Metadata
    ///  Supported values: 'overwrite' and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the app image by setting
    ///  'image.url' in the request to the current value returned for the app.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.action)
    pub action: ::std::string::String,
    ///  The action to perform on the patched App.Metadata
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.metadata_action)
    pub metadata_action: ::protobuf::MessageField<super::resources::PatchAction>,
    ///  If set, the app will be automatically reindexed upon change of its base workflow.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.reindex)
    pub reindex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppRequest {
    fn default() -> &'a PatchAppRequest {
        <PatchAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppRequest {
    pub fn new() -> PatchAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppRequest| { &m.user_app_id },
            |m: &mut PatchAppRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &PatchAppRequest| { &m.app },
            |m: &mut PatchAppRequest| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppRequest| { &m.action },
            |m: &mut PatchAppRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PatchAction>(
            "metadata_action",
            |m: &PatchAppRequest| { &m.metadata_action },
            |m: &mut PatchAppRequest| { &mut m.metadata_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex",
            |m: &PatchAppRequest| { &m.reindex },
            |m: &mut PatchAppRequest| { &mut m.reindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppRequest>(
            "PatchAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppRequest {
    const NAME: &'static str = "PatchAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                26 => {
                    self.action = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata_action)?;
                },
                40 => {
                    self.reindex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reindex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(v) = self.metadata_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppRequest {
        PatchAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppRequest {
        static instance: PatchAppRequest = PatchAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app: ::protobuf::MessageField::none(),
            action: ::std::string::String::new(),
            metadata_action: ::protobuf::MessageField::none(),
            reindex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppsIdsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAppsIdsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAppsIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppsIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppsIdsRequest {
    fn default() -> &'a PatchAppsIdsRequest {
        <PatchAppsIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsIdsRequest {
    pub fn new() -> PatchAppsIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppsIdsRequest| { &m.user_app_id },
            |m: &mut PatchAppsIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchAppsIdsRequest| { &m.ids },
            |m: &mut PatchAppsIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppsIdsRequest| { &m.action },
            |m: &mut PatchAppsIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppsIdsRequest>(
            "PatchAppsIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppsIdsRequest {
    const NAME: &'static str = "PatchAppsIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppsIdsRequest {
        PatchAppsIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppsIdsRequest {
        static instance: PatchAppsIdsRequest = PatchAppsIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppsIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppsIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppsIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Search over the available applications.
// @@protoc_insertion_point(message:clarifai.api.PostAppsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAppsSearchesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.app_query)
    pub app_query: ::protobuf::MessageField<super::resources::AppQuery>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppsSearchesRequest {
    fn default() -> &'a PostAppsSearchesRequest {
        <PostAppsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsSearchesRequest {
    pub fn new() -> PostAppsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppsSearchesRequest| { &m.user_app_id },
            |m: &mut PostAppsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AppQuery>(
            "app_query",
            |m: &PostAppsSearchesRequest| { &m.app_query },
            |m: &mut PostAppsSearchesRequest| { &mut m.app_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostAppsSearchesRequest| { &m.pagination },
            |m: &mut PostAppsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppsSearchesRequest>(
            "PostAppsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppsSearchesRequest {
    const NAME: &'static str = "PostAppsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_query)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppsSearchesRequest {
        PostAppsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_query.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppsSearchesRequest {
        static instance: PostAppsSearchesRequest = PostAppsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_query: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAppResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAppResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAppResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAppResponse.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAppResponse {
    fn default() -> &'a SingleAppResponse {
        <SingleAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppResponse {
    pub fn new() -> SingleAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAppResponse| { &m.status },
            |m: &mut SingleAppResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &SingleAppResponse| { &m.app },
            |m: &mut SingleAppResponse| { &mut m.app },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAppResponse>(
            "SingleAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAppResponse {
    const NAME: &'static str = "SingleAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAppResponse {
        SingleAppResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAppResponse {
        static instance: SingleAppResponse = SingleAppResponse {
            status: ::protobuf::MessageField::none(),
            app: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAppResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAppResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAppResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAppResponse.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAppResponse {
    fn default() -> &'a MultiAppResponse {
        <MultiAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppResponse {
    pub fn new() -> MultiAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAppResponse| { &m.status },
            |m: &mut MultiAppResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &MultiAppResponse| { &m.apps },
            |m: &mut MultiAppResponse| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAppResponse>(
            "MultiAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAppResponse {
    const NAME: &'static str = "MultiAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAppResponse {
        MultiAppResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAppResponse {
        static instance: MultiAppResponse = MultiAppResponse {
            status: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.ListCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Set this flag to list both deleted and not deleted collaborators
    ///  by default it's listing only not deleted collaborators
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.list_all_collaborators)
    pub list_all_collaborators: bool,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollaboratorsRequest {
    fn default() -> &'a ListCollaboratorsRequest {
        <ListCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaboratorsRequest {
    pub fn new() -> ListCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollaboratorsRequest| { &m.user_app_id },
            |m: &mut ListCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_all_collaborators",
            |m: &ListCollaboratorsRequest| { &m.list_all_collaborators },
            |m: &mut ListCollaboratorsRequest| { &mut m.list_all_collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollaboratorsRequest| { &m.page },
            |m: &mut ListCollaboratorsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollaboratorsRequest| { &m.per_page },
            |m: &mut ListCollaboratorsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollaboratorsRequest>(
            "ListCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollaboratorsRequest {
    const NAME: &'static str = "ListCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.list_all_collaborators = is.read_bool()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.list_all_collaborators != false {
            my_size += 1 + 1;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.list_all_collaborators != false {
            os.write_bool(2, self.list_all_collaborators)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollaboratorsRequest {
        ListCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.list_all_collaborators = false;
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollaboratorsRequest {
        static instance: ListCollaboratorsRequest = ListCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            list_all_collaborators: false,
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.PostCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostCollaboratorsRequest.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCollaboratorsRequest {
    fn default() -> &'a PostCollaboratorsRequest {
        <PostCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollaboratorsRequest {
    pub fn new() -> PostCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostCollaboratorsRequest| { &m.user_app_id },
            |m: &mut PostCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &PostCollaboratorsRequest| { &m.collaborators },
            |m: &mut PostCollaboratorsRequest| { &mut m.collaborators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCollaboratorsRequest>(
            "PostCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCollaboratorsRequest {
    const NAME: &'static str = "PostCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCollaboratorsRequest {
        PostCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCollaboratorsRequest {
        static instance: PostCollaboratorsRequest = PostCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    ///  The action to perform on the patched objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchCollaboratorsRequest {
    fn default() -> &'a PatchCollaboratorsRequest {
        <PatchCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollaboratorsRequest {
    pub fn new() -> PatchCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchCollaboratorsRequest| { &m.user_app_id },
            |m: &mut PatchCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &PatchCollaboratorsRequest| { &m.collaborators },
            |m: &mut PatchCollaboratorsRequest| { &mut m.collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchCollaboratorsRequest| { &m.action },
            |m: &mut PatchCollaboratorsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchCollaboratorsRequest>(
            "PatchCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchCollaboratorsRequest {
    const NAME: &'static str = "PatchCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchCollaboratorsRequest {
        PatchCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchCollaboratorsRequest {
        static instance: PatchCollaboratorsRequest = PatchCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.collaborator_ids)
    pub collaborator_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.user_emails)
    pub user_emails: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollaboratorsRequest {
    fn default() -> &'a DeleteCollaboratorsRequest {
        <DeleteCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollaboratorsRequest {
    pub fn new() -> DeleteCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteCollaboratorsRequest| { &m.user_app_id },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborator_ids",
            |m: &DeleteCollaboratorsRequest| { &m.collaborator_ids },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.collaborator_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_emails",
            |m: &DeleteCollaboratorsRequest| { &m.user_emails },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.user_emails },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollaboratorsRequest>(
            "DeleteCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollaboratorsRequest {
    const NAME: &'static str = "DeleteCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborator_ids.push(is.read_string()?);
                },
                26 => {
                    self.user_emails.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborator_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.user_emails {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborator_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.user_emails {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollaboratorsRequest {
        DeleteCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborator_ids.clear();
        self.user_emails.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollaboratorsRequest {
        static instance: DeleteCollaboratorsRequest = DeleteCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborator_ids: ::std::vec::Vec::new(),
            user_emails: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiCollaboratorsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiCollaboratorsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiCollaboratorsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    ///  The owner of the application.
    ///
    ///  When listing users that have access to the application, i.e. collaborators,
    ///  it is often relevant to also include the application owner, so return
    ///  their information here for convenience.
    ///
    ///  Note: app_owner is only returned by ListCollaborators and only if the
    ///  owner is a regular user, not an organization.
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.app_owner)
    pub app_owner: ::protobuf::MessageField<super::resources::User>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollaboratorsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollaboratorsResponse {
    fn default() -> &'a MultiCollaboratorsResponse {
        <MultiCollaboratorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaboratorsResponse {
    pub fn new() -> MultiCollaboratorsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollaboratorsResponse| { &m.status },
            |m: &mut MultiCollaboratorsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &MultiCollaboratorsResponse| { &m.collaborators },
            |m: &mut MultiCollaboratorsResponse| { &mut m.collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::User>(
            "app_owner",
            |m: &MultiCollaboratorsResponse| { &m.app_owner },
            |m: &mut MultiCollaboratorsResponse| { &mut m.app_owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollaboratorsResponse>(
            "MultiCollaboratorsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollaboratorsResponse {
    const NAME: &'static str = "MultiCollaboratorsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_owner)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.app_owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.app_owner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollaboratorsResponse {
        MultiCollaboratorsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collaborators.clear();
        self.app_owner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollaboratorsResponse {
        static instance: MultiCollaboratorsResponse = MultiCollaboratorsResponse {
            status: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            app_owner: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollaboratorsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollaboratorsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollaboratorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaboratorsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListCollaborationsRequest
// @@protoc_insertion_point(message:clarifai.api.ListCollaborationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListCollaborationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.per_page)
    pub per_page: u32,
    ///  Filtering options:
    ///  If true, we only return collaborations on apps that are marked as a template by the app owner.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.template_only)
    pub template_only: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollaborationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollaborationsRequest {
    fn default() -> &'a ListCollaborationsRequest {
        <ListCollaborationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaborationsRequest {
    pub fn new() -> ListCollaborationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollaborationsRequest| { &m.user_app_id },
            |m: &mut ListCollaborationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollaborationsRequest| { &m.page },
            |m: &mut ListCollaborationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollaborationsRequest| { &m.per_page },
            |m: &mut ListCollaborationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "template_only",
            |m: &ListCollaborationsRequest| { &m.template_only },
            |m: &mut ListCollaborationsRequest| { &mut m.template_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollaborationsRequest>(
            "ListCollaborationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollaborationsRequest {
    const NAME: &'static str = "ListCollaborationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.template_only = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.template_only != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.template_only != false {
            os.write_bool(4, self.template_only)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollaborationsRequest {
        ListCollaborationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.template_only = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollaborationsRequest {
        static instance: ListCollaborationsRequest = ListCollaborationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            template_only: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollaborationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollaborationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollaborationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaborationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiCollaborationsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiCollaborationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiCollaborationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaborationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaborationsResponse.collaborations)
    pub collaborations: ::std::vec::Vec<super::resources::Collaboration>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollaborationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollaborationsResponse {
    fn default() -> &'a MultiCollaborationsResponse {
        <MultiCollaborationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaborationsResponse {
    pub fn new() -> MultiCollaborationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollaborationsResponse| { &m.status },
            |m: &mut MultiCollaborationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborations",
            |m: &MultiCollaborationsResponse| { &m.collaborations },
            |m: &mut MultiCollaborationsResponse| { &mut m.collaborations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollaborationsResponse>(
            "MultiCollaborationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollaborationsResponse {
    const NAME: &'static str = "MultiCollaborationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collaborations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollaborationsResponse {
        MultiCollaborationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collaborations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollaborationsResponse {
        static instance: MultiCollaborationsResponse = MultiCollaborationsResponse {
            status: ::protobuf::MessageField::none(),
            collaborations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollaborationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollaborationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollaborationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaborationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetStatusCodeRequest
// @@protoc_insertion_point(message:clarifai.api.GetStatusCodeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetStatusCodeRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetStatusCodeRequest.status_code_id)
    pub status_code_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetStatusCodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStatusCodeRequest {
    fn default() -> &'a GetStatusCodeRequest {
        <GetStatusCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusCodeRequest {
    pub fn new() -> GetStatusCodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code_id",
            |m: &GetStatusCodeRequest| { &m.status_code_id },
            |m: &mut GetStatusCodeRequest| { &mut m.status_code_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStatusCodeRequest>(
            "GetStatusCodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStatusCodeRequest {
    const NAME: &'static str = "GetStatusCodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.status_code_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.status_code_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status_code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.status_code_id.is_empty() {
            os.write_string(1, &self.status_code_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStatusCodeRequest {
        GetStatusCodeRequest::new()
    }

    fn clear(&mut self) {
        self.status_code_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStatusCodeRequest {
        static instance: GetStatusCodeRequest = GetStatusCodeRequest {
            status_code_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStatusCodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStatusCodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStatusCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusCodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListStatusCodesRequest
// @@protoc_insertion_point(message:clarifai.api.ListStatusCodesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListStatusCodesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListStatusCodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListStatusCodesRequest {
    fn default() -> &'a ListStatusCodesRequest {
        <ListStatusCodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStatusCodesRequest {
    pub fn new() -> ListStatusCodesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListStatusCodesRequest>(
            "ListStatusCodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListStatusCodesRequest {
    const NAME: &'static str = "ListStatusCodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListStatusCodesRequest {
        ListStatusCodesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListStatusCodesRequest {
        static instance: ListStatusCodesRequest = ListStatusCodesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListStatusCodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListStatusCodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListStatusCodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleStatusCodeResponse
// @@protoc_insertion_point(message:clarifai.api.SingleStatusCodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleStatusCodeResponse {
    // message fields
    ///  Status of this request.
    // @@protoc_insertion_point(field:clarifai.api.SingleStatusCodeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleStatusCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleStatusCodeResponse {
    fn default() -> &'a SingleStatusCodeResponse {
        <SingleStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleStatusCodeResponse {
    pub fn new() -> SingleStatusCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleStatusCodeResponse| { &m.status },
            |m: &mut SingleStatusCodeResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleStatusCodeResponse>(
            "SingleStatusCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleStatusCodeResponse {
    const NAME: &'static str = "SingleStatusCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleStatusCodeResponse {
        SingleStatusCodeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleStatusCodeResponse {
        static instance: SingleStatusCodeResponse = SingleStatusCodeResponse {
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleStatusCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleStatusCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleStatusCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatusCodeResponse
// @@protoc_insertion_point(message:clarifai.api.MultiStatusCodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiStatusCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiStatusCodeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiStatusCodeResponse.statuses)
    pub statuses: ::std::vec::Vec<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatusCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatusCodeResponse {
    fn default() -> &'a MultiStatusCodeResponse {
        <MultiStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatusCodeResponse {
    pub fn new() -> MultiStatusCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatusCodeResponse| { &m.status },
            |m: &mut MultiStatusCodeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &MultiStatusCodeResponse| { &m.statuses },
            |m: &mut MultiStatusCodeResponse| { &mut m.statuses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatusCodeResponse>(
            "MultiStatusCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatusCodeResponse {
    const NAME: &'static str = "MultiStatusCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.statuses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.statuses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatusCodeResponse {
        MultiStatusCodeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.statuses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatusCodeResponse {
        static instance: MultiStatusCodeResponse = MultiStatusCodeResponse {
            status: ::protobuf::MessageField::none(),
            statuses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatusCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatusCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatusCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConceptRequest
// @@protoc_insertion_point(message:clarifai.api.GetConceptRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConceptRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept's id.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptRequest.concept_id)
    pub concept_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptRequest {
    fn default() -> &'a GetConceptRequest {
        <GetConceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptRequest {
    pub fn new() -> GetConceptRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptRequest| { &m.user_app_id },
            |m: &mut GetConceptRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &GetConceptRequest| { &m.concept_id },
            |m: &mut GetConceptRequest| { &mut m.concept_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptRequest>(
            "GetConceptRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptRequest {
    const NAME: &'static str = "GetConceptRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptRequest {
        GetConceptRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptRequest {
        static instance: GetConceptRequest = GetConceptRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.ListConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.per_page)
    pub per_page: u32,
    ///  Fuzzy match on concept ID
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptsRequest {
    fn default() -> &'a ListConceptsRequest {
        <ListConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptsRequest {
    pub fn new() -> ListConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptsRequest| { &m.user_app_id },
            |m: &mut ListConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptsRequest| { &m.page },
            |m: &mut ListConceptsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptsRequest| { &m.per_page },
            |m: &mut ListConceptsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListConceptsRequest| { &m.id },
            |m: &mut ListConceptsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptsRequest>(
            "ListConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptsRequest {
    const NAME: &'static str = "ListConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if !self.id.is_empty() {
            os.write_string(4, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptsRequest {
        ListConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptsRequest {
        static instance: ListConceptsRequest = ListConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Model id
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  Model version Id. Optional, if not provided latest model version is used.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.per_page)
    pub per_page: u32,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the concept:
    ///    - id
    ///    - name
    ///
    ///  Keywords are used for partial prefix-matching (so searching for "larif" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.search)
    pub search: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelConceptsRequest {
    fn default() -> &'a ListModelConceptsRequest {
        <ListModelConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelConceptsRequest {
    pub fn new() -> ListModelConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelConceptsRequest| { &m.user_app_id },
            |m: &mut ListModelConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelConceptsRequest| { &m.model_id },
            |m: &mut ListModelConceptsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ListModelConceptsRequest| { &m.version_id },
            |m: &mut ListModelConceptsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelConceptsRequest| { &m.page },
            |m: &mut ListModelConceptsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelConceptsRequest| { &m.per_page },
            |m: &mut ListModelConceptsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListModelConceptsRequest| { &m.search },
            |m: &mut ListModelConceptsRequest| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelConceptsRequest>(
            "ListModelConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelConceptsRequest {
    const NAME: &'static str = "ListModelConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                50 => {
                    self.search = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.search);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        if !self.search.is_empty() {
            os.write_string(6, &self.search)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelConceptsRequest {
        ListModelConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelConceptsRequest {
        static instance: ListModelConceptsRequest = ListModelConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            search: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostConceptsSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.PostConceptsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptsSearchesRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.concept_query)
    pub concept_query: ::protobuf::MessageField<super::resources::ConceptQuery>,
    ///  Request additional info to be retrieved for each concept in the response.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.extra_info)
    pub extra_info: ::protobuf::MessageField<ConceptExtraInfoRequest>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptsSearchesRequest {
    fn default() -> &'a PostConceptsSearchesRequest {
        <PostConceptsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsSearchesRequest {
    pub fn new() -> PostConceptsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptsSearchesRequest| { &m.user_app_id },
            |m: &mut PostConceptsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ConceptQuery>(
            "concept_query",
            |m: &PostConceptsSearchesRequest| { &m.concept_query },
            |m: &mut PostConceptsSearchesRequest| { &mut m.concept_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptExtraInfoRequest>(
            "extra_info",
            |m: &PostConceptsSearchesRequest| { &m.extra_info },
            |m: &mut PostConceptsSearchesRequest| { &mut m.extra_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostConceptsSearchesRequest| { &m.pagination },
            |m: &mut PostConceptsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptsSearchesRequest>(
            "PostConceptsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptsSearchesRequest {
    const NAME: &'static str = "PostConceptsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_query)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extra_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.extra_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptsSearchesRequest {
        PostConceptsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_query.clear();
        self.extra_info.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptsSearchesRequest {
        static instance: PostConceptsSearchesRequest = PostConceptsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_query: ::protobuf::MessageField::none(),
            extra_info: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ConceptExtraInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptExtraInfoRequest {
    // message fields
    ///  Determine if the concept is searchable by rank using this model.
    ///  Currently, only embedder models are supported.
    ///  ########## Supported fields ##########
    ///  - app_id
    ///  - id
    ///  - model_version.id
    ///  - user_id
    // @@protoc_insertion_point(field:clarifai.api.ConceptExtraInfoRequest.rankable_model)
    pub rankable_model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptExtraInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptExtraInfoRequest {
    fn default() -> &'a ConceptExtraInfoRequest {
        <ConceptExtraInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConceptExtraInfoRequest {
    pub fn new() -> ConceptExtraInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "rankable_model",
            |m: &ConceptExtraInfoRequest| { &m.rankable_model },
            |m: &mut ConceptExtraInfoRequest| { &mut m.rankable_model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptExtraInfoRequest>(
            "ConceptExtraInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptExtraInfoRequest {
    const NAME: &'static str = "ConceptExtraInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankable_model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rankable_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rankable_model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptExtraInfoRequest {
        ConceptExtraInfoRequest::new()
    }

    fn clear(&mut self) {
        self.rankable_model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptExtraInfoRequest {
        static instance: ConceptExtraInfoRequest = ConceptExtraInfoRequest {
            rankable_model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptExtraInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptExtraInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptExtraInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptExtraInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.PostConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concepts to add.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsRequest.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptsRequest {
    fn default() -> &'a PostConceptsRequest {
        <PostConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsRequest {
    pub fn new() -> PostConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptsRequest| { &m.user_app_id },
            |m: &mut PostConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &PostConceptsRequest| { &m.concepts },
            |m: &mut PostConceptsRequest| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptsRequest>(
            "PostConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptsRequest {
    const NAME: &'static str = "PostConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptsRequest {
        PostConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptsRequest {
        static instance: PostConceptsRequest = PostConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concepts to patch.
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    ///  The action to perform on the patched objects
    ///  For now ony action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchConceptsRequest {
    fn default() -> &'a PatchConceptsRequest {
        <PatchConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptsRequest {
    pub fn new() -> PatchConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchConceptsRequest| { &m.user_app_id },
            |m: &mut PatchConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &PatchConceptsRequest| { &m.concepts },
            |m: &mut PatchConceptsRequest| { &mut m.concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchConceptsRequest| { &m.action },
            |m: &mut PatchConceptsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchConceptsRequest>(
            "PatchConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchConceptsRequest {
    const NAME: &'static str = "PatchConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchConceptsRequest {
        PatchConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchConceptsRequest {
        static instance: PatchConceptsRequest = PatchConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConceptCountsRequest
// @@protoc_insertion_point(message:clarifai.api.GetConceptCountsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConceptCountsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptCountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptCountsRequest {
    fn default() -> &'a GetConceptCountsRequest {
        <GetConceptCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptCountsRequest {
    pub fn new() -> GetConceptCountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptCountsRequest| { &m.user_app_id },
            |m: &mut GetConceptCountsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &GetConceptCountsRequest| { &m.page },
            |m: &mut GetConceptCountsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &GetConceptCountsRequest| { &m.per_page },
            |m: &mut GetConceptCountsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptCountsRequest>(
            "GetConceptCountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptCountsRequest {
    const NAME: &'static str = "GetConceptCountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptCountsRequest {
        GetConceptCountsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptCountsRequest {
        static instance: GetConceptCountsRequest = GetConceptCountsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptCountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptCountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptCountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleConceptResponse
// @@protoc_insertion_point(message:clarifai.api.SingleConceptResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleConceptResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept.
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptResponse.concept)
    pub concept: ::protobuf::MessageField<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleConceptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleConceptResponse {
    fn default() -> &'a SingleConceptResponse {
        <SingleConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptResponse {
    pub fn new() -> SingleConceptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleConceptResponse| { &m.status },
            |m: &mut SingleConceptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Concept>(
            "concept",
            |m: &SingleConceptResponse| { &m.concept },
            |m: &mut SingleConceptResponse| { &mut m.concept },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleConceptResponse>(
            "SingleConceptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleConceptResponse {
    const NAME: &'static str = "SingleConceptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleConceptResponse {
        SingleConceptResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleConceptResponse {
        static instance: SingleConceptResponse = SingleConceptResponse {
            status: ::protobuf::MessageField::none(),
            concept: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleConceptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleConceptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concepts.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptResponse.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptResponse {
    fn default() -> &'a MultiConceptResponse {
        <MultiConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptResponse {
    pub fn new() -> MultiConceptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptResponse| { &m.status },
            |m: &mut MultiConceptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &MultiConceptResponse| { &m.concepts },
            |m: &mut MultiConceptResponse| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptResponse>(
            "MultiConceptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptResponse {
    const NAME: &'static str = "MultiConceptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptResponse {
        MultiConceptResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptResponse {
        static instance: MultiConceptResponse = MultiConceptResponse {
            status: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptCountResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptCountResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept counts.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptCountResponse.concept_counts)
    pub concept_counts: ::std::vec::Vec<super::resources::ConceptCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptCountResponse {
    fn default() -> &'a MultiConceptCountResponse {
        <MultiConceptCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptCountResponse {
    pub fn new() -> MultiConceptCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptCountResponse| { &m.status },
            |m: &mut MultiConceptCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_counts",
            |m: &MultiConceptCountResponse| { &m.concept_counts },
            |m: &mut MultiConceptCountResponse| { &mut m.concept_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptCountResponse>(
            "MultiConceptCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptCountResponse {
    const NAME: &'static str = "MultiConceptCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_counts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptCountResponse {
        MultiConceptCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptCountResponse {
        static instance: MultiConceptCountResponse = MultiConceptCountResponse {
            status: ::protobuf::MessageField::none(),
            concept_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET all relations such that the concept_id refers to the subject of the relation
// @@protoc_insertion_point(message:clarifai.api.ListConceptRelationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The subject concept id in your app to get all the relationships for.
    ///  Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
    ///
    ///  When listing all the relations it will only return one direction of the relationship
    ///  with the predicate acting on the subject and not the inverse like is done when providing a
    ///  concept_id so that we can return a reliable page size always.
    ///
    ///  When providing a concept_id, if a hyponym is present in the DB such as:
    ///  'honey' (subject), 'hyponym' (predicate for "is a kind of"), 'food' (object)
    ///  then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
    ///  object.
    ///  But you can also list the concept relations for 'food' and it will return the same hyponym
    ///  relationship with 'honey' as object and 'hypernym' as predicate.
    ///  Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
    ///  when listing the relations.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  If predicate is provided then only list relations with that predicate.
    ///
    ///  Note that if no subject is set in concept_id and predicate is set to
    ///  'hypernym', then it will return any stored hyponyms as hypernyms with
    ///  just the subject and object swapped since they are reversed relations.
    ///
    ///  Valid predicates are:
    ///  - 'hypernym'
    ///  - 'hyponym'
    ///  - 'synonym'
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.predicate)
    pub predicate: ::std::string::String,
    ///  If knowledge_graph_id is provided then just list relations from that knowledge graph.
    ///  If not provided then list relations from all knowledge graphs including the global one for this
    ///  app one (ie. knowledge_graph "") and any specific ones in the app.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.knowledge_graph_id)
    pub knowledge_graph_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptRelationsRequest {
    fn default() -> &'a ListConceptRelationsRequest {
        <ListConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptRelationsRequest {
    pub fn new() -> ListConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptRelationsRequest| { &m.user_app_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &ListConceptRelationsRequest| { &m.concept_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "predicate",
            |m: &ListConceptRelationsRequest| { &m.predicate },
            |m: &mut ListConceptRelationsRequest| { &mut m.predicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "knowledge_graph_id",
            |m: &ListConceptRelationsRequest| { &m.knowledge_graph_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.knowledge_graph_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptRelationsRequest| { &m.page },
            |m: &mut ListConceptRelationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptRelationsRequest| { &m.per_page },
            |m: &mut ListConceptRelationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptRelationsRequest>(
            "ListConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptRelationsRequest {
    const NAME: &'static str = "ListConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.predicate = is.read_string()?;
                },
                34 => {
                    self.knowledge_graph_id = is.read_string()?;
                },
                40 => {
                    self.page = is.read_uint32()?;
                },
                48 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.knowledge_graph_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(3, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(4, &self.knowledge_graph_id)?;
        }
        if self.page != 0 {
            os.write_uint32(5, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(6, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptRelationsRequest {
        ListConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptRelationsRequest {
        static instance: ListConceptRelationsRequest = ListConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            predicate: ::std::string::String::new(),
            knowledge_graph_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST new concept relations
// @@protoc_insertion_point(message:clarifai.api.PostConceptRelationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The subject concept id you're going to add relations for.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  The relationships you're going to add.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.concept_relations)
    pub concept_relations: ::std::vec::Vec<super::resources::ConceptRelation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptRelationsRequest {
    fn default() -> &'a PostConceptRelationsRequest {
        <PostConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptRelationsRequest {
    pub fn new() -> PostConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptRelationsRequest| { &m.user_app_id },
            |m: &mut PostConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PostConceptRelationsRequest| { &m.concept_id },
            |m: &mut PostConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relations",
            |m: &PostConceptRelationsRequest| { &m.concept_relations },
            |m: &mut PostConceptRelationsRequest| { &mut m.concept_relations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptRelationsRequest>(
            "PostConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptRelationsRequest {
    const NAME: &'static str = "PostConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_relations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_relations {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptRelationsRequest {
        PostConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_relations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptRelationsRequest {
        static instance: PostConceptRelationsRequest = PostConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_relations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DELETE concept relations
// @@protoc_insertion_point(message:clarifai.api.DeleteConceptRelationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept to delete relationship for.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  The concept relationship ids to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteConceptRelationsRequest {
    fn default() -> &'a DeleteConceptRelationsRequest {
        <DeleteConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConceptRelationsRequest {
    pub fn new() -> DeleteConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteConceptRelationsRequest| { &m.user_app_id },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &DeleteConceptRelationsRequest| { &m.concept_id },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteConceptRelationsRequest| { &m.ids },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteConceptRelationsRequest>(
            "DeleteConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteConceptRelationsRequest {
    const NAME: &'static str = "DeleteConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteConceptRelationsRequest {
        DeleteConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteConceptRelationsRequest {
        static instance: DeleteConceptRelationsRequest = DeleteConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET all knowledge graphs
// @@protoc_insertion_point(message:clarifai.api.ListKnowledgeGraphsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListKnowledgeGraphsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListKnowledgeGraphsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListKnowledgeGraphsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKnowledgeGraphsRequest {
    fn default() -> &'a ListKnowledgeGraphsRequest {
        <ListKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKnowledgeGraphsRequest {
    pub fn new() -> ListKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListKnowledgeGraphsRequest| { &m.user_app_id },
            |m: &mut ListKnowledgeGraphsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListKnowledgeGraphsRequest>(
            "ListKnowledgeGraphsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListKnowledgeGraphsRequest {
    const NAME: &'static str = "ListKnowledgeGraphsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKnowledgeGraphsRequest {
        ListKnowledgeGraphsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKnowledgeGraphsRequest {
        static instance: ListKnowledgeGraphsRequest = ListKnowledgeGraphsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListKnowledgeGraphsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListKnowledgeGraphsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKnowledgeGraphsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST new knowledge graphs
// @@protoc_insertion_point(message:clarifai.api.PostKnowledgeGraphsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostKnowledgeGraphsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostKnowledgeGraphsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostKnowledgeGraphsRequest.knowledge_graphs)
    pub knowledge_graphs: ::std::vec::Vec<super::resources::KnowledgeGraph>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostKnowledgeGraphsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostKnowledgeGraphsRequest {
    fn default() -> &'a PostKnowledgeGraphsRequest {
        <PostKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKnowledgeGraphsRequest {
    pub fn new() -> PostKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostKnowledgeGraphsRequest| { &m.user_app_id },
            |m: &mut PostKnowledgeGraphsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "knowledge_graphs",
            |m: &PostKnowledgeGraphsRequest| { &m.knowledge_graphs },
            |m: &mut PostKnowledgeGraphsRequest| { &mut m.knowledge_graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostKnowledgeGraphsRequest>(
            "PostKnowledgeGraphsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostKnowledgeGraphsRequest {
    const NAME: &'static str = "PostKnowledgeGraphsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.knowledge_graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.knowledge_graphs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostKnowledgeGraphsRequest {
        PostKnowledgeGraphsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.knowledge_graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostKnowledgeGraphsRequest {
        static instance: PostKnowledgeGraphsRequest = PostKnowledgeGraphsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            knowledge_graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostKnowledgeGraphsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostKnowledgeGraphsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKnowledgeGraphsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start concept mapping jobs
// @@protoc_insertion_point(message:clarifai.api.PostConceptMappingJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptMappingJobsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptMappingJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept mapping jobs that are being started
    // @@protoc_insertion_point(field:clarifai.api.PostConceptMappingJobsRequest.concept_mapping_jobs)
    pub concept_mapping_jobs: ::std::vec::Vec<super::resources::ConceptMappingJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptMappingJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptMappingJobsRequest {
    fn default() -> &'a PostConceptMappingJobsRequest {
        <PostConceptMappingJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptMappingJobsRequest {
    pub fn new() -> PostConceptMappingJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptMappingJobsRequest| { &m.user_app_id },
            |m: &mut PostConceptMappingJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_mapping_jobs",
            |m: &PostConceptMappingJobsRequest| { &m.concept_mapping_jobs },
            |m: &mut PostConceptMappingJobsRequest| { &mut m.concept_mapping_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptMappingJobsRequest>(
            "PostConceptMappingJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptMappingJobsRequest {
    const NAME: &'static str = "PostConceptMappingJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_mapping_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_mapping_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_mapping_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptMappingJobsRequest {
        PostConceptMappingJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_mapping_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptMappingJobsRequest {
        static instance: PostConceptMappingJobsRequest = PostConceptMappingJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_mapping_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptMappingJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptMappingJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptMappingJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptMappingJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptRelationResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptRelationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptRelationResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptRelationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept relations.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptRelationResponse.concept_relations)
    pub concept_relations: ::std::vec::Vec<super::resources::ConceptRelation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptRelationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptRelationResponse {
    fn default() -> &'a MultiConceptRelationResponse {
        <MultiConceptRelationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptRelationResponse {
    pub fn new() -> MultiConceptRelationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptRelationResponse| { &m.status },
            |m: &mut MultiConceptRelationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relations",
            |m: &MultiConceptRelationResponse| { &m.concept_relations },
            |m: &mut MultiConceptRelationResponse| { &mut m.concept_relations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptRelationResponse>(
            "MultiConceptRelationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptRelationResponse {
    const NAME: &'static str = "MultiConceptRelationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_relations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_relations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptRelationResponse {
        MultiConceptRelationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_relations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptRelationResponse {
        static instance: MultiConceptRelationResponse = MultiConceptRelationResponse {
            status: ::protobuf::MessageField::none(),
            concept_relations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptRelationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptRelationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptRelationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptRelationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiKnowledgeGraphResponse
// @@protoc_insertion_point(message:clarifai.api.MultiKnowledgeGraphResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiKnowledgeGraphResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiKnowledgeGraphResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned knowledge graphs.
    // @@protoc_insertion_point(field:clarifai.api.MultiKnowledgeGraphResponse.knowledge_graphs)
    pub knowledge_graphs: ::std::vec::Vec<super::resources::KnowledgeGraph>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiKnowledgeGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiKnowledgeGraphResponse {
    fn default() -> &'a MultiKnowledgeGraphResponse {
        <MultiKnowledgeGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKnowledgeGraphResponse {
    pub fn new() -> MultiKnowledgeGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiKnowledgeGraphResponse| { &m.status },
            |m: &mut MultiKnowledgeGraphResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "knowledge_graphs",
            |m: &MultiKnowledgeGraphResponse| { &m.knowledge_graphs },
            |m: &mut MultiKnowledgeGraphResponse| { &mut m.knowledge_graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiKnowledgeGraphResponse>(
            "MultiKnowledgeGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiKnowledgeGraphResponse {
    const NAME: &'static str = "MultiKnowledgeGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.knowledge_graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.knowledge_graphs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiKnowledgeGraphResponse {
        MultiKnowledgeGraphResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.knowledge_graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiKnowledgeGraphResponse {
        static instance: MultiKnowledgeGraphResponse = MultiKnowledgeGraphResponse {
            status: ::protobuf::MessageField::none(),
            knowledge_graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiKnowledgeGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiKnowledgeGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiKnowledgeGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKnowledgeGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptMappingJobResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptMappingJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptMappingJobResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptMappingJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The ids of the concept mapping jobs underway.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptMappingJobResponse.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptMappingJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptMappingJobResponse {
    fn default() -> &'a MultiConceptMappingJobResponse {
        <MultiConceptMappingJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptMappingJobResponse {
    pub fn new() -> MultiConceptMappingJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptMappingJobResponse| { &m.status },
            |m: &mut MultiConceptMappingJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &MultiConceptMappingJobResponse| { &m.ids },
            |m: &mut MultiConceptMappingJobResponse| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptMappingJobResponse>(
            "MultiConceptMappingJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptMappingJobResponse {
    const NAME: &'static str = "MultiConceptMappingJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptMappingJobResponse {
        MultiConceptMappingJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptMappingJobResponse {
        static instance: MultiConceptMappingJobResponse = MultiConceptMappingJobResponse {
            status: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptMappingJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptMappingJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptMappingJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptMappingJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET single concept language for the given concept.
// @@protoc_insertion_point(message:clarifai.api.GetConceptLanguageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConceptLanguageRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  This is the language identifier.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.language)
    pub language: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptLanguageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptLanguageRequest {
    fn default() -> &'a GetConceptLanguageRequest {
        <GetConceptLanguageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptLanguageRequest {
    pub fn new() -> GetConceptLanguageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptLanguageRequest| { &m.user_app_id },
            |m: &mut GetConceptLanguageRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &GetConceptLanguageRequest| { &m.concept_id },
            |m: &mut GetConceptLanguageRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &GetConceptLanguageRequest| { &m.language },
            |m: &mut GetConceptLanguageRequest| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptLanguageRequest>(
            "GetConceptLanguageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptLanguageRequest {
    const NAME: &'static str = "GetConceptLanguageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.language = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(3, &self.language)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptLanguageRequest {
        GetConceptLanguageRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptLanguageRequest {
        static instance: GetConceptLanguageRequest = GetConceptLanguageRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptLanguageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptLanguageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptLanguageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptLanguageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  List multiple concept languages for the given concept.
// @@protoc_insertion_point(message:clarifai.api.ListConceptLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptLanguagesRequest {
    fn default() -> &'a ListConceptLanguagesRequest {
        <ListConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptLanguagesRequest {
    pub fn new() -> ListConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut ListConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &ListConceptLanguagesRequest| { &m.concept_id },
            |m: &mut ListConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptLanguagesRequest| { &m.page },
            |m: &mut ListConceptLanguagesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptLanguagesRequest| { &m.per_page },
            |m: &mut ListConceptLanguagesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptLanguagesRequest>(
            "ListConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptLanguagesRequest {
    const NAME: &'static str = "ListConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptLanguagesRequest {
        ListConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptLanguagesRequest {
        static instance: ListConceptLanguagesRequest = ListConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PATCH multiple concept languages for the given concept.
// @@protoc_insertion_point(message:clarifai.api.PatchConceptLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    ///  The action to perform with the objects in the PATCH.
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchConceptLanguagesRequest {
    fn default() -> &'a PatchConceptLanguagesRequest {
        <PatchConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptLanguagesRequest {
    pub fn new() -> PatchConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PatchConceptLanguagesRequest| { &m.concept_id },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &PatchConceptLanguagesRequest| { &m.concept_languages },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchConceptLanguagesRequest| { &m.action },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchConceptLanguagesRequest>(
            "PatchConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchConceptLanguagesRequest {
    const NAME: &'static str = "PatchConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_languages.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchConceptLanguagesRequest {
        PatchConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchConceptLanguagesRequest {
        static instance: PatchConceptLanguagesRequest = PatchConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_languages: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST multiple concept languages for the given concept.
// @@protoc_insertion_point(message:clarifai.api.PostConceptLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptLanguagesRequest {
    fn default() -> &'a PostConceptLanguagesRequest {
        <PostConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptLanguagesRequest {
    pub fn new() -> PostConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut PostConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PostConceptLanguagesRequest| { &m.concept_id },
            |m: &mut PostConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &PostConceptLanguagesRequest| { &m.concept_languages },
            |m: &mut PostConceptLanguagesRequest| { &mut m.concept_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptLanguagesRequest>(
            "PostConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptLanguagesRequest {
    const NAME: &'static str = "PostConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptLanguagesRequest {
        PostConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptLanguagesRequest {
        static instance: PostConceptLanguagesRequest = PostConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleConceptLanguageResponse
// @@protoc_insertion_point(message:clarifai.api.SingleConceptLanguageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleConceptLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptLanguageResponse.concept_language)
    pub concept_language: ::protobuf::MessageField<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleConceptLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleConceptLanguageResponse {
    fn default() -> &'a SingleConceptLanguageResponse {
        <SingleConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptLanguageResponse {
    pub fn new() -> SingleConceptLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleConceptLanguageResponse| { &m.status },
            |m: &mut SingleConceptLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ConceptLanguage>(
            "concept_language",
            |m: &SingleConceptLanguageResponse| { &m.concept_language },
            |m: &mut SingleConceptLanguageResponse| { &mut m.concept_language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleConceptLanguageResponse>(
            "SingleConceptLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleConceptLanguageResponse {
    const NAME: &'static str = "SingleConceptLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_language)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept_language.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept_language.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleConceptLanguageResponse {
        SingleConceptLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleConceptLanguageResponse {
        static instance: SingleConceptLanguageResponse = SingleConceptLanguageResponse {
            status: ::protobuf::MessageField::none(),
            concept_language: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleConceptLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleConceptLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptLanguageResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptLanguageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptLanguageResponse.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptLanguageResponse {
    fn default() -> &'a MultiConceptLanguageResponse {
        <MultiConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptLanguageResponse {
    pub fn new() -> MultiConceptLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptLanguageResponse| { &m.status },
            |m: &mut MultiConceptLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &MultiConceptLanguageResponse| { &m.concept_languages },
            |m: &mut MultiConceptLanguageResponse| { &mut m.concept_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptLanguageResponse>(
            "MultiConceptLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptLanguageResponse {
    const NAME: &'static str = "MultiConceptLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptLanguageResponse {
        MultiConceptLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptLanguageResponse {
        static instance: MultiConceptLanguageResponse = MultiConceptLanguageResponse {
            status: ::protobuf::MessageField::none(),
            concept_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputRequest
// @@protoc_insertion_point(message:clarifai.api.GetInputRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputRequest {
    fn default() -> &'a GetInputRequest {
        <GetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputRequest {
    pub fn new() -> GetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputRequest| { &m.user_app_id },
            |m: &mut GetInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetInputRequest| { &m.input_id },
            |m: &mut GetInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputRequest>(
            "GetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputRequest {
    const NAME: &'static str = "GetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputRequest {
        GetInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputRequest {
        static instance: GetInputRequest = GetInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetVideoManifestRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetVideoManifestRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetVideoManifestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVideoManifestRequest {
    fn default() -> &'a GetVideoManifestRequest {
        <GetVideoManifestRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVideoManifestRequest {
    pub fn new() -> GetVideoManifestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetVideoManifestRequest| { &m.user_app_id },
            |m: &mut GetVideoManifestRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetVideoManifestRequest| { &m.input_id },
            |m: &mut GetVideoManifestRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVideoManifestRequest>(
            "GetVideoManifestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVideoManifestRequest {
    const NAME: &'static str = "GetVideoManifestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVideoManifestRequest {
        GetVideoManifestRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVideoManifestRequest {
        static instance: GetVideoManifestRequest = GetVideoManifestRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVideoManifestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVideoManifestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVideoManifestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVideoManifestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputSamplesRequest
// @@protoc_insertion_point(message:clarifai.api.GetInputSamplesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputSamplesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.task_id)
    pub task_id: ::std::string::String,
    ///  URL param. If zero ids provided, returns for all task labelers
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputSamplesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputSamplesRequest {
    fn default() -> &'a GetInputSamplesRequest {
        <GetInputSamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputSamplesRequest {
    pub fn new() -> GetInputSamplesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputSamplesRequest| { &m.user_app_id },
            |m: &mut GetInputSamplesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetInputSamplesRequest| { &m.task_id },
            |m: &mut GetInputSamplesRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &GetInputSamplesRequest| { &m.user_ids },
            |m: &mut GetInputSamplesRequest| { &mut m.user_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputSamplesRequest>(
            "GetInputSamplesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputSamplesRequest {
    const NAME: &'static str = "GetInputSamplesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputSamplesRequest {
        GetInputSamplesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputSamplesRequest {
        static instance: GetInputSamplesRequest = GetInputSamplesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            user_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputSamplesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputSamplesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputSamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputSamplesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListInputsRequest
// @@protoc_insertion_point(message:clarifai.api.ListInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.per_page)
    pub per_page: u32,
    ///  Set status to filter by status
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsRequest {
    fn default() -> &'a ListInputsRequest {
        <ListInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsRequest {
    pub fn new() -> ListInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsRequest| { &m.user_app_id },
            |m: &mut ListInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsRequest| { &m.page },
            |m: &mut ListInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsRequest| { &m.per_page },
            |m: &mut ListInputsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ListInputsRequest| { &m.status },
            |m: &mut ListInputsRequest| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListInputsRequest| { &m.ids },
            |m: &mut ListInputsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsRequest>(
            "ListInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsRequest {
    const NAME: &'static str = "ListInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                34 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsRequest {
        ListInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.status.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsRequest {
        static instance: ListInputsRequest = ListInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            status: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StreamInputsRequest
// @@protoc_insertion_point(message:clarifai.api.StreamInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 20.
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.last_id)
    pub last_id: ::std::string::String,
    ///  By default, the endpoint return inputs by the time when it is added.
    ///  If this is set to true, we will return inputs by id.
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.order_by_id)
    pub order_by_id: bool,
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.descending)
    pub descending: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StreamInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamInputsRequest {
    fn default() -> &'a StreamInputsRequest {
        <StreamInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamInputsRequest {
    pub fn new() -> StreamInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &StreamInputsRequest| { &m.user_app_id },
            |m: &mut StreamInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &StreamInputsRequest| { &m.per_page },
            |m: &mut StreamInputsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_id",
            |m: &StreamInputsRequest| { &m.last_id },
            |m: &mut StreamInputsRequest| { &mut m.last_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_by_id",
            |m: &StreamInputsRequest| { &m.order_by_id },
            |m: &mut StreamInputsRequest| { &mut m.order_by_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "descending",
            |m: &StreamInputsRequest| { &m.descending },
            |m: &mut StreamInputsRequest| { &mut m.descending },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamInputsRequest>(
            "StreamInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamInputsRequest {
    const NAME: &'static str = "StreamInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.per_page = is.read_uint32()?;
                },
                26 => {
                    self.last_id = is.read_string()?;
                },
                40 => {
                    self.order_by_id = is.read_bool()?;
                },
                32 => {
                    self.descending = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.per_page);
        }
        if !self.last_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.last_id);
        }
        if self.order_by_id != false {
            my_size += 1 + 1;
        }
        if self.descending != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        if !self.last_id.is_empty() {
            os.write_string(3, &self.last_id)?;
        }
        if self.order_by_id != false {
            os.write_bool(5, self.order_by_id)?;
        }
        if self.descending != false {
            os.write_bool(4, self.descending)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamInputsRequest {
        StreamInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.per_page = 0;
        self.last_id.clear();
        self.order_by_id = false;
        self.descending = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamInputsRequest {
        static instance: StreamInputsRequest = StreamInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            per_page: 0,
            last_id: ::std::string::String::new(),
            order_by_id: false,
            descending: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInputsRequest
// @@protoc_insertion_point(message:clarifai.api.PostInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of inputs to post.
    ///  For each input, the following fields are used:
    ///  * id
    ///  * data
    ///  * dataset_ids
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Collect statistics about created inputs in job with given ID.
    ///  * If job ID is empty, then job is not created.
    ///  * If job ID is non-empty and doesn't already exist, then a new job will be created with given ID.
    ///  * If job ID does already exist, then new inputs statistics are merged with previous inputs statistics.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.inputs_add_job_id)
    pub inputs_add_job_id: ::std::string::String,
    ///  How to handle input ID conflicts.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.input_id_conflict_resolution)
    pub input_id_conflict_resolution: ::protobuf::EnumOrUnknown<super::resources::InputIDConflictResolution>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsRequest {
    fn default() -> &'a PostInputsRequest {
        <PostInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsRequest {
    pub fn new() -> PostInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsRequest| { &m.user_app_id },
            |m: &mut PostInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostInputsRequest| { &m.inputs },
            |m: &mut PostInputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_add_job_id",
            |m: &PostInputsRequest| { &m.inputs_add_job_id },
            |m: &mut PostInputsRequest| { &mut m.inputs_add_job_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id_conflict_resolution",
            |m: &PostInputsRequest| { &m.input_id_conflict_resolution },
            |m: &mut PostInputsRequest| { &mut m.input_id_conflict_resolution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsRequest>(
            "PostInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsRequest {
    const NAME: &'static str = "PostInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    self.inputs_add_job_id = is.read_string()?;
                },
                32 => {
                    self.input_id_conflict_resolution = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.inputs_add_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.inputs_add_job_id);
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.input_id_conflict_resolution.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.inputs_add_job_id.is_empty() {
            os.write_string(3, &self.inputs_add_job_id)?;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.input_id_conflict_resolution))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsRequest {
        PostInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.inputs_add_job_id.clear();
        self.input_id_conflict_resolution = ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsRequest {
        static instance: PostInputsRequest = PostInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            inputs_add_job_id: ::std::string::String::new(),
            input_id_conflict_resolution: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchInputsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of inputs to patch.
    ///  Inputs are identified by id field.
    ///  For each input, the following fields are patchable:
    ///  * data
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchInputsRequest {
    fn default() -> &'a PatchInputsRequest {
        <PatchInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsRequest {
    pub fn new() -> PatchInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchInputsRequest| { &m.user_app_id },
            |m: &mut PatchInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PatchInputsRequest| { &m.inputs },
            |m: &mut PatchInputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchInputsRequest| { &m.action },
            |m: &mut PatchInputsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchInputsRequest>(
            "PatchInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchInputsRequest {
    const NAME: &'static str = "PatchInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchInputsRequest {
        PatchInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchInputsRequest {
        static instance: PatchInputsRequest = PatchInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteInputRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteInputRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInputRequest {
    fn default() -> &'a DeleteInputRequest {
        <DeleteInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputRequest {
    pub fn new() -> DeleteInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInputRequest| { &m.user_app_id },
            |m: &mut DeleteInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &DeleteInputRequest| { &m.input_id },
            |m: &mut DeleteInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInputRequest>(
            "DeleteInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInputRequest {
    const NAME: &'static str = "DeleteInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInputRequest {
        DeleteInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInputRequest {
        static instance: DeleteInputRequest = DeleteInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInputsRequest {
    fn default() -> &'a DeleteInputsRequest {
        <DeleteInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputsRequest {
    pub fn new() -> DeleteInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInputsRequest| { &m.user_app_id },
            |m: &mut DeleteInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteInputsRequest| { &m.ids },
            |m: &mut DeleteInputsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInputsRequest>(
            "DeleteInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInputsRequest {
    const NAME: &'static str = "DeleteInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInputsRequest {
        DeleteInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInputsRequest {
        static instance: DeleteInputsRequest = DeleteInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputResponse.input)
    pub input: ::protobuf::MessageField<super::resources::Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputResponse {
    fn default() -> &'a SingleInputResponse {
        <SingleInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputResponse {
    pub fn new() -> SingleInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputResponse| { &m.status },
            |m: &mut SingleInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Input>(
            "input",
            |m: &SingleInputResponse| { &m.input },
            |m: &mut SingleInputResponse| { &mut m.input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputResponse>(
            "SingleInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputResponse {
    const NAME: &'static str = "SingleInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputResponse {
        SingleInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputResponse {
        static instance: SingleInputResponse = SingleInputResponse {
            status: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetVideoManifestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetVideoManifestResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  MPEG-dash manifest as data-URI, base64-encoded
    ///  Can be empty if status is FAILED
    ///  Can be fallback manifest if status is MIXED_STATUS
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestResponse.manifest_url)
    pub manifest_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetVideoManifestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVideoManifestResponse {
    fn default() -> &'a GetVideoManifestResponse {
        <GetVideoManifestResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetVideoManifestResponse {
    pub fn new() -> GetVideoManifestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &GetVideoManifestResponse| { &m.status },
            |m: &mut GetVideoManifestResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manifest_url",
            |m: &GetVideoManifestResponse| { &m.manifest_url },
            |m: &mut GetVideoManifestResponse| { &mut m.manifest_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVideoManifestResponse>(
            "GetVideoManifestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVideoManifestResponse {
    const NAME: &'static str = "GetVideoManifestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.manifest_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.manifest_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.manifest_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.manifest_url.is_empty() {
            os.write_string(2, &self.manifest_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVideoManifestResponse {
        GetVideoManifestResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.manifest_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVideoManifestResponse {
        static instance: GetVideoManifestResponse = GetVideoManifestResponse {
            status: ::protobuf::MessageField::none(),
            manifest_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVideoManifestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVideoManifestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVideoManifestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVideoManifestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.inputs_add_job)
    pub inputs_add_job: ::protobuf::MessageField<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputResponse {
    fn default() -> &'a MultiInputResponse {
        <MultiInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputResponse {
    pub fn new() -> MultiInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputResponse| { &m.status },
            |m: &mut MultiInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &MultiInputResponse| { &m.inputs },
            |m: &mut MultiInputResponse| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsAddJob>(
            "inputs_add_job",
            |m: &MultiInputResponse| { &m.inputs_add_job },
            |m: &mut MultiInputResponse| { &mut m.inputs_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputResponse>(
            "MultiInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputResponse {
    const NAME: &'static str = "MultiInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inputs_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.inputs_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputResponse {
        MultiInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs.clear();
        self.inputs_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputResponse {
        static instance: MultiInputResponse = MultiInputResponse {
            status: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            inputs_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputAnnotationResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInputAnnotationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputAnnotationResponse.hits)
    pub hits: ::std::vec::Vec<super::resources::Hit>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputAnnotationResponse {
    fn default() -> &'a MultiInputAnnotationResponse {
        <MultiInputAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputAnnotationResponse {
    pub fn new() -> MultiInputAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputAnnotationResponse| { &m.status },
            |m: &mut MultiInputAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &MultiInputAnnotationResponse| { &m.hits },
            |m: &mut MultiInputAnnotationResponse| { &mut m.hits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputAnnotationResponse>(
            "MultiInputAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputAnnotationResponse {
    const NAME: &'static str = "MultiInputAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                26 => {
                    self.hits.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputAnnotationResponse {
        MultiInputAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.hits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputAnnotationResponse {
        static instance: MultiInputAnnotationResponse = MultiInputAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            hits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputCountResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInputCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputCountResponse.counts)
    pub counts: ::protobuf::MessageField<super::resources::InputCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputCountResponse {
    fn default() -> &'a SingleInputCountResponse {
        <SingleInputCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputCountResponse {
    pub fn new() -> SingleInputCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputCountResponse| { &m.status },
            |m: &mut SingleInputCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputCount>(
            "counts",
            |m: &SingleInputCountResponse| { &m.counts },
            |m: &mut SingleInputCountResponse| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputCountResponse>(
            "SingleInputCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputCountResponse {
    const NAME: &'static str = "SingleInputCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.counts)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputCountResponse {
        SingleInputCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputCountResponse {
        static instance: SingleInputCountResponse = SingleInputCountResponse {
            status: ::protobuf::MessageField::none(),
            counts: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputCountRequest
// @@protoc_insertion_point(message:clarifai.api.GetInputCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputCountRequest {
    fn default() -> &'a GetInputCountRequest {
        <GetInputCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputCountRequest {
    pub fn new() -> GetInputCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputCountRequest| { &m.user_app_id },
            |m: &mut GetInputCountRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputCountRequest>(
            "GetInputCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputCountRequest {
    const NAME: &'static str = "GetInputCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputCountRequest {
        GetInputCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputCountRequest {
        static instance: GetInputCountRequest = GetInputCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.starred_only)
    pub starred_only: bool,
    ///  Filter datasets by bookmark. If set, only return bookmarked datasets. Otherwise none bookmarked datasets only.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the dataset:
    ///    - id
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.search)
    pub search: ::std::string::String,
    ///  Fuzzy filter on dataset ID
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.id)
    pub id: ::std::string::String,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_datasets_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetsRequest {
    fn default() -> &'a ListDatasetsRequest {
        <ListDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetsRequest {
    pub fn new() -> ListDatasetsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_created_at = 7;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 8;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(v))
    }

    // bool sort_by_modified_at = 9;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_id = 11;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetsRequest| { &m.user_app_id },
            |m: &mut ListDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetsRequest| { &m.page },
            |m: &mut ListDatasetsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetsRequest| { &m.per_page },
            |m: &mut ListDatasetsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListDatasetsRequest| { &m.additional_fields },
            |m: &mut ListDatasetsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListDatasetsRequest| { &m.sort_ascending },
            |m: &mut ListDatasetsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListDatasetsRequest::has_sort_by_created_at,
            ListDatasetsRequest::sort_by_created_at,
            ListDatasetsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListDatasetsRequest::has_sort_by_star_count,
            ListDatasetsRequest::sort_by_star_count,
            ListDatasetsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListDatasetsRequest::has_sort_by_modified_at,
            ListDatasetsRequest::sort_by_modified_at,
            ListDatasetsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListDatasetsRequest::has_sort_by_id,
            ListDatasetsRequest::sort_by_id,
            ListDatasetsRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListDatasetsRequest| { &m.starred_only },
            |m: &mut ListDatasetsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListDatasetsRequest| { &m.bookmark },
            |m: &mut ListDatasetsRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListDatasetsRequest| { &m.search },
            |m: &mut ListDatasetsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListDatasetsRequest| { &m.id },
            |m: &mut ListDatasetsRequest| { &mut m.id },
        ));
        oneofs.push(list_datasets_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetsRequest>(
            "ListDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetsRequest {
    const NAME: &'static str = "ListDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.additional_fields.push(is.read_string()?);
                },
                48 => {
                    self.sort_ascending = is.read_bool()?;
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(is.read_bool()?));
                },
                32 => {
                    self.starred_only = is.read_bool()?;
                },
                80 => {
                    self.bookmark = is.read_bool()?;
                },
                106 => {
                    self.search = is.read_string()?;
                },
                98 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.search);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.id);
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_datasets_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(5, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(6, self.sort_ascending)?;
        }
        if self.starred_only != false {
            os.write_bool(4, self.starred_only)?;
        }
        if self.bookmark != false {
            os.write_bool(10, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(13, &self.search)?;
        }
        if !self.id.is_empty() {
            os.write_string(12, &self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_datasets_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_datasets_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(8, v)?;
                },
                &list_datasets_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(9, v)?;
                },
                &list_datasets_request::Sort_by::SortById(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetsRequest {
        ListDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.starred_only = false;
        self.bookmark = false;
        self.search.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetsRequest {
        static instance: ListDatasetsRequest = ListDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            starred_only: false,
            bookmark: false,
            search: ::std::string::String::new(),
            id: ::std::string::String::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListDatasetsRequest`
pub mod list_datasets_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListDatasetsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_star_count)
        SortByStarCount(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_id)
        SortById(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListDatasetsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  GetDatasetRequest
// @@protoc_insertion_point(message:clarifai.api.GetDatasetRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDatasetRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetRequest {
    fn default() -> &'a GetDatasetRequest {
        <GetDatasetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetRequest {
    pub fn new() -> GetDatasetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetRequest| { &m.user_app_id },
            |m: &mut GetDatasetRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetRequest| { &m.dataset_id },
            |m: &mut GetDatasetRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetDatasetRequest| { &m.additional_fields },
            |m: &mut GetDatasetRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetRequest>(
            "GetDatasetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetRequest {
    const NAME: &'static str = "GetDatasetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetRequest {
        GetDatasetRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetRequest {
        static instance: GetDatasetRequest = GetDatasetRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more datasets.
// @@protoc_insertion_point(message:clarifai.api.PostDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of datasets that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetsRequest.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetsRequest {
    fn default() -> &'a PostDatasetsRequest {
        <PostDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetsRequest {
    pub fn new() -> PostDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetsRequest| { &m.user_app_id },
            |m: &mut PostDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &PostDatasetsRequest| { &m.datasets },
            |m: &mut PostDatasetsRequest| { &mut m.datasets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetsRequest>(
            "PostDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetsRequest {
    const NAME: &'static str = "PostDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetsRequest {
        PostDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.datasets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetsRequest {
        static instance: PostDatasetsRequest = PostDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several datasets.
// @@protoc_insertion_point(message:clarifai.api.PatchDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of datasets that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    ///  The action to perform on the patched objects
    ///  Supported values: 'overwrite', 'merge', and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the dataset image by setting
    ///  'image.url' in the request to the current value returned for that dataset.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchDatasetsRequest {
    fn default() -> &'a PatchDatasetsRequest {
        <PatchDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDatasetsRequest {
    pub fn new() -> PatchDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchDatasetsRequest| { &m.user_app_id },
            |m: &mut PatchDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &PatchDatasetsRequest| { &m.datasets },
            |m: &mut PatchDatasetsRequest| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchDatasetsRequest| { &m.action },
            |m: &mut PatchDatasetsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchDatasetsRequest>(
            "PatchDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchDatasetsRequest {
    const NAME: &'static str = "PatchDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchDatasetsRequest {
        PatchDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.datasets.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchDatasetsRequest {
        static instance: PatchDatasetsRequest = PatchDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several datasets by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetsRequest.dataset_ids)
    pub dataset_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetsRequest {
    fn default() -> &'a DeleteDatasetsRequest {
        <DeleteDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetsRequest {
    pub fn new() -> DeleteDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_ids",
            |m: &DeleteDatasetsRequest| { &m.dataset_ids },
            |m: &mut DeleteDatasetsRequest| { &mut m.dataset_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetsRequest>(
            "DeleteDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetsRequest {
    const NAME: &'static str = "DeleteDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetsRequest {
        DeleteDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetsRequest {
        static instance: DeleteDatasetsRequest = DeleteDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiDatasetResponse
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetResponse.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetResponse {
    fn default() -> &'a MultiDatasetResponse {
        <MultiDatasetResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetResponse {
    pub fn new() -> MultiDatasetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetResponse| { &m.status },
            |m: &mut MultiDatasetResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &MultiDatasetResponse| { &m.datasets },
            |m: &mut MultiDatasetResponse| { &mut m.datasets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetResponse>(
            "MultiDatasetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetResponse {
    const NAME: &'static str = "MultiDatasetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetResponse {
        MultiDatasetResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.datasets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetResponse {
        static instance: MultiDatasetResponse = MultiDatasetResponse {
            status: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleDatasetResponse
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDatasetResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetResponse.dataset)
    pub dataset: ::protobuf::MessageField<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetResponse {
    fn default() -> &'a SingleDatasetResponse {
        <SingleDatasetResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetResponse {
    pub fn new() -> SingleDatasetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetResponse| { &m.status },
            |m: &mut SingleDatasetResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Dataset>(
            "dataset",
            |m: &SingleDatasetResponse| { &m.dataset },
            |m: &mut SingleDatasetResponse| { &mut m.dataset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetResponse>(
            "SingleDatasetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetResponse {
    const NAME: &'static str = "SingleDatasetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetResponse {
        SingleDatasetResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetResponse {
        static instance: SingleDatasetResponse = SingleDatasetResponse {
            status: ::protobuf::MessageField::none(),
            dataset: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetInputsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetInputsRequest {
    fn default() -> &'a ListDatasetInputsRequest {
        <ListDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetInputsRequest {
    pub fn new() -> ListDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetInputsRequest| { &m.user_app_id },
            |m: &mut ListDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetInputsRequest| { &m.dataset_id },
            |m: &mut ListDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetInputsRequest| { &m.page },
            |m: &mut ListDatasetInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetInputsRequest| { &m.per_page },
            |m: &mut ListDatasetInputsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetInputsRequest>(
            "ListDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetInputsRequest {
    const NAME: &'static str = "ListDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetInputsRequest {
        ListDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetInputsRequest {
        static instance: ListDatasetInputsRequest = ListDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetDatasetInputRequest
// @@protoc_insertion_point(message:clarifai.api.GetDatasetInputRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDatasetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset input by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetInputRequest {
    fn default() -> &'a GetDatasetInputRequest {
        <GetDatasetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetInputRequest {
    pub fn new() -> GetDatasetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetInputRequest| { &m.user_app_id },
            |m: &mut GetDatasetInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetInputRequest| { &m.dataset_id },
            |m: &mut GetDatasetInputRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetDatasetInputRequest| { &m.input_id },
            |m: &mut GetDatasetInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetInputRequest>(
            "GetDatasetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetInputRequest {
    const NAME: &'static str = "GetDatasetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetInputRequest {
        GetDatasetInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetInputRequest {
        static instance: GetDatasetInputRequest = GetDatasetInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more datasets.
// @@protoc_insertion_point(message:clarifai.api.PostDatasetInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of inputs that are requested to be added to this dataset.
    ///  Identify each input by id field. All other inputs fields are ignored.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.dataset_inputs)
    pub dataset_inputs: ::std::vec::Vec<super::resources::DatasetInput>,
    ///  Query to search inputs to be added to this dataset.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.search)
    pub search: ::protobuf::MessageField<super::resources::Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetInputsRequest {
    fn default() -> &'a PostDatasetInputsRequest {
        <PostDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetInputsRequest {
    pub fn new() -> PostDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetInputsRequest| { &m.user_app_id },
            |m: &mut PostDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PostDatasetInputsRequest| { &m.dataset_id },
            |m: &mut PostDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_inputs",
            |m: &PostDatasetInputsRequest| { &m.dataset_inputs },
            |m: &mut PostDatasetInputsRequest| { &mut m.dataset_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search",
            |m: &PostDatasetInputsRequest| { &m.search },
            |m: &mut PostDatasetInputsRequest| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetInputsRequest>(
            "PostDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetInputsRequest {
    const NAME: &'static str = "PostDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetInputsRequest {
        PostDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_inputs.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetInputsRequest {
        static instance: PostDatasetInputsRequest = PostDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_inputs: ::std::vec::Vec::new(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several dataset inputs by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Specify which inputs to delete from dataset.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetInputsRequest {
    fn default() -> &'a DeleteDatasetInputsRequest {
        <DeleteDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetInputsRequest {
    pub fn new() -> DeleteDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetInputsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteDatasetInputsRequest| { &m.dataset_id },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &DeleteDatasetInputsRequest| { &m.input_ids },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetInputsRequest>(
            "DeleteDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetInputsRequest {
    const NAME: &'static str = "DeleteDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetInputsRequest {
        DeleteDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetInputsRequest {
        static instance: DeleteDatasetInputsRequest = DeleteDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiDatasetInputResponse
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.dataset_inputs)
    pub dataset_inputs: ::std::vec::Vec<super::resources::DatasetInput>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.bulk_operation)
    pub bulk_operation: ::protobuf::MessageField<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetInputResponse {
    fn default() -> &'a MultiDatasetInputResponse {
        <MultiDatasetInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetInputResponse {
    pub fn new() -> MultiDatasetInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetInputResponse| { &m.status },
            |m: &mut MultiDatasetInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_inputs",
            |m: &MultiDatasetInputResponse| { &m.dataset_inputs },
            |m: &mut MultiDatasetInputResponse| { &mut m.dataset_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::BulkOperation>(
            "bulk_operation",
            |m: &MultiDatasetInputResponse| { &m.bulk_operation },
            |m: &mut MultiDatasetInputResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetInputResponse>(
            "MultiDatasetInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetInputResponse {
    const NAME: &'static str = "MultiDatasetInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bulk_operation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bulk_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.bulk_operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetInputResponse {
        MultiDatasetInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_inputs.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetInputResponse {
        static instance: MultiDatasetInputResponse = MultiDatasetInputResponse {
            status: ::protobuf::MessageField::none(),
            dataset_inputs: ::std::vec::Vec::new(),
            bulk_operation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleDatasetInputResponse
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDatasetInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputResponse.dataset_input)
    pub dataset_input: ::protobuf::MessageField<super::resources::DatasetInput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetInputResponse {
    fn default() -> &'a SingleDatasetInputResponse {
        <SingleDatasetInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetInputResponse {
    pub fn new() -> SingleDatasetInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetInputResponse| { &m.status },
            |m: &mut SingleDatasetInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetInput>(
            "dataset_input",
            |m: &SingleDatasetInputResponse| { &m.dataset_input },
            |m: &mut SingleDatasetInputResponse| { &mut m.dataset_input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetInputResponse>(
            "SingleDatasetInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetInputResponse {
    const NAME: &'static str = "SingleDatasetInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetInputResponse {
        SingleDatasetInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetInputResponse {
        static instance: SingleDatasetInputResponse = SingleDatasetInputResponse {
            status: ::protobuf::MessageField::none(),
            dataset_input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetVersionsRequest {
    fn default() -> &'a ListDatasetVersionsRequest {
        <ListDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetVersionsRequest {
    pub fn new() -> ListDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut ListDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut ListDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetVersionsRequest| { &m.page },
            |m: &mut ListDatasetVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetVersionsRequest| { &m.per_page },
            |m: &mut ListDatasetVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetVersionsRequest>(
            "ListDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetVersionsRequest {
    const NAME: &'static str = "ListDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetVersionsRequest {
        ListDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetVersionsRequest {
        static instance: ListDatasetVersionsRequest = ListDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetDatasetVersionRequest
// @@protoc_insertion_point(message:clarifai.api.GetDatasetVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDatasetVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetVersionRequest {
    fn default() -> &'a GetDatasetVersionRequest {
        <GetDatasetVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetVersionRequest {
    pub fn new() -> GetDatasetVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetVersionRequest| { &m.user_app_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetVersionRequest| { &m.dataset_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &GetDatasetVersionRequest| { &m.dataset_version_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.dataset_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetVersionRequest>(
            "GetDatasetVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetVersionRequest {
    const NAME: &'static str = "GetDatasetVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetVersionRequest {
        GetDatasetVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetVersionRequest {
        static instance: GetDatasetVersionRequest = GetDatasetVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetVersionMetricsGroupsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetVersionMetricsGroupsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetVersionMetricsGroupsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.per_page)
    pub per_page: u32,
    ///  Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.parent_paths)
    pub parent_paths: ::std::vec::Vec<::std::string::String>,
    ///  Filter by parent type. Multiple types are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::resources::DatasetVersionMetricsGroupType>>,
    ///  Filter by value. Multiple values are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.values)
    pub values: ::std::vec::Vec<::protobuf::well_known_types::struct_::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetVersionMetricsGroupsRequest {
    fn default() -> &'a ListDatasetVersionMetricsGroupsRequest {
        <ListDatasetVersionMetricsGroupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetVersionMetricsGroupsRequest {
    pub fn new() -> ListDatasetVersionMetricsGroupsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.user_app_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.dataset_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.dataset_version_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.dataset_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.page },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.per_page },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parent_paths",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.parent_paths },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.parent_paths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.types },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.values },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetVersionMetricsGroupsRequest>(
            "ListDatasetVersionMetricsGroupsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetVersionMetricsGroupsRequest {
    const NAME: &'static str = "ListDatasetVersionMetricsGroupsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                50 => {
                    self.parent_paths.push(is.read_string()?);
                },
                56 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                66 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        for value in &self.parent_paths {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.types {
            my_size += ::protobuf::rt::int32_size(7, value.value());
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        for v in &self.parent_paths {
            os.write_string(6, &v)?;
        };
        for v in &self.types {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetVersionMetricsGroupsRequest {
        ListDatasetVersionMetricsGroupsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.parent_paths.clear();
        self.types.clear();
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetVersionMetricsGroupsRequest {
        static instance: ListDatasetVersionMetricsGroupsRequest = ListDatasetVersionMetricsGroupsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            parent_paths: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetVersionMetricsGroupsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetVersionMetricsGroupsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetVersionMetricsGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetVersionMetricsGroupsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more dataset versions.
// @@protoc_insertion_point(message:clarifai.api.PostDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of dataset versions that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetVersionsRequest {
    fn default() -> &'a PostDatasetVersionsRequest {
        <PostDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetVersionsRequest {
    pub fn new() -> PostDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut PostDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PostDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut PostDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &PostDatasetVersionsRequest| { &m.dataset_versions },
            |m: &mut PostDatasetVersionsRequest| { &mut m.dataset_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetVersionsRequest>(
            "PostDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetVersionsRequest {
    const NAME: &'static str = "PostDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetVersionsRequest {
        PostDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetVersionsRequest {
        static instance: PostDatasetVersionsRequest = PostDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several dataset versions.
// @@protoc_insertion_point(message:clarifai.api.PatchDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of dataset versions that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    ///  The action to perform on the patched objects
    ///  For now, only 'overwrite' action is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchDatasetVersionsRequest {
    fn default() -> &'a PatchDatasetVersionsRequest {
        <PatchDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDatasetVersionsRequest {
    pub fn new() -> PatchDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PatchDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &PatchDatasetVersionsRequest| { &m.dataset_versions },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.dataset_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchDatasetVersionsRequest| { &m.action },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchDatasetVersionsRequest>(
            "PatchDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchDatasetVersionsRequest {
    const NAME: &'static str = "PatchDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchDatasetVersionsRequest {
        PatchDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchDatasetVersionsRequest {
        static instance: PatchDatasetVersionsRequest = PatchDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several dataset versions by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.dataset_version_ids)
    pub dataset_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetVersionsRequest {
    fn default() -> &'a DeleteDatasetVersionsRequest {
        <DeleteDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetVersionsRequest {
    pub fn new() -> DeleteDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_version_ids",
            |m: &DeleteDatasetVersionsRequest| { &m.dataset_version_ids },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.dataset_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetVersionsRequest>(
            "DeleteDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetVersionsRequest {
    const NAME: &'static str = "DeleteDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetVersionsRequest {
        DeleteDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetVersionsRequest {
        static instance: DeleteDatasetVersionsRequest = DeleteDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create exports of a dataset version.
// @@protoc_insertion_point(message:clarifai.api.PutDatasetVersionExportsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutDatasetVersionExportsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    ///  exports is the list of requested dataset version exports.
    ///  Only setting the 'format' field of the export is supported.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.exports)
    pub exports: ::std::vec::Vec<super::resources::DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutDatasetVersionExportsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutDatasetVersionExportsRequest {
    fn default() -> &'a PutDatasetVersionExportsRequest {
        <PutDatasetVersionExportsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutDatasetVersionExportsRequest {
    pub fn new() -> PutDatasetVersionExportsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutDatasetVersionExportsRequest| { &m.user_app_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PutDatasetVersionExportsRequest| { &m.dataset_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &PutDatasetVersionExportsRequest| { &m.dataset_version_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.dataset_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &PutDatasetVersionExportsRequest| { &m.exports },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.exports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutDatasetVersionExportsRequest>(
            "PutDatasetVersionExportsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutDatasetVersionExportsRequest {
    const NAME: &'static str = "PutDatasetVersionExportsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                34 => {
                    self.exports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutDatasetVersionExportsRequest {
        PutDatasetVersionExportsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.exports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutDatasetVersionExportsRequest {
        static instance: PutDatasetVersionExportsRequest = PutDatasetVersionExportsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            exports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutDatasetVersionExportsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutDatasetVersionExportsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutDatasetVersionExportsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutDatasetVersionExportsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionResponse.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionResponse {
    fn default() -> &'a MultiDatasetVersionResponse {
        <MultiDatasetVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionResponse {
    pub fn new() -> MultiDatasetVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionResponse| { &m.status },
            |m: &mut MultiDatasetVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &MultiDatasetVersionResponse| { &m.dataset_versions },
            |m: &mut MultiDatasetVersionResponse| { &mut m.dataset_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionResponse>(
            "MultiDatasetVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionResponse {
    const NAME: &'static str = "MultiDatasetVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionResponse {
        MultiDatasetVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionResponse {
        static instance: MultiDatasetVersionResponse = MultiDatasetVersionResponse {
            status: ::protobuf::MessageField::none(),
            dataset_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionExportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetVersionExportResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionExportResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionExportResponse.exports)
    pub exports: ::std::vec::Vec<super::resources::DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionExportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionExportResponse {
    fn default() -> &'a MultiDatasetVersionExportResponse {
        <MultiDatasetVersionExportResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionExportResponse {
    pub fn new() -> MultiDatasetVersionExportResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionExportResponse| { &m.status },
            |m: &mut MultiDatasetVersionExportResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &MultiDatasetVersionExportResponse| { &m.exports },
            |m: &mut MultiDatasetVersionExportResponse| { &mut m.exports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionExportResponse>(
            "MultiDatasetVersionExportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionExportResponse {
    const NAME: &'static str = "MultiDatasetVersionExportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.exports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionExportResponse {
        MultiDatasetVersionExportResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.exports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionExportResponse {
        static instance: MultiDatasetVersionExportResponse = MultiDatasetVersionExportResponse {
            status: ::protobuf::MessageField::none(),
            exports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionExportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionExportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionExportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionExportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionMetricsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetVersionMetricsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.dataset_version_metrics_groups)
    pub dataset_version_metrics_groups: ::std::vec::Vec<super::resources::DatasetVersionMetricsGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionMetricsGroupResponse {
    fn default() -> &'a MultiDatasetVersionMetricsGroupResponse {
        <MultiDatasetVersionMetricsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionMetricsGroupResponse {
    pub fn new() -> MultiDatasetVersionMetricsGroupResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionMetricsGroupResponse| { &m.status },
            |m: &mut MultiDatasetVersionMetricsGroupResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_version_metrics_groups",
            |m: &MultiDatasetVersionMetricsGroupResponse| { &m.dataset_version_metrics_groups },
            |m: &mut MultiDatasetVersionMetricsGroupResponse| { &mut m.dataset_version_metrics_groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionMetricsGroupResponse>(
            "MultiDatasetVersionMetricsGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionMetricsGroupResponse {
    const NAME: &'static str = "MultiDatasetVersionMetricsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_version_metrics_groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_version_metrics_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_version_metrics_groups {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionMetricsGroupResponse {
        MultiDatasetVersionMetricsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_version_metrics_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionMetricsGroupResponse {
        static instance: MultiDatasetVersionMetricsGroupResponse = MultiDatasetVersionMetricsGroupResponse {
            status: ::protobuf::MessageField::none(),
            dataset_version_metrics_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionMetricsGroupResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionMetricsGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionMetricsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionMetricsGroupResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleDatasetVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDatasetVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetVersionResponse.dataset_version)
    pub dataset_version: ::protobuf::MessageField<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetVersionResponse {
    fn default() -> &'a SingleDatasetVersionResponse {
        <SingleDatasetVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetVersionResponse {
    pub fn new() -> SingleDatasetVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetVersionResponse| { &m.status },
            |m: &mut SingleDatasetVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetVersion>(
            "dataset_version",
            |m: &SingleDatasetVersionResponse| { &m.dataset_version },
            |m: &mut SingleDatasetVersionResponse| { &mut m.dataset_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetVersionResponse>(
            "SingleDatasetVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetVersionResponse {
    const NAME: &'static str = "SingleDatasetVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetVersionResponse {
        SingleDatasetVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetVersionResponse {
        static instance: SingleDatasetVersionResponse = SingleDatasetVersionResponse {
            status: ::protobuf::MessageField::none(),
            dataset_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// //////////////////////////////////////////////////
///  Model prediction related stuff needs inputs and produces outputs.
/// //////////////////////////////////////////////////
///  Model prediction.
// @@protoc_insertion_point(message:clarifai.api.PostModelOutputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelOutputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  This allows you to specify config options for the model such as
    ///  the language which appear's in the model's output_info.
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelOutputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelOutputsRequest {
    fn default() -> &'a PostModelOutputsRequest {
        <PostModelOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelOutputsRequest {
    pub fn new() -> PostModelOutputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelOutputsRequest| { &m.user_app_id },
            |m: &mut PostModelOutputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelOutputsRequest| { &m.model_id },
            |m: &mut PostModelOutputsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostModelOutputsRequest| { &m.version_id },
            |m: &mut PostModelOutputsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostModelOutputsRequest| { &m.inputs },
            |m: &mut PostModelOutputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &PostModelOutputsRequest| { &m.model },
            |m: &mut PostModelOutputsRequest| { &mut m.model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelOutputsRequest>(
            "PostModelOutputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelOutputsRequest {
    const NAME: &'static str = "PostModelOutputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    self.inputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelOutputsRequest {
        PostModelOutputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelOutputsRequest {
        static instance: PostModelOutputsRequest = PostModelOutputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelOutputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelOutputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelOutputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Listing the inputs that went into training this model.
// @@protoc_insertion_point(message:clarifai.api.ListModelInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelInputsRequest {
    fn default() -> &'a ListModelInputsRequest {
        <ListModelInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelInputsRequest {
    pub fn new() -> ListModelInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelInputsRequest| { &m.user_app_id },
            |m: &mut ListModelInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelInputsRequest| { &m.model_id },
            |m: &mut ListModelInputsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ListModelInputsRequest| { &m.version_id },
            |m: &mut ListModelInputsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelInputsRequest| { &m.page },
            |m: &mut ListModelInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelInputsRequest| { &m.per_page },
            |m: &mut ListModelInputsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelInputsRequest>(
            "ListModelInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelInputsRequest {
    const NAME: &'static str = "ListModelInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelInputsRequest {
        ListModelInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelInputsRequest {
        static instance: ListModelInputsRequest = ListModelInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetKeyRequest
// @@protoc_insertion_point(message:clarifai.api.GetKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetKeyRequest.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetKeyRequest {
    fn default() -> &'a GetKeyRequest {
        <GetKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyRequest {
    pub fn new() -> GetKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetKeyRequest| { &m.user_app_id },
            |m: &mut GetKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &GetKeyRequest| { &m.key_id },
            |m: &mut GetKeyRequest| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetKeyRequest>(
            "GetKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetKeyRequest {
    const NAME: &'static str = "GetKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetKeyRequest {
        GetKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetKeyRequest {
        static instance: GetKeyRequest = GetKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListKeysRequest
// @@protoc_insertion_point(message:clarifai.api.ListKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.not_expired)
    pub not_expired: bool,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListKeysRequest| { &m.user_app_id },
            |m: &mut ListKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListKeysRequest| { &m.page },
            |m: &mut ListKeysRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListKeysRequest| { &m.per_page },
            |m: &mut ListKeysRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "not_expired",
            |m: &ListKeysRequest| { &m.not_expired },
            |m: &mut ListKeysRequest| { &mut m.not_expired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &ListKeysRequest| { &m.scopes },
            |m: &mut ListKeysRequest| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &ListKeysRequest| { &m.endpoints },
            |m: &mut ListKeysRequest| { &mut m.endpoints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListKeysRequest>(
            "ListKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListKeysRequest {
    const NAME: &'static str = "ListKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.not_expired = is.read_bool()?;
                },
                42 => {
                    self.scopes.push(is.read_string()?);
                },
                50 => {
                    self.endpoints.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.not_expired != false {
            my_size += 1 + 1;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.not_expired != false {
            os.write_bool(4, self.not_expired)?;
        }
        for v in &self.scopes {
            os.write_string(5, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.not_expired = false;
        self.scopes.clear();
        self.endpoints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ListKeysRequest = ListKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            not_expired: false,
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAppKeysRequest
// @@protoc_insertion_point(message:clarifai.api.ListAppKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAppKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppKeysRequest {
    fn default() -> &'a ListAppKeysRequest {
        <ListAppKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppKeysRequest {
    pub fn new() -> ListAppKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppKeysRequest| { &m.user_app_id },
            |m: &mut ListAppKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppKeysRequest| { &m.page },
            |m: &mut ListAppKeysRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppKeysRequest| { &m.per_page },
            |m: &mut ListAppKeysRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppKeysRequest>(
            "ListAppKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppKeysRequest {
    const NAME: &'static str = "ListAppKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppKeysRequest {
        ListAppKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppKeysRequest {
        static instance: ListAppKeysRequest = ListAppKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostKeysRequest
// @@protoc_insertion_point(message:clarifai.api.PostKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostKeysRequest.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostKeysRequest {
    fn default() -> &'a PostKeysRequest {
        <PostKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKeysRequest {
    pub fn new() -> PostKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostKeysRequest| { &m.user_app_id },
            |m: &mut PostKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &PostKeysRequest| { &m.keys },
            |m: &mut PostKeysRequest| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostKeysRequest>(
            "PostKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostKeysRequest {
    const NAME: &'static str = "PostKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostKeysRequest {
        PostKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostKeysRequest {
        static instance: PostKeysRequest = PostKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteKeyRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteKeyRequest.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteKeyRequest {
    fn default() -> &'a DeleteKeyRequest {
        <DeleteKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteKeyRequest {
    pub fn new() -> DeleteKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteKeyRequest| { &m.user_app_id },
            |m: &mut DeleteKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &DeleteKeyRequest| { &m.key_id },
            |m: &mut DeleteKeyRequest| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteKeyRequest>(
            "DeleteKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteKeyRequest {
    const NAME: &'static str = "DeleteKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteKeyRequest {
        DeleteKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteKeyRequest {
        static instance: DeleteKeyRequest = DeleteKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchKeysRequest
// @@protoc_insertion_point(message:clarifai.api.PatchKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    ///  The action to perform on the patched objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchKeysRequest {
    fn default() -> &'a PatchKeysRequest {
        <PatchKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchKeysRequest {
    pub fn new() -> PatchKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchKeysRequest| { &m.user_app_id },
            |m: &mut PatchKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &PatchKeysRequest| { &m.keys },
            |m: &mut PatchKeysRequest| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchKeysRequest| { &m.action },
            |m: &mut PatchKeysRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchKeysRequest>(
            "PatchKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchKeysRequest {
    const NAME: &'static str = "PatchKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchKeysRequest {
        PatchKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchKeysRequest {
        static instance: PatchKeysRequest = PatchKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleKeyResponse
// @@protoc_insertion_point(message:clarifai.api.SingleKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleKeyResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleKeyResponse.key)
    pub key: ::protobuf::MessageField<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleKeyResponse {
    fn default() -> &'a SingleKeyResponse {
        <SingleKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleKeyResponse {
    pub fn new() -> SingleKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleKeyResponse| { &m.status },
            |m: &mut SingleKeyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Key>(
            "key",
            |m: &SingleKeyResponse| { &m.key },
            |m: &mut SingleKeyResponse| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleKeyResponse>(
            "SingleKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleKeyResponse {
    const NAME: &'static str = "SingleKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleKeyResponse {
        SingleKeyResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleKeyResponse {
        static instance: SingleKeyResponse = SingleKeyResponse {
            status: ::protobuf::MessageField::none(),
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiKeyResponse
// @@protoc_insertion_point(message:clarifai.api.MultiKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiKeyResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiKeyResponse.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiKeyResponse {
    fn default() -> &'a MultiKeyResponse {
        <MultiKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKeyResponse {
    pub fn new() -> MultiKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiKeyResponse| { &m.status },
            |m: &mut MultiKeyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &MultiKeyResponse| { &m.keys },
            |m: &mut MultiKeyResponse| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiKeyResponse>(
            "MultiKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiKeyResponse {
    const NAME: &'static str = "MultiKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiKeyResponse {
        MultiKeyResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiKeyResponse {
        static instance: MultiKeyResponse = MultiKeyResponse {
            status: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.model_id)
    pub model_id: ::std::string::String,
    ///  This is included so that we can re-use this request for multiple
    ///  rpcs with and without the version_id.
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.language)
    pub language: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.trained_before)
    pub trained_before: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelRequest {
    fn default() -> &'a GetModelRequest {
        <GetModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelRequest {
    pub fn new() -> GetModelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelRequest| { &m.user_app_id },
            |m: &mut GetModelRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelRequest| { &m.model_id },
            |m: &mut GetModelRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelRequest| { &m.version_id },
            |m: &mut GetModelRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &GetModelRequest| { &m.language },
            |m: &mut GetModelRequest| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_before",
            |m: &GetModelRequest| { &m.trained_before },
            |m: &mut GetModelRequest| { &mut m.trained_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetModelRequest| { &m.additional_fields },
            |m: &mut GetModelRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelRequest>(
            "GetModelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelRequest {
    const NAME: &'static str = "GetModelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    self.language = is.read_string()?;
                },
                40 => {
                    self.trained_before = is.read_bool()?;
                },
                154 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if self.trained_before != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if self.trained_before != false {
            os.write_bool(5, self.trained_before)?;
        }
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelRequest {
        GetModelRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.language.clear();
        self.trained_before = false;
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelRequest {
        static instance: GetModelRequest = GetModelRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            trained_before: false,
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
    ///  supported.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.trained_only)
    pub trained_only: bool,
    ///  The list of input fields to the model.
    ///  For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.input_fields)
    pub input_fields: ::std::vec::Vec<::std::string::String>,
    ///  The list of output fields to the model.
    ///  For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.output_fields)
    pub output_fields: ::std::vec::Vec<::std::string::String>,
    ///  Filter by the license of the model version
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.license)
    pub license: ::std::string::String,
    ///  If true, we only return models that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return models that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.starred_only)
    pub starred_only: bool,
    ///  List of toolkit tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    ///  List of use_case tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.use_cases)
    pub use_cases: ::std::vec::Vec<::std::string::String>,
    ///  List of language tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  Old API behavior resulted in returning clarifai main models when calling ListModels while scoped to an app. While we transition
    ///  away from that, we can use this flag to not always fetch clarifai main models, unless that is the app we are explicitly listing for.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.dont_fetch_from_main)
    pub dont_fetch_from_main: bool,
    ///  Filter models by bookmark. If set, only return bookmarked models. Otherwise none bookmarked models only.
    ///  Note: you can not filter `trained_only` and bookmark at the same time.
    ///  When filter by bookmark, we will return trained and untrained models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the model:
    ///    - id
    ///    - name
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.search)
    pub search: ::std::string::String,
    ///  Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.name)
    pub name: ::std::string::String,
    ///  Extends the name filter to include the user_id of the application owner that the model belongs to.
    ///  Deprecated: use search instead of name.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.filter_by_user_id)
    pub filter_by_user_id: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_models_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelsRequest {
    fn default() -> &'a ListModelsRequest {
        <ListModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelsRequest {
    pub fn new() -> ListModelsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_name = 11;

    pub fn sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByName(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByName(v))
    }

    // bool sort_by_num_inputs = 12;

    pub fn sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(v))
    }

    // bool sort_by_modified_at = 13;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 24;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 25;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelsRequest| { &m.user_app_id },
            |m: &mut ListModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelsRequest| { &m.page },
            |m: &mut ListModelsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelsRequest| { &m.per_page },
            |m: &mut ListModelsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListModelsRequest| { &m.additional_fields },
            |m: &mut ListModelsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModelsRequest| { &m.sort_ascending },
            |m: &mut ListModelsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_name",
            ListModelsRequest::has_sort_by_name,
            ListModelsRequest::sort_by_name,
            ListModelsRequest::set_sort_by_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_num_inputs",
            ListModelsRequest::has_sort_by_num_inputs,
            ListModelsRequest::sort_by_num_inputs,
            ListModelsRequest::set_sort_by_num_inputs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListModelsRequest::has_sort_by_modified_at,
            ListModelsRequest::sort_by_modified_at,
            ListModelsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModelsRequest::has_sort_by_created_at,
            ListModelsRequest::sort_by_created_at,
            ListModelsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListModelsRequest::has_sort_by_star_count,
            ListModelsRequest::sort_by_star_count,
            ListModelsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ListModelsRequest| { &m.model_type_id },
            |m: &mut ListModelsRequest| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_only",
            |m: &ListModelsRequest| { &m.trained_only },
            |m: &mut ListModelsRequest| { &mut m.trained_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_fields",
            |m: &ListModelsRequest| { &m.input_fields },
            |m: &mut ListModelsRequest| { &mut m.input_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_fields",
            |m: &ListModelsRequest| { &m.output_fields },
            |m: &mut ListModelsRequest| { &mut m.output_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &ListModelsRequest| { &m.license },
            |m: &mut ListModelsRequest| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListModelsRequest| { &m.featured_only },
            |m: &mut ListModelsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListModelsRequest| { &m.starred_only },
            |m: &mut ListModelsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &ListModelsRequest| { &m.toolkits },
            |m: &mut ListModelsRequest| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "use_cases",
            |m: &ListModelsRequest| { &m.use_cases },
            |m: &mut ListModelsRequest| { &mut m.use_cases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &ListModelsRequest| { &m.languages },
            |m: &mut ListModelsRequest| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dont_fetch_from_main",
            |m: &ListModelsRequest| { &m.dont_fetch_from_main },
            |m: &mut ListModelsRequest| { &mut m.dont_fetch_from_main },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListModelsRequest| { &m.bookmark },
            |m: &mut ListModelsRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListModelsRequest| { &m.search },
            |m: &mut ListModelsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListModelsRequest| { &m.query },
            |m: &mut ListModelsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListModelsRequest| { &m.name },
            |m: &mut ListModelsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter_by_user_id",
            |m: &ListModelsRequest| { &m.filter_by_user_id },
            |m: &mut ListModelsRequest| { &mut m.filter_by_user_id },
        ));
        oneofs.push(list_models_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelsRequest>(
            "ListModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelsRequest {
    const NAME: &'static str = "ListModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                154 => {
                    self.additional_fields.push(is.read_string()?);
                },
                80 => {
                    self.sort_ascending = is.read_bool()?;
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByName(is.read_bool()?));
                },
                96 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                192 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                200 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                50 => {
                    self.model_type_id = is.read_string()?;
                },
                56 => {
                    self.trained_only = is.read_bool()?;
                },
                66 => {
                    self.input_fields.push(is.read_string()?);
                },
                74 => {
                    self.output_fields.push(is.read_string()?);
                },
                122 => {
                    self.license = is.read_string()?;
                },
                128 => {
                    self.featured_only = is.read_bool()?;
                },
                160 => {
                    self.starred_only = is.read_bool()?;
                },
                138 => {
                    self.toolkits.push(is.read_string()?);
                },
                146 => {
                    self.use_cases.push(is.read_string()?);
                },
                170 => {
                    self.languages.push(is.read_string()?);
                },
                184 => {
                    self.dont_fetch_from_main = is.read_bool()?;
                },
                208 => {
                    self.bookmark = is.read_bool()?;
                },
                218 => {
                    self.search = is.read_string()?;
                },
                114 => {
                    self.query = is.read_string()?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                176 => {
                    self.filter_by_user_id = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model_type_id);
        }
        if self.trained_only != false {
            my_size += 1 + 1;
        }
        for value in &self.input_fields {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.output_fields {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.license);
        }
        if self.featured_only != false {
            my_size += 2 + 1;
        }
        if self.starred_only != false {
            my_size += 2 + 1;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        if self.dont_fetch_from_main != false {
            my_size += 2 + 1;
        }
        if self.bookmark != false {
            my_size += 2 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.search);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.filter_by_user_id != false {
            my_size += 2 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_models_request::Sort_by::SortByName(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByNumInputs(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 2 + 1;
                },
                &list_models_request::Sort_by::SortByStarCount(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(10, self.sort_ascending)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(6, &self.model_type_id)?;
        }
        if self.trained_only != false {
            os.write_bool(7, self.trained_only)?;
        }
        for v in &self.input_fields {
            os.write_string(8, &v)?;
        };
        for v in &self.output_fields {
            os.write_string(9, &v)?;
        };
        if !self.license.is_empty() {
            os.write_string(15, &self.license)?;
        }
        if self.featured_only != false {
            os.write_bool(16, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(20, self.starred_only)?;
        }
        for v in &self.toolkits {
            os.write_string(17, &v)?;
        };
        for v in &self.use_cases {
            os.write_string(18, &v)?;
        };
        for v in &self.languages {
            os.write_string(21, &v)?;
        };
        if self.dont_fetch_from_main != false {
            os.write_bool(23, self.dont_fetch_from_main)?;
        }
        if self.bookmark != false {
            os.write_bool(26, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(27, &self.search)?;
        }
        if !self.query.is_empty() {
            os.write_string(14, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.filter_by_user_id != false {
            os.write_bool(22, self.filter_by_user_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_models_request::Sort_by::SortByName(v) => {
                    os.write_bool(11, v)?;
                },
                &list_models_request::Sort_by::SortByNumInputs(v) => {
                    os.write_bool(12, v)?;
                },
                &list_models_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(13, v)?;
                },
                &list_models_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(24, v)?;
                },
                &list_models_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(25, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelsRequest {
        ListModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.model_type_id.clear();
        self.trained_only = false;
        self.input_fields.clear();
        self.output_fields.clear();
        self.license.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.toolkits.clear();
        self.use_cases.clear();
        self.languages.clear();
        self.dont_fetch_from_main = false;
        self.bookmark = false;
        self.search.clear();
        self.query.clear();
        self.name.clear();
        self.filter_by_user_id = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelsRequest {
        static instance: ListModelsRequest = ListModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            model_type_id: ::std::string::String::new(),
            trained_only: false,
            input_fields: ::std::vec::Vec::new(),
            output_fields: ::std::vec::Vec::new(),
            license: ::std::string::String::new(),
            featured_only: false,
            starred_only: false,
            toolkits: ::std::vec::Vec::new(),
            use_cases: ::std::vec::Vec::new(),
            languages: ::std::vec::Vec::new(),
            dont_fetch_from_main: false,
            bookmark: false,
            search: ::std::string::String::new(),
            query: ::std::string::String::new(),
            name: ::std::string::String::new(),
            filter_by_user_id: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModelsRequest`
pub mod list_models_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModelsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_name)
        SortByName(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_num_inputs)
        SortByNumInputs(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModelsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  ResourceCountRequest
// @@protoc_insertion_point(message:clarifai.api.GetResourceCountsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetResourceCountsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetResourceCountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetResourceCountsRequest {
    fn default() -> &'a GetResourceCountsRequest {
        <GetResourceCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetResourceCountsRequest {
    pub fn new() -> GetResourceCountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetResourceCountsRequest| { &m.user_app_id },
            |m: &mut GetResourceCountsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetResourceCountsRequest>(
            "GetResourceCountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetResourceCountsRequest {
    const NAME: &'static str = "GetResourceCountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetResourceCountsRequest {
        GetResourceCountsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetResourceCountsRequest {
        static instance: GetResourceCountsRequest = GetResourceCountsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetResourceCountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetResourceCountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetResourceCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResourceCountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ResourceCountResponse
// @@protoc_insertion_point(message:clarifai.api.GetResourceCountsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetResourceCountsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.datasets)
    pub datasets: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.models)
    pub models: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.workflows)
    pub workflows: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.modules)
    pub modules: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.inputs)
    pub inputs: i64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetResourceCountsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetResourceCountsResponse {
    fn default() -> &'a GetResourceCountsResponse {
        <GetResourceCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetResourceCountsResponse {
    pub fn new() -> GetResourceCountsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &GetResourceCountsResponse| { &m.status },
            |m: &mut GetResourceCountsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datasets",
            |m: &GetResourceCountsResponse| { &m.datasets },
            |m: &mut GetResourceCountsResponse| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "models",
            |m: &GetResourceCountsResponse| { &m.models },
            |m: &mut GetResourceCountsResponse| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflows",
            |m: &GetResourceCountsResponse| { &m.workflows },
            |m: &mut GetResourceCountsResponse| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modules",
            |m: &GetResourceCountsResponse| { &m.modules },
            |m: &mut GetResourceCountsResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs",
            |m: &GetResourceCountsResponse| { &m.inputs },
            |m: &mut GetResourceCountsResponse| { &mut m.inputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetResourceCountsResponse>(
            "GetResourceCountsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetResourceCountsResponse {
    const NAME: &'static str = "GetResourceCountsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                16 => {
                    self.datasets = is.read_int64()?;
                },
                24 => {
                    self.models = is.read_int64()?;
                },
                32 => {
                    self.workflows = is.read_int64()?;
                },
                40 => {
                    self.modules = is.read_int64()?;
                },
                48 => {
                    self.inputs = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.datasets != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.datasets);
        }
        if self.models != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.models);
        }
        if self.workflows != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.workflows);
        }
        if self.modules != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.modules);
        }
        if self.inputs != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.inputs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.datasets != 0 {
            os.write_int64(2, self.datasets)?;
        }
        if self.models != 0 {
            os.write_int64(3, self.models)?;
        }
        if self.workflows != 0 {
            os.write_int64(4, self.workflows)?;
        }
        if self.modules != 0 {
            os.write_int64(5, self.modules)?;
        }
        if self.inputs != 0 {
            os.write_int64(6, self.inputs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetResourceCountsResponse {
        GetResourceCountsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.datasets = 0;
        self.models = 0;
        self.workflows = 0;
        self.modules = 0;
        self.inputs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetResourceCountsResponse {
        static instance: GetResourceCountsResponse = GetResourceCountsResponse {
            status: ::protobuf::MessageField::none(),
            datasets: 0,
            models: 0,
            workflows: 0,
            modules: 0,
            inputs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetResourceCountsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetResourceCountsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetResourceCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResourceCountsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchModelToolkitsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelToolkitsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelToolkitsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelToolkitsRequest {
    fn default() -> &'a PatchModelToolkitsRequest {
        <PatchModelToolkitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelToolkitsRequest {
    pub fn new() -> PatchModelToolkitsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelToolkitsRequest| { &m.user_app_id },
            |m: &mut PatchModelToolkitsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelToolkitsRequest| { &m.model_id },
            |m: &mut PatchModelToolkitsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &PatchModelToolkitsRequest| { &m.toolkits },
            |m: &mut PatchModelToolkitsRequest| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelToolkitsRequest| { &m.action },
            |m: &mut PatchModelToolkitsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelToolkitsRequest>(
            "PatchModelToolkitsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelToolkitsRequest {
    const NAME: &'static str = "PatchModelToolkitsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.toolkits.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.toolkits {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelToolkitsRequest {
        PatchModelToolkitsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.toolkits.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelToolkitsRequest {
        static instance: PatchModelToolkitsRequest = PatchModelToolkitsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            toolkits: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelToolkitsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelToolkitsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelToolkitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelToolkitsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelCheckConsentsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelCheckConsentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelCheckConsentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the model id
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  the consents
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelCheckConsentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelCheckConsentsRequest {
    fn default() -> &'a PatchModelCheckConsentsRequest {
        <PatchModelCheckConsentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelCheckConsentsRequest {
    pub fn new() -> PatchModelCheckConsentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelCheckConsentsRequest| { &m.user_app_id },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelCheckConsentsRequest| { &m.model_id },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &PatchModelCheckConsentsRequest| { &m.check_consents },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.check_consents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelCheckConsentsRequest| { &m.action },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelCheckConsentsRequest>(
            "PatchModelCheckConsentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelCheckConsentsRequest {
    const NAME: &'static str = "PatchModelCheckConsentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.check_consents.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.check_consents {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelCheckConsentsRequest {
        PatchModelCheckConsentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.check_consents.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelCheckConsentsRequest {
        static instance: PatchModelCheckConsentsRequest = PatchModelCheckConsentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            check_consents: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelCheckConsentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelCheckConsentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelCheckConsentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelCheckConsentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchModelUseCasesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelUseCasesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.usecases)
    pub usecases: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelUseCasesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelUseCasesRequest {
    fn default() -> &'a PatchModelUseCasesRequest {
        <PatchModelUseCasesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelUseCasesRequest {
    pub fn new() -> PatchModelUseCasesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelUseCasesRequest| { &m.user_app_id },
            |m: &mut PatchModelUseCasesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelUseCasesRequest| { &m.model_id },
            |m: &mut PatchModelUseCasesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usecases",
            |m: &PatchModelUseCasesRequest| { &m.usecases },
            |m: &mut PatchModelUseCasesRequest| { &mut m.usecases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelUseCasesRequest| { &m.action },
            |m: &mut PatchModelUseCasesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelUseCasesRequest>(
            "PatchModelUseCasesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelUseCasesRequest {
    const NAME: &'static str = "PatchModelUseCasesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.usecases.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.usecases {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelUseCasesRequest {
        PatchModelUseCasesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.usecases.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelUseCasesRequest {
        static instance: PatchModelUseCasesRequest = PatchModelUseCasesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            usecases: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelUseCasesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelUseCasesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelUseCasesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelUseCasesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchModelLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  Only overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelLanguagesRequest {
    fn default() -> &'a PatchModelLanguagesRequest {
        <PatchModelLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelLanguagesRequest {
    pub fn new() -> PatchModelLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelLanguagesRequest| { &m.user_app_id },
            |m: &mut PatchModelLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelLanguagesRequest| { &m.model_id },
            |m: &mut PatchModelLanguagesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &PatchModelLanguagesRequest| { &m.languages },
            |m: &mut PatchModelLanguagesRequest| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelLanguagesRequest| { &m.action },
            |m: &mut PatchModelLanguagesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelLanguagesRequest>(
            "PatchModelLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelLanguagesRequest {
    const NAME: &'static str = "PatchModelLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.languages.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.languages {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelLanguagesRequest {
        PatchModelLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.languages.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelLanguagesRequest {
        static instance: PatchModelLanguagesRequest = PatchModelLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            languages: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelToolkitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelToolkitResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelToolkitResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelToolkitResponse.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelToolkitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelToolkitResponse {
    fn default() -> &'a MultiModelToolkitResponse {
        <MultiModelToolkitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelToolkitResponse {
    pub fn new() -> MultiModelToolkitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelToolkitResponse| { &m.status },
            |m: &mut MultiModelToolkitResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &MultiModelToolkitResponse| { &m.toolkits },
            |m: &mut MultiModelToolkitResponse| { &mut m.toolkits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelToolkitResponse>(
            "MultiModelToolkitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelToolkitResponse {
    const NAME: &'static str = "MultiModelToolkitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.toolkits.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.toolkits {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelToolkitResponse {
        MultiModelToolkitResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.toolkits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelToolkitResponse {
        static instance: MultiModelToolkitResponse = MultiModelToolkitResponse {
            status: ::protobuf::MessageField::none(),
            toolkits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelToolkitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelToolkitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelToolkitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelToolkitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelCheckConsentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelCheckConsentResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelCheckConsentResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelCheckConsentResponse.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelCheckConsentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelCheckConsentResponse {
    fn default() -> &'a MultiModelCheckConsentResponse {
        <MultiModelCheckConsentResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelCheckConsentResponse {
    pub fn new() -> MultiModelCheckConsentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelCheckConsentResponse| { &m.status },
            |m: &mut MultiModelCheckConsentResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &MultiModelCheckConsentResponse| { &m.check_consents },
            |m: &mut MultiModelCheckConsentResponse| { &mut m.check_consents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelCheckConsentResponse>(
            "MultiModelCheckConsentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelCheckConsentResponse {
    const NAME: &'static str = "MultiModelCheckConsentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.check_consents.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.check_consents {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelCheckConsentResponse {
        MultiModelCheckConsentResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.check_consents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelCheckConsentResponse {
        static instance: MultiModelCheckConsentResponse = MultiModelCheckConsentResponse {
            status: ::protobuf::MessageField::none(),
            check_consents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelCheckConsentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelCheckConsentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelCheckConsentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelCheckConsentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelUseCaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelUseCaseResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelUseCaseResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelUseCaseResponse.usecases)
    pub usecases: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelUseCaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelUseCaseResponse {
    fn default() -> &'a MultiModelUseCaseResponse {
        <MultiModelUseCaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelUseCaseResponse {
    pub fn new() -> MultiModelUseCaseResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelUseCaseResponse| { &m.status },
            |m: &mut MultiModelUseCaseResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usecases",
            |m: &MultiModelUseCaseResponse| { &m.usecases },
            |m: &mut MultiModelUseCaseResponse| { &mut m.usecases },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelUseCaseResponse>(
            "MultiModelUseCaseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelUseCaseResponse {
    const NAME: &'static str = "MultiModelUseCaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.usecases.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.usecases {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelUseCaseResponse {
        MultiModelUseCaseResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.usecases.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelUseCaseResponse {
        static instance: MultiModelUseCaseResponse = MultiModelUseCaseResponse {
            status: ::protobuf::MessageField::none(),
            usecases: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelUseCaseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelUseCaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelUseCaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelUseCaseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelLanguageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelLanguageResponse.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelLanguageResponse {
    fn default() -> &'a MultiModelLanguageResponse {
        <MultiModelLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelLanguageResponse {
    pub fn new() -> MultiModelLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelLanguageResponse| { &m.status },
            |m: &mut MultiModelLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &MultiModelLanguageResponse| { &m.languages },
            |m: &mut MultiModelLanguageResponse| { &mut m.languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelLanguageResponse>(
            "MultiModelLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelLanguageResponse {
    const NAME: &'static str = "MultiModelLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.languages.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.languages {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelLanguageResponse {
        MultiModelLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelLanguageResponse {
        static instance: MultiModelLanguageResponse = MultiModelLanguageResponse {
            status: ::protobuf::MessageField::none(),
            languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelsRequest
// @@protoc_insertion_point(message:clarifai.api.PostModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  NOTE: inconsistent since "model" is not plural, please use "models" below.
    ///  Previously you could only create one model at a time.
    ///  We still support this but you should pass it as models=[model] so
    ///  that this endpoint is consistent with the rest of our API.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    ///  This allows you to create one or more model by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelsRequest {
    fn default() -> &'a PostModelsRequest {
        <PostModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsRequest {
    pub fn new() -> PostModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelsRequest| { &m.user_app_id },
            |m: &mut PostModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &PostModelsRequest| { &m.model },
            |m: &mut PostModelsRequest| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &PostModelsRequest| { &m.models },
            |m: &mut PostModelsRequest| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelsRequest>(
            "PostModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelsRequest {
    const NAME: &'static str = "PostModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                26 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelsRequest {
        PostModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model.clear();
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelsRequest {
        static instance: PostModelsRequest = PostModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    ///
    ///  Note that 'remove' can be used to remove the model image by setting
    ///  'image.url' in the request to the current value returned for that model.
    ///  This cannot be used in a request that is patching other fields as well.
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelsRequest {
    fn default() -> &'a PatchModelsRequest {
        <PatchModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelsRequest {
    pub fn new() -> PatchModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelsRequest| { &m.user_app_id },
            |m: &mut PatchModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &PatchModelsRequest| { &m.models },
            |m: &mut PatchModelsRequest| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelsRequest| { &m.action },
            |m: &mut PatchModelsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelsRequest>(
            "PatchModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelsRequest {
    const NAME: &'static str = "PatchModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.models.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelsRequest {
        PatchModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.models.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelsRequest {
        static instance: PatchModelsRequest = PatchModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.IdUpdateSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IdUpdateSource {
    // message fields
    /// old id
    // @@protoc_insertion_point(field:clarifai.api.IdUpdateSource.id)
    pub id: ::std::string::String,
    /// new id
    // @@protoc_insertion_point(field:clarifai.api.IdUpdateSource.new_id)
    pub new_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.IdUpdateSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdUpdateSource {
    fn default() -> &'a IdUpdateSource {
        <IdUpdateSource as ::protobuf::Message>::default_instance()
    }
}

impl IdUpdateSource {
    pub fn new() -> IdUpdateSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &IdUpdateSource| { &m.id },
            |m: &mut IdUpdateSource| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_id",
            |m: &IdUpdateSource| { &m.new_id },
            |m: &mut IdUpdateSource| { &mut m.new_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdUpdateSource>(
            "IdUpdateSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdUpdateSource {
    const NAME: &'static str = "IdUpdateSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.new_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.new_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.new_id.is_empty() {
            os.write_string(2, &self.new_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdUpdateSource {
        IdUpdateSource::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.new_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdUpdateSource {
        static instance: IdUpdateSource = IdUpdateSource {
            id: ::std::string::String::new(),
            new_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdUpdateSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdUpdateSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdUpdateSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdUpdateSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelIdsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelIdsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelIdsRequest {
    fn default() -> &'a PatchModelIdsRequest {
        <PatchModelIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelIdsRequest {
    pub fn new() -> PatchModelIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelIdsRequest| { &m.user_app_id },
            |m: &mut PatchModelIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchModelIdsRequest| { &m.ids },
            |m: &mut PatchModelIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelIdsRequest| { &m.action },
            |m: &mut PatchModelIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelIdsRequest>(
            "PatchModelIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelIdsRequest {
    const NAME: &'static str = "PatchModelIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelIdsRequest {
        PatchModelIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelIdsRequest {
        static instance: PatchModelIdsRequest = PatchModelIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteModelRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteModelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModelRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelRequest.model_id)
    pub model_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelRequest {
    fn default() -> &'a DeleteModelRequest {
        <DeleteModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelRequest {
    pub fn new() -> DeleteModelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelRequest| { &m.user_app_id },
            |m: &mut DeleteModelRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DeleteModelRequest| { &m.model_id },
            |m: &mut DeleteModelRequest| { &mut m.model_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelRequest>(
            "DeleteModelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelRequest {
    const NAME: &'static str = "DeleteModelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelRequest {
        DeleteModelRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelRequest {
        static instance: DeleteModelRequest = DeleteModelRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelsRequest {
    fn default() -> &'a DeleteModelsRequest {
        <DeleteModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelsRequest {
    pub fn new() -> DeleteModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelsRequest| { &m.user_app_id },
            |m: &mut DeleteModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModelsRequest| { &m.ids },
            |m: &mut DeleteModelsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteModelsRequest| { &m.delete_all },
            |m: &mut DeleteModelsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelsRequest>(
            "DeleteModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelsRequest {
    const NAME: &'static str = "DeleteModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelsRequest {
        DeleteModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelsRequest {
        static instance: DeleteModelsRequest = DeleteModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Search over the available models.
// @@protoc_insertion_point(message:clarifai.api.PostModelsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelsSearchesRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.model_query)
    pub model_query: ::protobuf::MessageField<super::resources::ModelQuery>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelsSearchesRequest {
    fn default() -> &'a PostModelsSearchesRequest {
        <PostModelsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsSearchesRequest {
    pub fn new() -> PostModelsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelsSearchesRequest| { &m.user_app_id },
            |m: &mut PostModelsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelQuery>(
            "model_query",
            |m: &PostModelsSearchesRequest| { &m.model_query },
            |m: &mut PostModelsSearchesRequest| { &mut m.model_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostModelsSearchesRequest| { &m.pagination },
            |m: &mut PostModelsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelsSearchesRequest>(
            "PostModelsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelsSearchesRequest {
    const NAME: &'static str = "PostModelsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_query)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelsSearchesRequest {
        PostModelsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_query.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelsSearchesRequest {
        static instance: PostModelsSearchesRequest = PostModelsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_query: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelResponse.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelResponse {
    fn default() -> &'a SingleModelResponse {
        <SingleModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelResponse {
    pub fn new() -> SingleModelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelResponse| { &m.status },
            |m: &mut SingleModelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &SingleModelResponse| { &m.model },
            |m: &mut SingleModelResponse| { &mut m.model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelResponse>(
            "SingleModelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelResponse {
    const NAME: &'static str = "SingleModelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelResponse {
        SingleModelResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelResponse {
        static instance: SingleModelResponse = SingleModelResponse {
            status: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelResponse.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelResponse {
    fn default() -> &'a MultiModelResponse {
        <MultiModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelResponse {
    pub fn new() -> MultiModelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelResponse| { &m.status },
            |m: &mut MultiModelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &MultiModelResponse| { &m.models },
            |m: &mut MultiModelResponse| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelResponse>(
            "MultiModelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelResponse {
    const NAME: &'static str = "MultiModelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelResponse {
        MultiModelResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelResponse {
        static instance: MultiModelResponse = MultiModelResponse {
            status: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelVersionsRequest {
    fn default() -> &'a PatchModelVersionsRequest {
        <PatchModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelVersionsRequest {
    pub fn new() -> PatchModelVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelVersionsRequest| { &m.user_app_id },
            |m: &mut PatchModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelVersionsRequest| { &m.model_id },
            |m: &mut PatchModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PatchModelVersionsRequest| { &m.model_versions },
            |m: &mut PatchModelVersionsRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelVersionsRequest| { &m.action },
            |m: &mut PatchModelVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelVersionsRequest>(
            "PatchModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelVersionsRequest {
    const NAME: &'static str = "PatchModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelVersionsRequest {
        PatchModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelVersionsRequest {
        static instance: PatchModelVersionsRequest = PatchModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  request for different endpoints currently.
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionRequest {
    fn default() -> &'a GetModelVersionRequest {
        <GetModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionRequest {
    pub fn new() -> GetModelVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionRequest| { &m.user_app_id },
            |m: &mut GetModelVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionRequest| { &m.model_id },
            |m: &mut GetModelVersionRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionRequest| { &m.version_id },
            |m: &mut GetModelVersionRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionRequest>(
            "GetModelVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionRequest {
    const NAME: &'static str = "GetModelVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionRequest {
        GetModelVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionRequest {
        static instance: GetModelVersionRequest = GetModelVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.per_page)
    pub per_page: u32,
    ///  Filtering options:
    ///  To list only the model versions that have these concept ids present in them.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    ///  To list only the model versions that have been trained.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.trained_only)
    pub trained_only: bool,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.sort_ascending)
    pub sort_ascending: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_model_versions_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionsRequest {
    fn default() -> &'a ListModelVersionsRequest {
        <ListModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionsRequest {
    pub fn new() -> ListModelVersionsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_status_code = 8;

    pub fn sort_by_status_code(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_status_code(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_status_code(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_status_code(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(v))
    }

    // bool sort_by_num_inputs = 9;

    pub fn sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(v))
    }

    // bool sort_by_description = 10;

    pub fn sort_by_description(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_description(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_description(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_description(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(v))
    }

    // bool sort_by_created_at = 11;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionsRequest| { &m.user_app_id },
            |m: &mut ListModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionsRequest| { &m.model_id },
            |m: &mut ListModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionsRequest| { &m.page },
            |m: &mut ListModelVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionsRequest| { &m.per_page },
            |m: &mut ListModelVersionsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ListModelVersionsRequest| { &m.concept_ids },
            |m: &mut ListModelVersionsRequest| { &mut m.concept_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_only",
            |m: &ListModelVersionsRequest| { &m.trained_only },
            |m: &mut ListModelVersionsRequest| { &mut m.trained_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModelVersionsRequest| { &m.sort_ascending },
            |m: &mut ListModelVersionsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_status_code",
            ListModelVersionsRequest::has_sort_by_status_code,
            ListModelVersionsRequest::sort_by_status_code,
            ListModelVersionsRequest::set_sort_by_status_code,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_num_inputs",
            ListModelVersionsRequest::has_sort_by_num_inputs,
            ListModelVersionsRequest::sort_by_num_inputs,
            ListModelVersionsRequest::set_sort_by_num_inputs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_description",
            ListModelVersionsRequest::has_sort_by_description,
            ListModelVersionsRequest::sort_by_description,
            ListModelVersionsRequest::set_sort_by_description,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModelVersionsRequest::has_sort_by_created_at,
            ListModelVersionsRequest::sort_by_created_at,
            ListModelVersionsRequest::set_sort_by_created_at,
        ));
        oneofs.push(list_model_versions_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionsRequest>(
            "ListModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionsRequest {
    const NAME: &'static str = "ListModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.concept_ids.push(is.read_string()?);
                },
                48 => {
                    self.trained_only = is.read_bool()?;
                },
                56 => {
                    self.sort_ascending = is.read_bool()?;
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(is.read_bool()?));
                },
                80 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.trained_only != false {
            my_size += 1 + 1;
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_model_versions_request::Sort_by::SortByStatusCode(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByNumInputs(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByDescription(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        for v in &self.concept_ids {
            os.write_string(5, &v)?;
        };
        if self.trained_only != false {
            os.write_bool(6, self.trained_only)?;
        }
        if self.sort_ascending != false {
            os.write_bool(7, self.sort_ascending)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_model_versions_request::Sort_by::SortByStatusCode(v) => {
                    os.write_bool(8, v)?;
                },
                &list_model_versions_request::Sort_by::SortByNumInputs(v) => {
                    os.write_bool(9, v)?;
                },
                &list_model_versions_request::Sort_by::SortByDescription(v) => {
                    os.write_bool(10, v)?;
                },
                &list_model_versions_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionsRequest {
        ListModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.concept_ids.clear();
        self.trained_only = false;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionsRequest {
        static instance: ListModelVersionsRequest = ListModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            concept_ids: ::std::vec::Vec::new(),
            trained_only: false,
            sort_ascending: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModelVersionsRequest`
pub mod list_model_versions_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModelVersionsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_status_code)
        SortByStatusCode(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_num_inputs)
        SortByNumInputs(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_description)
        SortByDescription(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModelVersionsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  DeleteModelVersionRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteModelVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModelVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelVersionRequest {
    fn default() -> &'a DeleteModelVersionRequest {
        <DeleteModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelVersionRequest {
    pub fn new() -> DeleteModelVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelVersionRequest| { &m.user_app_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DeleteModelVersionRequest| { &m.model_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &DeleteModelVersionRequest| { &m.version_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelVersionRequest>(
            "DeleteModelVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelVersionRequest {
    const NAME: &'static str = "DeleteModelVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.model_id = is.read_string()?;
                },
                34 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(4, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelVersionRequest {
        DeleteModelVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelVersionRequest {
        static instance: DeleteModelVersionRequest = DeleteModelVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionResponse.model_version)
    pub model_version: ::protobuf::MessageField<super::resources::ModelVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionResponse {
    fn default() -> &'a SingleModelVersionResponse {
        <SingleModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionResponse {
    pub fn new() -> SingleModelVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionResponse| { &m.status },
            |m: &mut SingleModelVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersion>(
            "model_version",
            |m: &SingleModelVersionResponse| { &m.model_version },
            |m: &mut SingleModelVersionResponse| { &mut m.model_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionResponse>(
            "SingleModelVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionResponse {
    const NAME: &'static str = "SingleModelVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionResponse {
        SingleModelVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionResponse {
        static instance: SingleModelVersionResponse = SingleModelVersionResponse {
            status: ::protobuf::MessageField::none(),
            model_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionResponse.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionResponse {
    fn default() -> &'a MultiModelVersionResponse {
        <MultiModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionResponse {
    pub fn new() -> MultiModelVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelVersionResponse| { &m.status },
            |m: &mut MultiModelVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &MultiModelVersionResponse| { &m.model_versions },
            |m: &mut MultiModelVersionResponse| { &mut m.model_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelVersionResponse>(
            "MultiModelVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelVersionResponse {
    const NAME: &'static str = "MultiModelVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelVersionResponse {
        MultiModelVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelVersionResponse {
        static instance: MultiModelVersionResponse = MultiModelVersionResponse {
            status: ::protobuf::MessageField::none(),
            model_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Create (train) a new model version.
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    ///  Description about this training run
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.description)
    pub description: ::std::string::String,
    ///  When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
    ///  We will merge this with default_eval_info.
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.eval_info)
    pub eval_info: ::protobuf::MessageField<super::resources::EvalInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsRequest {
    fn default() -> &'a PostModelVersionsRequest {
        <PostModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsRequest {
    pub fn new() -> PostModelVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsRequest| { &m.model_id },
            |m: &mut PostModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PostModelVersionsRequest| { &m.model_versions },
            |m: &mut PostModelVersionsRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &PostModelVersionsRequest| { &m.description },
            |m: &mut PostModelVersionsRequest| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalInfo>(
            "eval_info",
            |m: &PostModelVersionsRequest| { &m.eval_info },
            |m: &mut PostModelVersionsRequest| { &mut m.eval_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsRequest>(
            "PostModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsRequest {
    const NAME: &'static str = "PostModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                66 => {
                    self.description = is.read_string()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsRequest {
        PostModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.description.clear();
        self.eval_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsRequest {
        static instance: PostModelVersionsRequest = PostModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            description: ::std::string::String::new(),
            eval_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PostWorkflowVersionsUnPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowVersionsUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.publications)
    pub publications: ::std::vec::Vec<WorkflowVersionUnPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowVersionsUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowVersionsUnPublishRequest {
    fn default() -> &'a PostWorkflowVersionsUnPublishRequest {
        <PostWorkflowVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowVersionsUnPublishRequest {
    pub fn new() -> PostWorkflowVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.user_app_id },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.workflow_id },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.publications },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowVersionsUnPublishRequest>(
            "PostWorkflowVersionsUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowVersionsUnPublishRequest {
    const NAME: &'static str = "PostWorkflowVersionsUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowVersionsUnPublishRequest {
        PostWorkflowVersionsUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowVersionsUnPublishRequest {
        static instance: PostWorkflowVersionsUnPublishRequest = PostWorkflowVersionsUnPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowVersionsUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowVersionsUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowVersionsUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PostWorkflowVersionsPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowVersionsPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.publications)
    pub publications: ::std::vec::Vec<WorkflowVersionPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowVersionsPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowVersionsPublishRequest {
    fn default() -> &'a PostWorkflowVersionsPublishRequest {
        <PostWorkflowVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowVersionsPublishRequest {
    pub fn new() -> PostWorkflowVersionsPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowVersionsPublishRequest| { &m.user_app_id },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowVersionsPublishRequest| { &m.workflow_id },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostWorkflowVersionsPublishRequest| { &m.publications },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowVersionsPublishRequest>(
            "PostWorkflowVersionsPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowVersionsPublishRequest {
    const NAME: &'static str = "PostWorkflowVersionsPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowVersionsPublishRequest {
        PostWorkflowVersionsPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowVersionsPublishRequest {
        static instance: PostWorkflowVersionsPublishRequest = PostWorkflowVersionsPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowVersionsPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowVersionsPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowVersionsPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.WorkflowVersionPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowVersionPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersionPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersionPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersionPublishRequest {
    fn default() -> &'a WorkflowVersionPublishRequest {
        <WorkflowVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersionPublishRequest {
    pub fn new() -> WorkflowVersionPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &WorkflowVersionPublishRequest| { &m.version_id },
            |m: &mut WorkflowVersionPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersionPublishRequest>(
            "WorkflowVersionPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersionPublishRequest {
    const NAME: &'static str = "WorkflowVersionPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersionPublishRequest {
        WorkflowVersionPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersionPublishRequest {
        static instance: WorkflowVersionPublishRequest = WorkflowVersionPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersionPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersionPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersionPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.WorkflowVersionUnPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowVersionUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersionUnPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersionUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersionUnPublishRequest {
    fn default() -> &'a WorkflowVersionUnPublishRequest {
        <WorkflowVersionUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersionUnPublishRequest {
    pub fn new() -> WorkflowVersionUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &WorkflowVersionUnPublishRequest| { &m.version_id },
            |m: &mut WorkflowVersionUnPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersionUnPublishRequest>(
            "WorkflowVersionUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersionUnPublishRequest {
    const NAME: &'static str = "WorkflowVersionUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersionUnPublishRequest {
        WorkflowVersionUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersionUnPublishRequest {
        static instance: WorkflowVersionUnPublishRequest = WorkflowVersionUnPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersionUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersionUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersionUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersionUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionPublishRequest
// @@protoc_insertion_point(message:clarifai.api.ModelVersionPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersionPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionPublishRequest {
    fn default() -> &'a ModelVersionPublishRequest {
        <ModelVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionPublishRequest {
    pub fn new() -> ModelVersionPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ModelVersionPublishRequest| { &m.version_id },
            |m: &mut ModelVersionPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionPublishRequest>(
            "ModelVersionPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionPublishRequest {
    const NAME: &'static str = "ModelVersionPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionPublishRequest {
        ModelVersionPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionPublishRequest {
        static instance: ModelVersionPublishRequest = ModelVersionPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelVersionsPublishRequest
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.publications)
    pub publications: ::std::vec::Vec<ModelVersionPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsPublishRequest {
    fn default() -> &'a PostModelVersionsPublishRequest {
        <PostModelVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsPublishRequest {
    pub fn new() -> PostModelVersionsPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsPublishRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsPublishRequest| { &m.model_id },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostModelVersionsPublishRequest| { &m.publications },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsPublishRequest>(
            "PostModelVersionsPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsPublishRequest {
    const NAME: &'static str = "PostModelVersionsPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsPublishRequest {
        PostModelVersionsPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsPublishRequest {
        static instance: PostModelVersionsPublishRequest = PostModelVersionsPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionUnpublishRequest
// @@protoc_insertion_point(message:clarifai.api.ModelVersionUnpublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersionUnpublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionUnpublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionUnpublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionUnpublishRequest {
    fn default() -> &'a ModelVersionUnpublishRequest {
        <ModelVersionUnpublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionUnpublishRequest {
    pub fn new() -> ModelVersionUnpublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ModelVersionUnpublishRequest| { &m.version_id },
            |m: &mut ModelVersionUnpublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionUnpublishRequest>(
            "ModelVersionUnpublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionUnpublishRequest {
    const NAME: &'static str = "ModelVersionUnpublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionUnpublishRequest {
        ModelVersionUnpublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionUnpublishRequest {
        static instance: ModelVersionUnpublishRequest = ModelVersionUnpublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionUnpublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionUnpublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionUnpublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionUnpublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelVersionsUnPublishRequest
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsUnPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.publications)
    pub publications: ::std::vec::Vec<ModelVersionUnpublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUnPublishRequest {
    fn default() -> &'a PostModelVersionsUnPublishRequest {
        <PostModelVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUnPublishRequest {
    pub fn new() -> PostModelVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsUnPublishRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsUnPublishRequest| { &m.model_id },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostModelVersionsUnPublishRequest| { &m.publications },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsUnPublishRequest>(
            "PostModelVersionsUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsUnPublishRequest {
    const NAME: &'static str = "PostModelVersionsUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsUnPublishRequest {
        PostModelVersionsUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsUnPublishRequest {
        static instance: PostModelVersionsUnPublishRequest = PostModelVersionsUnPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model vesion
// @@protoc_insertion_point(message:clarifai.api.PostEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  eval_info, id, model, and ground_truth_dataset will be used when creating the evaluation
    ///  If no dataset is provided, all app data that is annotated with concepts from the model will be used.
    // @@protoc_insertion_point(field:clarifai.api.PostEvaluationsRequest.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostEvaluationsRequest {
    fn default() -> &'a PostEvaluationsRequest {
        <PostEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostEvaluationsRequest {
    pub fn new() -> PostEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostEvaluationsRequest| { &m.user_app_id },
            |m: &mut PostEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &PostEvaluationsRequest| { &m.eval_metrics },
            |m: &mut PostEvaluationsRequest| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostEvaluationsRequest>(
            "PostEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostEvaluationsRequest {
    const NAME: &'static str = "PostEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostEvaluationsRequest {
        PostEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostEvaluationsRequest {
        static instance: PostEvaluationsRequest = PostEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.per_page)
    pub per_page: u32,
    ///  If true, sort in ascending order, otherwise sort in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filter on model type id
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  Filter on dataset ID of the dataset version specified in the metric version
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.eval_dataset_ids)
    pub eval_dataset_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter on dataset ID of the dataset version specified by the model version
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.train_dataset_ids)
    pub train_dataset_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter on concept IDs specified in the modele version's output_info
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    ///  Whether to show failed metrics, defaults to false
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.show_failed_metrics)
    pub show_failed_metrics: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_evaluations_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEvaluationsRequest {
    fn default() -> &'a ListEvaluationsRequest {
        <ListEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEvaluationsRequest {
    pub fn new() -> ListEvaluationsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_app_id = 5;

    pub fn sort_by_app_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_app_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_app_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_app_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(v))
    }

    // bool sort_by_roc_auc = 6;

    pub fn sort_by_roc_auc(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_roc_auc(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_roc_auc(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_roc_auc(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(v))
    }

    // bool sort_by_f1 = 7;

    pub fn sort_by_f1(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_f1(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_f1(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_f1(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(v))
    }

    // bool sort_by_created_at = 8;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_mean_avg_precision = 9;

    pub fn sort_by_mean_avg_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_mean_avg_precision(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_mean_avg_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_mean_avg_precision(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v))
    }

    // bool sort_by_precision = 10;

    pub fn sort_by_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_precision(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_precision(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(v))
    }

    // bool sort_by_recall = 11;

    pub fn sort_by_recall(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_recall(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_recall(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_recall(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(v))
    }

    // bool sort_by_model_id = 16;

    pub fn sort_by_model_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_model_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_model_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_model_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(v))
    }

    // bool sort_by_eval_dataset_id = 17;

    pub fn sort_by_eval_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_eval_dataset_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_eval_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_eval_dataset_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(v))
    }

    // bool sort_by_train_dataset_id = 18;

    pub fn sort_by_train_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_train_dataset_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_train_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_train_dataset_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListEvaluationsRequest| { &m.user_app_id },
            |m: &mut ListEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListEvaluationsRequest| { &m.page },
            |m: &mut ListEvaluationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListEvaluationsRequest| { &m.per_page },
            |m: &mut ListEvaluationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListEvaluationsRequest| { &m.sort_ascending },
            |m: &mut ListEvaluationsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_app_id",
            ListEvaluationsRequest::has_sort_by_app_id,
            ListEvaluationsRequest::sort_by_app_id,
            ListEvaluationsRequest::set_sort_by_app_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_roc_auc",
            ListEvaluationsRequest::has_sort_by_roc_auc,
            ListEvaluationsRequest::sort_by_roc_auc,
            ListEvaluationsRequest::set_sort_by_roc_auc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_f1",
            ListEvaluationsRequest::has_sort_by_f1,
            ListEvaluationsRequest::sort_by_f1,
            ListEvaluationsRequest::set_sort_by_f1,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListEvaluationsRequest::has_sort_by_created_at,
            ListEvaluationsRequest::sort_by_created_at,
            ListEvaluationsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_mean_avg_precision",
            ListEvaluationsRequest::has_sort_by_mean_avg_precision,
            ListEvaluationsRequest::sort_by_mean_avg_precision,
            ListEvaluationsRequest::set_sort_by_mean_avg_precision,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_precision",
            ListEvaluationsRequest::has_sort_by_precision,
            ListEvaluationsRequest::sort_by_precision,
            ListEvaluationsRequest::set_sort_by_precision,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_recall",
            ListEvaluationsRequest::has_sort_by_recall,
            ListEvaluationsRequest::sort_by_recall,
            ListEvaluationsRequest::set_sort_by_recall,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_model_id",
            ListEvaluationsRequest::has_sort_by_model_id,
            ListEvaluationsRequest::sort_by_model_id,
            ListEvaluationsRequest::set_sort_by_model_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_eval_dataset_id",
            ListEvaluationsRequest::has_sort_by_eval_dataset_id,
            ListEvaluationsRequest::sort_by_eval_dataset_id,
            ListEvaluationsRequest::set_sort_by_eval_dataset_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_train_dataset_id",
            ListEvaluationsRequest::has_sort_by_train_dataset_id,
            ListEvaluationsRequest::sort_by_train_dataset_id,
            ListEvaluationsRequest::set_sort_by_train_dataset_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ListEvaluationsRequest| { &m.model_type_id },
            |m: &mut ListEvaluationsRequest| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_dataset_ids",
            |m: &ListEvaluationsRequest| { &m.eval_dataset_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.eval_dataset_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "train_dataset_ids",
            |m: &ListEvaluationsRequest| { &m.train_dataset_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.train_dataset_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ListEvaluationsRequest| { &m.concept_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.concept_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_failed_metrics",
            |m: &ListEvaluationsRequest| { &m.show_failed_metrics },
            |m: &mut ListEvaluationsRequest| { &mut m.show_failed_metrics },
        ));
        oneofs.push(list_evaluations_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEvaluationsRequest>(
            "ListEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEvaluationsRequest {
    const NAME: &'static str = "ListEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.sort_ascending = is.read_bool()?;
                },
                40 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(is.read_bool()?));
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(is.read_bool()?));
                },
                80 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(is.read_bool()?));
                },
                128 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(is.read_bool()?));
                },
                136 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(is.read_bool()?));
                },
                144 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(is.read_bool()?));
                },
                98 => {
                    self.model_type_id = is.read_string()?;
                },
                106 => {
                    self.eval_dataset_ids.push(is.read_string()?);
                },
                114 => {
                    self.train_dataset_ids.push(is.read_string()?);
                },
                122 => {
                    self.concept_ids.push(is.read_string()?);
                },
                152 => {
                    self.show_failed_metrics = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.model_type_id);
        }
        for value in &self.eval_dataset_ids {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.train_dataset_ids {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if self.show_failed_metrics != false {
            my_size += 2 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_evaluations_request::Sort_by::SortByAppId(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByRocAuc(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByF1(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByPrecision(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByRecall(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByModelId(v) => {
                    my_size += 2 + 1;
                },
                &list_evaluations_request::Sort_by::SortByEvalDatasetId(v) => {
                    my_size += 2 + 1;
                },
                &list_evaluations_request::Sort_by::SortByTrainDatasetId(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(4, self.sort_ascending)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(12, &self.model_type_id)?;
        }
        for v in &self.eval_dataset_ids {
            os.write_string(13, &v)?;
        };
        for v in &self.train_dataset_ids {
            os.write_string(14, &v)?;
        };
        for v in &self.concept_ids {
            os.write_string(15, &v)?;
        };
        if self.show_failed_metrics != false {
            os.write_bool(19, self.show_failed_metrics)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_evaluations_request::Sort_by::SortByAppId(v) => {
                    os.write_bool(5, v)?;
                },
                &list_evaluations_request::Sort_by::SortByRocAuc(v) => {
                    os.write_bool(6, v)?;
                },
                &list_evaluations_request::Sort_by::SortByF1(v) => {
                    os.write_bool(7, v)?;
                },
                &list_evaluations_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(8, v)?;
                },
                &list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v) => {
                    os.write_bool(9, v)?;
                },
                &list_evaluations_request::Sort_by::SortByPrecision(v) => {
                    os.write_bool(10, v)?;
                },
                &list_evaluations_request::Sort_by::SortByRecall(v) => {
                    os.write_bool(11, v)?;
                },
                &list_evaluations_request::Sort_by::SortByModelId(v) => {
                    os.write_bool(16, v)?;
                },
                &list_evaluations_request::Sort_by::SortByEvalDatasetId(v) => {
                    os.write_bool(17, v)?;
                },
                &list_evaluations_request::Sort_by::SortByTrainDatasetId(v) => {
                    os.write_bool(18, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEvaluationsRequest {
        ListEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.model_type_id.clear();
        self.eval_dataset_ids.clear();
        self.train_dataset_ids.clear();
        self.concept_ids.clear();
        self.show_failed_metrics = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEvaluationsRequest {
        static instance: ListEvaluationsRequest = ListEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            sort_ascending: false,
            model_type_id: ::std::string::String::new(),
            eval_dataset_ids: ::std::vec::Vec::new(),
            train_dataset_ids: ::std::vec::Vec::new(),
            concept_ids: ::std::vec::Vec::new(),
            show_failed_metrics: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListEvaluationsRequest`
pub mod list_evaluations_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListEvaluationsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_app_id)
        SortByAppId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_roc_auc)
        SortByRocAuc(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_f1)
        SortByF1(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_mean_avg_precision)
        SortByMeanAvgPrecision(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_precision)
        SortByPrecision(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_recall)
        SortByRecall(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_model_id)
        SortByModelId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_eval_dataset_id)
        SortByEvalDatasetId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_train_dataset_id)
        SortByTrainDatasetId(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListEvaluationsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.GetEvaluationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetEvaluationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.evaluation_id)
    pub evaluation_id: ::std::string::String,
    ///  Any of the fields you wish to return in the metrics
    ///  By default, only the summary is returned.
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetEvaluationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEvaluationRequest {
    fn default() -> &'a GetEvaluationRequest {
        <GetEvaluationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEvaluationRequest {
    pub fn new() -> GetEvaluationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetEvaluationRequest| { &m.user_app_id },
            |m: &mut GetEvaluationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_id",
            |m: &GetEvaluationRequest| { &m.evaluation_id },
            |m: &mut GetEvaluationRequest| { &mut m.evaluation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetEvaluationRequest| { &m.fields },
            |m: &mut GetEvaluationRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEvaluationRequest>(
            "GetEvaluationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEvaluationRequest {
    const NAME: &'static str = "GetEvaluationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.evaluation_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.evaluation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.evaluation_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.evaluation_id.is_empty() {
            os.write_string(2, &self.evaluation_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEvaluationRequest {
        GetEvaluationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.evaluation_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEvaluationRequest {
        static instance: GetEvaluationRequest = GetEvaluationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            evaluation_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEvaluationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEvaluationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEvaluationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEvaluationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model vesion
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  EvalInfo and ID will be used when creating the evaluation
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionEvaluationsRequest {
    fn default() -> &'a PostModelVersionEvaluationsRequest {
        <PostModelVersionEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionEvaluationsRequest {
    pub fn new() -> PostModelVersionEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.model_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.model_version_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &PostModelVersionEvaluationsRequest| { &m.eval_metrics },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionEvaluationsRequest>(
            "PostModelVersionEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionEvaluationsRequest {
    const NAME: &'static str = "PostModelVersionEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionEvaluationsRequest {
        PostModelVersionEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionEvaluationsRequest {
        static instance: PostModelVersionEvaluationsRequest = PostModelVersionEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListModelVersionEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelVersionEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionEvaluationsRequest {
    fn default() -> &'a ListModelVersionEvaluationsRequest {
        <ListModelVersionEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionEvaluationsRequest {
    pub fn new() -> ListModelVersionEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.user_app_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.model_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.model_version_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionEvaluationsRequest| { &m.page },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionEvaluationsRequest| { &m.per_page },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionEvaluationsRequest>(
            "ListModelVersionEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionEvaluationsRequest {
    const NAME: &'static str = "ListModelVersionEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionEvaluationsRequest {
        ListModelVersionEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionEvaluationsRequest {
        static instance: ListModelVersionEvaluationsRequest = ListModelVersionEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetModelVersionEvaluationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionEvaluationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.evaluation_id)
    pub evaluation_id: ::std::string::String,
    ///  Any of the fields you wish to return from multiclass_metrics
    ///  By default, only the summary is returned.
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionEvaluationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionEvaluationRequest {
    fn default() -> &'a GetModelVersionEvaluationRequest {
        <GetModelVersionEvaluationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionEvaluationRequest {
    pub fn new() -> GetModelVersionEvaluationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionEvaluationRequest| { &m.user_app_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionEvaluationRequest| { &m.model_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &GetModelVersionEvaluationRequest| { &m.model_version_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_id",
            |m: &GetModelVersionEvaluationRequest| { &m.evaluation_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.evaluation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetModelVersionEvaluationRequest| { &m.fields },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionEvaluationRequest>(
            "GetModelVersionEvaluationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionEvaluationRequest {
    const NAME: &'static str = "GetModelVersionEvaluationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.evaluation_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.evaluation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.evaluation_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.evaluation_id.is_empty() {
            os.write_string(4, &self.evaluation_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionEvaluationRequest {
        GetModelVersionEvaluationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.evaluation_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionEvaluationRequest {
        static instance: GetModelVersionEvaluationRequest = GetModelVersionEvaluationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            evaluation_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionEvaluationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionEvaluationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionEvaluationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionEvaluationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleEvalMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleEvalMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleEvalMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleEvalMetricsResponse.eval_metrics)
    pub eval_metrics: ::protobuf::MessageField<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleEvalMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleEvalMetricsResponse {
    fn default() -> &'a SingleEvalMetricsResponse {
        <SingleEvalMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleEvalMetricsResponse {
    pub fn new() -> SingleEvalMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleEvalMetricsResponse| { &m.status },
            |m: &mut SingleEvalMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalMetrics>(
            "eval_metrics",
            |m: &SingleEvalMetricsResponse| { &m.eval_metrics },
            |m: &mut SingleEvalMetricsResponse| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleEvalMetricsResponse>(
            "SingleEvalMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleEvalMetricsResponse {
    const NAME: &'static str = "SingleEvalMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eval_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.eval_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleEvalMetricsResponse {
        SingleEvalMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleEvalMetricsResponse {
        static instance: SingleEvalMetricsResponse = SingleEvalMetricsResponse {
            status: ::protobuf::MessageField::none(),
            eval_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleEvalMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleEvalMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleEvalMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleEvalMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiEvalMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiEvalMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiEvalMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiEvalMetricsResponse.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiEvalMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiEvalMetricsResponse {
    fn default() -> &'a MultiEvalMetricsResponse {
        <MultiEvalMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiEvalMetricsResponse {
    pub fn new() -> MultiEvalMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiEvalMetricsResponse| { &m.status },
            |m: &mut MultiEvalMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &MultiEvalMetricsResponse| { &m.eval_metrics },
            |m: &mut MultiEvalMetricsResponse| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiEvalMetricsResponse>(
            "MultiEvalMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiEvalMetricsResponse {
    const NAME: &'static str = "MultiEvalMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiEvalMetricsResponse {
        MultiEvalMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiEvalMetricsResponse {
        static instance: MultiEvalMetricsResponse = MultiEvalMetricsResponse {
            status: ::protobuf::MessageField::none(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiEvalMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiEvalMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiEvalMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiEvalMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model version.
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  Use this to filter inputs that are used in evaluation
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.test_search)
    pub test_search: ::protobuf::MessageField<super::resources::Search>,
    ///  evaluation info. Such as dataset used for evaluation.
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.eval_info)
    pub eval_info: ::protobuf::MessageField<super::resources::EvalInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionMetricsRequest {
    fn default() -> &'a PostModelVersionMetricsRequest {
        <PostModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionMetricsRequest {
    pub fn new() -> PostModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionMetricsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionMetricsRequest| { &m.model_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostModelVersionMetricsRequest| { &m.version_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "test_search",
            |m: &PostModelVersionMetricsRequest| { &m.test_search },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.test_search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalInfo>(
            "eval_info",
            |m: &PostModelVersionMetricsRequest| { &m.eval_info },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.eval_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionMetricsRequest>(
            "PostModelVersionMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionMetricsRequest {
    const NAME: &'static str = "PostModelVersionMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.test_search)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(v) = self.test_search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionMetricsRequest {
        PostModelVersionMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.test_search.clear();
        self.eval_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionMetricsRequest {
        static instance: PostModelVersionMetricsRequest = PostModelVersionMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            test_search: ::protobuf::MessageField::none(),
            eval_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Get the already computed evaluation metrics for this model
///  version.
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  Any of the fields you wish to return from multiclass_metrics
    ///  By default, only the summary will be returned
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionMetricsRequest {
    fn default() -> &'a GetModelVersionMetricsRequest {
        <GetModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionMetricsRequest {
    pub fn new() -> GetModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionMetricsRequest| { &m.user_app_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionMetricsRequest| { &m.model_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionMetricsRequest| { &m.version_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetModelVersionMetricsRequest| { &m.fields },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionMetricsRequest>(
            "GetModelVersionMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionMetricsRequest {
    const NAME: &'static str = "GetModelVersionMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionMetricsRequest {
        GetModelVersionMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionMetricsRequest {
        static instance: GetModelVersionMetricsRequest = GetModelVersionMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelTypeRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelTypeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelTypeRequest {
    // message fields
    ///  use and app combo. Not really used for this endpoint at this time so may go away in future.
    // @@protoc_insertion_point(field:clarifai.api.GetModelTypeRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The specific ModelType.Id you want to retrieve.
    // @@protoc_insertion_point(field:clarifai.api.GetModelTypeRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelTypeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelTypeRequest {
    fn default() -> &'a GetModelTypeRequest {
        <GetModelTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelTypeRequest {
    pub fn new() -> GetModelTypeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelTypeRequest| { &m.user_app_id },
            |m: &mut GetModelTypeRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &GetModelTypeRequest| { &m.model_type_id },
            |m: &mut GetModelTypeRequest| { &mut m.model_type_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelTypeRequest>(
            "GetModelTypeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelTypeRequest {
    const NAME: &'static str = "GetModelTypeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_type_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(2, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelTypeRequest {
        GetModelTypeRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_type_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelTypeRequest {
        static instance: GetModelTypeRequest = GetModelTypeRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_type_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelTypeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelTypeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelTypeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelTypesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelTypesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelTypesRequest {
    // message fields
    ///  use and app combo. Not really used for this endpoint at this time so may go away in future.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelTypesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelTypesRequest {
    fn default() -> &'a ListModelTypesRequest {
        <ListModelTypesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelTypesRequest {
    pub fn new() -> ListModelTypesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelTypesRequest| { &m.user_app_id },
            |m: &mut ListModelTypesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelTypesRequest| { &m.page },
            |m: &mut ListModelTypesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelTypesRequest| { &m.per_page },
            |m: &mut ListModelTypesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelTypesRequest>(
            "ListModelTypesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelTypesRequest {
    const NAME: &'static str = "ListModelTypesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelTypesRequest {
        ListModelTypesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelTypesRequest {
        static instance: ListModelTypesRequest = ListModelTypesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelTypesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelTypesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelTypesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelTypesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListOpenSourceLicensesRequest
// @@protoc_insertion_point(message:clarifai.api.ListOpenSourceLicensesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOpenSourceLicensesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListOpenSourceLicensesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesRequest {
    fn default() -> &'a ListOpenSourceLicensesRequest {
        <ListOpenSourceLicensesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesRequest {
    pub fn new() -> ListOpenSourceLicensesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOpenSourceLicensesRequest>(
            "ListOpenSourceLicensesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesRequest {
    const NAME: &'static str = "ListOpenSourceLicensesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOpenSourceLicensesRequest {
        ListOpenSourceLicensesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOpenSourceLicensesRequest {
        static instance: ListOpenSourceLicensesRequest = ListOpenSourceLicensesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOpenSourceLicensesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOpenSourceLicensesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOpenSourceLicensesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListOpenSourceLicensesResponse
// @@protoc_insertion_point(message:clarifai.api.ListOpenSourceLicensesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOpenSourceLicensesResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListOpenSourceLicensesResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ListOpenSourceLicensesResponse.licenses)
    pub licenses: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListOpenSourceLicensesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesResponse {
    fn default() -> &'a ListOpenSourceLicensesResponse {
        <ListOpenSourceLicensesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesResponse {
    pub fn new() -> ListOpenSourceLicensesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ListOpenSourceLicensesResponse| { &m.status },
            |m: &mut ListOpenSourceLicensesResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "licenses",
            |m: &ListOpenSourceLicensesResponse| { &m.licenses },
            |m: &mut ListOpenSourceLicensesResponse| { &mut m.licenses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOpenSourceLicensesResponse>(
            "ListOpenSourceLicensesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesResponse {
    const NAME: &'static str = "ListOpenSourceLicensesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.licenses.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.licenses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.licenses {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOpenSourceLicensesResponse {
        ListOpenSourceLicensesResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.licenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOpenSourceLicensesResponse {
        static instance: ListOpenSourceLicensesResponse = ListOpenSourceLicensesResponse {
            status: ::protobuf::MessageField::none(),
            licenses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOpenSourceLicensesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOpenSourceLicensesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOpenSourceLicensesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelTypeResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelTypeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelTypeResponse {
    // message fields
    ///  Status of the response.
    // @@protoc_insertion_point(field:clarifai.api.SingleModelTypeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The retrieved ModelType object. .
    // @@protoc_insertion_point(field:clarifai.api.SingleModelTypeResponse.model_type)
    pub model_type: ::protobuf::MessageField<super::resources::ModelType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelTypeResponse {
    fn default() -> &'a SingleModelTypeResponse {
        <SingleModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelTypeResponse {
    pub fn new() -> SingleModelTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelTypeResponse| { &m.status },
            |m: &mut SingleModelTypeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelType>(
            "model_type",
            |m: &SingleModelTypeResponse| { &m.model_type },
            |m: &mut SingleModelTypeResponse| { &mut m.model_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelTypeResponse>(
            "SingleModelTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelTypeResponse {
    const NAME: &'static str = "SingleModelTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_type)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelTypeResponse {
        SingleModelTypeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelTypeResponse {
        static instance: SingleModelTypeResponse = SingleModelTypeResponse {
            status: ::protobuf::MessageField::none(),
            model_type: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelTypeResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelTypeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelTypeResponse {
    // message fields
    ///  Status of the response.
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  List of ModelType objects.
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.model_types)
    pub model_types: ::std::vec::Vec<super::resources::ModelType>,
    ///  List of model importers
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.model_importers)
    pub model_importers: ::protobuf::MessageField<super::resources::ModelTypeField>,
    ///  Triton model envs that can be used for model upload
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.triton_conda_envs_info)
    pub triton_conda_envs_info: ::std::vec::Vec<super::resources::TritonCondaEnvInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelTypeResponse {
    fn default() -> &'a MultiModelTypeResponse {
        <MultiModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelTypeResponse {
    pub fn new() -> MultiModelTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelTypeResponse| { &m.status },
            |m: &mut MultiModelTypeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_types",
            |m: &MultiModelTypeResponse| { &m.model_types },
            |m: &mut MultiModelTypeResponse| { &mut m.model_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelTypeField>(
            "model_importers",
            |m: &MultiModelTypeResponse| { &m.model_importers },
            |m: &mut MultiModelTypeResponse| { &mut m.model_importers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "triton_conda_envs_info",
            |m: &MultiModelTypeResponse| { &m.triton_conda_envs_info },
            |m: &mut MultiModelTypeResponse| { &mut m.triton_conda_envs_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelTypeResponse>(
            "MultiModelTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelTypeResponse {
    const NAME: &'static str = "MultiModelTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_types.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_importers)?;
                },
                34 => {
                    self.triton_conda_envs_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.model_importers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.triton_conda_envs_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_types {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.model_importers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.triton_conda_envs_info {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelTypeResponse {
        MultiModelTypeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_types.clear();
        self.model_importers.clear();
        self.triton_conda_envs_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelTypeResponse {
        static instance: MultiModelTypeResponse = MultiModelTypeResponse {
            status: ::protobuf::MessageField::none(),
            model_types: ::std::vec::Vec::new(),
            model_importers: ::protobuf::MessageField::none(),
            triton_conda_envs_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelVersionInputExampleRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionInputExampleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionInputExampleRequest {
    // message fields
    ///  authorization field  (contains app/user id info)
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of model the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.model_id)
    pub model_id: ::std::string::String,
    ///  specific version the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Id of example to fetch
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.example_id)
    pub example_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionInputExampleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionInputExampleRequest {
    fn default() -> &'a GetModelVersionInputExampleRequest {
        <GetModelVersionInputExampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionInputExampleRequest {
    pub fn new() -> GetModelVersionInputExampleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionInputExampleRequest| { &m.user_app_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionInputExampleRequest| { &m.model_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &GetModelVersionInputExampleRequest| { &m.model_version_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "example_id",
            |m: &GetModelVersionInputExampleRequest| { &m.example_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.example_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionInputExampleRequest>(
            "GetModelVersionInputExampleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionInputExampleRequest {
    const NAME: &'static str = "GetModelVersionInputExampleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.example_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.example_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.example_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.example_id.is_empty() {
            os.write_string(4, &self.example_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionInputExampleRequest {
        GetModelVersionInputExampleRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.example_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionInputExampleRequest {
        static instance: GetModelVersionInputExampleRequest = GetModelVersionInputExampleRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            example_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionInputExampleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionInputExampleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionInputExampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionInputExampleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelVersionInputExamplesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionInputExamplesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelVersionInputExamplesRequest {
    // message fields
    ///  authorization field  (contains app/user id info)
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of model the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.model_id)
    pub model_id: ::std::string::String,
    ///  specific version the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Optional, defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.page)
    pub page: u32,
    ///  Optional, defaults to 128 references per page.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionInputExamplesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionInputExamplesRequest {
    fn default() -> &'a ListModelVersionInputExamplesRequest {
        <ListModelVersionInputExamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionInputExamplesRequest {
    pub fn new() -> ListModelVersionInputExamplesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.user_app_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.model_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.model_version_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionInputExamplesRequest| { &m.page },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionInputExamplesRequest| { &m.per_page },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionInputExamplesRequest>(
            "ListModelVersionInputExamplesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionInputExamplesRequest {
    const NAME: &'static str = "ListModelVersionInputExamplesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionInputExamplesRequest {
        ListModelVersionInputExamplesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionInputExamplesRequest {
        static instance: ListModelVersionInputExamplesRequest = ListModelVersionInputExamplesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionInputExamplesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionInputExamplesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionInputExamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionInputExamplesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionInputExampleResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionInputExampleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelVersionInputExampleResponse {
    // message fields
    ///  status of response
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionInputExampleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  model input example message
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionInputExampleResponse.model_version_input_example)
    pub model_version_input_example: ::protobuf::MessageField<super::resources::ModelVersionInputExample>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionInputExampleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionInputExampleResponse {
    fn default() -> &'a SingleModelVersionInputExampleResponse {
        <SingleModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionInputExampleResponse {
    pub fn new() -> SingleModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionInputExampleResponse| { &m.status },
            |m: &mut SingleModelVersionInputExampleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersionInputExample>(
            "model_version_input_example",
            |m: &SingleModelVersionInputExampleResponse| { &m.model_version_input_example },
            |m: &mut SingleModelVersionInputExampleResponse| { &mut m.model_version_input_example },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionInputExampleResponse>(
            "SingleModelVersionInputExampleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionInputExampleResponse {
    const NAME: &'static str = "SingleModelVersionInputExampleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version_input_example)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version_input_example.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_version_input_example.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionInputExampleResponse {
        SingleModelVersionInputExampleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_example.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionInputExampleResponse {
        static instance: SingleModelVersionInputExampleResponse = SingleModelVersionInputExampleResponse {
            status: ::protobuf::MessageField::none(),
            model_version_input_example: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionInputExampleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionInputExampleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionInputExampleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelVersionInputExampleResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelVersionInputExampleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelVersionInputExampleResponse {
    // message fields
    ///  status of response
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionInputExampleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  model input example messages
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionInputExampleResponse.model_version_input_examples)
    pub model_version_input_examples: ::std::vec::Vec<super::resources::ModelVersionInputExample>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelVersionInputExampleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionInputExampleResponse {
    fn default() -> &'a MultiModelVersionInputExampleResponse {
        <MultiModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionInputExampleResponse {
    pub fn new() -> MultiModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelVersionInputExampleResponse| { &m.status },
            |m: &mut MultiModelVersionInputExampleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_input_examples",
            |m: &MultiModelVersionInputExampleResponse| { &m.model_version_input_examples },
            |m: &mut MultiModelVersionInputExampleResponse| { &mut m.model_version_input_examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelVersionInputExampleResponse>(
            "MultiModelVersionInputExampleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelVersionInputExampleResponse {
    const NAME: &'static str = "MultiModelVersionInputExampleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_version_input_examples.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_version_input_examples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_version_input_examples {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelVersionInputExampleResponse {
        MultiModelVersionInputExampleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelVersionInputExampleResponse {
        static instance: MultiModelVersionInputExampleResponse = MultiModelVersionInputExampleResponse {
            status: ::protobuf::MessageField::none(),
            model_version_input_examples: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelVersionInputExampleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelVersionInputExampleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionInputExampleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelReferencesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelReferencesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelReferencesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.model_id)
    pub model_id: ::std::string::String,
    ///  Optional, defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.page)
    pub page: u32,
    ///  Optional, defaults to 128 references per page.
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelReferencesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelReferencesRequest {
    fn default() -> &'a ListModelReferencesRequest {
        <ListModelReferencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelReferencesRequest {
    pub fn new() -> ListModelReferencesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelReferencesRequest| { &m.user_app_id },
            |m: &mut ListModelReferencesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelReferencesRequest| { &m.model_id },
            |m: &mut ListModelReferencesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelReferencesRequest| { &m.page },
            |m: &mut ListModelReferencesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelReferencesRequest| { &m.per_page },
            |m: &mut ListModelReferencesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelReferencesRequest>(
            "ListModelReferencesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelReferencesRequest {
    const NAME: &'static str = "ListModelReferencesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelReferencesRequest {
        ListModelReferencesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelReferencesRequest {
        static instance: ListModelReferencesRequest = ListModelReferencesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelReferencesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelReferencesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelReferencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelReferencesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelReferenceResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelReferenceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelReferenceResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelReferenceResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelReferenceResponse.model_references)
    pub model_references: ::std::vec::Vec<super::resources::ModelReference>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelReferenceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelReferenceResponse {
    fn default() -> &'a MultiModelReferenceResponse {
        <MultiModelReferenceResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelReferenceResponse {
    pub fn new() -> MultiModelReferenceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelReferenceResponse| { &m.status },
            |m: &mut MultiModelReferenceResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_references",
            |m: &MultiModelReferenceResponse| { &m.model_references },
            |m: &mut MultiModelReferenceResponse| { &mut m.model_references },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelReferenceResponse>(
            "MultiModelReferenceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelReferenceResponse {
    const NAME: &'static str = "MultiModelReferenceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_references.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_references {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelReferenceResponse {
        MultiModelReferenceResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_references.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelReferenceResponse {
        static instance: MultiModelReferenceResponse = MultiModelReferenceResponse {
            status: ::protobuf::MessageField::none(),
            model_references: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelReferenceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelReferenceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelReferenceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelReferenceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiOutputResponse
// @@protoc_insertion_point(message:clarifai.api.MultiOutputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiOutputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiOutputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiOutputResponse.outputs)
    pub outputs: ::std::vec::Vec<super::resources::Output>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiOutputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiOutputResponse {
    fn default() -> &'a MultiOutputResponse {
        <MultiOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiOutputResponse {
    pub fn new() -> MultiOutputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiOutputResponse| { &m.status },
            |m: &mut MultiOutputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &MultiOutputResponse| { &m.outputs },
            |m: &mut MultiOutputResponse| { &mut m.outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiOutputResponse>(
            "MultiOutputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiOutputResponse {
    const NAME: &'static str = "MultiOutputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiOutputResponse {
        MultiOutputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiOutputResponse {
        static instance: MultiOutputResponse = MultiOutputResponse {
            status: ::protobuf::MessageField::none(),
            outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiOutputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiOutputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiOutputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListScopesRequest
// @@protoc_insertion_point(message:clarifai.api.ListScopesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListScopesRequest {
    // message fields
    ///  If "personal_access_token" include scopes and endpoints available to personal access tokens.
    ///  If "api_key" include scopes and endpoints available to app-specific keys. (default)
    // @@protoc_insertion_point(field:clarifai.api.ListScopesRequest.key_type)
    pub key_type: ::std::string::String,
    ///  For all user specific information we include user_app_id to get the user_id in a consistent way
    // @@protoc_insertion_point(field:clarifai.api.ListScopesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListScopesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListScopesRequest {
    fn default() -> &'a ListScopesRequest {
        <ListScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListScopesRequest {
    pub fn new() -> ListScopesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_type",
            |m: &ListScopesRequest| { &m.key_type },
            |m: &mut ListScopesRequest| { &mut m.key_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListScopesRequest| { &m.user_app_id },
            |m: &mut ListScopesRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListScopesRequest>(
            "ListScopesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListScopesRequest {
    const NAME: &'static str = "ListScopesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_type = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_type);
        }
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key_type.is_empty() {
            os.write_string(1, &self.key_type)?;
        }
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListScopesRequest {
        ListScopesRequest::new()
    }

    fn clear(&mut self) {
        self.key_type.clear();
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListScopesRequest {
        static instance: ListScopesRequest = ListScopesRequest {
            key_type: ::std::string::String::new(),
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListScopesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListScopesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListScopesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesRequest
// @@protoc_insertion_point(message:clarifai.api.MyScopesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyScopesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MyScopesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesRequest {
    fn default() -> &'a MyScopesRequest {
        <MyScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRequest {
    pub fn new() -> MyScopesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &MyScopesRequest| { &m.user_app_id },
            |m: &mut MyScopesRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesRequest>(
            "MyScopesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesRequest {
    const NAME: &'static str = "MyScopesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesRequest {
        MyScopesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesRequest {
        static instance: MyScopesRequest = MyScopesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesUserRequest
// @@protoc_insertion_point(message:clarifai.api.MyScopesUserRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyScopesUserRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MyScopesUserRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesUserRequest {
    fn default() -> &'a MyScopesUserRequest {
        <MyScopesUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesUserRequest {
    pub fn new() -> MyScopesUserRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &MyScopesUserRequest| { &m.user_app_id },
            |m: &mut MyScopesUserRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesUserRequest>(
            "MyScopesUserRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesUserRequest {
    const NAME: &'static str = "MyScopesUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesUserRequest {
        MyScopesUserRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesUserRequest {
        static instance: MyScopesUserRequest = MyScopesUserRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesUserRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesUserRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesUserRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesRootRequest
// @@protoc_insertion_point(message:clarifai.api.MyScopesRootRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyScopesRootRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesRootRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesRootRequest {
    fn default() -> &'a MyScopesRootRequest {
        <MyScopesRootRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRootRequest {
    pub fn new() -> MyScopesRootRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesRootRequest>(
            "MyScopesRootRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesRootRequest {
    const NAME: &'static str = "MyScopesRootRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesRootRequest {
        MyScopesRootRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesRootRequest {
        static instance: MyScopesRootRequest = MyScopesRootRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesRootRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesRootRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesRootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRootRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeDepsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeDepsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeDepsResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  scopes is a list of low-level scopes and their dependencies.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.scope_deps)
    pub scope_deps: ::std::vec::Vec<super::resources::ScopeDeps>,
    ///  endpoint_scopes is a listof all the publicly available endponts which can be
    ///  used as scopes as well. A call to each of those endpoint depends on a subset
    ///  of the above "scopes"
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.endpoint_deps)
    pub endpoint_deps: ::std::vec::Vec<super::resources::EndpointDeps>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeDepsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeDepsResponse {
    fn default() -> &'a MultiScopeDepsResponse {
        <MultiScopeDepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeDepsResponse {
    pub fn new() -> MultiScopeDepsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeDepsResponse| { &m.status },
            |m: &mut MultiScopeDepsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scope_deps",
            |m: &MultiScopeDepsResponse| { &m.scope_deps },
            |m: &mut MultiScopeDepsResponse| { &mut m.scope_deps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoint_deps",
            |m: &MultiScopeDepsResponse| { &m.endpoint_deps },
            |m: &mut MultiScopeDepsResponse| { &mut m.endpoint_deps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeDepsResponse>(
            "MultiScopeDepsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeDepsResponse {
    const NAME: &'static str = "MultiScopeDepsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scope_deps.push(is.read_message()?);
                },
                26 => {
                    self.endpoint_deps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scope_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.endpoint_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scope_deps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.endpoint_deps {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeDepsResponse {
        MultiScopeDepsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scope_deps.clear();
        self.endpoint_deps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeDepsResponse {
        static instance: MultiScopeDepsResponse = MultiScopeDepsResponse {
            status: ::protobuf::MessageField::none(),
            scope_deps: ::std::vec::Vec::new(),
            endpoint_deps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeDepsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeDepsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeDepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeDepsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  The app that the key has access to.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeResponse {
    fn default() -> &'a MultiScopeResponse {
        <MultiScopeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeResponse {
    pub fn new() -> MultiScopeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeResponse| { &m.status },
            |m: &mut MultiScopeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeResponse| { &m.scopes },
            |m: &mut MultiScopeResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &MultiScopeResponse| { &m.app },
            |m: &mut MultiScopeResponse| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeResponse| { &m.endpoints },
            |m: &mut MultiScopeResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeResponse>(
            "MultiScopeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeResponse {
    const NAME: &'static str = "MultiScopeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeResponse {
        MultiScopeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.app.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeResponse {
        static instance: MultiScopeResponse = MultiScopeResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            app: ::protobuf::MessageField::none(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeUserResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeUserResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeUserResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeUserResponse {
    fn default() -> &'a MultiScopeUserResponse {
        <MultiScopeUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeUserResponse {
    pub fn new() -> MultiScopeUserResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeUserResponse| { &m.status },
            |m: &mut MultiScopeUserResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeUserResponse| { &m.scopes },
            |m: &mut MultiScopeUserResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeUserResponse| { &m.endpoints },
            |m: &mut MultiScopeUserResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeUserResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeUserResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeUserResponse>(
            "MultiScopeUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeUserResponse {
    const NAME: &'static str = "MultiScopeUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeUserResponse {
        MultiScopeUserResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeUserResponse {
        static instance: MultiScopeUserResponse = MultiScopeUserResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeRootResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeRootResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeRootResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeRootResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeRootResponse {
    fn default() -> &'a MultiScopeRootResponse {
        <MultiScopeRootResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeRootResponse {
    pub fn new() -> MultiScopeRootResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeRootResponse| { &m.status },
            |m: &mut MultiScopeRootResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeRootResponse| { &m.scopes },
            |m: &mut MultiScopeRootResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeRootResponse| { &m.endpoints },
            |m: &mut MultiScopeRootResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeRootResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeRootResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeRootResponse>(
            "MultiScopeRootResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeRootResponse {
    const NAME: &'static str = "MultiScopeRootResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeRootResponse {
        MultiScopeRootResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeRootResponse {
        static instance: MultiScopeRootResponse = MultiScopeRootResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeRootResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeRootResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeRootResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeRootResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetSearchRequest
// @@protoc_insertion_point(message:clarifai.api.GetSearchRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSearchRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetSearchRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetSearchRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetSearchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSearchRequest {
    fn default() -> &'a GetSearchRequest {
        <GetSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSearchRequest {
    pub fn new() -> GetSearchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetSearchRequest| { &m.user_app_id },
            |m: &mut GetSearchRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetSearchRequest| { &m.id },
            |m: &mut GetSearchRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSearchRequest>(
            "GetSearchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSearchRequest {
    const NAME: &'static str = "GetSearchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSearchRequest {
        GetSearchRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSearchRequest {
        static instance: GetSearchRequest = GetSearchRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSearchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSearchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSearchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.ListSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSearchesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSearchesRequest {
    fn default() -> &'a ListSearchesRequest {
        <ListSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSearchesRequest {
    pub fn new() -> ListSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListSearchesRequest| { &m.user_app_id },
            |m: &mut ListSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListSearchesRequest| { &m.page },
            |m: &mut ListSearchesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListSearchesRequest| { &m.per_page },
            |m: &mut ListSearchesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSearchesRequest>(
            "ListSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSearchesRequest {
    const NAME: &'static str = "ListSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSearchesRequest {
        ListSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSearchesRequest {
        static instance: ListSearchesRequest = ListSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.PostSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The query; this specifies how the data to be searched
    ///  this will be replaced by "Searches"
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.query)
    pub query: ::protobuf::MessageField<super::resources::Query>,
    ///  The searched to be executed or saved
    ///  Eventually the request level fields will be deprecated in favor of this object
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostSearchesRequest {
    fn default() -> &'a PostSearchesRequest {
        <PostSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesRequest {
    pub fn new() -> PostSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostSearchesRequest| { &m.user_app_id },
            |m: &mut PostSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Query>(
            "query",
            |m: &PostSearchesRequest| { &m.query },
            |m: &mut PostSearchesRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostSearchesRequest| { &m.searches },
            |m: &mut PostSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostSearchesRequest| { &m.pagination },
            |m: &mut PostSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostSearchesRequest>(
            "PostSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostSearchesRequest {
    const NAME: &'static str = "PostSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                26 => {
                    self.searches.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostSearchesRequest {
        PostSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.query.clear();
        self.searches.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostSearchesRequest {
        static instance: PostSearchesRequest = PostSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            query: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchInputsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchInputsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchInputsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchInputsSearchesRequest {
    fn default() -> &'a PatchInputsSearchesRequest {
        <PatchInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsSearchesRequest {
    pub fn new() -> PatchInputsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchInputsSearchesRequest| { &m.user_app_id },
            |m: &mut PatchInputsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchInputsSearchesRequest| { &m.searches },
            |m: &mut PatchInputsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchInputsSearchesRequest| { &m.action },
            |m: &mut PatchInputsSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchInputsSearchesRequest>(
            "PatchInputsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchInputsSearchesRequest {
    const NAME: &'static str = "PatchInputsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchInputsSearchesRequest {
        PatchInputsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchInputsSearchesRequest {
        static instance: PatchInputsSearchesRequest = PatchInputsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchInputsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchInputsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsSearchesRequest {
    fn default() -> &'a PatchAnnotationsSearchesRequest {
        <PatchAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsSearchesRequest {
    pub fn new() -> PatchAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsSearchesRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchAnnotationsSearchesRequest| { &m.searches },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsSearchesRequest| { &m.action },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsSearchesRequest>(
            "PatchAnnotationsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsSearchesRequest {
    const NAME: &'static str = "PatchAnnotationsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsSearchesRequest {
        PatchAnnotationsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsSearchesRequest {
        static instance: PatchAnnotationsSearchesRequest = PatchAnnotationsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.PatchSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchSearchesRequest {
    fn default() -> &'a PatchSearchesRequest {
        <PatchSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchSearchesRequest {
    pub fn new() -> PatchSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchSearchesRequest| { &m.user_app_id },
            |m: &mut PatchSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchSearchesRequest| { &m.searches },
            |m: &mut PatchSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchSearchesRequest| { &m.action },
            |m: &mut PatchSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchSearchesRequest>(
            "PatchSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchSearchesRequest {
    const NAME: &'static str = "PatchSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchSearchesRequest {
        PatchSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchSearchesRequest {
        static instance: PatchSearchesRequest = PatchSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostSearchesByIDRequest performs returns results of a saved search given its ID
// @@protoc_insertion_point(message:clarifai.api.PostSearchesByIDRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostSearchesByIDRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  ID for saves search to be executed
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.id)
    pub id: ::std::string::String,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostSearchesByIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostSearchesByIDRequest {
    fn default() -> &'a PostSearchesByIDRequest {
        <PostSearchesByIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesByIDRequest {
    pub fn new() -> PostSearchesByIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostSearchesByIDRequest| { &m.user_app_id },
            |m: &mut PostSearchesByIDRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PostSearchesByIDRequest| { &m.id },
            |m: &mut PostSearchesByIDRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostSearchesByIDRequest| { &m.pagination },
            |m: &mut PostSearchesByIDRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostSearchesByIDRequest>(
            "PostSearchesByIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostSearchesByIDRequest {
    const NAME: &'static str = "PostSearchesByIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostSearchesByIDRequest {
        PostSearchesByIDRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostSearchesByIDRequest {
        static instance: PostSearchesByIDRequest = PostSearchesByIDRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostSearchesByIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostSearchesByIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostSearchesByIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesByIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteSearchRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteSearchRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSearchRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteSearchRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteSearchRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteSearchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSearchRequest {
    fn default() -> &'a DeleteSearchRequest {
        <DeleteSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSearchRequest {
    pub fn new() -> DeleteSearchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteSearchRequest| { &m.user_app_id },
            |m: &mut DeleteSearchRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteSearchRequest| { &m.id },
            |m: &mut DeleteSearchRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSearchRequest>(
            "DeleteSearchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSearchRequest {
    const NAME: &'static str = "DeleteSearchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSearchRequest {
        DeleteSearchRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSearchRequest {
        static instance: DeleteSearchRequest = DeleteSearchRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSearchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSearchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSearchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Execute a new annotation search and optionally save it
///  annotation search over annotations using rank and filter proto
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searched to be executed or saved
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsSearchesRequest {
    fn default() -> &'a PostAnnotationsSearchesRequest {
        <PostAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsSearchesRequest {
    pub fn new() -> PostAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationsSearchesRequest| { &m.user_app_id },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostAnnotationsSearchesRequest| { &m.searches },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostAnnotationsSearchesRequest| { &m.pagination },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationsSearchesRequest>(
            "PostAnnotationsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationsSearchesRequest {
    const NAME: &'static str = "PostAnnotationsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationsSearchesRequest {
        PostAnnotationsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationsSearchesRequest {
        static instance: PostAnnotationsSearchesRequest = PostAnnotationsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationSearchMetricsRequest {
    fn default() -> &'a DeleteAnnotationSearchMetricsRequest {
        <DeleteAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationSearchMetricsRequest {
    pub fn new() -> DeleteAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationSearchMetricsRequest>(
            "DeleteAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationSearchMetricsRequest {
    const NAME: &'static str = "DeleteAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationSearchMetricsRequest {
        DeleteAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationSearchMetricsRequest {
        static instance: DeleteAnnotationSearchMetricsRequest = DeleteAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Execute a new input search and optionally save it
// @@protoc_insertion_point(message:clarifai.api.PostInputsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searched to be executed or saved
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  If only_count is set, then the response will not contain hits,
    ///  but hit_counts instead.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.only_count)
    pub only_count: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsSearchesRequest {
    fn default() -> &'a PostInputsSearchesRequest {
        <PostInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsSearchesRequest {
    pub fn new() -> PostInputsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsSearchesRequest| { &m.user_app_id },
            |m: &mut PostInputsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostInputsSearchesRequest| { &m.searches },
            |m: &mut PostInputsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostInputsSearchesRequest| { &m.pagination },
            |m: &mut PostInputsSearchesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "only_count",
            |m: &PostInputsSearchesRequest| { &m.only_count },
            |m: &mut PostInputsSearchesRequest| { &mut m.only_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsSearchesRequest>(
            "PostInputsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsSearchesRequest {
    const NAME: &'static str = "PostInputsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                32 => {
                    self.only_count = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.only_count != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.only_count != false {
            os.write_bool(4, self.only_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsSearchesRequest {
        PostInputsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.only_count = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsSearchesRequest {
        static instance: PostInputsSearchesRequest = PostInputsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            only_count: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleSearchResponse returns saved search in response to GetSearchRequest
// @@protoc_insertion_point(message:clarifai.api.SingleSearchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleSearchResponse {
    // message fields
    ///  Status of whether the search was successful.
    // @@protoc_insertion_point(field:clarifai.api.SingleSearchResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleSearchResponse.search)
    pub search: ::protobuf::MessageField<super::resources::Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleSearchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleSearchResponse {
    fn default() -> &'a SingleSearchResponse {
        <SingleSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleSearchResponse {
    pub fn new() -> SingleSearchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleSearchResponse| { &m.status },
            |m: &mut SingleSearchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search",
            |m: &SingleSearchResponse| { &m.search },
            |m: &mut SingleSearchResponse| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleSearchResponse>(
            "SingleSearchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleSearchResponse {
    const NAME: &'static str = "SingleSearchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleSearchResponse {
        SingleSearchResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleSearchResponse {
        static instance: SingleSearchResponse = SingleSearchResponse {
            status: ::protobuf::MessageField::none(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleSearchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleSearchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSearchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiSearchResponse
// @@protoc_insertion_point(message:clarifai.api.MultiSearchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiSearchResponse {
    // message fields
    ///  Status of whether the search was successful.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  A unique id which uniquely identifies a search
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.id)
    pub id: ::std::string::String,
    ///  The list of search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.hits)
    pub hits: ::std::vec::Vec<super::resources::Hit>,
    ///  The original query provided in the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.query)
    pub query: ::protobuf::MessageField<super::resources::Query>,
    ///  The original Searches provided in the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The counts of hits for each search, in the same order as searches.
    ///  Only returned if the request set only_count.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.hit_counts)
    pub hit_counts: ::std::vec::Vec<super::resources::HitCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiSearchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiSearchResponse {
    fn default() -> &'a MultiSearchResponse {
        <MultiSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiSearchResponse {
    pub fn new() -> MultiSearchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiSearchResponse| { &m.status },
            |m: &mut MultiSearchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MultiSearchResponse| { &m.id },
            |m: &mut MultiSearchResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &MultiSearchResponse| { &m.hits },
            |m: &mut MultiSearchResponse| { &mut m.hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Query>(
            "query",
            |m: &MultiSearchResponse| { &m.query },
            |m: &mut MultiSearchResponse| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &MultiSearchResponse| { &m.searches },
            |m: &mut MultiSearchResponse| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hit_counts",
            |m: &MultiSearchResponse| { &m.hit_counts },
            |m: &mut MultiSearchResponse| { &mut m.hit_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiSearchResponse>(
            "MultiSearchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiSearchResponse {
    const NAME: &'static str = "MultiSearchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.hits.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                42 => {
                    self.searches.push(is.read_message()?);
                },
                50 => {
                    self.hit_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.hit_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.hit_counts {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiSearchResponse {
        MultiSearchResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.hits.clear();
        self.query.clear();
        self.searches.clear();
        self.hit_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiSearchResponse {
        static instance: MultiSearchResponse = MultiSearchResponse {
            status: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            hits: ::std::vec::Vec::new(),
            query: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            hit_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiSearchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiSearchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSearchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  A unique customer facing id to identify this eval request
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    ///  The ground truth we are evaluating against
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.ground_truth)
    pub ground_truth: ::protobuf::MessageField<super::resources::Search>,
    ///  The set we are evaluating
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.search_to_eval)
    pub search_to_eval: ::protobuf::MessageField<super::resources::Search>,
    ///  List of concepts to evaluate are expected to be in data.concepts
    ///  If nil, then all app concepts are used
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.data)
    pub data: ::protobuf::MessageField<super::resources::Data>,
    ///  The type of evaluation to use
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.evaluation_type)
    pub evaluation_type: ::protobuf::EnumOrUnknown<super::resources::EvaluationType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationSearchMetricsRequest {
    fn default() -> &'a PostAnnotationSearchMetricsRequest {
        <PostAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationSearchMetricsRequest {
    pub fn new() -> PostAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PostAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "ground_truth",
            |m: &PostAnnotationSearchMetricsRequest| { &m.ground_truth },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.ground_truth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search_to_eval",
            |m: &PostAnnotationSearchMetricsRequest| { &m.search_to_eval },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.search_to_eval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Data>(
            "data",
            |m: &PostAnnotationSearchMetricsRequest| { &m.data },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_type",
            |m: &PostAnnotationSearchMetricsRequest| { &m.evaluation_type },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.evaluation_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationSearchMetricsRequest>(
            "PostAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationSearchMetricsRequest {
    const NAME: &'static str = "PostAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ground_truth)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search_to_eval)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                48 => {
                    self.evaluation_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined) {
            my_size += ::protobuf::rt::int32_size(6, self.evaluation_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.ground_truth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.evaluation_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationSearchMetricsRequest {
        PostAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.data.clear();
        self.evaluation_type = ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationSearchMetricsRequest {
        static instance: PostAnnotationSearchMetricsRequest = PostAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            ground_truth: ::protobuf::MessageField::none(),
            search_to_eval: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            evaluation_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Unique custom facing id that identifies the eval to get
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationSearchMetricsRequest {
    fn default() -> &'a GetAnnotationSearchMetricsRequest {
        <GetAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationSearchMetricsRequest {
    pub fn new() -> GetAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationSearchMetricsRequest>(
            "GetAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationSearchMetricsRequest {
    const NAME: &'static str = "GetAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationSearchMetricsRequest {
        GetAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationSearchMetricsRequest {
        static instance: GetAnnotationSearchMetricsRequest = GetAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationSearchMetricsRequest {
    fn default() -> &'a ListAnnotationSearchMetricsRequest {
        <ListAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationSearchMetricsRequest {
    pub fn new() -> ListAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut ListAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationSearchMetricsRequest>(
            "ListAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationSearchMetricsRequest {
    const NAME: &'static str = "ListAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationSearchMetricsRequest {
        ListAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationSearchMetricsRequest {
        static instance: ListAnnotationSearchMetricsRequest = ListAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationSearchMetricsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationSearchMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAnnotationSearchMetricsResponse {
    // message fields
    ///  Status of the request
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationSearchMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationSearchMetricsResponse.annotation_search_metrics)
    pub annotation_search_metrics: ::std::vec::Vec<super::resources::AnnotationSearchMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationSearchMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationSearchMetricsResponse {
    fn default() -> &'a MultiAnnotationSearchMetricsResponse {
        <MultiAnnotationSearchMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationSearchMetricsResponse {
    pub fn new() -> MultiAnnotationSearchMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationSearchMetricsResponse| { &m.status },
            |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_search_metrics",
            |m: &MultiAnnotationSearchMetricsResponse| { &m.annotation_search_metrics },
            |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.annotation_search_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationSearchMetricsResponse>(
            "MultiAnnotationSearchMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationSearchMetricsResponse {
    const NAME: &'static str = "MultiAnnotationSearchMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotation_search_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_search_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_search_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationSearchMetricsResponse {
        MultiAnnotationSearchMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_search_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationSearchMetricsResponse {
        static instance: MultiAnnotationSearchMetricsResponse = MultiAnnotationSearchMetricsResponse {
            status: ::protobuf::MessageField::none(),
            annotation_search_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationSearchMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationSearchMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationSearchMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationSearchMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationFiltersRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationFiltersRequest {
    fn default() -> &'a ListAnnotationFiltersRequest {
        <ListAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationFiltersRequest {
    pub fn new() -> ListAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationFiltersRequest| { &m.page },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationFiltersRequest| { &m.per_page },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationFiltersRequest>(
            "ListAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationFiltersRequest {
    const NAME: &'static str = "ListAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationFiltersRequest {
        ListAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationFiltersRequest {
        static instance: ListAnnotationFiltersRequest = ListAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationFilterRequest
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationFilterRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAnnotationFilterRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationFilterRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify annotation filter by id.
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationFilterRequest.annotation_filter_id)
    pub annotation_filter_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationFilterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationFilterRequest {
    fn default() -> &'a GetAnnotationFilterRequest {
        <GetAnnotationFilterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationFilterRequest {
    pub fn new() -> GetAnnotationFilterRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationFilterRequest| { &m.user_app_id },
            |m: &mut GetAnnotationFilterRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_filter_id",
            |m: &GetAnnotationFilterRequest| { &m.annotation_filter_id },
            |m: &mut GetAnnotationFilterRequest| { &mut m.annotation_filter_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationFilterRequest>(
            "GetAnnotationFilterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationFilterRequest {
    const NAME: &'static str = "GetAnnotationFilterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filter_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.annotation_filter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_filter_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.annotation_filter_id.is_empty() {
            os.write_string(2, &self.annotation_filter_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationFilterRequest {
        GetAnnotationFilterRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filter_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationFilterRequest {
        static instance: GetAnnotationFilterRequest = GetAnnotationFilterRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filter_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationFilterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationFilterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationFilterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationFilterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more annotation filters.
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of annotation filters that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationFiltersRequest.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationFiltersRequest {
    fn default() -> &'a PostAnnotationFiltersRequest {
        <PostAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationFiltersRequest {
    pub fn new() -> PostAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut PostAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &PostAnnotationFiltersRequest| { &m.annotation_filters },
            |m: &mut PostAnnotationFiltersRequest| { &mut m.annotation_filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationFiltersRequest>(
            "PostAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationFiltersRequest {
    const NAME: &'static str = "PostAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationFiltersRequest {
        PostAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationFiltersRequest {
        static instance: PostAnnotationFiltersRequest = PostAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several annotation filters.
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of annotation filters that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    ///  The action to perform on the patched objects
    ///  For now, only 'overwrite' action is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationFiltersRequest {
    fn default() -> &'a PatchAnnotationFiltersRequest {
        <PatchAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationFiltersRequest {
    pub fn new() -> PatchAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &PatchAnnotationFiltersRequest| { &m.annotation_filters },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.annotation_filters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationFiltersRequest| { &m.action },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationFiltersRequest>(
            "PatchAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationFiltersRequest {
    const NAME: &'static str = "PatchAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationFiltersRequest {
        PatchAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filters.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationFiltersRequest {
        static instance: PatchAnnotationFiltersRequest = PatchAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several annotation filters by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Specify which filters to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationFiltersRequest.annotation_filter_ids)
    pub annotation_filter_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationFiltersRequest {
    fn default() -> &'a DeleteAnnotationFiltersRequest {
        <DeleteAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationFiltersRequest {
    pub fn new() -> DeleteAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filter_ids",
            |m: &DeleteAnnotationFiltersRequest| { &m.annotation_filter_ids },
            |m: &mut DeleteAnnotationFiltersRequest| { &mut m.annotation_filter_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationFiltersRequest>(
            "DeleteAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationFiltersRequest {
    const NAME: &'static str = "DeleteAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filter_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filter_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filter_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationFiltersRequest {
        DeleteAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filter_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationFiltersRequest {
        static instance: DeleteAnnotationFiltersRequest = DeleteAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filter_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationFilterResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationFilterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAnnotationFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationFilterResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationFilterResponse.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationFilterResponse {
    fn default() -> &'a MultiAnnotationFilterResponse {
        <MultiAnnotationFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationFilterResponse {
    pub fn new() -> MultiAnnotationFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationFilterResponse| { &m.status },
            |m: &mut MultiAnnotationFilterResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &MultiAnnotationFilterResponse| { &m.annotation_filters },
            |m: &mut MultiAnnotationFilterResponse| { &mut m.annotation_filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationFilterResponse>(
            "MultiAnnotationFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationFilterResponse {
    const NAME: &'static str = "MultiAnnotationFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationFilterResponse {
        MultiAnnotationFilterResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationFilterResponse {
        static instance: MultiAnnotationFilterResponse = MultiAnnotationFilterResponse {
            status: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAnnotationFilterResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAnnotationFilterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAnnotationFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationFilterResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationFilterResponse.annotation_filter)
    pub annotation_filter: ::protobuf::MessageField<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAnnotationFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationFilterResponse {
    fn default() -> &'a SingleAnnotationFilterResponse {
        <SingleAnnotationFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationFilterResponse {
    pub fn new() -> SingleAnnotationFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAnnotationFilterResponse| { &m.status },
            |m: &mut SingleAnnotationFilterResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AnnotationFilter>(
            "annotation_filter",
            |m: &SingleAnnotationFilterResponse| { &m.annotation_filter },
            |m: &mut SingleAnnotationFilterResponse| { &mut m.annotation_filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAnnotationFilterResponse>(
            "SingleAnnotationFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAnnotationFilterResponse {
    const NAME: &'static str = "SingleAnnotationFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.annotation_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAnnotationFilterResponse {
        SingleAnnotationFilterResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAnnotationFilterResponse {
        static instance: SingleAnnotationFilterResponse = SingleAnnotationFilterResponse {
            status: ::protobuf::MessageField::none(),
            annotation_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAnnotationFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAnnotationFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAnnotationFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetUserRequest
// @@protoc_insertion_point(message:clarifai.api.GetUserRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetUserRequest {
    // message fields
    ///  we used to have user_id but moved to the standard convention. Since this endpoint
    ///  hasn't been exposed and only used by portal as a url this won't effect anything external.
    // @@protoc_insertion_point(field:clarifai.api.GetUserRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetUserRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserRequest {
    fn default() -> &'a GetUserRequest {
        <GetUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUserRequest {
    pub fn new() -> GetUserRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetUserRequest| { &m.user_app_id },
            |m: &mut GetUserRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetUserRequest| { &m.additional_fields },
            |m: &mut GetUserRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserRequest>(
            "GetUserRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserRequest {
    const NAME: &'static str = "GetUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserRequest {
        GetUserRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserRequest {
        static instance: GetUserRequest = GetUserRequest {
            user_app_id: ::protobuf::MessageField::none(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleUserResponse
// @@protoc_insertion_point(message:clarifai.api.SingleUserResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleUserResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleUserResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleUserResponse.user)
    pub user: ::protobuf::MessageField<super::resources::User>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleUserResponse {
    fn default() -> &'a SingleUserResponse {
        <SingleUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleUserResponse {
    pub fn new() -> SingleUserResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleUserResponse| { &m.status },
            |m: &mut SingleUserResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::User>(
            "user",
            |m: &SingleUserResponse| { &m.user },
            |m: &mut SingleUserResponse| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleUserResponse>(
            "SingleUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleUserResponse {
    const NAME: &'static str = "SingleUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleUserResponse {
        SingleUserResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleUserResponse {
        static instance: SingleUserResponse = SingleUserResponse {
            status: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostValidatePasswordRequest
// @@protoc_insertion_point(message:clarifai.api.PostValidatePasswordRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostValidatePasswordRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostValidatePasswordRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  password to be validated
    // @@protoc_insertion_point(field:clarifai.api.PostValidatePasswordRequest.password)
    pub password: ::protobuf::MessageField<super::resources::Password>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostValidatePasswordRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostValidatePasswordRequest {
    fn default() -> &'a PostValidatePasswordRequest {
        <PostValidatePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostValidatePasswordRequest {
    pub fn new() -> PostValidatePasswordRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostValidatePasswordRequest| { &m.user_app_id },
            |m: &mut PostValidatePasswordRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Password>(
            "password",
            |m: &PostValidatePasswordRequest| { &m.password },
            |m: &mut PostValidatePasswordRequest| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostValidatePasswordRequest>(
            "PostValidatePasswordRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostValidatePasswordRequest {
    const NAME: &'static str = "PostValidatePasswordRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.password)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.password.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.password.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostValidatePasswordRequest {
        PostValidatePasswordRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostValidatePasswordRequest {
        static instance: PostValidatePasswordRequest = PostValidatePasswordRequest {
            user_app_id: ::protobuf::MessageField::none(),
            password: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostValidatePasswordRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostValidatePasswordRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostValidatePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostValidatePasswordRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SinglePasswordValidationResponse
// @@protoc_insertion_point(message:clarifai.api.SinglePasswordValidationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SinglePasswordValidationResponse {
    // message fields
    ///  Standard clarifai status code
    // @@protoc_insertion_point(field:clarifai.api.SinglePasswordValidationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SinglePasswordValidationResponse.password_violations)
    pub password_violations: ::protobuf::MessageField<super::resources::PasswordViolations>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SinglePasswordValidationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SinglePasswordValidationResponse {
    fn default() -> &'a SinglePasswordValidationResponse {
        <SinglePasswordValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SinglePasswordValidationResponse {
    pub fn new() -> SinglePasswordValidationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SinglePasswordValidationResponse| { &m.status },
            |m: &mut SinglePasswordValidationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PasswordViolations>(
            "password_violations",
            |m: &SinglePasswordValidationResponse| { &m.password_violations },
            |m: &mut SinglePasswordValidationResponse| { &mut m.password_violations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SinglePasswordValidationResponse>(
            "SinglePasswordValidationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SinglePasswordValidationResponse {
    const NAME: &'static str = "SinglePasswordValidationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.password_violations)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.password_violations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.password_violations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SinglePasswordValidationResponse {
        SinglePasswordValidationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.password_violations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SinglePasswordValidationResponse {
        static instance: SinglePasswordValidationResponse = SinglePasswordValidationResponse {
            status: ::protobuf::MessageField::none(),
            password_violations: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SinglePasswordValidationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SinglePasswordValidationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SinglePasswordValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePasswordValidationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetWorkflowRequest
// @@protoc_insertion_point(message:clarifai.api.GetWorkflowRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWorkflowRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Workflow ID to retrieve
    ///  If no ID is specified we return default workflow of the application
    ///  If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  if true will not expand search to clarifai workflows
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.exclude_clarifai_workflows)
    pub exclude_clarifai_workflows: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetWorkflowRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWorkflowRequest {
    fn default() -> &'a GetWorkflowRequest {
        <GetWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowRequest {
    pub fn new() -> GetWorkflowRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetWorkflowRequest| { &m.user_app_id },
            |m: &mut GetWorkflowRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &GetWorkflowRequest| { &m.workflow_id },
            |m: &mut GetWorkflowRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &GetWorkflowRequest| { &m.favor_clarifai_workflows },
            |m: &mut GetWorkflowRequest| { &mut m.favor_clarifai_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetWorkflowRequest| { &m.additional_fields },
            |m: &mut GetWorkflowRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exclude_clarifai_workflows",
            |m: &GetWorkflowRequest| { &m.exclude_clarifai_workflows },
            |m: &mut GetWorkflowRequest| { &mut m.exclude_clarifai_workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetWorkflowRequest>(
            "GetWorkflowRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetWorkflowRequest {
    const NAME: &'static str = "GetWorkflowRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                24 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                34 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.exclude_clarifai_workflows = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.exclude_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(3, self.favor_clarifai_workflows)?;
        }
        for v in &self.additional_fields {
            os.write_string(4, &v)?;
        };
        if self.exclude_clarifai_workflows != false {
            os.write_bool(5, self.exclude_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWorkflowRequest {
        GetWorkflowRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.favor_clarifai_workflows = false;
        self.additional_fields.clear();
        self.exclude_clarifai_workflows = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWorkflowRequest {
        static instance: GetWorkflowRequest = GetWorkflowRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            favor_clarifai_workflows: false,
            additional_fields: ::std::vec::Vec::new(),
            exclude_clarifai_workflows: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetWorkflowRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetWorkflowRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListWorkflowsRequest
// @@protoc_insertion_point(message:clarifai.api.ListWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  If true, we only return workflows that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return workflows that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.starred_only)
    pub starred_only: bool,
    ///  Filter workflows by bookmark. If set, only return bookmarked workflows. Otherwise none bookmarked workflows only.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the workflow:
    ///    - id
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.search)
    pub search: ::std::string::String,
    ///  Query various text fields (id, description and notes) that can contain the words in the query string.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.id)
    pub id: ::std::string::String,
    ///  Full text and prefix matching on id, owner id, description and notes. Searchable fields may be added
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.search_term)
    pub search_term: ::std::string::String,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_workflows_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListWorkflowsRequest {
    fn default() -> &'a ListWorkflowsRequest {
        <ListWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowsRequest {
    pub fn new() -> ListWorkflowsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_id = 6;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(v))
    }

    // bool sort_by_modified_at = 7;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 13;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 14;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListWorkflowsRequest| { &m.user_app_id },
            |m: &mut ListWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListWorkflowsRequest| { &m.page },
            |m: &mut ListWorkflowsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListWorkflowsRequest| { &m.per_page },
            |m: &mut ListWorkflowsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListWorkflowsRequest| { &m.additional_fields },
            |m: &mut ListWorkflowsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListWorkflowsRequest| { &m.sort_ascending },
            |m: &mut ListWorkflowsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListWorkflowsRequest::has_sort_by_id,
            ListWorkflowsRequest::sort_by_id,
            ListWorkflowsRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListWorkflowsRequest::has_sort_by_modified_at,
            ListWorkflowsRequest::sort_by_modified_at,
            ListWorkflowsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListWorkflowsRequest::has_sort_by_created_at,
            ListWorkflowsRequest::sort_by_created_at,
            ListWorkflowsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListWorkflowsRequest::has_sort_by_star_count,
            ListWorkflowsRequest::sort_by_star_count,
            ListWorkflowsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListWorkflowsRequest| { &m.featured_only },
            |m: &mut ListWorkflowsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListWorkflowsRequest| { &m.starred_only },
            |m: &mut ListWorkflowsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListWorkflowsRequest| { &m.bookmark },
            |m: &mut ListWorkflowsRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListWorkflowsRequest| { &m.search },
            |m: &mut ListWorkflowsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListWorkflowsRequest| { &m.query },
            |m: &mut ListWorkflowsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListWorkflowsRequest| { &m.id },
            |m: &mut ListWorkflowsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search_term",
            |m: &ListWorkflowsRequest| { &m.search_term },
            |m: &mut ListWorkflowsRequest| { &mut m.search_term },
        ));
        oneofs.push(list_workflows_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListWorkflowsRequest>(
            "ListWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListWorkflowsRequest {
    const NAME: &'static str = "ListWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                82 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.sort_ascending = is.read_bool()?;
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                112 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.featured_only = is.read_bool()?;
                },
                88 => {
                    self.starred_only = is.read_bool()?;
                },
                120 => {
                    self.bookmark = is.read_bool()?;
                },
                130 => {
                    self.search = is.read_string()?;
                },
                66 => {
                    self.query = is.read_string()?;
                },
                34 => {
                    self.id = is.read_string()?;
                },
                98 => {
                    self.search_term = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.featured_only != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.search);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id);
        }
        if !self.search_term.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.search_term);
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_workflows_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        if self.bookmark != false {
            os.write_bool(15, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(16, &self.search)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.id.is_empty() {
            os.write_string(4, &self.id)?;
        }
        if !self.search_term.is_empty() {
            os.write_string(12, &self.search_term)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_workflows_request::Sort_by::SortById(v) => {
                    os.write_bool(6, v)?;
                },
                &list_workflows_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_workflows_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(13, v)?;
                },
                &list_workflows_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(14, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListWorkflowsRequest {
        ListWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.featured_only = false;
        self.starred_only = false;
        self.bookmark = false;
        self.search.clear();
        self.query.clear();
        self.id.clear();
        self.search_term.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListWorkflowsRequest {
        static instance: ListWorkflowsRequest = ListWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            featured_only: false,
            starred_only: false,
            bookmark: false,
            search: ::std::string::String::new(),
            query: ::std::string::String::new(),
            id: ::std::string::String::new(),
            search_term: ::std::string::String::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListWorkflowsRequest`
pub mod list_workflows_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListWorkflowsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_id)
        SortById(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListWorkflowsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostWorkflowsRequest
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowsRequest.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowsRequest {
    fn default() -> &'a PostWorkflowsRequest {
        <PostWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowsRequest {
    pub fn new() -> PostWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowsRequest| { &m.user_app_id },
            |m: &mut PostWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &PostWorkflowsRequest| { &m.workflows },
            |m: &mut PostWorkflowsRequest| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowsRequest>(
            "PostWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowsRequest {
    const NAME: &'static str = "PostWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowsRequest {
        PostWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowsRequest {
        static instance: PostWorkflowsRequest = PostWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    ///
    ///  Note that 'remove' can be used to remove the workflow image by setting
    ///  'image.url' in the request to the current value returned for that workflow.
    ///  This cannot be used in a request that is patching other fields as well.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowsRequest {
    fn default() -> &'a PatchWorkflowsRequest {
        <PatchWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowsRequest {
    pub fn new() -> PatchWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &PatchWorkflowsRequest| { &m.workflows },
            |m: &mut PatchWorkflowsRequest| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowsRequest| { &m.action },
            |m: &mut PatchWorkflowsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowsRequest>(
            "PatchWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowsRequest {
    const NAME: &'static str = "PatchWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowsRequest {
        PatchWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowsRequest {
        static instance: PatchWorkflowsRequest = PatchWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowIdsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowIdsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchWorkflowIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowIdsRequest {
    fn default() -> &'a PatchWorkflowIdsRequest {
        <PatchWorkflowIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowIdsRequest {
    pub fn new() -> PatchWorkflowIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowIdsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchWorkflowIdsRequest| { &m.ids },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowIdsRequest| { &m.action },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowIdsRequest>(
            "PatchWorkflowIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowIdsRequest {
    const NAME: &'static str = "PatchWorkflowIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowIdsRequest {
        PatchWorkflowIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowIdsRequest {
        static instance: PatchWorkflowIdsRequest = PatchWorkflowIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteWorkflowRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteWorkflowRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowRequest {
    fn default() -> &'a DeleteWorkflowRequest {
        <DeleteWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowRequest {
    pub fn new() -> DeleteWorkflowRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &DeleteWorkflowRequest| { &m.workflow_id },
            |m: &mut DeleteWorkflowRequest| { &mut m.workflow_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowRequest>(
            "DeleteWorkflowRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowRequest {
    const NAME: &'static str = "DeleteWorkflowRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowRequest {
        DeleteWorkflowRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowRequest {
        static instance: DeleteWorkflowRequest = DeleteWorkflowRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowsRequest {
    fn default() -> &'a DeleteWorkflowsRequest {
        <DeleteWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowsRequest {
    pub fn new() -> DeleteWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowsRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteWorkflowsRequest| { &m.ids },
            |m: &mut DeleteWorkflowsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteWorkflowsRequest| { &m.delete_all },
            |m: &mut DeleteWorkflowsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowsRequest>(
            "DeleteWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowsRequest {
    const NAME: &'static str = "DeleteWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowsRequest {
        DeleteWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowsRequest {
        static instance: DeleteWorkflowsRequest = DeleteWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleWorkflowResponse
// @@protoc_insertion_point(message:clarifai.api.SingleWorkflowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleWorkflowResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowResponse.workflow)
    pub workflow: ::protobuf::MessageField<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleWorkflowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowResponse {
    fn default() -> &'a SingleWorkflowResponse {
        <SingleWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowResponse {
    pub fn new() -> SingleWorkflowResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleWorkflowResponse| { &m.status },
            |m: &mut SingleWorkflowResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Workflow>(
            "workflow",
            |m: &SingleWorkflowResponse| { &m.workflow },
            |m: &mut SingleWorkflowResponse| { &mut m.workflow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleWorkflowResponse>(
            "SingleWorkflowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleWorkflowResponse {
    const NAME: &'static str = "SingleWorkflowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleWorkflowResponse {
        SingleWorkflowResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleWorkflowResponse {
        static instance: SingleWorkflowResponse = SingleWorkflowResponse {
            status: ::protobuf::MessageField::none(),
            workflow: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleWorkflowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleWorkflowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkflowResponse
// @@protoc_insertion_point(message:clarifai.api.MultiWorkflowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiWorkflowResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowResponse.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkflowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowResponse {
    fn default() -> &'a MultiWorkflowResponse {
        <MultiWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowResponse {
    pub fn new() -> MultiWorkflowResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkflowResponse| { &m.status },
            |m: &mut MultiWorkflowResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &MultiWorkflowResponse| { &m.workflows },
            |m: &mut MultiWorkflowResponse| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkflowResponse>(
            "MultiWorkflowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkflowResponse {
    const NAME: &'static str = "MultiWorkflowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkflowResponse {
        MultiWorkflowResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkflowResponse {
        static instance: MultiWorkflowResponse = MultiWorkflowResponse {
            status: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkflowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkflowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsRequest
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Workflow ID to retrieve
    ///  If no ID is specified we return default workflow of the application
    ///  If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Workflow version ID to retrieve
    ///  If no ID is specified, latest workflow version is used
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
    ///  to be within models. This is not consistent with setting this on the request for post model
    ///  outputs where it is inside a model object. To make this consistent we would send in the
    ///  workflow object so that each model can have it's own output config. If nobody is setting
    ///  this OutputConfig it would probably be easier to just remove it for now to keep things simpler
    ///  and then it's more consistent we just don't support the OutputConfig on workflows.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.output_config)
    pub output_config: ::protobuf::MessageField<super::resources::OutputConfig>,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    ///  A workflow state to be maintained across PostWorkflowResults requests/responses.
    ///  If it is not sent in the initial request with workflow_state.id = "init" then no
    ///  state will be saved or returned in PostWorkflowResultsResponse.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.workflow_state)
    pub workflow_state: ::protobuf::MessageField<super::resources::WorkflowState>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsRequest {
    fn default() -> &'a PostWorkflowResultsRequest {
        <PostWorkflowResultsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsRequest {
    pub fn new() -> PostWorkflowResultsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowResultsRequest| { &m.user_app_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowResultsRequest| { &m.workflow_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostWorkflowResultsRequest| { &m.version_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostWorkflowResultsRequest| { &m.inputs },
            |m: &mut PostWorkflowResultsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::OutputConfig>(
            "output_config",
            |m: &PostWorkflowResultsRequest| { &m.output_config },
            |m: &mut PostWorkflowResultsRequest| { &mut m.output_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &PostWorkflowResultsRequest| { &m.favor_clarifai_workflows },
            |m: &mut PostWorkflowResultsRequest| { &mut m.favor_clarifai_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowState>(
            "workflow_state",
            |m: &PostWorkflowResultsRequest| { &m.workflow_state },
            |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsRequest>(
            "PostWorkflowResultsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsRequest {
    const NAME: &'static str = "PostWorkflowResultsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                58 => {
                    self.version_id = is.read_string()?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_config)?;
                },
                40 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.output_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(5, self.favor_clarifai_workflows)?;
        }
        if let Some(v) = self.workflow_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsRequest {
        PostWorkflowResultsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.output_config.clear();
        self.favor_clarifai_workflows = false;
        self.workflow_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsRequest {
        static instance: PostWorkflowResultsRequest = PostWorkflowResultsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            output_config: ::protobuf::MessageField::none(),
            favor_clarifai_workflows: false,
            workflow_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsResponse
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The workflow that was used in predictions with PostWorkflowResults
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.workflow)
    pub workflow: ::protobuf::MessageField<super::resources::Workflow>,
    ///  The resulting predictions of all models in the workflow.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.results)
    pub results: ::std::vec::Vec<super::resources::WorkflowResult>,
    ///  A workflow state to be maintained across PostWorkflowResults requests/responses.
    ///  This WorkflowState should be passed in to subsequent PostWorkflowResults calls
    ///  if you want to keep track of state across requests.
    ///  If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
    ///  response.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.workflow_state)
    pub workflow_state: ::protobuf::MessageField<super::resources::WorkflowState>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsResponse {
    fn default() -> &'a PostWorkflowResultsResponse {
        <PostWorkflowResultsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsResponse {
    pub fn new() -> PostWorkflowResultsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostWorkflowResultsResponse| { &m.status },
            |m: &mut PostWorkflowResultsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Workflow>(
            "workflow",
            |m: &PostWorkflowResultsResponse| { &m.workflow },
            |m: &mut PostWorkflowResultsResponse| { &mut m.workflow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PostWorkflowResultsResponse| { &m.results },
            |m: &mut PostWorkflowResultsResponse| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowState>(
            "workflow_state",
            |m: &PostWorkflowResultsResponse| { &m.workflow_state },
            |m: &mut PostWorkflowResultsResponse| { &mut m.workflow_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsResponse>(
            "PostWorkflowResultsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsResponse {
    const NAME: &'static str = "PostWorkflowResultsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow)?;
                },
                26 => {
                    self.results.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.workflow_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsResponse {
        PostWorkflowResultsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.results.clear();
        self.workflow_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsResponse {
        static instance: PostWorkflowResultsResponse = PostWorkflowResultsResponse {
            status: ::protobuf::MessageField::none(),
            workflow: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            workflow_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsSimilarityRequest
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsSimilarityRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsSimilarityRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Workflow version ID to retrieve
    ///  If no ID is specified, latest workflow version is used
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.version_id)
    pub version_id: ::std::string::String,
    ///  The specific model version whose outputs we are comparing
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Each probe is compared against every pool input
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.probe_inputs)
    pub probe_inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Each pool input is compared against ever probe input
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.pool_inputs)
    pub pool_inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsSimilarityRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityRequest {
    fn default() -> &'a PostWorkflowResultsSimilarityRequest {
        <PostWorkflowResultsSimilarityRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityRequest {
    pub fn new() -> PostWorkflowResultsSimilarityRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.user_app_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.workflow_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.version_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.model_version_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "probe_inputs",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.probe_inputs },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.probe_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pool_inputs",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.pool_inputs },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.pool_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.favor_clarifai_workflows },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.favor_clarifai_workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsSimilarityRequest>(
            "PostWorkflowResultsSimilarityRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityRequest {
    const NAME: &'static str = "PostWorkflowResultsSimilarityRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                58 => {
                    self.version_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.probe_inputs.push(is.read_message()?);
                },
                42 => {
                    self.pool_inputs.push(is.read_message()?);
                },
                48 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.probe_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pool_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.probe_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.pool_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.favor_clarifai_workflows != false {
            os.write_bool(6, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsSimilarityRequest {
        PostWorkflowResultsSimilarityRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.model_version_id.clear();
        self.probe_inputs.clear();
        self.pool_inputs.clear();
        self.favor_clarifai_workflows = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityRequest {
        static instance: PostWorkflowResultsSimilarityRequest = PostWorkflowResultsSimilarityRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            probe_inputs: ::std::vec::Vec::new(),
            pool_inputs: ::std::vec::Vec::new(),
            favor_clarifai_workflows: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsSimilarityRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsSimilarityRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsSimilarityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsSimilarityResponse
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsSimilarityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsSimilarityResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityResponse.results)
    pub results: ::std::vec::Vec<super::resources::WorkflowResultsSimilarity>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsSimilarityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityResponse {
    fn default() -> &'a PostWorkflowResultsSimilarityResponse {
        <PostWorkflowResultsSimilarityResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityResponse {
    pub fn new() -> PostWorkflowResultsSimilarityResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostWorkflowResultsSimilarityResponse| { &m.status },
            |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PostWorkflowResultsSimilarityResponse| { &m.results },
            |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsSimilarityResponse>(
            "PostWorkflowResultsSimilarityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityResponse {
    const NAME: &'static str = "PostWorkflowResultsSimilarityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsSimilarityResponse {
        PostWorkflowResultsSimilarityResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityResponse {
        static instance: PostWorkflowResultsSimilarityResponse = PostWorkflowResultsSimilarityResponse {
            status: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsSimilarityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsSimilarityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsSimilarityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListWorkflowVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListWorkflowVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List versions for the workflow identified by this id
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListWorkflowVersionsRequest {
    fn default() -> &'a ListWorkflowVersionsRequest {
        <ListWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowVersionsRequest {
    pub fn new() -> ListWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &ListWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListWorkflowVersionsRequest| { &m.page },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListWorkflowVersionsRequest| { &m.per_page },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListWorkflowVersionsRequest>(
            "ListWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListWorkflowVersionsRequest {
    const NAME: &'static str = "ListWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListWorkflowVersionsRequest {
        ListWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListWorkflowVersionsRequest {
        static instance: ListWorkflowVersionsRequest = ListWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetWorkflowVersionRequest
// @@protoc_insertion_point(message:clarifai.api.GetWorkflowVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWorkflowVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested version.
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Get the identified by this id
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.workflow_version_id)
    pub workflow_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetWorkflowVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWorkflowVersionRequest {
    fn default() -> &'a GetWorkflowVersionRequest {
        <GetWorkflowVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowVersionRequest {
    pub fn new() -> GetWorkflowVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetWorkflowVersionRequest| { &m.user_app_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &GetWorkflowVersionRequest| { &m.workflow_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_version_id",
            |m: &GetWorkflowVersionRequest| { &m.workflow_version_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetWorkflowVersionRequest>(
            "GetWorkflowVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetWorkflowVersionRequest {
    const NAME: &'static str = "GetWorkflowVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.workflow_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.workflow_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.workflow_version_id.is_empty() {
            os.write_string(3, &self.workflow_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWorkflowVersionRequest {
        GetWorkflowVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWorkflowVersionRequest {
        static instance: GetWorkflowVersionRequest = GetWorkflowVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetWorkflowVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetWorkflowVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetWorkflowVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteWorkflowVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested versions to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Delete the versions identified by these ids
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.workflow_version_ids)
    pub workflow_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowVersionsRequest {
    fn default() -> &'a DeleteWorkflowVersionsRequest {
        <DeleteWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowVersionsRequest {
    pub fn new() -> DeleteWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &DeleteWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_version_ids",
            |m: &DeleteWorkflowVersionsRequest| { &m.workflow_version_ids },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowVersionsRequest>(
            "DeleteWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowVersionsRequest {
    const NAME: &'static str = "DeleteWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowVersionsRequest {
        DeleteWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowVersionsRequest {
        static instance: DeleteWorkflowVersionsRequest = DeleteWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested versions to patch.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Patch these versions.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.workflow_versions)
    pub workflow_versions: ::std::vec::Vec<super::resources::WorkflowVersion>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowVersionsRequest {
    fn default() -> &'a PatchWorkflowVersionsRequest {
        <PatchWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowVersionsRequest {
    pub fn new() -> PatchWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PatchWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_versions",
            |m: &PatchWorkflowVersionsRequest| { &m.workflow_versions },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowVersionsRequest| { &m.action },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowVersionsRequest>(
            "PatchWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowVersionsRequest {
    const NAME: &'static str = "PatchWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowVersionsRequest {
        PatchWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowVersionsRequest {
        static instance: PatchWorkflowVersionsRequest = PatchWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkflowVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiWorkflowVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiWorkflowVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowVersionResponse.workflow_versions)
    pub workflow_versions: ::std::vec::Vec<super::resources::WorkflowVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkflowVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowVersionResponse {
    fn default() -> &'a MultiWorkflowVersionResponse {
        <MultiWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowVersionResponse {
    pub fn new() -> MultiWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkflowVersionResponse| { &m.status },
            |m: &mut MultiWorkflowVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_versions",
            |m: &MultiWorkflowVersionResponse| { &m.workflow_versions },
            |m: &mut MultiWorkflowVersionResponse| { &mut m.workflow_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkflowVersionResponse>(
            "MultiWorkflowVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkflowVersionResponse {
    const NAME: &'static str = "MultiWorkflowVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workflow_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflow_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkflowVersionResponse {
        MultiWorkflowVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkflowVersionResponse {
        static instance: MultiWorkflowVersionResponse = MultiWorkflowVersionResponse {
            status: ::protobuf::MessageField::none(),
            workflow_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkflowVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkflowVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleWorkflowVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleWorkflowVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleWorkflowVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowVersionResponse.workflow_version)
    pub workflow_version: ::protobuf::MessageField<super::resources::WorkflowVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleWorkflowVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowVersionResponse {
    fn default() -> &'a SingleWorkflowVersionResponse {
        <SingleWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowVersionResponse {
    pub fn new() -> SingleWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleWorkflowVersionResponse| { &m.status },
            |m: &mut SingleWorkflowVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowVersion>(
            "workflow_version",
            |m: &SingleWorkflowVersionResponse| { &m.workflow_version },
            |m: &mut SingleWorkflowVersionResponse| { &mut m.workflow_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleWorkflowVersionResponse>(
            "SingleWorkflowVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleWorkflowVersionResponse {
    const NAME: &'static str = "SingleWorkflowVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleWorkflowVersionResponse {
        SingleWorkflowVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleWorkflowVersionResponse {
        static instance: SingleWorkflowVersionResponse = SingleWorkflowVersionResponse {
            status: ::protobuf::MessageField::none(),
            workflow_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleWorkflowVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleWorkflowVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to start app duplication jobs.
// @@protoc_insertion_point(message:clarifai.api.PostAppDuplicationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAppDuplicationsRequest {
    // message fields
    ///  The user and application ID of the source application to duplicate.
    // @@protoc_insertion_point(field:clarifai.api.PostAppDuplicationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAppDuplicationsRequest.app_duplications)
    pub app_duplications: ::std::vec::Vec<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppDuplicationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppDuplicationsRequest {
    fn default() -> &'a PostAppDuplicationsRequest {
        <PostAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppDuplicationsRequest {
    pub fn new() -> PostAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppDuplicationsRequest| { &m.user_app_id },
            |m: &mut PostAppDuplicationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_duplications",
            |m: &PostAppDuplicationsRequest| { &m.app_duplications },
            |m: &mut PostAppDuplicationsRequest| { &mut m.app_duplications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppDuplicationsRequest>(
            "PostAppDuplicationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppDuplicationsRequest {
    const NAME: &'static str = "PostAppDuplicationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.app_duplications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.app_duplications {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppDuplicationsRequest {
        PostAppDuplicationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppDuplicationsRequest {
        static instance: PostAppDuplicationsRequest = PostAppDuplicationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_duplications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppDuplicationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppDuplicationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppDuplicationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get an app duplication job.
// @@protoc_insertion_point(message:clarifai.api.GetAppDuplicationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAppDuplicationRequest {
    // message fields
    ///  The ID of the user that created the app duplication job.
    // @@protoc_insertion_point(field:clarifai.api.GetAppDuplicationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetAppDuplicationRequest.app_duplication_id)
    pub app_duplication_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAppDuplicationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAppDuplicationRequest {
    fn default() -> &'a GetAppDuplicationRequest {
        <GetAppDuplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppDuplicationRequest {
    pub fn new() -> GetAppDuplicationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAppDuplicationRequest| { &m.user_app_id },
            |m: &mut GetAppDuplicationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_duplication_id",
            |m: &GetAppDuplicationRequest| { &m.app_duplication_id },
            |m: &mut GetAppDuplicationRequest| { &mut m.app_duplication_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAppDuplicationRequest>(
            "GetAppDuplicationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAppDuplicationRequest {
    const NAME: &'static str = "GetAppDuplicationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.app_duplication_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_duplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_duplication_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_duplication_id.is_empty() {
            os.write_string(2, &self.app_duplication_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAppDuplicationRequest {
        GetAppDuplicationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplication_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAppDuplicationRequest {
        static instance: GetAppDuplicationRequest = GetAppDuplicationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_duplication_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAppDuplicationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAppDuplicationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAppDuplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppDuplicationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list all the app duplication jobs that a user created.
// @@protoc_insertion_point(message:clarifai.api.ListAppDuplicationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAppDuplicationsRequest {
    // message fields
    ///  The ID of the user whose app duplication jobs to list.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppDuplicationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppDuplicationsRequest {
    fn default() -> &'a ListAppDuplicationsRequest {
        <ListAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppDuplicationsRequest {
    pub fn new() -> ListAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppDuplicationsRequest| { &m.user_app_id },
            |m: &mut ListAppDuplicationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppDuplicationsRequest| { &m.page },
            |m: &mut ListAppDuplicationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppDuplicationsRequest| { &m.per_page },
            |m: &mut ListAppDuplicationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppDuplicationsRequest>(
            "ListAppDuplicationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppDuplicationsRequest {
    const NAME: &'static str = "ListAppDuplicationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppDuplicationsRequest {
        ListAppDuplicationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppDuplicationsRequest {
        static instance: ListAppDuplicationsRequest = ListAppDuplicationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppDuplicationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppDuplicationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppDuplicationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAppDuplicationsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAppDuplicationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAppDuplicationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAppDuplicationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAppDuplicationsResponse.app_duplications)
    pub app_duplications: ::std::vec::Vec<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAppDuplicationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAppDuplicationsResponse {
    fn default() -> &'a MultiAppDuplicationsResponse {
        <MultiAppDuplicationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppDuplicationsResponse {
    pub fn new() -> MultiAppDuplicationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAppDuplicationsResponse| { &m.status },
            |m: &mut MultiAppDuplicationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_duplications",
            |m: &MultiAppDuplicationsResponse| { &m.app_duplications },
            |m: &mut MultiAppDuplicationsResponse| { &mut m.app_duplications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAppDuplicationsResponse>(
            "MultiAppDuplicationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAppDuplicationsResponse {
    const NAME: &'static str = "MultiAppDuplicationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.app_duplications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.app_duplications {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAppDuplicationsResponse {
        MultiAppDuplicationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_duplications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAppDuplicationsResponse {
        static instance: MultiAppDuplicationsResponse = MultiAppDuplicationsResponse {
            status: ::protobuf::MessageField::none(),
            app_duplications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAppDuplicationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAppDuplicationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAppDuplicationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppDuplicationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAppDuplicationResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAppDuplicationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAppDuplicationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAppDuplicationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAppDuplicationResponse.app_duplication)
    pub app_duplication: ::protobuf::MessageField<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAppDuplicationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAppDuplicationResponse {
    fn default() -> &'a SingleAppDuplicationResponse {
        <SingleAppDuplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppDuplicationResponse {
    pub fn new() -> SingleAppDuplicationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAppDuplicationResponse| { &m.status },
            |m: &mut SingleAppDuplicationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AppDuplication>(
            "app_duplication",
            |m: &SingleAppDuplicationResponse| { &m.app_duplication },
            |m: &mut SingleAppDuplicationResponse| { &mut m.app_duplication },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAppDuplicationResponse>(
            "SingleAppDuplicationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAppDuplicationResponse {
    const NAME: &'static str = "SingleAppDuplicationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_duplication)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_duplication.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_duplication.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAppDuplicationResponse {
        SingleAppDuplicationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_duplication.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAppDuplicationResponse {
        static instance: SingleAppDuplicationResponse = SingleAppDuplicationResponse {
            status: ::protobuf::MessageField::none(),
            app_duplication: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAppDuplicationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAppDuplicationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAppDuplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppDuplicationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create Tasks.
// @@protoc_insertion_point(message:clarifai.api.PostTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostTasksRequest.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostTasksRequest {
    fn default() -> &'a PostTasksRequest {
        <PostTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTasksRequest {
    pub fn new() -> PostTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostTasksRequest| { &m.user_app_id },
            |m: &mut PostTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &PostTasksRequest| { &m.tasks },
            |m: &mut PostTasksRequest| { &mut m.tasks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostTasksRequest>(
            "PostTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostTasksRequest {
    const NAME: &'static str = "PostTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostTasksRequest {
        PostTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostTasksRequest {
        static instance: PostTasksRequest = PostTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get one task.
// @@protoc_insertion_point(message:clarifai.api.GetTaskRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTaskRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.task_id)
    pub task_id: ::std::string::String,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported: all, worker.users, review.users.
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetTaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTaskRequest {
    fn default() -> &'a GetTaskRequest {
        <GetTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskRequest {
    pub fn new() -> GetTaskRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetTaskRequest| { &m.user_app_id },
            |m: &mut GetTaskRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetTaskRequest| { &m.task_id },
            |m: &mut GetTaskRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetTaskRequest| { &m.additional_fields },
            |m: &mut GetTaskRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTaskRequest>(
            "GetTaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTaskRequest {
    const NAME: &'static str = "GetTaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTaskRequest {
        GetTaskRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTaskRequest {
        static instance: GetTaskRequest = GetTaskRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list multiple tasks.
// @@protoc_insertion_point(message:clarifai.api.ListTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.per_page)
    pub per_page: u32,
    ///  Get tasks that have ANY user from this list assigned as worker.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.worker_user_ids)
    pub worker_user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get tasks that have ANY user from this list assigned as reviewer.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.review_user_ids)
    pub review_user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get tasks that are associated to ANY label order from this list.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.label_order_ids)
    pub label_order_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get label order tasks as well
    ///  It is automatically set to true if label_order_ids is set.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.including_label_order_tasks)
    pub including_label_order_tasks: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported: all, worker.users, review.users.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTasksRequest {
    fn default() -> &'a ListTasksRequest {
        <ListTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTasksRequest {
    pub fn new() -> ListTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListTasksRequest| { &m.user_app_id },
            |m: &mut ListTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListTasksRequest| { &m.page },
            |m: &mut ListTasksRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListTasksRequest| { &m.per_page },
            |m: &mut ListTasksRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "worker_user_ids",
            |m: &ListTasksRequest| { &m.worker_user_ids },
            |m: &mut ListTasksRequest| { &mut m.worker_user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "review_user_ids",
            |m: &ListTasksRequest| { &m.review_user_ids },
            |m: &mut ListTasksRequest| { &mut m.review_user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_order_ids",
            |m: &ListTasksRequest| { &m.label_order_ids },
            |m: &mut ListTasksRequest| { &mut m.label_order_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "including_label_order_tasks",
            |m: &ListTasksRequest| { &m.including_label_order_tasks },
            |m: &mut ListTasksRequest| { &mut m.including_label_order_tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListTasksRequest| { &m.additional_fields },
            |m: &mut ListTasksRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTasksRequest>(
            "ListTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTasksRequest {
    const NAME: &'static str = "ListTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.worker_user_ids.push(is.read_string()?);
                },
                42 => {
                    self.review_user_ids.push(is.read_string()?);
                },
                66 => {
                    self.label_order_ids.push(is.read_string()?);
                },
                48 => {
                    self.including_label_order_tasks = is.read_bool()?;
                },
                58 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.worker_user_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.review_user_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.label_order_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.including_label_order_tasks != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.worker_user_ids {
            os.write_string(4, &v)?;
        };
        for v in &self.review_user_ids {
            os.write_string(5, &v)?;
        };
        for v in &self.label_order_ids {
            os.write_string(8, &v)?;
        };
        if self.including_label_order_tasks != false {
            os.write_bool(6, self.including_label_order_tasks)?;
        }
        for v in &self.additional_fields {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTasksRequest {
        ListTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.worker_user_ids.clear();
        self.review_user_ids.clear();
        self.label_order_ids.clear();
        self.including_label_order_tasks = false;
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTasksRequest {
        static instance: ListTasksRequest = ListTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            worker_user_ids: ::std::vec::Vec::new(),
            review_user_ids: ::std::vec::Vec::new(),
            label_order_ids: ::std::vec::Vec::new(),
            including_label_order_tasks: false,
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch a list of tasks.
// @@protoc_insertion_point(message:clarifai.api.PatchTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchTasksRequest {
    fn default() -> &'a PatchTasksRequest {
        <PatchTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchTasksRequest {
    pub fn new() -> PatchTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchTasksRequest| { &m.user_app_id },
            |m: &mut PatchTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &PatchTasksRequest| { &m.tasks },
            |m: &mut PatchTasksRequest| { &mut m.tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchTasksRequest| { &m.action },
            |m: &mut PatchTasksRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchTasksRequest>(
            "PatchTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchTasksRequest {
    const NAME: &'static str = "PatchTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchTasksRequest {
        PatchTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchTasksRequest {
        static instance: PatchTasksRequest = PatchTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete a list of tasks.
// @@protoc_insertion_point(message:clarifai.api.DeleteTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteTasksRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTasksRequest {
    fn default() -> &'a DeleteTasksRequest {
        <DeleteTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTasksRequest {
    pub fn new() -> DeleteTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteTasksRequest| { &m.user_app_id },
            |m: &mut DeleteTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteTasksRequest| { &m.ids },
            |m: &mut DeleteTasksRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTasksRequest>(
            "DeleteTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTasksRequest {
    const NAME: &'static str = "DeleteTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTasksRequest {
        DeleteTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTasksRequest {
        static instance: DeleteTasksRequest = DeleteTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple Tasks.
// @@protoc_insertion_point(message:clarifai.api.MultiTaskResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskResponse.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTaskResponse {
    fn default() -> &'a MultiTaskResponse {
        <MultiTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTaskResponse {
    pub fn new() -> MultiTaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTaskResponse| { &m.status },
            |m: &mut MultiTaskResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &MultiTaskResponse| { &m.tasks },
            |m: &mut MultiTaskResponse| { &mut m.tasks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTaskResponse>(
            "MultiTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTaskResponse {
    const NAME: &'static str = "MultiTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTaskResponse {
        MultiTaskResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.tasks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTaskResponse {
        static instance: MultiTaskResponse = MultiTaskResponse {
            status: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a single Task.
// @@protoc_insertion_point(message:clarifai.api.SingleTaskResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskResponse.task)
    pub task: ::protobuf::MessageField<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleTaskResponse {
    fn default() -> &'a SingleTaskResponse {
        <SingleTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskResponse {
    pub fn new() -> SingleTaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleTaskResponse| { &m.status },
            |m: &mut SingleTaskResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Task>(
            "task",
            |m: &SingleTaskResponse| { &m.task },
            |m: &mut SingleTaskResponse| { &mut m.task },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTaskResponse>(
            "SingleTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleTaskResponse {
    const NAME: &'static str = "SingleTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.task)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.task.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleTaskResponse {
        SingleTaskResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.task.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleTaskResponse {
        static instance: SingleTaskResponse = SingleTaskResponse {
            status: ::protobuf::MessageField::none(),
            task: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetTaskCountRequest can be used for fetching -
///  1. Task annotation count per user, per status
///  1. Task input (anchor annotations) count per user, per status
// @@protoc_insertion_point(message:clarifai.api.GetTaskCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTaskCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  task_id for which count per user per status is needed
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.task_id)
    pub task_id: ::std::string::String,
    ///  for given task_id, user_ids to filter on (optional)
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetTaskCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTaskCountRequest {
    fn default() -> &'a GetTaskCountRequest {
        <GetTaskCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskCountRequest {
    pub fn new() -> GetTaskCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetTaskCountRequest| { &m.user_app_id },
            |m: &mut GetTaskCountRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetTaskCountRequest| { &m.task_id },
            |m: &mut GetTaskCountRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &GetTaskCountRequest| { &m.user_ids },
            |m: &mut GetTaskCountRequest| { &mut m.user_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTaskCountRequest>(
            "GetTaskCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTaskCountRequest {
    const NAME: &'static str = "GetTaskCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTaskCountRequest {
        GetTaskCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTaskCountRequest {
        static instance: GetTaskCountRequest = GetTaskCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            user_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTaskCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTaskCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTaskCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleTaskCountResponse represent counts of annotations or inputs(anchor annotations) for labelers in given task
// @@protoc_insertion_point(message:clarifai.api.SingleTaskCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleTaskCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.app_id)
    pub app_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.task_id)
    pub task_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.counts)
    pub counts: ::std::vec::Vec<super::resources::TaskStatusCountPerUser>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleTaskCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleTaskCountResponse {
    fn default() -> &'a SingleTaskCountResponse {
        <SingleTaskCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskCountResponse {
    pub fn new() -> SingleTaskCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleTaskCountResponse| { &m.status },
            |m: &mut SingleTaskCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &SingleTaskCountResponse| { &m.app_id },
            |m: &mut SingleTaskCountResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &SingleTaskCountResponse| { &m.task_id },
            |m: &mut SingleTaskCountResponse| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "counts",
            |m: &SingleTaskCountResponse| { &m.counts },
            |m: &mut SingleTaskCountResponse| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTaskCountResponse>(
            "SingleTaskCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleTaskCountResponse {
    const NAME: &'static str = "SingleTaskCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                26 => {
                    self.task_id = is.read_string()?;
                },
                34 => {
                    self.counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.task_id);
        }
        for value in &self.counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(3, &self.task_id)?;
        }
        for v in &self.counts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleTaskCountResponse {
        SingleTaskCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_id.clear();
        self.task_id.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleTaskCountResponse {
        static instance: SingleTaskCountResponse = SingleTaskCountResponse {
            status: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            task_id: ::std::string::String::new(),
            counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleTaskCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleTaskCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleTaskCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create label orders.
// @@protoc_insertion_point(message:clarifai.api.PostLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostLabelOrdersRequest.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostLabelOrdersRequest {
    fn default() -> &'a PostLabelOrdersRequest {
        <PostLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostLabelOrdersRequest {
    pub fn new() -> PostLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostLabelOrdersRequest| { &m.user_app_id },
            |m: &mut PostLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &PostLabelOrdersRequest| { &m.label_orders },
            |m: &mut PostLabelOrdersRequest| { &mut m.label_orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostLabelOrdersRequest>(
            "PostLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostLabelOrdersRequest {
    const NAME: &'static str = "PostLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostLabelOrdersRequest {
        PostLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostLabelOrdersRequest {
        static instance: PostLabelOrdersRequest = PostLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get one label order.
// @@protoc_insertion_point(message:clarifai.api.GetLabelOrderRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetLabelOrderRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetLabelOrderRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetLabelOrderRequest.label_order_id)
    pub label_order_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetLabelOrderRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLabelOrderRequest {
    fn default() -> &'a GetLabelOrderRequest {
        <GetLabelOrderRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLabelOrderRequest {
    pub fn new() -> GetLabelOrderRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetLabelOrderRequest| { &m.user_app_id },
            |m: &mut GetLabelOrderRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label_order_id",
            |m: &GetLabelOrderRequest| { &m.label_order_id },
            |m: &mut GetLabelOrderRequest| { &mut m.label_order_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLabelOrderRequest>(
            "GetLabelOrderRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLabelOrderRequest {
    const NAME: &'static str = "GetLabelOrderRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_order_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.label_order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label_order_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.label_order_id.is_empty() {
            os.write_string(2, &self.label_order_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLabelOrderRequest {
        GetLabelOrderRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_order_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLabelOrderRequest {
        static instance: GetLabelOrderRequest = GetLabelOrderRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_order_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLabelOrderRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLabelOrderRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLabelOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLabelOrderRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list multiple label orders.
// @@protoc_insertion_point(message:clarifai.api.ListLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListLabelOrdersRequest {
    fn default() -> &'a ListLabelOrdersRequest {
        <ListLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListLabelOrdersRequest {
    pub fn new() -> ListLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListLabelOrdersRequest| { &m.user_app_id },
            |m: &mut ListLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListLabelOrdersRequest| { &m.page },
            |m: &mut ListLabelOrdersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListLabelOrdersRequest| { &m.per_page },
            |m: &mut ListLabelOrdersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListLabelOrdersRequest>(
            "ListLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListLabelOrdersRequest {
    const NAME: &'static str = "ListLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListLabelOrdersRequest {
        ListLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListLabelOrdersRequest {
        static instance: ListLabelOrdersRequest = ListLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch a list of label orders.
// @@protoc_insertion_point(message:clarifai.api.PatchLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchLabelOrdersRequest {
    fn default() -> &'a PatchLabelOrdersRequest {
        <PatchLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchLabelOrdersRequest {
    pub fn new() -> PatchLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchLabelOrdersRequest| { &m.user_app_id },
            |m: &mut PatchLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &PatchLabelOrdersRequest| { &m.label_orders },
            |m: &mut PatchLabelOrdersRequest| { &mut m.label_orders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchLabelOrdersRequest| { &m.action },
            |m: &mut PatchLabelOrdersRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchLabelOrdersRequest>(
            "PatchLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchLabelOrdersRequest {
    const NAME: &'static str = "PatchLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchLabelOrdersRequest {
        PatchLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchLabelOrdersRequest {
        static instance: PatchLabelOrdersRequest = PatchLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete a list of label orders.
// @@protoc_insertion_point(message:clarifai.api.DeleteLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteLabelOrdersRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteLabelOrdersRequest {
    fn default() -> &'a DeleteLabelOrdersRequest {
        <DeleteLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteLabelOrdersRequest {
    pub fn new() -> DeleteLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteLabelOrdersRequest| { &m.user_app_id },
            |m: &mut DeleteLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteLabelOrdersRequest| { &m.ids },
            |m: &mut DeleteLabelOrdersRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteLabelOrdersRequest>(
            "DeleteLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteLabelOrdersRequest {
    const NAME: &'static str = "DeleteLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteLabelOrdersRequest {
        DeleteLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteLabelOrdersRequest {
        static instance: DeleteLabelOrdersRequest = DeleteLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple label order.
// @@protoc_insertion_point(message:clarifai.api.MultiLabelOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiLabelOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiLabelOrderResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiLabelOrderResponse.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiLabelOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiLabelOrderResponse {
    fn default() -> &'a MultiLabelOrderResponse {
        <MultiLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiLabelOrderResponse {
    pub fn new() -> MultiLabelOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiLabelOrderResponse| { &m.status },
            |m: &mut MultiLabelOrderResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &MultiLabelOrderResponse| { &m.label_orders },
            |m: &mut MultiLabelOrderResponse| { &mut m.label_orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiLabelOrderResponse>(
            "MultiLabelOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiLabelOrderResponse {
    const NAME: &'static str = "MultiLabelOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiLabelOrderResponse {
        MultiLabelOrderResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.label_orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiLabelOrderResponse {
        static instance: MultiLabelOrderResponse = MultiLabelOrderResponse {
            status: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiLabelOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiLabelOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiLabelOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a label order.
// @@protoc_insertion_point(message:clarifai.api.SingleLabelOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleLabelOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleLabelOrderResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleLabelOrderResponse.label_order)
    pub label_order: ::protobuf::MessageField<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleLabelOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleLabelOrderResponse {
    fn default() -> &'a SingleLabelOrderResponse {
        <SingleLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleLabelOrderResponse {
    pub fn new() -> SingleLabelOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleLabelOrderResponse| { &m.status },
            |m: &mut SingleLabelOrderResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::LabelOrder>(
            "label_order",
            |m: &SingleLabelOrderResponse| { &m.label_order },
            |m: &mut SingleLabelOrderResponse| { &mut m.label_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleLabelOrderResponse>(
            "SingleLabelOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleLabelOrderResponse {
    const NAME: &'static str = "SingleLabelOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.label_order)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.label_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.label_order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleLabelOrderResponse {
        SingleLabelOrderResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.label_order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleLabelOrderResponse {
        static instance: SingleLabelOrderResponse = SingleLabelOrderResponse {
            status: ::protobuf::MessageField::none(),
            label_order: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleLabelOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleLabelOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleLabelOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create Collectors.
// @@protoc_insertion_point(message:clarifai.api.PostCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostCollectorsRequest.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCollectorsRequest {
    fn default() -> &'a PostCollectorsRequest {
        <PostCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollectorsRequest {
    pub fn new() -> PostCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostCollectorsRequest| { &m.user_app_id },
            |m: &mut PostCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &PostCollectorsRequest| { &m.collectors },
            |m: &mut PostCollectorsRequest| { &mut m.collectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCollectorsRequest>(
            "PostCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCollectorsRequest {
    const NAME: &'static str = "PostCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCollectorsRequest {
        PostCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCollectorsRequest {
        static instance: PostCollectorsRequest = PostCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchCollectorsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchCollectorsRequest {
    fn default() -> &'a PatchCollectorsRequest {
        <PatchCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollectorsRequest {
    pub fn new() -> PatchCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchCollectorsRequest| { &m.user_app_id },
            |m: &mut PatchCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &PatchCollectorsRequest| { &m.collectors },
            |m: &mut PatchCollectorsRequest| { &mut m.collectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchCollectorsRequest| { &m.action },
            |m: &mut PatchCollectorsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchCollectorsRequest>(
            "PatchCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchCollectorsRequest {
    const NAME: &'static str = "PatchCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchCollectorsRequest {
        PatchCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchCollectorsRequest {
        static instance: PatchCollectorsRequest = PatchCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollectorsRequest {
    fn default() -> &'a DeleteCollectorsRequest {
        <DeleteCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectorsRequest {
    pub fn new() -> DeleteCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteCollectorsRequest| { &m.user_app_id },
            |m: &mut DeleteCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteCollectorsRequest| { &m.ids },
            |m: &mut DeleteCollectorsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteCollectorsRequest| { &m.delete_all },
            |m: &mut DeleteCollectorsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollectorsRequest>(
            "DeleteCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollectorsRequest {
    const NAME: &'static str = "DeleteCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollectorsRequest {
        DeleteCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollectorsRequest {
        static instance: DeleteCollectorsRequest = DeleteCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to GET a single Collector.
// @@protoc_insertion_point(message:clarifai.api.GetCollectorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCollectorRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetCollectorRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetCollectorRequest.collector_id)
    pub collector_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetCollectorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCollectorRequest {
    fn default() -> &'a GetCollectorRequest {
        <GetCollectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCollectorRequest {
    pub fn new() -> GetCollectorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetCollectorRequest| { &m.user_app_id },
            |m: &mut GetCollectorRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collector_id",
            |m: &GetCollectorRequest| { &m.collector_id },
            |m: &mut GetCollectorRequest| { &mut m.collector_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCollectorRequest>(
            "GetCollectorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCollectorRequest {
    const NAME: &'static str = "GetCollectorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collector_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.collector_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collector_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.collector_id.is_empty() {
            os.write_string(2, &self.collector_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCollectorRequest {
        GetCollectorRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collector_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCollectorRequest {
        static instance: GetCollectorRequest = GetCollectorRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collector_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCollectorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCollectorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCollectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCollectorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to GET all the Collectors.
// @@protoc_insertion_point(message:clarifai.api.ListCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollectorsRequest {
    fn default() -> &'a ListCollectorsRequest {
        <ListCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollectorsRequest {
    pub fn new() -> ListCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollectorsRequest| { &m.user_app_id },
            |m: &mut ListCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollectorsRequest| { &m.page },
            |m: &mut ListCollectorsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollectorsRequest| { &m.per_page },
            |m: &mut ListCollectorsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollectorsRequest>(
            "ListCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollectorsRequest {
    const NAME: &'static str = "ListCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollectorsRequest {
        ListCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollectorsRequest {
        static instance: ListCollectorsRequest = ListCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple Collectors.
// @@protoc_insertion_point(message:clarifai.api.MultiCollectorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiCollectorResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollectorResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollectorResponse.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollectorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollectorResponse {
    fn default() -> &'a MultiCollectorResponse {
        <MultiCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollectorResponse {
    pub fn new() -> MultiCollectorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollectorResponse| { &m.status },
            |m: &mut MultiCollectorResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &MultiCollectorResponse| { &m.collectors },
            |m: &mut MultiCollectorResponse| { &mut m.collectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollectorResponse>(
            "MultiCollectorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollectorResponse {
    const NAME: &'static str = "MultiCollectorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollectorResponse {
        MultiCollectorResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollectorResponse {
        static instance: MultiCollectorResponse = MultiCollectorResponse {
            status: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollectorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollectorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollectorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a single Collector.
// @@protoc_insertion_point(message:clarifai.api.SingleCollectorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleCollectorResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleCollectorResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleCollectorResponse.collector)
    pub collector: ::protobuf::MessageField<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleCollectorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleCollectorResponse {
    fn default() -> &'a SingleCollectorResponse {
        <SingleCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleCollectorResponse {
    pub fn new() -> SingleCollectorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleCollectorResponse| { &m.status },
            |m: &mut SingleCollectorResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Collector>(
            "collector",
            |m: &SingleCollectorResponse| { &m.collector },
            |m: &mut SingleCollectorResponse| { &mut m.collector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleCollectorResponse>(
            "SingleCollectorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleCollectorResponse {
    const NAME: &'static str = "SingleCollectorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.collector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.collector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.collector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleCollectorResponse {
        SingleCollectorResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleCollectorResponse {
        static instance: SingleCollectorResponse = SingleCollectorResponse {
            status: ::protobuf::MessageField::none(),
            collector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleCollectorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleCollectorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleCollectorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostStatValuesRequest
// @@protoc_insertion_point(message:clarifai.api.PostStatValuesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostStatValuesRequest {
    // message fields
    ///  The user and app information for the request.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The stats to post, can post more than one at a time.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesRequest.stat_values)
    pub stat_values: ::std::vec::Vec<super::resources::StatValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostStatValuesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostStatValuesRequest {
    fn default() -> &'a PostStatValuesRequest {
        <PostStatValuesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesRequest {
    pub fn new() -> PostStatValuesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostStatValuesRequest| { &m.user_app_id },
            |m: &mut PostStatValuesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_values",
            |m: &PostStatValuesRequest| { &m.stat_values },
            |m: &mut PostStatValuesRequest| { &mut m.stat_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostStatValuesRequest>(
            "PostStatValuesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostStatValuesRequest {
    const NAME: &'static str = "PostStatValuesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.stat_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostStatValuesRequest {
        PostStatValuesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostStatValuesRequest {
        static instance: PostStatValuesRequest = PostStatValuesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            stat_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostStatValuesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostStatValuesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostStatValuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatValueResponse
// @@protoc_insertion_point(message:clarifai.api.MultiStatValueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiStatValueResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned stats values.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueResponse.stat_values)
    pub stat_values: ::std::vec::Vec<super::resources::StatValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatValueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatValueResponse {
    fn default() -> &'a MultiStatValueResponse {
        <MultiStatValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueResponse {
    pub fn new() -> MultiStatValueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatValueResponse| { &m.status },
            |m: &mut MultiStatValueResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_values",
            |m: &MultiStatValueResponse| { &m.stat_values },
            |m: &mut MultiStatValueResponse| { &mut m.stat_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatValueResponse>(
            "MultiStatValueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatValueResponse {
    const NAME: &'static str = "MultiStatValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.stat_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatValueResponse {
        MultiStatValueResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.stat_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatValueResponse {
        static instance: MultiStatValueResponse = MultiStatValueResponse {
            status: ::protobuf::MessageField::none(),
            stat_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatValueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatValueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostStatValuesAggregateRequest
// @@protoc_insertion_point(message:clarifai.api.PostStatValuesAggregateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostStatValuesAggregateRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesAggregateRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Query to retrieve aggregate values.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesAggregateRequest.stat_value_aggregate_queries)
    pub stat_value_aggregate_queries: ::std::vec::Vec<super::resources::StatValueAggregateQuery>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostStatValuesAggregateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostStatValuesAggregateRequest {
    fn default() -> &'a PostStatValuesAggregateRequest {
        <PostStatValuesAggregateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesAggregateRequest {
    pub fn new() -> PostStatValuesAggregateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostStatValuesAggregateRequest| { &m.user_app_id },
            |m: &mut PostStatValuesAggregateRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregate_queries",
            |m: &PostStatValuesAggregateRequest| { &m.stat_value_aggregate_queries },
            |m: &mut PostStatValuesAggregateRequest| { &mut m.stat_value_aggregate_queries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostStatValuesAggregateRequest>(
            "PostStatValuesAggregateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostStatValuesAggregateRequest {
    const NAME: &'static str = "PostStatValuesAggregateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.stat_value_aggregate_queries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_value_aggregate_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_value_aggregate_queries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostStatValuesAggregateRequest {
        PostStatValuesAggregateRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_value_aggregate_queries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostStatValuesAggregateRequest {
        static instance: PostStatValuesAggregateRequest = PostStatValuesAggregateRequest {
            user_app_id: ::protobuf::MessageField::none(),
            stat_value_aggregate_queries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostStatValuesAggregateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostStatValuesAggregateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostStatValuesAggregateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesAggregateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatValueAggregateResponse
// @@protoc_insertion_point(message:clarifai.api.MultiStatValueAggregateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiStatValueAggregateResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueAggregateResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The aggregate results for each query passedin.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueAggregateResponse.stat_value_aggregate_results)
    pub stat_value_aggregate_results: ::std::vec::Vec<super::resources::StatValueAggregateResult>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatValueAggregateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatValueAggregateResponse {
    fn default() -> &'a MultiStatValueAggregateResponse {
        <MultiStatValueAggregateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueAggregateResponse {
    pub fn new() -> MultiStatValueAggregateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatValueAggregateResponse| { &m.status },
            |m: &mut MultiStatValueAggregateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregate_results",
            |m: &MultiStatValueAggregateResponse| { &m.stat_value_aggregate_results },
            |m: &mut MultiStatValueAggregateResponse| { &mut m.stat_value_aggregate_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatValueAggregateResponse>(
            "MultiStatValueAggregateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatValueAggregateResponse {
    const NAME: &'static str = "MultiStatValueAggregateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.stat_value_aggregate_results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_value_aggregate_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_value_aggregate_results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatValueAggregateResponse {
        MultiStatValueAggregateResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.stat_value_aggregate_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatValueAggregateResponse {
        static instance: MultiStatValueAggregateResponse = MultiStatValueAggregateResponse {
            status: ::protobuf::MessageField::none(),
            stat_value_aggregate_results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatValueAggregateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatValueAggregateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatValueAggregateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueAggregateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostTrendingMetricsViewRequest
// @@protoc_insertion_point(message:clarifai.api.PostTrendingMetricsViewRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostTrendingMetricsViewRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  For now view types 'apps', 'workflows', and 'models' are supported.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.view_type)
    pub view_type: ::std::string::String,
    ///  ID of the views object.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.object_id)
    pub object_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostTrendingMetricsViewRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostTrendingMetricsViewRequest {
    fn default() -> &'a PostTrendingMetricsViewRequest {
        <PostTrendingMetricsViewRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTrendingMetricsViewRequest {
    pub fn new() -> PostTrendingMetricsViewRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostTrendingMetricsViewRequest| { &m.user_app_id },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_type",
            |m: &PostTrendingMetricsViewRequest| { &m.view_type },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.view_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &PostTrendingMetricsViewRequest| { &m.object_id },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.object_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostTrendingMetricsViewRequest>(
            "PostTrendingMetricsViewRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostTrendingMetricsViewRequest {
    const NAME: &'static str = "PostTrendingMetricsViewRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.view_type = is.read_string()?;
                },
                26 => {
                    self.object_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if !self.object_id.is_empty() {
            os.write_string(3, &self.object_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostTrendingMetricsViewRequest {
        PostTrendingMetricsViewRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.object_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostTrendingMetricsViewRequest {
        static instance: PostTrendingMetricsViewRequest = PostTrendingMetricsViewRequest {
            user_app_id: ::protobuf::MessageField::none(),
            view_type: ::std::string::String::new(),
            object_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostTrendingMetricsViewRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostTrendingMetricsViewRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostTrendingMetricsViewRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTrendingMetricsViewRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListTrendingMetricsViewsRequest
// @@protoc_insertion_point(message:clarifai.api.ListTrendingMetricsViewsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTrendingMetricsViewsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  For now view types 'apps', 'workflows', and 'models' are supported.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.view_type)
    pub view_type: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListTrendingMetricsViewsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTrendingMetricsViewsRequest {
    fn default() -> &'a ListTrendingMetricsViewsRequest {
        <ListTrendingMetricsViewsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTrendingMetricsViewsRequest {
    pub fn new() -> ListTrendingMetricsViewsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListTrendingMetricsViewsRequest| { &m.user_app_id },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_type",
            |m: &ListTrendingMetricsViewsRequest| { &m.view_type },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.view_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListTrendingMetricsViewsRequest| { &m.page },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListTrendingMetricsViewsRequest| { &m.per_page },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTrendingMetricsViewsRequest>(
            "ListTrendingMetricsViewsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTrendingMetricsViewsRequest {
    const NAME: &'static str = "ListTrendingMetricsViewsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.view_type = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTrendingMetricsViewsRequest {
        ListTrendingMetricsViewsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTrendingMetricsViewsRequest {
        static instance: ListTrendingMetricsViewsRequest = ListTrendingMetricsViewsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            view_type: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTrendingMetricsViewsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTrendingMetricsViewsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTrendingMetricsViewsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTrendingMetricsViewsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiTrendingMetricsViewResponse
// @@protoc_insertion_point(message:clarifai.api.MultiTrendingMetricsViewResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTrendingMetricsViewResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTrendingMetricsViewResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTrendingMetricsViewResponse.metrics)
    pub metrics: ::std::vec::Vec<super::resources::TrendingMetric>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTrendingMetricsViewResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTrendingMetricsViewResponse {
    fn default() -> &'a MultiTrendingMetricsViewResponse {
        <MultiTrendingMetricsViewResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTrendingMetricsViewResponse {
    pub fn new() -> MultiTrendingMetricsViewResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTrendingMetricsViewResponse| { &m.status },
            |m: &mut MultiTrendingMetricsViewResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &MultiTrendingMetricsViewResponse| { &m.metrics },
            |m: &mut MultiTrendingMetricsViewResponse| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTrendingMetricsViewResponse>(
            "MultiTrendingMetricsViewResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTrendingMetricsViewResponse {
    const NAME: &'static str = "MultiTrendingMetricsViewResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTrendingMetricsViewResponse {
        MultiTrendingMetricsViewResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTrendingMetricsViewResponse {
        static instance: MultiTrendingMetricsViewResponse = MultiTrendingMetricsViewResponse {
            status: ::protobuf::MessageField::none(),
            metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTrendingMetricsViewResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTrendingMetricsViewResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTrendingMetricsViewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTrendingMetricsViewResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModuleRequest
// @@protoc_insertion_point(message:clarifai.api.GetModuleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleRequest {
    fn default() -> &'a GetModuleRequest {
        <GetModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleRequest {
    pub fn new() -> GetModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleRequest| { &m.user_app_id },
            |m: &mut GetModuleRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleRequest| { &m.module_id },
            |m: &mut GetModuleRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetModuleRequest| { &m.additional_fields },
            |m: &mut GetModuleRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleRequest>(
            "GetModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleRequest {
    const NAME: &'static str = "GetModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleRequest {
        GetModuleRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleRequest {
        static instance: GetModuleRequest = GetModuleRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModulesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.starred_only)
    pub starred_only: bool,
    ///  Filter modules by bookmark. If set, only return bookmarked modules. Otherwise none bookmarked modules only.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the module:
    ///    - id
    ///    - description
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.search)
    pub search: ::std::string::String,
    ///  Filter by the id and description of the module. This supports wildcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.name)
    pub name: ::std::string::String,
    ///  Filter by the application owner whose this module belongs to
    ///  Deprecated: use search instead of name.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.filter_by_user_id)
    pub filter_by_user_id: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_modules_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesRequest {
    fn default() -> &'a ListModulesRequest {
        <ListModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesRequest {
    pub fn new() -> ListModulesRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_created_at = 7;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 8;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(v))
    }

    // bool sort_by_modified_at = 9;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_id = 11;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortById(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModulesRequest| { &m.user_app_id },
            |m: &mut ListModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModulesRequest| { &m.page },
            |m: &mut ListModulesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModulesRequest| { &m.per_page },
            |m: &mut ListModulesRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListModulesRequest| { &m.additional_fields },
            |m: &mut ListModulesRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModulesRequest| { &m.sort_ascending },
            |m: &mut ListModulesRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModulesRequest::has_sort_by_created_at,
            ListModulesRequest::sort_by_created_at,
            ListModulesRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListModulesRequest::has_sort_by_star_count,
            ListModulesRequest::sort_by_star_count,
            ListModulesRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListModulesRequest::has_sort_by_modified_at,
            ListModulesRequest::sort_by_modified_at,
            ListModulesRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListModulesRequest::has_sort_by_id,
            ListModulesRequest::sort_by_id,
            ListModulesRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListModulesRequest| { &m.starred_only },
            |m: &mut ListModulesRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListModulesRequest| { &m.bookmark },
            |m: &mut ListModulesRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListModulesRequest| { &m.search },
            |m: &mut ListModulesRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListModulesRequest| { &m.name },
            |m: &mut ListModulesRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter_by_user_id",
            |m: &ListModulesRequest| { &m.filter_by_user_id },
            |m: &mut ListModulesRequest| { &mut m.filter_by_user_id },
        ));
        oneofs.push(list_modules_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesRequest>(
            "ListModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesRequest {
    const NAME: &'static str = "ListModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.additional_fields.push(is.read_string()?);
                },
                48 => {
                    self.sort_ascending = is.read_bool()?;
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortById(is.read_bool()?));
                },
                32 => {
                    self.starred_only = is.read_bool()?;
                },
                80 => {
                    self.bookmark = is.read_bool()?;
                },
                114 => {
                    self.search = is.read_string()?;
                },
                98 => {
                    self.name = is.read_string()?;
                },
                104 => {
                    self.filter_by_user_id = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.search);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.name);
        }
        if self.filter_by_user_id != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_modules_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(5, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(6, self.sort_ascending)?;
        }
        if self.starred_only != false {
            os.write_bool(4, self.starred_only)?;
        }
        if self.bookmark != false {
            os.write_bool(10, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(14, &self.search)?;
        }
        if !self.name.is_empty() {
            os.write_string(12, &self.name)?;
        }
        if self.filter_by_user_id != false {
            os.write_bool(13, self.filter_by_user_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_modules_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_modules_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(8, v)?;
                },
                &list_modules_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(9, v)?;
                },
                &list_modules_request::Sort_by::SortById(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesRequest {
        ListModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.starred_only = false;
        self.bookmark = false;
        self.search.clear();
        self.name.clear();
        self.filter_by_user_id = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesRequest {
        static instance: ListModulesRequest = ListModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            starred_only: false,
            bookmark: false,
            search: ::std::string::String::new(),
            name: ::std::string::String::new(),
            filter_by_user_id: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModulesRequest`
pub mod list_modules_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModulesRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_star_count)
        SortByStarCount(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_id)
        SortById(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModulesRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostModulesRequest
// @@protoc_insertion_point(message:clarifai.api.PostModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModulesRequest.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModulesRequest {
    fn default() -> &'a PostModulesRequest {
        <PostModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModulesRequest {
    pub fn new() -> PostModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModulesRequest| { &m.user_app_id },
            |m: &mut PostModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &PostModulesRequest| { &m.modules },
            |m: &mut PostModulesRequest| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModulesRequest>(
            "PostModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModulesRequest {
    const NAME: &'static str = "PostModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModulesRequest {
        PostModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModulesRequest {
        static instance: PostModulesRequest = PostModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModulesRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    ///  The action to perform on the patched objects
    ///  Supported values: 'overwrite' and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the module image by setting
    ///  'image.url' in the request to the current value returned for that module.
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModulesRequest {
    fn default() -> &'a PatchModulesRequest {
        <PatchModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModulesRequest {
    pub fn new() -> PatchModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModulesRequest| { &m.user_app_id },
            |m: &mut PatchModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &PatchModulesRequest| { &m.modules },
            |m: &mut PatchModulesRequest| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModulesRequest| { &m.action },
            |m: &mut PatchModulesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModulesRequest>(
            "PatchModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModulesRequest {
    const NAME: &'static str = "PatchModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.modules.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModulesRequest {
        PatchModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.modules.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModulesRequest {
        static instance: PatchModulesRequest = PatchModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModulesRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesRequest {
    fn default() -> &'a DeleteModulesRequest {
        <DeleteModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesRequest {
    pub fn new() -> DeleteModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModulesRequest| { &m.user_app_id },
            |m: &mut DeleteModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModulesRequest| { &m.ids },
            |m: &mut DeleteModulesRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesRequest>(
            "DeleteModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesRequest {
    const NAME: &'static str = "DeleteModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesRequest {
        DeleteModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesRequest {
        static instance: DeleteModulesRequest = DeleteModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModuleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleResponse.module)
    pub module: ::protobuf::MessageField<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleResponse {
    fn default() -> &'a SingleModuleResponse {
        <SingleModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleResponse {
    pub fn new() -> SingleModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleResponse| { &m.status },
            |m: &mut SingleModuleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Module>(
            "module",
            |m: &SingleModuleResponse| { &m.module },
            |m: &mut SingleModuleResponse| { &mut m.module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleResponse>(
            "SingleModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleResponse {
    const NAME: &'static str = "SingleModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleResponse {
        SingleModuleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleResponse {
        static instance: SingleModuleResponse = SingleModuleResponse {
            status: ::protobuf::MessageField::none(),
            module: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModuleResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModuleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleResponse.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModuleResponse {
    fn default() -> &'a MultiModuleResponse {
        <MultiModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModuleResponse {
    pub fn new() -> MultiModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModuleResponse| { &m.status },
            |m: &mut MultiModuleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &MultiModuleResponse| { &m.modules },
            |m: &mut MultiModuleResponse| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModuleResponse>(
            "MultiModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModuleResponse {
    const NAME: &'static str = "MultiModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModuleResponse {
        MultiModuleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModuleResponse {
        static instance: MultiModuleResponse = MultiModuleResponse {
            status: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  request for different endpoints currently.
// @@protoc_insertion_point(message:clarifai.api.GetModuleVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModuleVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.module_version_id)
    pub module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleVersionRequest {
    fn default() -> &'a GetModuleVersionRequest {
        <GetModuleVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleVersionRequest {
    pub fn new() -> GetModuleVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleVersionRequest| { &m.user_app_id },
            |m: &mut GetModuleVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleVersionRequest| { &m.module_id },
            |m: &mut GetModuleVersionRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_version_id",
            |m: &GetModuleVersionRequest| { &m.module_version_id },
            |m: &mut GetModuleVersionRequest| { &mut m.module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleVersionRequest>(
            "GetModuleVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleVersionRequest {
    const NAME: &'static str = "GetModuleVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if !self.module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if !self.module_version_id.is_empty() {
            os.write_string(3, &self.module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleVersionRequest {
        GetModuleVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleVersionRequest {
        static instance: GetModuleVersionRequest = GetModuleVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModuleVersionsRequest {
    fn default() -> &'a ListModuleVersionsRequest {
        <ListModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModuleVersionsRequest {
    pub fn new() -> ListModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModuleVersionsRequest| { &m.user_app_id },
            |m: &mut ListModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &ListModuleVersionsRequest| { &m.module_id },
            |m: &mut ListModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModuleVersionsRequest| { &m.page },
            |m: &mut ListModuleVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModuleVersionsRequest| { &m.per_page },
            |m: &mut ListModuleVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModuleVersionsRequest>(
            "ListModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModuleVersionsRequest {
    const NAME: &'static str = "ListModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModuleVersionsRequest {
        ListModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModuleVersionsRequest {
        static instance: ListModuleVersionsRequest = ListModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PostModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModuleVersionsRequest {
    fn default() -> &'a PostModuleVersionsRequest {
        <PostModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModuleVersionsRequest {
    pub fn new() -> PostModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PostModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &PostModuleVersionsRequest| { &m.module_id },
            |m: &mut PostModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &PostModuleVersionsRequest| { &m.module_versions },
            |m: &mut PostModuleVersionsRequest| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModuleVersionsRequest>(
            "PostModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModuleVersionsRequest {
    const NAME: &'static str = "PostModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModuleVersionsRequest {
        PostModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModuleVersionsRequest {
        static instance: PostModuleVersionsRequest = PostModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several module versions by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModuleVersionsRequest {
    fn default() -> &'a DeleteModuleVersionsRequest {
        <DeleteModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModuleVersionsRequest {
    pub fn new() -> DeleteModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModuleVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &DeleteModuleVersionsRequest| { &m.module_id },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModuleVersionsRequest| { &m.ids },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModuleVersionsRequest>(
            "DeleteModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModuleVersionsRequest {
    const NAME: &'static str = "DeleteModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModuleVersionsRequest {
        DeleteModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModuleVersionsRequest {
        static instance: DeleteModuleVersionsRequest = DeleteModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get the number of installations (by all users) for the module version 
// @@protoc_insertion_point(message:clarifai.api.GetModuleVersionUsageCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModuleVersionUsageCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionUsageCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionUsageCountRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionUsageCountRequest.module_version_id)
    pub module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleVersionUsageCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleVersionUsageCountRequest {
    fn default() -> &'a GetModuleVersionUsageCountRequest {
        <GetModuleVersionUsageCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleVersionUsageCountRequest {
    pub fn new() -> GetModuleVersionUsageCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleVersionUsageCountRequest| { &m.user_app_id },
            |m: &mut GetModuleVersionUsageCountRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleVersionUsageCountRequest| { &m.module_id },
            |m: &mut GetModuleVersionUsageCountRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_version_id",
            |m: &GetModuleVersionUsageCountRequest| { &m.module_version_id },
            |m: &mut GetModuleVersionUsageCountRequest| { &mut m.module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleVersionUsageCountRequest>(
            "GetModuleVersionUsageCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleVersionUsageCountRequest {
    const NAME: &'static str = "GetModuleVersionUsageCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if !self.module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if !self.module_version_id.is_empty() {
            os.write_string(3, &self.module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleVersionUsageCountRequest {
        GetModuleVersionUsageCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleVersionUsageCountRequest {
        static instance: GetModuleVersionUsageCountRequest = GetModuleVersionUsageCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleVersionUsageCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleVersionUsageCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleVersionUsageCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleVersionUsageCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionResponse.module_version)
    pub module_version: ::protobuf::MessageField<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleVersionResponse {
    fn default() -> &'a SingleModuleVersionResponse {
        <SingleModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleVersionResponse {
    pub fn new() -> SingleModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleVersionResponse| { &m.status },
            |m: &mut SingleModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModuleVersion>(
            "module_version",
            |m: &SingleModuleVersionResponse| { &m.module_version },
            |m: &mut SingleModuleVersionResponse| { &mut m.module_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleVersionResponse>(
            "SingleModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleVersionResponse {
    const NAME: &'static str = "SingleModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleVersionResponse {
        SingleModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleVersionResponse {
        static instance: SingleModuleVersionResponse = SingleModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            module_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleVersionResponse.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModuleVersionResponse {
    fn default() -> &'a MultiModuleVersionResponse {
        <MultiModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModuleVersionResponse {
    pub fn new() -> MultiModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModuleVersionResponse| { &m.status },
            |m: &mut MultiModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &MultiModuleVersionResponse| { &m.module_versions },
            |m: &mut MultiModuleVersionResponse| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModuleVersionResponse>(
            "MultiModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModuleVersionResponse {
    const NAME: &'static str = "MultiModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModuleVersionResponse {
        MultiModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModuleVersionResponse {
        static instance: MultiModuleVersionResponse = MultiModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleVersionUsageCountResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModuleVersionUsageCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModuleVersionUsageCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionUsageCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionUsageCountResponse.usage_count)
    pub usage_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleVersionUsageCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleVersionUsageCountResponse {
    fn default() -> &'a SingleModuleVersionUsageCountResponse {
        <SingleModuleVersionUsageCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleVersionUsageCountResponse {
    pub fn new() -> SingleModuleVersionUsageCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleVersionUsageCountResponse| { &m.status },
            |m: &mut SingleModuleVersionUsageCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage_count",
            |m: &SingleModuleVersionUsageCountResponse| { &m.usage_count },
            |m: &mut SingleModuleVersionUsageCountResponse| { &mut m.usage_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleVersionUsageCountResponse>(
            "SingleModuleVersionUsageCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleVersionUsageCountResponse {
    const NAME: &'static str = "SingleModuleVersionUsageCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                16 => {
                    self.usage_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.usage_count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.usage_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.usage_count != 0 {
            os.write_uint32(2, self.usage_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleVersionUsageCountResponse {
        SingleModuleVersionUsageCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.usage_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleVersionUsageCountResponse {
        static instance: SingleModuleVersionUsageCountResponse = SingleModuleVersionUsageCountResponse {
            status: ::protobuf::MessageField::none(),
            usage_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleVersionUsageCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleVersionUsageCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleVersionUsageCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleVersionUsageCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInstalledModuleVersionRequest
// @@protoc_insertion_point(message:clarifai.api.GetInstalledModuleVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInstalledModuleVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInstalledModuleVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the ID to get of the install module version.
    // @@protoc_insertion_point(field:clarifai.api.GetInstalledModuleVersionRequest.installed_module_version_id)
    pub installed_module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInstalledModuleVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInstalledModuleVersionRequest {
    fn default() -> &'a GetInstalledModuleVersionRequest {
        <GetInstalledModuleVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInstalledModuleVersionRequest {
    pub fn new() -> GetInstalledModuleVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInstalledModuleVersionRequest| { &m.user_app_id },
            |m: &mut GetInstalledModuleVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installed_module_version_id",
            |m: &GetInstalledModuleVersionRequest| { &m.installed_module_version_id },
            |m: &mut GetInstalledModuleVersionRequest| { &mut m.installed_module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInstalledModuleVersionRequest>(
            "GetInstalledModuleVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInstalledModuleVersionRequest {
    const NAME: &'static str = "GetInstalledModuleVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.installed_module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.installed_module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.installed_module_version_id.is_empty() {
            os.write_string(2, &self.installed_module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInstalledModuleVersionRequest {
        GetInstalledModuleVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInstalledModuleVersionRequest {
        static instance: GetInstalledModuleVersionRequest = GetInstalledModuleVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInstalledModuleVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInstalledModuleVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInstalledModuleVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInstalledModuleVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListInstalledModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListInstalledModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInstalledModuleVersionsRequest {
    fn default() -> &'a ListInstalledModuleVersionsRequest {
        <ListInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInstalledModuleVersionsRequest {
    pub fn new() -> ListInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInstalledModuleVersionsRequest| { &m.page },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInstalledModuleVersionsRequest| { &m.per_page },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInstalledModuleVersionsRequest>(
            "ListInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInstalledModuleVersionsRequest {
    const NAME: &'static str = "ListInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInstalledModuleVersionsRequest {
        ListInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInstalledModuleVersionsRequest {
        static instance: ListInstalledModuleVersionsRequest = ListInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInstalledModuleVersionsRequest to install a module version into the app in the URL
// @@protoc_insertion_point(message:clarifai.api.PostInstalledModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsRequest.installed_module_versions)
    pub installed_module_versions: ::std::vec::Vec<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInstalledModuleVersionsRequest {
    fn default() -> &'a PostInstalledModuleVersionsRequest {
        <PostInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInstalledModuleVersionsRequest {
    pub fn new() -> PostInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PostInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_module_versions",
            |m: &PostInstalledModuleVersionsRequest| { &m.installed_module_versions },
            |m: &mut PostInstalledModuleVersionsRequest| { &mut m.installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInstalledModuleVersionsRequest>(
            "PostInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInstalledModuleVersionsRequest {
    const NAME: &'static str = "PostInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.installed_module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.installed_module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInstalledModuleVersionsRequest {
        PostInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInstalledModuleVersionsRequest {
        static instance: PostInstalledModuleVersionsRequest = PostInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
///  version.
// @@protoc_insertion_point(message:clarifai.api.PostInstalledModuleVersionsKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInstalledModuleVersionsKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the ID to get of the install module version.
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsKeyRequest.installed_module_version_id)
    pub installed_module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInstalledModuleVersionsKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInstalledModuleVersionsKeyRequest {
    fn default() -> &'a PostInstalledModuleVersionsKeyRequest {
        <PostInstalledModuleVersionsKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInstalledModuleVersionsKeyRequest {
    pub fn new() -> PostInstalledModuleVersionsKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInstalledModuleVersionsKeyRequest| { &m.user_app_id },
            |m: &mut PostInstalledModuleVersionsKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installed_module_version_id",
            |m: &PostInstalledModuleVersionsKeyRequest| { &m.installed_module_version_id },
            |m: &mut PostInstalledModuleVersionsKeyRequest| { &mut m.installed_module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInstalledModuleVersionsKeyRequest>(
            "PostInstalledModuleVersionsKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInstalledModuleVersionsKeyRequest {
    const NAME: &'static str = "PostInstalledModuleVersionsKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.installed_module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.installed_module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.installed_module_version_id.is_empty() {
            os.write_string(2, &self.installed_module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInstalledModuleVersionsKeyRequest {
        PostInstalledModuleVersionsKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInstalledModuleVersionsKeyRequest {
        static instance: PostInstalledModuleVersionsKeyRequest = PostInstalledModuleVersionsKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInstalledModuleVersionsKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInstalledModuleVersionsKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInstalledModuleVersionsKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInstalledModuleVersionsKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several installed module versions by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteInstalledModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInstalledModuleVersionsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInstalledModuleVersionsRequest {
    fn default() -> &'a DeleteInstalledModuleVersionsRequest {
        <DeleteInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInstalledModuleVersionsRequest {
    pub fn new() -> DeleteInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteInstalledModuleVersionsRequest| { &m.ids },
            |m: &mut DeleteInstalledModuleVersionsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInstalledModuleVersionsRequest>(
            "DeleteInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInstalledModuleVersionsRequest {
    const NAME: &'static str = "DeleteInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInstalledModuleVersionsRequest {
        DeleteInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInstalledModuleVersionsRequest {
        static instance: DeleteInstalledModuleVersionsRequest = DeleteInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInstalledModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInstalledModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInstalledModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInstalledModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInstalledModuleVersionResponse.installed_module_version)
    pub installed_module_version: ::protobuf::MessageField<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInstalledModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInstalledModuleVersionResponse {
    fn default() -> &'a SingleInstalledModuleVersionResponse {
        <SingleInstalledModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInstalledModuleVersionResponse {
    pub fn new() -> SingleInstalledModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInstalledModuleVersionResponse| { &m.status },
            |m: &mut SingleInstalledModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InstalledModuleVersion>(
            "installed_module_version",
            |m: &SingleInstalledModuleVersionResponse| { &m.installed_module_version },
            |m: &mut SingleInstalledModuleVersionResponse| { &mut m.installed_module_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInstalledModuleVersionResponse>(
            "SingleInstalledModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInstalledModuleVersionResponse {
    const NAME: &'static str = "SingleInstalledModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.installed_module_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.installed_module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.installed_module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInstalledModuleVersionResponse {
        SingleInstalledModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.installed_module_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInstalledModuleVersionResponse {
        static instance: SingleInstalledModuleVersionResponse = SingleInstalledModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            installed_module_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInstalledModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInstalledModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInstalledModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInstalledModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInstalledModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInstalledModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInstalledModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInstalledModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInstalledModuleVersionResponse.installed_module_versions)
    pub installed_module_versions: ::std::vec::Vec<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInstalledModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInstalledModuleVersionResponse {
    fn default() -> &'a MultiInstalledModuleVersionResponse {
        <MultiInstalledModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInstalledModuleVersionResponse {
    pub fn new() -> MultiInstalledModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInstalledModuleVersionResponse| { &m.status },
            |m: &mut MultiInstalledModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_module_versions",
            |m: &MultiInstalledModuleVersionResponse| { &m.installed_module_versions },
            |m: &mut MultiInstalledModuleVersionResponse| { &mut m.installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInstalledModuleVersionResponse>(
            "MultiInstalledModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInstalledModuleVersionResponse {
    const NAME: &'static str = "MultiInstalledModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.installed_module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.installed_module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.installed_module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInstalledModuleVersionResponse {
        MultiInstalledModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.installed_module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInstalledModuleVersionResponse {
        static instance: MultiInstalledModuleVersionResponse = MultiInstalledModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            installed_module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInstalledModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInstalledModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInstalledModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInstalledModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListNextTaskAssignmentsRequest
// @@protoc_insertion_point(message:clarifai.api.ListNextTaskAssignmentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListNextTaskAssignmentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListNextTaskAssignmentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListNextTaskAssignmentsRequest.task_id)
    pub task_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListNextTaskAssignmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListNextTaskAssignmentsRequest {
    fn default() -> &'a ListNextTaskAssignmentsRequest {
        <ListNextTaskAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListNextTaskAssignmentsRequest {
    pub fn new() -> ListNextTaskAssignmentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListNextTaskAssignmentsRequest| { &m.user_app_id },
            |m: &mut ListNextTaskAssignmentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &ListNextTaskAssignmentsRequest| { &m.task_id },
            |m: &mut ListNextTaskAssignmentsRequest| { &mut m.task_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListNextTaskAssignmentsRequest>(
            "ListNextTaskAssignmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListNextTaskAssignmentsRequest {
    const NAME: &'static str = "ListNextTaskAssignmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListNextTaskAssignmentsRequest {
        ListNextTaskAssignmentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListNextTaskAssignmentsRequest {
        static instance: ListNextTaskAssignmentsRequest = ListNextTaskAssignmentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListNextTaskAssignmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListNextTaskAssignmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListNextTaskAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNextTaskAssignmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to perform bulk operations on a list of inputs based on input source.
// @@protoc_insertion_point(message:clarifai.api.PostBulkOperationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostBulkOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostBulkOperationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc.
    // @@protoc_insertion_point(field:clarifai.api.PostBulkOperationsRequest.bulk_operations)
    pub bulk_operations: ::std::vec::Vec<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostBulkOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostBulkOperationsRequest {
    fn default() -> &'a PostBulkOperationsRequest {
        <PostBulkOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostBulkOperationsRequest {
    pub fn new() -> PostBulkOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostBulkOperationsRequest| { &m.user_app_id },
            |m: &mut PostBulkOperationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bulk_operations",
            |m: &PostBulkOperationsRequest| { &m.bulk_operations },
            |m: &mut PostBulkOperationsRequest| { &mut m.bulk_operations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostBulkOperationsRequest>(
            "PostBulkOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostBulkOperationsRequest {
    const NAME: &'static str = "PostBulkOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.bulk_operations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bulk_operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.bulk_operations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostBulkOperationsRequest {
        PostBulkOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.bulk_operations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostBulkOperationsRequest {
        static instance: PostBulkOperationsRequest = PostBulkOperationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            bulk_operations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostBulkOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostBulkOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostBulkOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostBulkOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list all the bulk operations.
// @@protoc_insertion_point(message:clarifai.api.ListBulkOperationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListBulkOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListBulkOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListBulkOperationsRequest {
    fn default() -> &'a ListBulkOperationsRequest {
        <ListBulkOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBulkOperationsRequest {
    pub fn new() -> ListBulkOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListBulkOperationsRequest| { &m.user_app_id },
            |m: &mut ListBulkOperationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListBulkOperationsRequest| { &m.page },
            |m: &mut ListBulkOperationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListBulkOperationsRequest| { &m.per_page },
            |m: &mut ListBulkOperationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListBulkOperationsRequest>(
            "ListBulkOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListBulkOperationsRequest {
    const NAME: &'static str = "ListBulkOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListBulkOperationsRequest {
        ListBulkOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListBulkOperationsRequest {
        static instance: ListBulkOperationsRequest = ListBulkOperationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListBulkOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListBulkOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListBulkOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBulkOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get the details of a bulk operation by ID.
// @@protoc_insertion_point(message:clarifai.api.GetBulkOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The bulk operation id
    // @@protoc_insertion_point(field:clarifai.api.GetBulkOperationRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBulkOperationRequest {
    fn default() -> &'a GetBulkOperationRequest {
        <GetBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBulkOperationRequest {
    pub fn new() -> GetBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetBulkOperationRequest| { &m.user_app_id },
            |m: &mut GetBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetBulkOperationRequest| { &m.id },
            |m: &mut GetBulkOperationRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBulkOperationRequest>(
            "GetBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBulkOperationRequest {
    const NAME: &'static str = "GetBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBulkOperationRequest {
        GetBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBulkOperationRequest {
        static instance: GetBulkOperationRequest = GetBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cancel a list of bulk operation ids
// @@protoc_insertion_point(message:clarifai.api.CancelBulkOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation ids to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelBulkOperationRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelBulkOperationRequest {
    fn default() -> &'a CancelBulkOperationRequest {
        <CancelBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelBulkOperationRequest {
    pub fn new() -> CancelBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelBulkOperationRequest| { &m.user_app_id },
            |m: &mut CancelBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CancelBulkOperationRequest| { &m.ids },
            |m: &mut CancelBulkOperationRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelBulkOperationRequest>(
            "CancelBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelBulkOperationRequest {
    const NAME: &'static str = "CancelBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelBulkOperationRequest {
        CancelBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelBulkOperationRequest {
        static instance: CancelBulkOperationRequest = CancelBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete the terminated bulk operations by ID
///  Only operations in terminated state can be deleted.
// @@protoc_insertion_point(message:clarifai.api.DeleteBulkOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation ids to be deleted
    // @@protoc_insertion_point(field:clarifai.api.DeleteBulkOperationRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteBulkOperationRequest {
    fn default() -> &'a DeleteBulkOperationRequest {
        <DeleteBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBulkOperationRequest {
    pub fn new() -> DeleteBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteBulkOperationRequest| { &m.user_app_id },
            |m: &mut DeleteBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteBulkOperationRequest| { &m.ids },
            |m: &mut DeleteBulkOperationRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteBulkOperationRequest>(
            "DeleteBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteBulkOperationRequest {
    const NAME: &'static str = "DeleteBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteBulkOperationRequest {
        DeleteBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteBulkOperationRequest {
        static instance: DeleteBulkOperationRequest = DeleteBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleBulkOperationsResponse
// @@protoc_insertion_point(message:clarifai.api.SingleBulkOperationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleBulkOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleBulkOperationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleBulkOperationsResponse.bulk_operation)
    pub bulk_operation: ::protobuf::MessageField<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleBulkOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleBulkOperationsResponse {
    fn default() -> &'a SingleBulkOperationsResponse {
        <SingleBulkOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleBulkOperationsResponse {
    pub fn new() -> SingleBulkOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleBulkOperationsResponse| { &m.status },
            |m: &mut SingleBulkOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::BulkOperation>(
            "bulk_operation",
            |m: &SingleBulkOperationsResponse| { &m.bulk_operation },
            |m: &mut SingleBulkOperationsResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleBulkOperationsResponse>(
            "SingleBulkOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleBulkOperationsResponse {
    const NAME: &'static str = "SingleBulkOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bulk_operation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bulk_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bulk_operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleBulkOperationsResponse {
        SingleBulkOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleBulkOperationsResponse {
        static instance: SingleBulkOperationsResponse = SingleBulkOperationsResponse {
            status: ::protobuf::MessageField::none(),
            bulk_operation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleBulkOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleBulkOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleBulkOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleBulkOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiBulkOperationsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiBulkOperationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiBulkOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiBulkOperationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiBulkOperationsResponse.bulk_operation)
    pub bulk_operation: ::std::vec::Vec<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiBulkOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiBulkOperationsResponse {
    fn default() -> &'a MultiBulkOperationsResponse {
        <MultiBulkOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiBulkOperationsResponse {
    pub fn new() -> MultiBulkOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiBulkOperationsResponse| { &m.status },
            |m: &mut MultiBulkOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bulk_operation",
            |m: &MultiBulkOperationsResponse| { &m.bulk_operation },
            |m: &mut MultiBulkOperationsResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiBulkOperationsResponse>(
            "MultiBulkOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiBulkOperationsResponse {
    const NAME: &'static str = "MultiBulkOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.bulk_operation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bulk_operation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.bulk_operation {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiBulkOperationsResponse {
        MultiBulkOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiBulkOperationsResponse {
        static instance: MultiBulkOperationsResponse = MultiBulkOperationsResponse {
            status: ::protobuf::MessageField::none(),
            bulk_operation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiBulkOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiBulkOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiBulkOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiBulkOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PutTaskAssignmentsRequest
// @@protoc_insertion_point(message:clarifai.api.PutTaskAssignmentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutTaskAssignmentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.task_id)
    pub task_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutTaskAssignmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutTaskAssignmentsRequest {
    fn default() -> &'a PutTaskAssignmentsRequest {
        <PutTaskAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutTaskAssignmentsRequest {
    pub fn new() -> PutTaskAssignmentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutTaskAssignmentsRequest| { &m.user_app_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &PutTaskAssignmentsRequest| { &m.task_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &PutTaskAssignmentsRequest| { &m.input_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutTaskAssignmentsRequest>(
            "PutTaskAssignmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutTaskAssignmentsRequest {
    const NAME: &'static str = "PutTaskAssignmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutTaskAssignmentsRequest {
        PutTaskAssignmentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutTaskAssignmentsRequest {
        static instance: PutTaskAssignmentsRequest = PutTaskAssignmentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutTaskAssignmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutTaskAssignmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutTaskAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutTaskAssignmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  List all the input ingestion jobs
// @@protoc_insertion_point(message:clarifai.api.ListInputsAddJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInputsAddJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsAddJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsAddJobsRequest {
    fn default() -> &'a ListInputsAddJobsRequest {
        <ListInputsAddJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsAddJobsRequest {
    pub fn new() -> ListInputsAddJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsAddJobsRequest| { &m.user_app_id },
            |m: &mut ListInputsAddJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsAddJobsRequest| { &m.page },
            |m: &mut ListInputsAddJobsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsAddJobsRequest| { &m.per_page },
            |m: &mut ListInputsAddJobsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsAddJobsRequest>(
            "ListInputsAddJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsAddJobsRequest {
    const NAME: &'static str = "ListInputsAddJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsAddJobsRequest {
        ListInputsAddJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsAddJobsRequest {
        static instance: ListInputsAddJobsRequest = ListInputsAddJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsAddJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsAddJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsAddJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsAddJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetInputsAddJobRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputsAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputsAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of add inputs job
    // @@protoc_insertion_point(field:clarifai.api.GetInputsAddJobRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputsAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputsAddJobRequest {
    fn default() -> &'a GetInputsAddJobRequest {
        <GetInputsAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputsAddJobRequest {
    pub fn new() -> GetInputsAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputsAddJobRequest| { &m.user_app_id },
            |m: &mut GetInputsAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetInputsAddJobRequest| { &m.id },
            |m: &mut GetInputsAddJobRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputsAddJobRequest>(
            "GetInputsAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputsAddJobRequest {
    const NAME: &'static str = "GetInputsAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputsAddJobRequest {
        GetInputsAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputsAddJobRequest {
        static instance: GetInputsAddJobRequest = GetInputsAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputsAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputsAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputsAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputsAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.CancelInputsAddJobRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelInputsAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of add inputs job to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsAddJobRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelInputsAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInputsAddJobRequest {
    fn default() -> &'a CancelInputsAddJobRequest {
        <CancelInputsAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelInputsAddJobRequest {
    pub fn new() -> CancelInputsAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelInputsAddJobRequest| { &m.user_app_id },
            |m: &mut CancelInputsAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CancelInputsAddJobRequest| { &m.id },
            |m: &mut CancelInputsAddJobRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInputsAddJobRequest>(
            "CancelInputsAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInputsAddJobRequest {
    const NAME: &'static str = "CancelInputsAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInputsAddJobRequest {
        CancelInputsAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInputsAddJobRequest {
        static instance: CancelInputsAddJobRequest = CancelInputsAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInputsAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInputsAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInputsAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInputsAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputsAddJobResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInputsAddJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputsAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsAddJobResponse.inputs_add_jobs)
    pub inputs_add_jobs: ::std::vec::Vec<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputsAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputsAddJobResponse {
    fn default() -> &'a MultiInputsAddJobResponse {
        <MultiInputsAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputsAddJobResponse {
    pub fn new() -> MultiInputsAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputsAddJobResponse| { &m.status },
            |m: &mut MultiInputsAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_add_jobs",
            |m: &MultiInputsAddJobResponse| { &m.inputs_add_jobs },
            |m: &mut MultiInputsAddJobResponse| { &mut m.inputs_add_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputsAddJobResponse>(
            "MultiInputsAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputsAddJobResponse {
    const NAME: &'static str = "MultiInputsAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs_add_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_add_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_add_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputsAddJobResponse {
        MultiInputsAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_add_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputsAddJobResponse {
        static instance: MultiInputsAddJobResponse = MultiInputsAddJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_add_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputsAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputsAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputsAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputsAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputsAddJobResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInputsAddJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputsAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsAddJobResponse.inputs_add_job)
    pub inputs_add_job: ::protobuf::MessageField<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputsAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputsAddJobResponse {
    fn default() -> &'a SingleInputsAddJobResponse {
        <SingleInputsAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputsAddJobResponse {
    pub fn new() -> SingleInputsAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputsAddJobResponse| { &m.status },
            |m: &mut SingleInputsAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsAddJob>(
            "inputs_add_job",
            |m: &SingleInputsAddJobResponse| { &m.inputs_add_job },
            |m: &mut SingleInputsAddJobResponse| { &mut m.inputs_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputsAddJobResponse>(
            "SingleInputsAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputsAddJobResponse {
    const NAME: &'static str = "SingleInputsAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inputs_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputsAddJobResponse {
        SingleInputsAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputsAddJobResponse {
        static instance: SingleInputsAddJobResponse = SingleInputsAddJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputsAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputsAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputsAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputsAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start a multipart upload
// @@protoc_insertion_point(message:clarifai.api.PostUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostUploadsRequest.uploads)
    pub uploads: ::std::vec::Vec<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostUploadsRequest {
    fn default() -> &'a PostUploadsRequest {
        <PostUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostUploadsRequest {
    pub fn new() -> PostUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostUploadsRequest| { &m.user_app_id },
            |m: &mut PostUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &PostUploadsRequest| { &m.uploads },
            |m: &mut PostUploadsRequest| { &mut m.uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostUploadsRequest>(
            "PostUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostUploadsRequest {
    const NAME: &'static str = "PostUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostUploadsRequest {
        PostUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostUploadsRequest {
        static instance: PostUploadsRequest = PostUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Stops or deletes multipart upload
// @@protoc_insertion_point(message:clarifai.api.DeleteUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteUploadsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteUploadsRequest {
    fn default() -> &'a DeleteUploadsRequest {
        <DeleteUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteUploadsRequest {
    pub fn new() -> DeleteUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteUploadsRequest| { &m.user_app_id },
            |m: &mut DeleteUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteUploadsRequest| { &m.ids },
            |m: &mut DeleteUploadsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteUploadsRequest>(
            "DeleteUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteUploadsRequest {
    const NAME: &'static str = "DeleteUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteUploadsRequest {
        DeleteUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteUploadsRequest {
        static instance: DeleteUploadsRequest = DeleteUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUploadsRequest {
    fn default() -> &'a ListUploadsRequest {
        <ListUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUploadsRequest {
    pub fn new() -> ListUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListUploadsRequest| { &m.user_app_id },
            |m: &mut ListUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListUploadsRequest| { &m.page },
            |m: &mut ListUploadsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListUploadsRequest| { &m.per_page },
            |m: &mut ListUploadsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUploadsRequest>(
            "ListUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUploadsRequest {
    const NAME: &'static str = "ListUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUploadsRequest {
        ListUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUploadsRequest {
        static instance: ListUploadsRequest = ListUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetUploadRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Upload ID
    // @@protoc_insertion_point(field:clarifai.api.GetUploadRequest.upload_id)
    pub upload_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUploadRequest {
    fn default() -> &'a GetUploadRequest {
        <GetUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUploadRequest {
    pub fn new() -> GetUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetUploadRequest| { &m.user_app_id },
            |m: &mut GetUploadRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &GetUploadRequest| { &m.upload_id },
            |m: &mut GetUploadRequest| { &mut m.upload_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUploadRequest>(
            "GetUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUploadRequest {
    const NAME: &'static str = "GetUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.upload_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.upload_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(2, &self.upload_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUploadRequest {
        GetUploadRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.upload_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUploadRequest {
        static instance: GetUploadRequest = GetUploadRequest {
            user_app_id: ::protobuf::MessageField::none(),
            upload_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleUploadResponse.upload)
    pub upload: ::protobuf::MessageField<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleUploadResponse {
    fn default() -> &'a SingleUploadResponse {
        <SingleUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleUploadResponse {
    pub fn new() -> SingleUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleUploadResponse| { &m.status },
            |m: &mut SingleUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Upload>(
            "upload",
            |m: &SingleUploadResponse| { &m.upload },
            |m: &mut SingleUploadResponse| { &mut m.upload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleUploadResponse>(
            "SingleUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleUploadResponse {
    const NAME: &'static str = "SingleUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upload)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.upload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.upload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleUploadResponse {
        SingleUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.upload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleUploadResponse {
        static instance: SingleUploadResponse = SingleUploadResponse {
            status: ::protobuf::MessageField::none(),
            upload: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiUploadResponse.uploads)
    pub uploads: ::std::vec::Vec<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiUploadResponse {
    fn default() -> &'a MultiUploadResponse {
        <MultiUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiUploadResponse {
    pub fn new() -> MultiUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiUploadResponse| { &m.status },
            |m: &mut MultiUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &MultiUploadResponse| { &m.uploads },
            |m: &mut MultiUploadResponse| { &mut m.uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiUploadResponse>(
            "MultiUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiUploadResponse {
    const NAME: &'static str = "MultiUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiUploadResponse {
        MultiUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiUploadResponse {
        static instance: MultiUploadResponse = MultiUploadResponse {
            status: ::protobuf::MessageField::none(),
            uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Upload a part of a multipart upload.
///  Behaviour on completion depends on the endpoint that was used to initiate the upload.
// @@protoc_insertion_point(message:clarifai.api.PutUploadContentPartsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutUploadContentPartsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.upload_id)
    pub upload_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.content_parts)
    pub content_parts: ::std::vec::Vec<super::resources::UploadContentPart>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutUploadContentPartsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutUploadContentPartsRequest {
    fn default() -> &'a PutUploadContentPartsRequest {
        <PutUploadContentPartsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutUploadContentPartsRequest {
    pub fn new() -> PutUploadContentPartsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutUploadContentPartsRequest| { &m.user_app_id },
            |m: &mut PutUploadContentPartsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &PutUploadContentPartsRequest| { &m.upload_id },
            |m: &mut PutUploadContentPartsRequest| { &mut m.upload_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_parts",
            |m: &PutUploadContentPartsRequest| { &m.content_parts },
            |m: &mut PutUploadContentPartsRequest| { &mut m.content_parts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutUploadContentPartsRequest>(
            "PutUploadContentPartsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutUploadContentPartsRequest {
    const NAME: &'static str = "PutUploadContentPartsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.upload_id = is.read_string()?;
                },
                26 => {
                    self.content_parts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.upload_id);
        }
        for value in &self.content_parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(2, &self.upload_id)?;
        }
        for v in &self.content_parts {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutUploadContentPartsRequest {
        PutUploadContentPartsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.upload_id.clear();
        self.content_parts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutUploadContentPartsRequest {
        static instance: PutUploadContentPartsRequest = PutUploadContentPartsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            upload_id: ::std::string::String::new(),
            content_parts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutUploadContentPartsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutUploadContentPartsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutUploadContentPartsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutUploadContentPartsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Initiates retrieval of inputs from cloud storage from a user provided data source.
///  Will create and return an inputs-add-job for tracking progress.
///  Archives will be extracted and their contents will be processed as inputs.
///
///  The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
///  files in the images_folder beginning with abc or in a subfolder beginning with abc.
///  For example:
///  bucket/images_folder/abcImage.png
///  bucket/images_folder/abc-1/Data.zip
///
///  If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
///  Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
///  in which case it only requires rights to access that particular file.
// @@protoc_insertion_point(message:clarifai.api.PostInputsDataSourcesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsDataSourcesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.data_sources)
    pub data_sources: ::std::vec::Vec<super::resources::InputsDataSource>,
    ///  If call back url is set, we will send a Post request to this endpoint with job status.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.call_back_url)
    pub call_back_url: ::std::string::String,
    ///  Personal Access Token to the application to which inputs are added
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.app_pat)
    pub app_pat: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsDataSourcesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsDataSourcesRequest {
    fn default() -> &'a PostInputsDataSourcesRequest {
        <PostInputsDataSourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsDataSourcesRequest {
    pub fn new() -> PostInputsDataSourcesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsDataSourcesRequest| { &m.user_app_id },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_sources",
            |m: &PostInputsDataSourcesRequest| { &m.data_sources },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.data_sources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_back_url",
            |m: &PostInputsDataSourcesRequest| { &m.call_back_url },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.call_back_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_pat",
            |m: &PostInputsDataSourcesRequest| { &m.app_pat },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.app_pat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsDataSourcesRequest>(
            "PostInputsDataSourcesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsDataSourcesRequest {
    const NAME: &'static str = "PostInputsDataSourcesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.data_sources.push(is.read_message()?);
                },
                26 => {
                    self.call_back_url = is.read_string()?;
                },
                34 => {
                    self.app_pat = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.data_sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.call_back_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.call_back_url);
        }
        if !self.app_pat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_pat);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.data_sources {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.call_back_url.is_empty() {
            os.write_string(3, &self.call_back_url)?;
        }
        if !self.app_pat.is_empty() {
            os.write_string(4, &self.app_pat)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsDataSourcesRequest {
        PostInputsDataSourcesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.data_sources.clear();
        self.call_back_url.clear();
        self.app_pat.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsDataSourcesRequest {
        static instance: PostInputsDataSourcesRequest = PostInputsDataSourcesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            data_sources: ::std::vec::Vec::new(),
            call_back_url: ::std::string::String::new(),
            app_pat: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsDataSourcesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsDataSourcesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsDataSourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsDataSourcesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetInputsExtractionJobRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputsExtractionJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputsExtractionJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputsExtractionJobRequest.inputs_extraction_job_id)
    pub inputs_extraction_job_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputsExtractionJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputsExtractionJobRequest {
    fn default() -> &'a GetInputsExtractionJobRequest {
        <GetInputsExtractionJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputsExtractionJobRequest {
    pub fn new() -> GetInputsExtractionJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputsExtractionJobRequest| { &m.user_app_id },
            |m: &mut GetInputsExtractionJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_extraction_job_id",
            |m: &GetInputsExtractionJobRequest| { &m.inputs_extraction_job_id },
            |m: &mut GetInputsExtractionJobRequest| { &mut m.inputs_extraction_job_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputsExtractionJobRequest>(
            "GetInputsExtractionJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputsExtractionJobRequest {
    const NAME: &'static str = "GetInputsExtractionJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs_extraction_job_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.inputs_extraction_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.inputs_extraction_job_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.inputs_extraction_job_id.is_empty() {
            os.write_string(2, &self.inputs_extraction_job_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputsExtractionJobRequest {
        GetInputsExtractionJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs_extraction_job_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputsExtractionJobRequest {
        static instance: GetInputsExtractionJobRequest = GetInputsExtractionJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs_extraction_job_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputsExtractionJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputsExtractionJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputsExtractionJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputsExtractionJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListInputsExtractionJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInputsExtractionJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsExtractionJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsExtractionJobsRequest {
    fn default() -> &'a ListInputsExtractionJobsRequest {
        <ListInputsExtractionJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsExtractionJobsRequest {
    pub fn new() -> ListInputsExtractionJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsExtractionJobsRequest| { &m.user_app_id },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsExtractionJobsRequest| { &m.page },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsExtractionJobsRequest| { &m.per_page },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsExtractionJobsRequest>(
            "ListInputsExtractionJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsExtractionJobsRequest {
    const NAME: &'static str = "ListInputsExtractionJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsExtractionJobsRequest {
        ListInputsExtractionJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsExtractionJobsRequest {
        static instance: ListInputsExtractionJobsRequest = ListInputsExtractionJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsExtractionJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsExtractionJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsExtractionJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsExtractionJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleInputsExtractionJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputsExtractionJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsExtractionJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsExtractionJobResponse.inputs_extraction_job)
    pub inputs_extraction_job: ::protobuf::MessageField<super::resources::InputsExtractionJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputsExtractionJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputsExtractionJobResponse {
    fn default() -> &'a SingleInputsExtractionJobResponse {
        <SingleInputsExtractionJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputsExtractionJobResponse {
    pub fn new() -> SingleInputsExtractionJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputsExtractionJobResponse| { &m.status },
            |m: &mut SingleInputsExtractionJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsExtractionJob>(
            "inputs_extraction_job",
            |m: &SingleInputsExtractionJobResponse| { &m.inputs_extraction_job },
            |m: &mut SingleInputsExtractionJobResponse| { &mut m.inputs_extraction_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputsExtractionJobResponse>(
            "SingleInputsExtractionJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputsExtractionJobResponse {
    const NAME: &'static str = "SingleInputsExtractionJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_extraction_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_extraction_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inputs_extraction_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputsExtractionJobResponse {
        SingleInputsExtractionJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_extraction_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputsExtractionJobResponse {
        static instance: SingleInputsExtractionJobResponse = SingleInputsExtractionJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_extraction_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputsExtractionJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputsExtractionJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputsExtractionJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputsExtractionJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiInputsExtractionJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputsExtractionJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsExtractionJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsExtractionJobResponse.inputs_extraction_jobs)
    pub inputs_extraction_jobs: ::std::vec::Vec<super::resources::InputsExtractionJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputsExtractionJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputsExtractionJobResponse {
    fn default() -> &'a MultiInputsExtractionJobResponse {
        <MultiInputsExtractionJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputsExtractionJobResponse {
    pub fn new() -> MultiInputsExtractionJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputsExtractionJobResponse| { &m.status },
            |m: &mut MultiInputsExtractionJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_extraction_jobs",
            |m: &MultiInputsExtractionJobResponse| { &m.inputs_extraction_jobs },
            |m: &mut MultiInputsExtractionJobResponse| { &mut m.inputs_extraction_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputsExtractionJobResponse>(
            "MultiInputsExtractionJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputsExtractionJobResponse {
    const NAME: &'static str = "MultiInputsExtractionJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs_extraction_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_extraction_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_extraction_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputsExtractionJobResponse {
        MultiInputsExtractionJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_extraction_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputsExtractionJobResponse {
        static instance: MultiInputsExtractionJobResponse = MultiInputsExtractionJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_extraction_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputsExtractionJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputsExtractionJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputsExtractionJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputsExtractionJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cancel a list of extraction job ids
// @@protoc_insertion_point(message:clarifai.api.CancelInputsExtractionJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelInputsExtractionJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsExtractionJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of extraction job ids to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsExtractionJobsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelInputsExtractionJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInputsExtractionJobsRequest {
    fn default() -> &'a CancelInputsExtractionJobsRequest {
        <CancelInputsExtractionJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelInputsExtractionJobsRequest {
    pub fn new() -> CancelInputsExtractionJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelInputsExtractionJobsRequest| { &m.user_app_id },
            |m: &mut CancelInputsExtractionJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CancelInputsExtractionJobsRequest| { &m.ids },
            |m: &mut CancelInputsExtractionJobsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInputsExtractionJobsRequest>(
            "CancelInputsExtractionJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInputsExtractionJobsRequest {
    const NAME: &'static str = "CancelInputsExtractionJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInputsExtractionJobsRequest {
        CancelInputsExtractionJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInputsExtractionJobsRequest {
        static instance: CancelInputsExtractionJobsRequest = CancelInputsExtractionJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInputsExtractionJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInputsExtractionJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInputsExtractionJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInputsExtractionJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start uploading a file archive containing inputs.
///  Will create and return an inputs-add-job for tracking progress.
///
///  Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
///  Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
// @@protoc_insertion_point(message:clarifai.api.PostInputsUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostInputsUploadsRequest.inputs_uploads)
    pub inputs_uploads: ::std::vec::Vec<super::resources::InputsUpload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsUploadsRequest {
    fn default() -> &'a PostInputsUploadsRequest {
        <PostInputsUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsUploadsRequest {
    pub fn new() -> PostInputsUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsUploadsRequest| { &m.user_app_id },
            |m: &mut PostInputsUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_uploads",
            |m: &PostInputsUploadsRequest| { &m.inputs_uploads },
            |m: &mut PostInputsUploadsRequest| { &mut m.inputs_uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsUploadsRequest>(
            "PostInputsUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsUploadsRequest {
    const NAME: &'static str = "PostInputsUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs_uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsUploadsRequest {
        PostInputsUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs_uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsUploadsRequest {
        static instance: PostInputsUploadsRequest = PostInputsUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs_uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetRunnerRequest
// @@protoc_insertion_point(message:clarifai.api.GetRunnerRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetRunnerRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetRunnerRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetRunnerRequest.runner_id)
    pub runner_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetRunnerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRunnerRequest {
    fn default() -> &'a GetRunnerRequest {
        <GetRunnerRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRunnerRequest {
    pub fn new() -> GetRunnerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetRunnerRequest| { &m.user_app_id },
            |m: &mut GetRunnerRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &GetRunnerRequest| { &m.runner_id },
            |m: &mut GetRunnerRequest| { &mut m.runner_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetRunnerRequest>(
            "GetRunnerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetRunnerRequest {
    const NAME: &'static str = "GetRunnerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRunnerRequest {
        GetRunnerRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRunnerRequest {
        static instance: GetRunnerRequest = GetRunnerRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetRunnerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetRunnerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetRunnerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRunnerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListRunnersRequest
// @@protoc_insertion_point(message:clarifai.api.ListRunnersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRunnersRequest {
    fn default() -> &'a ListRunnersRequest {
        <ListRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRunnersRequest {
    pub fn new() -> ListRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListRunnersRequest| { &m.user_app_id },
            |m: &mut ListRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListRunnersRequest| { &m.page },
            |m: &mut ListRunnersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListRunnersRequest| { &m.per_page },
            |m: &mut ListRunnersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRunnersRequest>(
            "ListRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRunnersRequest {
    const NAME: &'static str = "ListRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRunnersRequest {
        ListRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRunnersRequest {
        static instance: ListRunnersRequest = ListRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostRunnersRequest
// @@protoc_insertion_point(message:clarifai.api.PostRunnersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more runner by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnersRequest.runners)
    pub runners: ::std::vec::Vec<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostRunnersRequest {
    fn default() -> &'a PostRunnersRequest {
        <PostRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostRunnersRequest {
    pub fn new() -> PostRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostRunnersRequest| { &m.user_app_id },
            |m: &mut PostRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runners",
            |m: &PostRunnersRequest| { &m.runners },
            |m: &mut PostRunnersRequest| { &mut m.runners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostRunnersRequest>(
            "PostRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostRunnersRequest {
    const NAME: &'static str = "PostRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.runners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runners {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostRunnersRequest {
        PostRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostRunnersRequest {
        static instance: PostRunnersRequest = PostRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteRunnersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteRunnersRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteRunnersRequest {
    fn default() -> &'a DeleteRunnersRequest {
        <DeleteRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRunnersRequest {
    pub fn new() -> DeleteRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteRunnersRequest| { &m.user_app_id },
            |m: &mut DeleteRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteRunnersRequest| { &m.ids },
            |m: &mut DeleteRunnersRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteRunnersRequest>(
            "DeleteRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteRunnersRequest {
    const NAME: &'static str = "DeleteRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteRunnersRequest {
        DeleteRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteRunnersRequest {
        static instance: DeleteRunnersRequest = DeleteRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleRunnerResponse
// @@protoc_insertion_point(message:clarifai.api.SingleRunnerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleRunnerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleRunnerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleRunnerResponse.runner)
    pub runner: ::protobuf::MessageField<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleRunnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleRunnerResponse {
    fn default() -> &'a SingleRunnerResponse {
        <SingleRunnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleRunnerResponse {
    pub fn new() -> SingleRunnerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleRunnerResponse| { &m.status },
            |m: &mut SingleRunnerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Runner>(
            "runner",
            |m: &SingleRunnerResponse| { &m.runner },
            |m: &mut SingleRunnerResponse| { &mut m.runner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleRunnerResponse>(
            "SingleRunnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleRunnerResponse {
    const NAME: &'static str = "SingleRunnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runner)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.runner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleRunnerResponse {
        SingleRunnerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleRunnerResponse {
        static instance: SingleRunnerResponse = SingleRunnerResponse {
            status: ::protobuf::MessageField::none(),
            runner: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleRunnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleRunnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleRunnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleRunnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiRunnerResponse
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiRunnerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerResponse.runners)
    pub runners: ::std::vec::Vec<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerResponse {
    fn default() -> &'a MultiRunnerResponse {
        <MultiRunnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerResponse {
    pub fn new() -> MultiRunnerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerResponse| { &m.status },
            |m: &mut MultiRunnerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runners",
            |m: &MultiRunnerResponse| { &m.runners },
            |m: &mut MultiRunnerResponse| { &mut m.runners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerResponse>(
            "MultiRunnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerResponse {
    const NAME: &'static str = "MultiRunnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runners {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerResponse {
        MultiRunnerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerResponse {
        static instance: MultiRunnerResponse = MultiRunnerResponse {
            status: ::protobuf::MessageField::none(),
            runners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListRunnerItemsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListRunnerItemsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListRunnerItemsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListRunnerItemsRequest.runner_id)
    pub runner_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListRunnerItemsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRunnerItemsRequest {
    fn default() -> &'a ListRunnerItemsRequest {
        <ListRunnerItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRunnerItemsRequest {
    pub fn new() -> ListRunnerItemsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListRunnerItemsRequest| { &m.user_app_id },
            |m: &mut ListRunnerItemsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &ListRunnerItemsRequest| { &m.runner_id },
            |m: &mut ListRunnerItemsRequest| { &mut m.runner_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRunnerItemsRequest>(
            "ListRunnerItemsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRunnerItemsRequest {
    const NAME: &'static str = "ListRunnerItemsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRunnerItemsRequest {
        ListRunnerItemsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRunnerItemsRequest {
        static instance: ListRunnerItemsRequest = ListRunnerItemsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRunnerItemsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRunnerItemsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRunnerItemsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRunnerItemsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostRunnerItemOutputsRequest
// @@protoc_insertion_point(message:clarifai.api.PostRunnerItemOutputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostRunnerItemOutputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_id)
    pub runner_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.item_id)
    pub item_id: ::std::string::String,
    ///  This allows you to create one or more runner by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_item_outputs)
    pub runner_item_outputs: ::std::vec::Vec<RunnerItemOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostRunnerItemOutputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostRunnerItemOutputsRequest {
    fn default() -> &'a PostRunnerItemOutputsRequest {
        <PostRunnerItemOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostRunnerItemOutputsRequest {
    pub fn new() -> PostRunnerItemOutputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostRunnerItemOutputsRequest| { &m.user_app_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "item_id",
            |m: &PostRunnerItemOutputsRequest| { &m.item_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_item_outputs",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_item_outputs },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_item_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostRunnerItemOutputsRequest>(
            "PostRunnerItemOutputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostRunnerItemOutputsRequest {
    const NAME: &'static str = "PostRunnerItemOutputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                26 => {
                    self.item_id = is.read_string()?;
                },
                34 => {
                    self.runner_item_outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        if !self.item_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.item_id);
        }
        for value in &self.runner_item_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        if !self.item_id.is_empty() {
            os.write_string(3, &self.item_id)?;
        }
        for v in &self.runner_item_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostRunnerItemOutputsRequest {
        PostRunnerItemOutputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.item_id.clear();
        self.runner_item_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostRunnerItemOutputsRequest {
        static instance: PostRunnerItemOutputsRequest = PostRunnerItemOutputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            item_id: ::std::string::String::new(),
            runner_item_outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostRunnerItemOutputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostRunnerItemOutputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostRunnerItemOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostRunnerItemOutputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiRunnerItemResponse
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiRunnerItemResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemResponse.items)
    pub items: ::std::vec::Vec<RunnerItem>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerItemResponse {
    fn default() -> &'a MultiRunnerItemResponse {
        <MultiRunnerItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerItemResponse {
    pub fn new() -> MultiRunnerItemResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerItemResponse| { &m.status },
            |m: &mut MultiRunnerItemResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &MultiRunnerItemResponse| { &m.items },
            |m: &mut MultiRunnerItemResponse| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerItemResponse>(
            "MultiRunnerItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerItemResponse {
    const NAME: &'static str = "MultiRunnerItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerItemResponse {
        MultiRunnerItemResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerItemResponse {
        static instance: MultiRunnerItemResponse = MultiRunnerItemResponse {
            status: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.RunnerItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RunnerItem {
    // message fields
    ///  A UUID hash for this work item.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.id)
    pub id: ::std::string::String,
    ///  A description of the work to be done in case needed for UIs.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.description)
    pub description: ::std::string::String,
    ///  TODO(zeiler): make these options a oneof.
    ///  first work to do would be an inference runner.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.post_model_outputs_request)
    pub post_model_outputs_request: ::protobuf::MessageField<PostModelOutputsRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerItem {
    fn default() -> &'a RunnerItem {
        <RunnerItem as ::protobuf::Message>::default_instance()
    }
}

impl RunnerItem {
    pub fn new() -> RunnerItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RunnerItem| { &m.id },
            |m: &mut RunnerItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &RunnerItem| { &m.description },
            |m: &mut RunnerItem| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PostModelOutputsRequest>(
            "post_model_outputs_request",
            |m: &RunnerItem| { &m.post_model_outputs_request },
            |m: &mut RunnerItem| { &mut m.post_model_outputs_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerItem>(
            "RunnerItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerItem {
    const NAME: &'static str = "RunnerItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.post_model_outputs_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(v) = self.post_model_outputs_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(v) = self.post_model_outputs_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerItem {
        RunnerItem::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.post_model_outputs_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerItem {
        static instance: RunnerItem = RunnerItem {
            id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            post_model_outputs_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.RunnerItemOutput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RunnerItemOutput {
    // message fields
    ///  The output of the first task type.
    ///  TODO(zeiler): should the interface be more like pairs of things wiht request/response in one "item"?
    // @@protoc_insertion_point(field:clarifai.api.RunnerItemOutput.multi_output_response)
    pub multi_output_response: ::protobuf::MessageField<MultiOutputResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerItemOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerItemOutput {
    fn default() -> &'a RunnerItemOutput {
        <RunnerItemOutput as ::protobuf::Message>::default_instance()
    }
}

impl RunnerItemOutput {
    pub fn new() -> RunnerItemOutput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MultiOutputResponse>(
            "multi_output_response",
            |m: &RunnerItemOutput| { &m.multi_output_response },
            |m: &mut RunnerItemOutput| { &mut m.multi_output_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerItemOutput>(
            "RunnerItemOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerItemOutput {
    const NAME: &'static str = "RunnerItemOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.multi_output_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.multi_output_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.multi_output_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerItemOutput {
        RunnerItemOutput::new()
    }

    fn clear(&mut self) {
        self.multi_output_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerItemOutput {
        static instance: RunnerItemOutput = RunnerItemOutput {
            multi_output_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerItemOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerItemOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerItemOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerItemOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiRunnerItemOutputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiRunnerItemOutputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemOutputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemOutputResponse.runner_item_outputs)
    pub runner_item_outputs: ::std::vec::Vec<RunnerItemOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerItemOutputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerItemOutputResponse {
    fn default() -> &'a MultiRunnerItemOutputResponse {
        <MultiRunnerItemOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerItemOutputResponse {
    pub fn new() -> MultiRunnerItemOutputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerItemOutputResponse| { &m.status },
            |m: &mut MultiRunnerItemOutputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_item_outputs",
            |m: &MultiRunnerItemOutputResponse| { &m.runner_item_outputs },
            |m: &mut MultiRunnerItemOutputResponse| { &mut m.runner_item_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerItemOutputResponse>(
            "MultiRunnerItemOutputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerItemOutputResponse {
    const NAME: &'static str = "MultiRunnerItemOutputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runner_item_outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runner_item_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runner_item_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerItemOutputResponse {
        MultiRunnerItemOutputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner_item_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerItemOutputResponse {
        static instance: MultiRunnerItemOutputResponse = MultiRunnerItemOutputResponse {
            status: ::protobuf::MessageField::none(),
            runner_item_outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerItemOutputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerItemOutputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerItemOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerItemOutputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Get the estimated training time for a model version
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsTrainingTimeEstimateRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.estimated_input_count)
    pub estimated_input_count: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsTrainingTimeEstimateRequest {
    fn default() -> &'a PostModelVersionsTrainingTimeEstimateRequest {
        <PostModelVersionsTrainingTimeEstimateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsTrainingTimeEstimateRequest {
    pub fn new() -> PostModelVersionsTrainingTimeEstimateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.model_id },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.model_versions },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "estimated_input_count",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.estimated_input_count },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.estimated_input_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsTrainingTimeEstimateRequest>(
            "PostModelVersionsTrainingTimeEstimateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsTrainingTimeEstimateRequest {
    const NAME: &'static str = "PostModelVersionsTrainingTimeEstimateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                32 => {
                    self.estimated_input_count = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.estimated_input_count != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.estimated_input_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.estimated_input_count != 0 {
            os.write_uint64(4, self.estimated_input_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsTrainingTimeEstimateRequest {
        PostModelVersionsTrainingTimeEstimateRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.estimated_input_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsTrainingTimeEstimateRequest {
        static instance: PostModelVersionsTrainingTimeEstimateRequest = PostModelVersionsTrainingTimeEstimateRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            estimated_input_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsTrainingTimeEstimateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsTrainingTimeEstimateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsTrainingTimeEstimateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsTrainingTimeEstimateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Estimated training time in seconds
// @@protoc_insertion_point(message:clarifai.api.MultiTrainingTimeEstimateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTrainingTimeEstimateResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTrainingTimeEstimateResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTrainingTimeEstimateResponse.training_time_estimates)
    pub training_time_estimates: ::std::vec::Vec<::protobuf::well_known_types::duration::Duration>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTrainingTimeEstimateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTrainingTimeEstimateResponse {
    fn default() -> &'a MultiTrainingTimeEstimateResponse {
        <MultiTrainingTimeEstimateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTrainingTimeEstimateResponse {
    pub fn new() -> MultiTrainingTimeEstimateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTrainingTimeEstimateResponse| { &m.status },
            |m: &mut MultiTrainingTimeEstimateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "training_time_estimates",
            |m: &MultiTrainingTimeEstimateResponse| { &m.training_time_estimates },
            |m: &mut MultiTrainingTimeEstimateResponse| { &mut m.training_time_estimates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTrainingTimeEstimateResponse>(
            "MultiTrainingTimeEstimateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTrainingTimeEstimateResponse {
    const NAME: &'static str = "MultiTrainingTimeEstimateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.training_time_estimates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.training_time_estimates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.training_time_estimates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTrainingTimeEstimateResponse {
        MultiTrainingTimeEstimateResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.training_time_estimates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTrainingTimeEstimateResponse {
        static instance: MultiTrainingTimeEstimateResponse = MultiTrainingTimeEstimateResponse {
            status: ::protobuf::MessageField::none(),
            training_time_estimates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTrainingTimeEstimateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTrainingTimeEstimateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTrainingTimeEstimateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTrainingTimeEstimateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.OrganizationInvitationStatus)
pub enum OrganizationInvitationStatus {
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.NOT_SET)
    NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.PENDING)
    PENDING = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.ACCEPTED)
    ACCEPTED = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.CANCELLED)
    CANCELLED = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.DECLINED)
    DECLINED = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.EXPIRED)
    EXPIRED = 5,
}

impl ::protobuf::Enum for OrganizationInvitationStatus {
    const NAME: &'static str = "OrganizationInvitationStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrganizationInvitationStatus> {
        match value {
            0 => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            1 => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            2 => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            3 => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            4 => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            5 => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<OrganizationInvitationStatus> {
        match str {
            "NOT_SET" => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            "PENDING" => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            "ACCEPTED" => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            "CANCELLED" => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            "DECLINED" => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            "EXPIRED" => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OrganizationInvitationStatus] = &[
        OrganizationInvitationStatus::NOT_SET,
        OrganizationInvitationStatus::PENDING,
        OrganizationInvitationStatus::ACCEPTED,
        OrganizationInvitationStatus::CANCELLED,
        OrganizationInvitationStatus::DECLINED,
        OrganizationInvitationStatus::EXPIRED,
    ];
}

impl ::protobuf::EnumFull for OrganizationInvitationStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OrganizationInvitationStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OrganizationInvitationStatus {
    fn default() -> Self {
        OrganizationInvitationStatus::NOT_SET
    }
}

impl OrganizationInvitationStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrganizationInvitationStatus>("OrganizationInvitationStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20proto/clarifai/api/service.proto\x12\x0cclarifai.api\x1a\"proto/cl\
    arifai/api/resources.proto\x1a&proto/clarifai/api/status/status.proto\
    \x1a)proto/clarifai/api/utils/extensions.proto\x1a%proto/clarifai/auth/s\
    cope/scope.proto\x1a(proto/clarifai/auth/util/extension.proto\x1a+proto/\
    clarifai/api/status/status_code.proto\x1a\x1cgoogle/api/annotations.prot\
    o\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.pr\
    oto\x1a\x1fgoogle/protobuf/timestamp.proto\";\n\nPagination\x12\x12\n\
    \x04page\x18\x01\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x02\x20\
    \x01(\rR\x07perPage\"\x92\x01\n\x14GetAnnotationRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12#\n\rannotation_id\x18\x02\x20\x01(\tR\x0cannotationId\x12\x19\n\x08\
    input_id\x18\x03\x20\x01(\tR\x07inputId\"\xb3\x03\n\x16ListAnnotationsRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1b\
    \n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\x12\x19\n\x08user_ids\x18\
    \t\x20\x03(\tR\x07userIds\x12*\n\x11model_version_ids\x18\n\x20\x03(\tR\
    \x0fmodelVersionIds\x127\n\x08statuses\x18\x05\x20\x03(\x0b2\x1b.clarifa\
    i.api.status.StatusR\x08statuses\x120\n\x14list_all_annotations\x18\x06\
    \x20\x01(\x08R\x12listAllAnnotations\x12.\n\x13return_model_output\x18\
    \x0c\x20\x01(\x08R\x11returnModelOutput\x12\x12\n\x04page\x18\x07\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x08\x20\x01(\rR\x07perPage\
    \x12\x17\n\x07task_id\x18\x0b\x20\x01(\tR\x06taskIdJ\x04\x08\x04\x10\x05\
    \"\x90\x01\n\x16PostAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\"\
    \xda\x01\n\x17PatchAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\x12/\n\x14delete_if_empty\
    _data\x18\x04\x20\x01(\x08R\x11deleteIfEmptyData\"\xad\x02\n\x1dPatchAnn\
    otationsStatusRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08user_ids\x18\x03\x20\
    \x03(\tR\x07userIds\x12\x17\n\x07task_id\x18\x04\x20\x01(\tR\x06taskId\
    \x12B\n\x0cstatus_codes\x18\x06\x20\x03(\x0e2\x1f.clarifai.api.status.St\
    atusCodeR\x0bstatusCodes\x12\x16\n\x06action\x18\x05\x20\x01(\tR\x06acti\
    on\x12@\n\x0bstatus_code\x18\x02\x20\x01(\x0e2\x1f.clarifai.api.status.S\
    tatusCodeR\nstatusCode\"\x95\x01\n\x1ePatchAnnotationsStatusResponse\x12\
    3\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06s\
    tatus\x12\x19\n\x08user_ids\x18\x02\x20\x03(\tR\x07userIds\x12#\n\rupdat\
    ed_count\x18\x03\x20\x01(\rR\x0cupdatedCount\"\x95\x01\n\x17DeleteAnnota\
    tionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07i\
    nputId\x12#\n\rannotation_id\x18\x03\x20\x01(\tR\x0cannotationId\"\x85\
    \x01\n\x18DeleteAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\
    \x02\x20\x03(\tR\x03ids\x12\x1b\n\tinput_ids\x18\x03\x20\x03(\tR\x08inpu\
    tIds\"\x89\x01\n\x18SingleAnnotationResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x128\n\nannotat\
    ion\x18\x02\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\"\x90\
    \x01\n\x17MultiAnnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12@\n\x0bannotations\x18\x02\
    \x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotationsB\x04\x80\xb5\
    \x18\x01\"\xd9\x01\n\x1cListAnnotationWorkersRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\x12+\n\x11additional_fields\x18\x04\x20\x03(\tR\
    \x10additionalFields\x12!\n\x0ctrusted_only\x18\x05\x20\x01(\x08R\x0btru\
    stedOnly\"\x80\x01\n\x13MultiWorkerResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x124\n\x07workers\
    \x18\x02\x20\x03(\x0b2\x14.clarifai.api.WorkerR\x07workersB\x04\x80\xb5\
    \x18\x01\"x\n\rGetAppRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x11additional_fields\
    \x18\x02\x20\x03(\tR\x10additionalFields\"\xd9\x04\n\x0fListAppsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12+\n\x11additional_fields\
    \x18\n\x20\x03(\tR\x10additionalFields\x12%\n\x0esort_ascending\x18\x05\
    \x20\x01(\x08R\rsortAscending\x12\"\n\x0csort_by_name\x18\x06\x20\x01(\
    \x08H\0R\nsortByName\x12/\n\x13sort_by_modified_at\x18\x07\x20\x01(\x08H\
    \0R\x10sortByModifiedAt\x12-\n\x12sort_by_created_at\x18\x0c\x20\x01(\
    \x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_star_count\x18\r\x20\x01(\
    \x08H\0R\x0fsortByStarCount\x12#\n\rfeatured_only\x18\t\x20\x01(\x08R\
    \x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x0b\x20\x01(\x08R\x0bstarred\
    Only\x12#\n\rtemplate_only\x18\x10\x20\x01(\x08R\x0ctemplateOnly\x12\x16\
    \n\x06search\x18\x0f\x20\x01(\tR\x06search\x12\x18\n\x05query\x18\x08\
    \x20\x01(\tR\x05queryB\x02\x18\x01\x12\x16\n\x04name\x18\x04\x20\x01(\tR\
    \x04nameB\x02\x18\x01\x12\x12\n\x02id\x18\x0e\x20\x01(\tR\x02idB\x02\x18\
    \x01B\t\n\x07sort_by\"t\n\x0fPostAppsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04a\
    pps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\"N\n\x10DeleteAp\
    pRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\"\xeb\x01\n\x10PatchAppsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    %\n\x04apps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\x12\x16\
    \n\x06action\x18\x03\x20\x01(\tR\x06action\x12B\n\x0fmetadata_action\x18\
    \x04\x20\x01(\x0b2\x19.clarifai.api.PatchActionR\x0emetadataAction\x12\
    \x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reindex\"\xe8\x01\n\x0fPatchA\
    ppRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai\
    .api.AppR\x03app\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\x12B\
    \n\x0fmetadata_action\x18\x04\x20\x01(\x0b2\x19.clarifai.api.PatchAction\
    R\x0emetadataAction\x12\x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reinde\
    x\"\x99\x01\n\x13PatchAppsIdsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x03ids\x18\
    \x03\x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSourceR\x03ids\x12\x16\n\x06\
    action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x17PostAppsSearchesRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x123\n\tapp_query\x18\x02\x20\x01(\x0b2\x16.clarifai.a\
    pi.AppQueryR\x08appQuery\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.cl\
    arifai.api.PaginationR\npagination\"m\n\x11SingleAppResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\"t\n\
    \x10MultiAppResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12+\n\x04apps\x18\x02\x20\x03(\x0b2\x11.c\
    larifai.api.AppR\x04appsB\x04\x80\xb5\x18\x01\"\xbb\x01\n\x18ListCollabo\
    ratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x124\n\x16list_all_collaborators\x18\x02\x20\
    \x01(\x08R\x14listAllCollaborators\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x98\x01\
    \n\x18PostCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\
    \x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\"\
    \xb1\x01\n\x19PatchCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollabo\
    rators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborato\
    rs\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\xa4\x01\n\x1aDele\
    teCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12)\n\x10collaborator_ids\x18\x02\
    \x20\x03(\tR\x0fcollaboratorIds\x12\x1f\n\x0buser_emails\x18\x03\x20\x03\
    (\tR\nuserEmails\"\xca\x01\n\x1aMultiCollaboratorsResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12F\
    \n\rcollaborators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\r\
    collaboratorsB\x04\x80\xb5\x18\x01\x12/\n\tapp_owner\x18\x03\x20\x01(\
    \x0b2\x12.clarifai.api.UserR\x08appOwner\"\xab\x01\n\x19ListCollaboratio\
    nsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12#\n\rtemplate_o\
    nly\x18\x04\x20\x01(\x08R\x0ctemplateOnly\"\x9d\x01\n\x1bMultiCollaborat\
    ionsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12I\n\x0ecollaborations\x18\x02\x20\x03(\x0b2\x1b\
    .clarifai.api.CollaborationR\x0ecollaborationsB\x04\x80\xb5\x18\x01\"<\n\
    \x14GetStatusCodeRequest\x12$\n\x0estatus_code_id\x18\x01\x20\x01(\tR\
    \x0cstatusCodeId\"\x18\n\x16ListStatusCodesRequest\"O\n\x18SingleStatusC\
    odeResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\"\x87\x01\n\x17MultiStatusCodeResponse\x123\n\x06st\
    atus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    7\n\x08statuses\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.status.StatusR\
    \x08statuses\"n\n\x11GetConceptRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_\
    id\x18\x02\x20\x01(\tR\tconceptId\"\x90\x01\n\x13ListConceptsRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08p\
    er_page\x18\x03\x20\x01(\rR\x07perPage\x12\x0e\n\x02id\x18\x04\x20\x01(\
    \tR\x02id\"\xd7\x01\n\x18ListModelConceptsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\
    \n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\
    \x03\x20\x01(\tR\tversionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04pag\
    e\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\x12\x16\n\x06sear\
    ch\x18\x06\x20\x01(\tR\x06search\"\x9a\x02\n\x1bPostConceptsSearchesRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12?\n\rconcept_query\x18\x02\x20\x01(\x0b2\x1a.clarif\
    ai.api.ConceptQueryR\x0cconceptQuery\x12D\n\nextra_info\x18\x04\x20\x01(\
    \x0b2%.clarifai.api.ConceptExtraInfoRequestR\textraInfo\x128\n\npaginati\
    on\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"U\n\
    \x17ConceptExtraInfoRequest\x12:\n\x0erankable_model\x18\x01\x20\x01(\
    \x0b2\x13.clarifai.api.ModelR\rrankableModel\"\x84\x01\n\x13PostConcepts\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.clari\
    fai.api.ConceptR\x08concepts\"\x9d\x01\n\x14PatchConceptsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.clarifai.api.Concep\
    tR\x08concepts\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x84\
    \x01\n\x17GetConceptCountsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"}\n\x15SingleConceptResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07concept\x18\
    \x02\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\"\x84\x01\n\x14M\
    ultiConceptResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x127\n\x08concepts\x18\x02\x20\x03(\x0b2\
    \x15.clarifai.api.ConceptR\x08conceptsB\x04\x80\xb5\x18\x01\"\x99\x01\n\
    \x19MultiConceptCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b\
    .clarifai.api.status.StatusR\x06status\x12G\n\x0econcept_counts\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.ConceptCountR\rconceptCountsB\x04\x80\
    \xb5\x18\x01\"\xf3\x01\n\x1bListConceptRelationsRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x1c\n\tpredica\
    te\x18\x03\x20\x01(\tR\tpredicate\x12,\n\x12knowledge_graph_id\x18\x04\
    \x20\x01(\tR\x10knowledgeGraphId\x12\x12\n\x04page\x18\x05\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x06\x20\x01(\rR\x07perPage\"\xc4\x01\
    \n\x1bPostConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_relations\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptRelationR\x10conceptRelations\"\x8c\
    \x01\n\x1dDeleteConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconc\
    ept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x10\n\x03ids\x18\x03\x20\x03(\
    \tR\x03ids\"X\n\x1aListKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xa1\x01\n\
    \x1aPostKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphs\"\xae\x01\n\x1dPostConceptMappingJobsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12Q\n\
    \x14concept_mapping_jobs\x18\x02\x20\x03(\x0b2\x1f.clarifai.api.ConceptM\
    appingJobR\x12conceptMappingJobs\"\xa5\x01\n\x1cMultiConceptRelationResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12P\n\x11concept_relations\x18\x02\x20\x03(\x0b2\x1d.clar\
    ifai.api.ConceptRelationR\x10conceptRelationsB\x04\x80\xb5\x18\x01\"\xa1\
    \x01\n\x1bMultiKnowledgeGraphResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphsB\x04\x80\xb5\x18\x01\"g\n\x1eMultiConceptMappingJobResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x92\x01\n\x19GetConcept\
    LanguageRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\
    \tconceptId\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08language\"\xa7\
    \x01\n\x1bListConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_\
    id\x18\x02\x20\x01(\tR\tconceptId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xdd\x01\
    \n\x1cPatchConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_languages\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguages\x12\x16\
    \n\x06action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x1bPostConceptLan\
    guagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tc\
    onceptId\x12J\n\x11concept_languages\x18\x03\x20\x03(\x0b2\x1d.clarifai.\
    api.ConceptLanguageR\x10conceptLanguages\"\x9e\x01\n\x1dSingleConceptLan\
    guageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12H\n\x10concept_language\x18\x02\x20\x01(\x0b2\
    \x1d.clarifai.api.ConceptLanguageR\x0fconceptLanguage\"\xa5\x01\n\x1cMul\
    tiConceptLanguageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12P\n\x11concept_languages\x18\x02\
    \x20\x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguagesB\
    \x04\x80\xb5\x18\x01\"h\n\x0fGetInputRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08input_id\x18\x02\x20\x01(\tR\x07inputId\"p\n\x17GetVideoManifestRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\"\
    \x88\x01\n\x16GetInputSamplesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_i\
    d\x18\x02\x20\x01(\tR\x06taskId\x12\x19\n\x08user_ids\x18\x03\x20\x03(\t\
    R\x07userIds\"\xc5\x01\n\x11ListInputsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\x123\n\x06status\x18\x05\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x12\x10\n\x03ids\x18\x04\x20\x03(\tR\x03ids\
    \"\xc5\x01\n\x13StreamInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08per_pa\
    ge\x18\x02\x20\x01(\rR\x07perPage\x12\x17\n\x07last_id\x18\x03\x20\x01(\
    \tR\x06lastId\x12\x1e\n\x0border_by_id\x18\x05\x20\x01(\x08R\torderById\
    \x12\x1e\n\ndescending\x18\x04\x20\x01(\x08R\ndescending\"\x91\x02\n\x11\
    PostInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12+\n\x06inputs\x18\x02\x20\x03(\x0b2\
    \x13.clarifai.api.InputR\x06inputs\x12)\n\x11inputs_add_job_id\x18\x03\
    \x20\x01(\tR\x0einputsAddJobId\x12h\n\x1cinput_id_conflict_resolution\
    \x18\x04\x20\x01(\x0e2'.clarifai.api.InputIDConflictResolutionR\x19input\
    IdConflictResolution\"\x95\x01\n\x12PatchInputsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    +\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06inputs\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"k\n\x12DeleteInputRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\
    \"i\n\x13DeleteInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\
    \x03(\tR\x03idsJ\x04\x08\x03\x10\x04\"u\n\x13SingleInputResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12)\n\x05input\x18\x02\x20\x01(\x0b2\x13.clarifai.api.InputR\x05inpu\
    t\"r\n\x18GetVideoManifestResponse\x123\n\x06status\x18\x01\x20\x01(\x0b\
    2\x1b.clarifai.api.status.StatusR\x06status\x12!\n\x0cmanifest_url\x18\
    \x02\x20\x01(\tR\x0bmanifestUrl\"\xbe\x01\n\x12MultiInputResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x121\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06inp\
    utsB\x04\x80\xb5\x18\x01\x12@\n\x0einputs_add_job\x18\x03\x20\x01(\x0b2\
    \x1a.clarifai.api.InputsAddJobR\x0cinputsAddJob\"\x80\x01\n\x1cMultiInpu\
    tAnnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\x11.cl\
    arifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\"\x81\x01\n\x18SingleInputC\
    ountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x120\n\x06counts\x18\x02\x20\x01(\x0b2\x18.clarifa\
    i.api.InputCountR\x06counts\"R\n\x14GetInputCountRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\
    \xf9\x03\n\x13ListDatasetsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\x12+\n\x11additional_fields\x18\x05\x20\x03(\tR\x10additionalField\
    s\x12%\n\x0esort_ascending\x18\x06\x20\x01(\x08R\rsortAscending\x12-\n\
    \x12sort_by_created_at\x18\x07\x20\x01(\x08H\0R\x0fsortByCreatedAt\x12-\
    \n\x12sort_by_star_count\x18\x08\x20\x01(\x08H\0R\x0fsortByStarCount\x12\
    /\n\x13sort_by_modified_at\x18\t\x20\x01(\x08H\0R\x10sortByModifiedAt\
    \x12\x1e\n\nsort_by_id\x18\x0b\x20\x01(\x08H\0R\x08sortById\x12!\n\x0cst\
    arred_only\x18\x04\x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08bookmark\
    \x18\n\x20\x01(\x08R\x08bookmark\x12\x16\n\x06search\x18\r\x20\x01(\tR\
    \x06search\x12\x12\n\x02id\x18\x0c\x20\x01(\tR\x02idB\x02\x18\x01B\t\n\
    \x07sort_by\"\x9b\x01\n\x11GetDatasetRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\n\
    dataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12+\n\x11additional_fields\
    \x18\x03\x20\x03(\tR\x10additionalFields\"\x84\x01\n\x13PostDatasetsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x121\n\x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.\
    api.DatasetR\x08datasets\"\x9d\x01\n\x14PatchDatasetsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x121\n\x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\
    \x08datasets\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"t\n\x15D\
    eleteDatasetsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bdataset_ids\x18\x02\x20\
    \x03(\tR\ndatasetIds\"\x84\x01\n\x14MultiDatasetResponse\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\
    \x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\x08datasets\
    B\x04\x80\xb5\x18\x01\"}\n\x15SingleDatasetResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07d\
    ataset\x18\x02\x20\x01(\x0b2\x15.clarifai.api.DatasetR\x07dataset\"\xa4\
    \x01\n\x18ListDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x8e\x01\
    \n\x16GetDatasetInputRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\
    \x20\x01(\tR\tdatasetId\x12\x19\n\x08input_id\x18\x03\x20\x01(\tR\x07inp\
    utId\"\xe6\x01\n\x18PostDatasetInputsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\n\
    dataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12A\n\x0edataset_inputs\x18\
    \x03\x20\x03(\x0b2\x1a.clarifai.api.DatasetInputR\rdatasetInputs\x12,\n\
    \x06search\x18\x04\x20\x01(\x0b2\x14.clarifai.api.SearchR\x06search\"\
    \x94\x01\n\x1aDeleteDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndata\
    set_id\x18\x02\x20\x01(\tR\tdatasetId\x12\x1b\n\tinput_ids\x18\x03\x20\
    \x03(\tR\x08inputIds\"\xe3\x01\n\x19MultiDatasetInputResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12G\n\x0edataset_inputs\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.Dataset\
    InputR\rdatasetInputsB\x04\x80\xb5\x18\x01\x12B\n\x0ebulk_operation\x18\
    \x04\x20\x01(\x0b2\x1b.clarifai.api.BulkOperationR\rbulkOperationJ\x04\
    \x08\x03\x10\x04\"\x92\x01\n\x1aSingleDatasetInputResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12?\
    \n\rdataset_input\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.DatasetInputR\
    \x0cdatasetInput\"\xa6\x01\n\x1aListDatasetVersionsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12\x12\n\x04page\
    \x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\
    \x07perPage\"\xa3\x01\n\x18GetDatasetVersionRequest\x12:\n\x0buser_app_i\
    d\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12,\n\x12dataset_vers\
    ion_id\x18\x03\x20\x01(\tR\x10datasetVersionId\"\xf7\x02\n&ListDatasetVe\
    rsionMetricsGroupsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\
    \x20\x01(\tR\tdatasetId\x12,\n\x12dataset_version_id\x18\x03\x20\x01(\tR\
    \x10datasetVersionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04page\x12\
    \x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\x12!\n\x0cparent_paths\
    \x18\x06\x20\x03(\tR\x0bparentPaths\x12B\n\x05types\x18\x07\x20\x03(\x0e\
    2,.clarifai.api.DatasetVersionMetricsGroupTypeR\x05types\x12.\n\x06value\
    s\x18\x08\x20\x03(\x0b2\x16.google.protobuf.ValueR\x06values\"\xc0\x01\n\
    \x1aPostDatasetVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12G\n\x10dataset_versions\x18\x03\x20\
    \x03(\x0b2\x1c.clarifai.api.DatasetVersionR\x0fdatasetVersions\"\xd9\x01\
    \n\x1bPatchDatasetVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12G\n\x10dataset_versions\x18\x03\x20\
    \x03(\x0b2\x1c.clarifai.api.DatasetVersionR\x0fdatasetVersions\x12\x16\n\
    \x06action\x18\x04\x20\x01(\tR\x06action\"\xa9\x01\n\x1cDeleteDatasetVer\
    sionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tda\
    tasetId\x12.\n\x13dataset_version_ids\x18\x03\x20\x03(\tR\x11datasetVers\
    ionIds\"\xe8\x01\n\x1fPutDatasetVersionExportsRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12,\n\x12dataset_vers\
    ion_id\x18\x03\x20\x01(\tR\x10datasetVersionId\x12<\n\x07exports\x18\x04\
    \x20\x03(\x0b2\".clarifai.api.DatasetVersionExportR\x07exports\"\xa1\x01\
    \n\x1bMultiDatasetVersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10dataset_versions\
    \x18\x02\x20\x03(\x0b2\x1c.clarifai.api.DatasetVersionR\x0fdatasetVersio\
    nsB\x04\x80\xb5\x18\x01\"\x9c\x01\n!MultiDatasetVersionExportResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12B\n\x07exports\x18\x02\x20\x03(\x0b2\".clarifai.api.Datase\
    tVersionExportR\x07exportsB\x04\x80\xb5\x18\x01\"\xd3\x01\n'MultiDataset\
    VersionMetricsGroupResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.c\
    larifai.api.status.StatusR\x06status\x12s\n\x1edataset_version_metrics_g\
    roups\x18\x02\x20\x03(\x0b2(.clarifai.api.DatasetVersionMetricsGroupR\
    \x1bdatasetVersionMetricsGroupsB\x04\x80\xb5\x18\x01\"\x9a\x01\n\x1cSing\
    leDatasetVersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clar\
    ifai.api.status.StatusR\x06status\x12E\n\x0fdataset_version\x18\x02\x20\
    \x01(\x0b2\x1c.clarifai.api.DatasetVersionR\x0edatasetVersion\"\xe7\x01\
    \n\x17PostModelOutputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\
    \x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tv\
    ersionId\x12+\n\x06inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.InputR\
    \x06inputs\x12)\n\x05model\x18\x05\x20\x01(\x0b2\x13.clarifai.api.ModelR\
    \x05model\"\xbd\x01\n\x16ListModelInputsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\
    \n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\
    \x03\x20\x01(\tR\tversionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04pag\
    e\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\"b\n\rGetKeyReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\"\xd3\
    \x01\n\x0fListKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\
    \x12\x1f\n\x0bnot_expired\x18\x04\x20\x01(\x08R\nnotExpired\x12\x16\n\
    \x06scopes\x18\x05\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x06\
    \x20\x03(\tR\tendpoints\"\x7f\n\x12ListAppKeysRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\"t\n\x0fPostKeysRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\
    \x04keys\x18\x02\x20\x03(\x0b2\x11.clarifai.api.KeyR\x04keys\"e\n\x10Del\
    eteKeyRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05k\
    eyId\"\x8d\x01\n\x10PatchKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04keys\x18\
    \x02\x20\x03(\x0b2\x11.clarifai.api.KeyR\x04keys\x12\x16\n\x06action\x18\
    \x03\x20\x01(\tR\x06action\"m\n\x11SingleKeyResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12#\n\
    \x03key\x18\x02\x20\x01(\x0b2\x11.clarifai.api.KeyR\x03key\"t\n\x10Multi\
    KeyResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x12+\n\x04keys\x18\x02\x20\x03(\x0b2\x11.clarifai.a\
    pi.KeyR\x04keysB\x04\x80\xb5\x18\x01\"\xf7\x01\n\x0fGetModelRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\
    \nversion_id\x18\x03\x20\x01(\tR\tversionId\x12\x1a\n\x08language\x18\
    \x04\x20\x01(\tR\x08language\x12%\n\x0etrained_before\x18\x05\x20\x01(\
    \x08R\rtrainedBefore\x12+\n\x11additional_fields\x18\x13\x20\x03(\tR\x10\
    additionalFields\"\xd3\x07\n\x11ListModelsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\
    \n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\x12+\n\x11additional_fields\x18\x13\x20\x03(\tR\x10a\
    dditionalFields\x12%\n\x0esort_ascending\x18\n\x20\x01(\x08R\rsortAscend\
    ing\x12\"\n\x0csort_by_name\x18\x0b\x20\x01(\x08H\0R\nsortByName\x12-\n\
    \x12sort_by_num_inputs\x18\x0c\x20\x01(\x08H\0R\x0fsortByNumInputs\x12/\
    \n\x13sort_by_modified_at\x18\r\x20\x01(\x08H\0R\x10sortByModifiedAt\x12\
    -\n\x12sort_by_created_at\x18\x18\x20\x01(\x08H\0R\x0fsortByCreatedAt\
    \x12-\n\x12sort_by_star_count\x18\x19\x20\x01(\x08H\0R\x0fsortByStarCoun\
    t\x12\"\n\rmodel_type_id\x18\x06\x20\x01(\tR\x0bmodelTypeId\x12!\n\x0ctr\
    ained_only\x18\x07\x20\x01(\x08R\x0btrainedOnly\x12!\n\x0cinput_fields\
    \x18\x08\x20\x03(\tR\x0binputFields\x12#\n\routput_fields\x18\t\x20\x03(\
    \tR\x0coutputFields\x12\x18\n\x07license\x18\x0f\x20\x01(\tR\x07license\
    \x12#\n\rfeatured_only\x18\x10\x20\x01(\x08R\x0cfeaturedOnly\x12!\n\x0cs\
    tarred_only\x18\x14\x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08toolkits\
    \x18\x11\x20\x03(\tR\x08toolkits\x12\x1b\n\tuse_cases\x18\x12\x20\x03(\t\
    R\x08useCases\x12\x1c\n\tlanguages\x18\x15\x20\x03(\tR\tlanguages\x12/\n\
    \x14dont_fetch_from_main\x18\x17\x20\x01(\x08R\x11dontFetchFromMain\x12\
    \x1a\n\x08bookmark\x18\x1a\x20\x01(\x08R\x08bookmark\x12\x16\n\x06search\
    \x18\x1b\x20\x01(\tR\x06search\x12\x18\n\x05query\x18\x0e\x20\x01(\tR\
    \x05queryB\x02\x18\x01\x12\x16\n\x04name\x18\x05\x20\x01(\tR\x04nameB\
    \x02\x18\x01\x12-\n\x11filter_by_user_id\x18\x16\x20\x01(\x08R\x0efilter\
    ByUserIdB\x02\x18\x01B\t\n\x07sort_byJ\x04\x08\x04\x10\x05\"V\n\x18GetRe\
    sourceCountsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\"\xd4\x01\n\x19GetResourceCountsRespon\
    se\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Status\
    R\x06status\x12\x1a\n\x08datasets\x18\x02\x20\x01(\x03R\x08datasets\x12\
    \x16\n\x06models\x18\x03\x20\x01(\x03R\x06models\x12\x1c\n\tworkflows\
    \x18\x04\x20\x01(\x03R\tworkflows\x12\x18\n\x07modules\x18\x05\x20\x01(\
    \x03R\x07modules\x12\x16\n\x06inputs\x18\x06\x20\x01(\x03R\x06inputs\"\
    \xa6\x01\n\x19PatchModelToolkitsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08mo\
    del_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1a\n\x08toolkits\x18\x03\x20\
    \x03(\tR\x08toolkits\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"\
    \xb6\x01\n\x1ePatchModelCheckConsentsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12%\n\x0echeck_consents\x18\
    \x03\x20\x03(\tR\rcheckConsents\x12\x16\n\x06action\x18\x04\x20\x01(\tR\
    \x06action\"\xa6\x01\n\x19PatchModelUseCasesRequest\x12:\n\x0buser_app_i\
    d\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1a\n\x08usecases\
    \x18\x03\x20\x03(\tR\x08usecases\x12\x16\n\x06action\x18\x04\x20\x01(\tR\
    \x06action\"\xa9\x01\n\x1aPatchModelLanguagesRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1c\n\tlanguages\
    \x18\x03\x20\x03(\tR\tlanguages\x12\x16\n\x06action\x18\x04\x20\x01(\tR\
    \x06action\"l\n\x19MultiModelToolkitResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\n\x08to\
    olkits\x18\x02\x20\x03(\tR\x08toolkits\"|\n\x1eMultiModelCheckConsentRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12%\n\x0echeck_consents\x18\x02\x20\x03(\tR\rcheckConsen\
    ts\"l\n\x19MultiModelUseCaseResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\n\x08usecases\
    \x18\x02\x20\x03(\tR\x08usecases\"o\n\x1aMultiModelLanguageResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12\x1c\n\tlanguages\x18\x02\x20\x03(\tR\tlanguages\"\xab\x01\n\x11\
    PostModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12-\n\x05model\x18\x02\x20\x01(\x0b2\
    \x13.clarifai.api.ModelR\x05modelB\x02\x18\x01\x12+\n\x06models\x18\x03\
    \x20\x03(\x0b2\x13.clarifai.api.ModelR\x06models\"\x95\x01\n\x12PatchMod\
    elsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12+\n\x06models\x18\x02\x20\x03(\x0b2\x13.clar\
    ifai.api.ModelR\x06models\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06act\
    ion\"7\n\x0eIdUpdateSource\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x15\n\x06new_id\x18\x02\x20\x01(\tR\x05newId\"\x9a\x01\n\x14PatchModelI\
    dsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12.\n\x03ids\x18\x03\x20\x03(\x0b2\x1c.clarifai\
    .api.IdUpdateSourceR\x03ids\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06a\
    ction\"k\n\x12DeleteModelRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\tR\x07modelId\"\x82\x01\n\x13DeleteModelsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_\
    all\x18\x03\x20\x01(\x08R\tdeleteAll\"\xcc\x01\n\x19PostModelsSearchesRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x129\n\x0bmodel_query\x18\x02\x20\x01(\x0b2\x18.clar\
    ifai.api.ModelQueryR\nmodelQuery\x128\n\npagination\x18\x03\x20\x01(\x0b\
    2\x18.clarifai.api.PaginationR\npagination\"u\n\x13SingleModelResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12)\n\x05model\x18\x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\
    \x05model\"|\n\x12MultiModelResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x121\n\x06models\x18\x02\
    \x20\x03(\x0b2\x13.clarifai.api.ModelR\x06modelsB\x04\x80\xb5\x18\x01\"\
    \xcd\x01\n\x19PatchModelVersionsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08mo\
    del_id\x18\x02\x20\x01(\tR\x07modelId\x12A\n\x0emodel_versions\x18\x03\
    \x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\rmodelVersions\x12\x16\n\
    \x06action\x18\x04\x20\x01(\tR\x06action\"\x8e\x01\n\x16GetModelVersionR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\"\xd7\x03\n\x18Li\
    stModelVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\
    \x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\x12\x1f\n\x0bconcept_i\
    ds\x18\x05\x20\x03(\tR\nconceptIds\x12!\n\x0ctrained_only\x18\x06\x20\
    \x01(\x08R\x0btrainedOnly\x12%\n\x0esort_ascending\x18\x07\x20\x01(\x08R\
    \rsortAscending\x12/\n\x13sort_by_status_code\x18\x08\x20\x01(\x08H\0R\
    \x10sortByStatusCode\x12-\n\x12sort_by_num_inputs\x18\t\x20\x01(\x08H\0R\
    \x0fsortByNumInputs\x120\n\x13sort_by_description\x18\n\x20\x01(\x08H\0R\
    \x11sortByDescription\x12-\n\x12sort_by_created_at\x18\x0b\x20\x01(\x08H\
    \0R\x0fsortByCreatedAtB\t\n\x07sort_by\"\x91\x01\n\x19DeleteModelVersion\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x03\x20\x01(\tR\x07model\
    Id\x12\x1d\n\nversion_id\x18\x04\x20\x01(\tR\tversionId\"\x92\x01\n\x1aS\
    ingleModelVersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12?\n\rmodel_version\x18\x02\x20\x01\
    (\x0b2\x1a.clarifai.api.ModelVersionR\x0cmodelVersion\"\x99\x01\n\x19Mul\
    tiModelVersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarif\
    ai.api.status.StatusR\x06status\x12G\n\x0emodel_versions\x18\x02\x20\x03\
    (\x0b2\x1a.clarifai.api.ModelVersionR\rmodelVersionsB\x04\x80\xb5\x18\
    \x01\"\xa9\x02\n\x18PostModelVersionsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12A\n\x0emodel_versions\x18\
    \x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\rmodelVersions\x12\x20\
    \n\x0bdescription\x18\x08\x20\x01(\tR\x0bdescription\x123\n\teval_info\
    \x18\n\x20\x01(\x0b2\x16.clarifai.api.EvalInfoR\x08evalInfoJ\x04\x08\x04\
    \x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07J\x04\x08\x07\x10\x08J\
    \x04\x08\t\x10\n\"\xd6\x01\n$PostWorkflowVersionsUnPublishRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12Q\n\
    \x0cpublications\x18\x03\x20\x03(\x0b2-.clarifai.api.WorkflowVersionUnPu\
    blishRequestR\x0cpublications\"\xd2\x01\n\"PostWorkflowVersionsPublishRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkfl\
    owId\x12O\n\x0cpublications\x18\x03\x20\x03(\x0b2+.clarifai.api.Workflow\
    VersionPublishRequestR\x0cpublications\">\n\x1dWorkflowVersionPublishReq\
    uest\x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\tversionId\"@\n\x1fWorkfl\
    owVersionUnPublishRequest\x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\tver\
    sionId\";\n\x1aModelVersionPublishRequest\x12\x1d\n\nversion_id\x18\x01\
    \x20\x01(\tR\tversionId\"\xc6\x01\n\x1fPostModelVersionsPublishRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12L\
    \n\x0cpublications\x18\x03\x20\x03(\x0b2(.clarifai.api.ModelVersionPubli\
    shRequestR\x0cpublications\"=\n\x1cModelVersionUnpublishRequest\x12\x1d\
    \n\nversion_id\x18\x01\x20\x01(\tR\tversionId\"\xca\x01\n!PostModelVersi\
    onsUnPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\
    \tR\x07modelId\x12N\n\x0cpublications\x18\x03\x20\x03(\x0b2*.clarifai.ap\
    i.ModelVersionUnpublishRequestR\x0cpublications\"\x92\x01\n\x16PostEvalu\
    ationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12<\n\x0ceval_metrics\x18\x02\x20\x03(\x0b2\
    \x19.clarifai.api.EvalMetricsR\x0bevalMetrics\"\xd0\x06\n\x16ListEvaluat\
    ionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12%\n\x0esort_asc\
    ending\x18\x04\x20\x01(\x08R\rsortAscending\x12%\n\x0esort_by_app_id\x18\
    \x05\x20\x01(\x08H\0R\x0bsortByAppId\x12'\n\x0fsort_by_roc_auc\x18\x06\
    \x20\x01(\x08H\0R\x0csortByRocAuc\x12\x1e\n\nsort_by_f1\x18\x07\x20\x01(\
    \x08H\0R\x08sortByF1\x12-\n\x12sort_by_created_at\x18\x08\x20\x01(\x08H\
    \0R\x0fsortByCreatedAt\x12<\n\x1asort_by_mean_avg_precision\x18\t\x20\
    \x01(\x08H\0R\x16sortByMeanAvgPrecision\x12,\n\x11sort_by_precision\x18\
    \n\x20\x01(\x08H\0R\x0fsortByPrecision\x12&\n\x0esort_by_recall\x18\x0b\
    \x20\x01(\x08H\0R\x0csortByRecall\x12)\n\x10sort_by_model_id\x18\x10\x20\
    \x01(\x08H\0R\rsortByModelId\x126\n\x17sort_by_eval_dataset_id\x18\x11\
    \x20\x01(\x08H\0R\x13sortByEvalDatasetId\x128\n\x18sort_by_train_dataset\
    _id\x18\x12\x20\x01(\x08H\0R\x14sortByTrainDatasetId\x12\"\n\rmodel_type\
    _id\x18\x0c\x20\x01(\tR\x0bmodelTypeId\x12(\n\x10eval_dataset_ids\x18\r\
    \x20\x03(\tR\x0eevalDatasetIds\x12*\n\x11train_dataset_ids\x18\x0e\x20\
    \x03(\tR\x0ftrainDatasetIds\x12\x1f\n\x0bconcept_ids\x18\x0f\x20\x03(\tR\
    \nconceptIds\x12.\n\x13show_failed_metrics\x18\x13\x20\x01(\x08R\x11show\
    FailedMetricsB\t\n\x07sort_by\"\xaa\x01\n\x14GetEvaluationRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12#\n\revaluation_id\x18\x02\x20\x01(\tR\x0cevaluationId\x121\n\
    \x06fields\x18\x03\x20\x01(\x0b2\x19.clarifai.api.FieldsValueR\x06fields\
    \"\xe3\x01\n\"PostModelVersionEvaluationsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\
    \n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\
    \x18\x03\x20\x01(\tR\x0emodelVersionId\x12<\n\x0ceval_metrics\x18\x04\
    \x20\x03(\x0b2\x19.clarifai.api.EvalMetricsR\x0bevalMetrics\"\xd4\x01\n\
    \"ListModelVersionEvaluationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\
    \x01(\tR\x0emodelVersionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\"\xfb\x01\n\x20Get\
    ModelVersionEvaluationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\
    \x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\
    \tR\x0emodelVersionId\x12#\n\revaluation_id\x18\x04\x20\x01(\tR\x0cevalu\
    ationId\x121\n\x06fields\x18\x05\x20\x01(\x0b2\x19.clarifai.api.FieldsVa\
    lueR\x06fields\"\x8e\x01\n\x19SingleEvalMetricsResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12<\n\
    \x0ceval_metrics\x18\x02\x20\x01(\x0b2\x19.clarifai.api.EvalMetricsR\x0b\
    evalMetrics\"\x8d\x01\n\x18MultiEvalMetricsResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12<\n\x0ce\
    val_metrics\x18\x02\x20\x03(\x0b2\x19.clarifai.api.EvalMetricsR\x0bevalM\
    etrics\"\x88\x02\n\x1ePostModelVersionMetricsRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\
    \x18\x03\x20\x01(\tR\tversionId\x125\n\x0btest_search\x18\x05\x20\x01(\
    \x0b2\x14.clarifai.api.SearchR\ntestSearch\x123\n\teval_info\x18\n\x20\
    \x01(\x0b2\x16.clarifai.api.EvalInfoR\x08evalInfoJ\x04\x08\x04\x10\x05\"\
    \xc8\x01\n\x1dGetModelVersionMetricsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\
    \x03\x20\x01(\tR\tversionId\x121\n\x06fields\x18\x04\x20\x01(\x0b2\x19.c\
    larifai.api.FieldsValueR\x06fields\"u\n\x13GetModelTypeRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\"\n\rmodel_type_id\x18\x02\x20\x01(\tR\x0bmodelTypeId\"\x82\
    \x01\n\x15ListModelTypesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"\x1f\n\x1dListOpenSourceLicensesRequest\"q\n\x1eListOpenSourceLic\
    ensesResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12\x1a\n\x08licenses\x18\x02\x20\x03(\tR\x08lice\
    nses\"\x8c\x01\n\x17SingleModelTypeResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12<\n\nmodel_type\
    \x18\x02\x20\x01(\x0b2\x17.clarifai.api.ModelTypeR\tmodelTypeB\x04\x80\
    \xb5\x18\x01\"\xab\x02\n\x16MultiModelTypeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12>\n\x0bm\
    odel_types\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ModelTypeR\nmodelTypes\
    B\x04\x80\xb5\x18\x01\x12E\n\x0fmodel_importers\x18\x03\x20\x01(\x0b2\
    \x1c.clarifai.api.ModelTypeFieldR\x0emodelImporters\x12U\n\x16triton_con\
    da_envs_info\x18\x04\x20\x03(\x0b2\x20.clarifai.api.TritonCondaEnvInfoR\
    \x13tritonCondaEnvsInfo\"\xc4\x01\n\"GetModelVersionInputExampleRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\
    \n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x12\x1d\n\n\
    example_id\x18\x04\x20\x01(\tR\texampleId\"\xd6\x01\n$ListModelVersionIn\
    putExamplesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clari\
    fai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\
    \tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVe\
    rsionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04page\x12\x19\n\x08per_p\
    age\x18\x05\x20\x01(\rR\x07perPage\"\xc4\x01\n&SingleModelVersionInputEx\
    ampleResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12e\n\x1bmodel_version_input_example\x18\x02\x20\
    \x01(\x0b2&.clarifai.api.ModelVersionInputExampleR\x18modelVersionInputE\
    xample\"\xc5\x01\n%MultiModelVersionInputExampleResponse\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12g\n\
    \x1cmodel_version_input_examples\x18\x02\x20\x03(\x0b2&.clarifai.api.Mod\
    elVersionInputExampleR\x19modelVersionInputExamples\"\xa2\x01\n\x1aListM\
    odelReferencesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\
    \x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x9b\x01\n\x1bMultiMo\
    delReferenceResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12G\n\x10model_references\x18\x02\x20\x03\
    (\x0b2\x1c.clarifai.api.ModelReferenceR\x0fmodelReferences\"\x80\x01\n\
    \x13MultiOutputResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x124\n\x07outputs\x18\x02\x20\x03(\x0b2\
    \x14.clarifai.api.OutputR\x07outputsB\x04\x80\xb5\x18\x01\"j\n\x11ListSc\
    opesRequest\x12\x19\n\x08key_type\x18\x01\x20\x01(\tR\x07keyType\x12:\n\
    \x0buser_app_id\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\"M\n\x0fMyScopesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"Q\n\x13MyScopesUserRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\"\x15\n\x13MyScopesRootRequest\"\xc6\x01\n\x16MultiSco\
    peDepsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x126\n\nscope_deps\x18\x02\x20\x03(\x0b2\x17.cla\
    rifai.api.ScopeDepsR\tscopeDeps\x12?\n\rendpoint_deps\x18\x03\x20\x03(\
    \x0b2\x1a.clarifai.api.EndpointDepsR\x0cendpointDeps\"\xd2\x01\n\x12Mult\
    iScopeResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scope\
    s\x12#\n\x03app\x18\x03\x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\x12\
    \x1c\n\tendpoints\x18\x04\x20\x03(\tR\tendpoints\x12,\n\x12user_feature_\
    flags\x18\x05\x20\x01(\tR\x10userFeatureFlags\"\xb1\x01\n\x16MultiScopeU\
    serResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\
    \x12\x1c\n\tendpoints\x18\x04\x20\x03(\tR\tendpoints\x12,\n\x12user_feat\
    ure_flags\x18\x05\x20\x01(\tR\x10userFeatureFlags\"\xb1\x01\n\x16MultiSc\
    opeRootResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.\
    status.StatusR\x06status\x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scop\
    es\x12\x1c\n\tendpoints\x18\x04\x20\x03(\tR\tendpoints\x12,\n\x12user_fe\
    ature_flags\x18\x05\x20\x01(\tR\x10userFeatureFlags\"^\n\x10GetSearchReq\
    uest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAp\
    pIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\x80\x01\n\
    \x13ListSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\
    \rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xec\
    \x01\n\x13PostSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12-\n\x05query\x18\x02\x20\
    \x01(\x0b2\x13.clarifai.api.QueryR\x05queryB\x02\x18\x01\x120\n\x08searc\
    hes\x18\x03\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x128\n\np\
    agination\x18\x04\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\
    \"\xa2\x01\n\x1aPatchInputsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searc\
    hes\x18\x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\xa7\x01\n\x1fPatchAnnotations\
    SearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\
    \x14.clarifai.api.SearchR\x08searches\x12\x16\n\x06action\x18\x03\x20\
    \x01(\tR\x06action\"\x9c\x01\n\x14PatchSearchesRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    0\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08search\
    es\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x9f\x01\n\x17Post\
    SearchesByIDRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.Paginat\
    ionR\npagination\"a\n\x13DeleteSearchRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\
    \x02id\x18\x02\x20\x01(\tR\x02id\"\xc8\x01\n\x1ePostAnnotationsSearchesR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarif\
    ai.api.SearchR\x08searches\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.\
    clarifai.api.PaginationR\npagination\"r\n$DeleteAnnotationSearchMetricsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\xe2\x01\
    \n\x19PostInputsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\
    \x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x128\n\npaginati\
    on\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\x12\
    \x1d\n\nonly_count\x18\x04\x20\x01(\x08R\tonlyCount\"y\n\x14SingleSearch\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x12,\n\x06search\x18\x05\x20\x01(\x0b2\x14.clarifai.ap\
    i.SearchR\x06search\"\x9b\x02\n\x13MultiSearchResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x0e\
    \n\x02id\x18\x02\x20\x01(\tR\x02id\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\
    \x11.clarifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\x12)\n\x05query\x18\
    \x04\x20\x01(\x0b2\x13.clarifai.api.QueryR\x05query\x120\n\x08searches\
    \x18\x05\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x125\n\nhit_\
    counts\x18\x06\x20\x03(\x0b2\x16.clarifai.api.HitCountR\thitCounts\"\xd4\
    \x02\n\"PostAnnotationSearchMetricsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\
    \x18\x02\x20\x01(\tR\x02id\x127\n\x0cground_truth\x18\x03\x20\x01(\x0b2\
    \x14.clarifai.api.SearchR\x0bgroundTruth\x12:\n\x0esearch_to_eval\x18\
    \x04\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0csearchToEval\x12&\n\x04da\
    ta\x18\x05\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x12E\n\x0fevalua\
    tion_type\x18\x06\x20\x01(\x0e2\x1c.clarifai.api.EvaluationTypeR\x0eeval\
    uationType\"o\n!GetAnnotationSearchMetricsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\
    \n\x02id\x18\x02\x20\x01(\tR\x02id\"`\n\"ListAnnotationSearchMetricsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\"\xbe\x01\n$MultiAnnotationSearchMetricsResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12a\n\x19annotation_search_metrics\x18\x02\x20\x03(\x0b2%.clarifai\
    .api.AnnotationSearchMetricsR\x17annotationSearchMetrics\"\x89\x01\n\x1c\
    ListAnnotationFiltersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\
    \x8a\x01\n\x1aGetAnnotationFilterRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x14annot\
    ation_filter_id\x18\x02\x20\x01(\tR\x12annotationFilterId\"\xa9\x01\n\
    \x1cPostAnnotationFiltersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12M\n\x12annotation_fil\
    ters\x18\x02\x20\x03(\x0b2\x1e.clarifai.api.AnnotationFilterR\x11annotat\
    ionFilters\"\xc2\x01\n\x1dPatchAnnotationFiltersRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12M\n\x12annotation_filters\x18\x02\x20\x03(\x0b2\x1e.clarifai.api.Ann\
    otationFilterR\x11annotationFilters\x12\x16\n\x06action\x18\x03\x20\x01(\
    \tR\x06action\"\x90\x01\n\x1eDeleteAnnotationFiltersRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x122\n\x15annotation_filter_ids\x18\x02\x20\x03(\tR\x13annotationFilte\
    rIds\"\xa9\x01\n\x1dMultiAnnotationFilterResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12S\n\x12a\
    nnotation_filters\x18\x02\x20\x03(\x0b2\x1e.clarifai.api.AnnotationFilte\
    rR\x11annotationFiltersB\x04\x80\xb5\x18\x01\"\xa2\x01\n\x1eSingleAnnota\
    tionFilterResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.a\
    pi.status.StatusR\x06status\x12K\n\x11annotation_filter\x18\x02\x20\x01(\
    \x0b2\x1e.clarifai.api.AnnotationFilterR\x10annotationFilter\"y\n\x0eGet\
    UserRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12+\n\x11additional_fields\x18\x02\x20\x03(\t\
    R\x10additionalFields\"q\n\x12SingleUserResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12&\n\x04u\
    ser\x18\x02\x20\x01(\x0b2\x12.clarifai.api.UserR\x04user\"\x8d\x01\n\x1b\
    PostValidatePasswordRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x122\n\x08password\x18\x02\
    \x20\x01(\x0b2\x16.clarifai.api.PasswordR\x08password\"\xaa\x01\n\x20Sin\
    glePasswordValidationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b\
    .clarifai.api.status.StatusR\x06status\x12Q\n\x13password_violations\x18\
    \x02\x20\x01(\x0b2\x20.clarifai.api.PasswordViolationsR\x12passwordViola\
    tions\"\x96\x02\n\x12GetWorkflowRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bwo\
    rkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x128\n\x18favor_clarifai_workf\
    lows\x18\x03\x20\x01(\x08R\x16favorClarifaiWorkflows\x12+\n\x11additiona\
    l_fields\x18\x04\x20\x03(\tR\x10additionalFields\x12<\n\x1aexclude_clari\
    fai_workflows\x18\x05\x20\x01(\x08R\x18excludeClarifaiWorkflows\"\xde\
    \x04\n\x14ListWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\x12+\n\x11additional_fields\x18\n\x20\x03(\tR\x10additionalFields\
    \x12%\n\x0esort_ascending\x18\x05\x20\x01(\x08R\rsortAscending\x12\x1e\n\
    \nsort_by_id\x18\x06\x20\x01(\x08H\0R\x08sortById\x12/\n\x13sort_by_modi\
    fied_at\x18\x07\x20\x01(\x08H\0R\x10sortByModifiedAt\x12-\n\x12sort_by_c\
    reated_at\x18\r\x20\x01(\x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_st\
    ar_count\x18\x0e\x20\x01(\x08H\0R\x0fsortByStarCount\x12#\n\rfeatured_on\
    ly\x18\t\x20\x01(\x08R\x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x0b\
    \x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08bookmark\x18\x0f\x20\x01(\x08\
    R\x08bookmark\x12\x16\n\x06search\x18\x10\x20\x01(\tR\x06search\x12\x18\
    \n\x05query\x18\x08\x20\x01(\tR\x05queryB\x02\x18\x01\x12\x12\n\x02id\
    \x18\x04\x20\x01(\tR\x02idB\x02\x18\x01\x12#\n\x0bsearch_term\x18\x0c\
    \x20\x01(\tR\nsearchTermB\x02\x18\x01B\t\n\x07sort_by\"\x88\x01\n\x14Pos\
    tWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflows\x18\x02\x20\x03(\x0b2\
    \x16.clarifai.api.WorkflowR\tworkflows\"\xa1\x01\n\x15PatchWorkflowsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x124\n\tworkflows\x18\x02\x20\x03(\x0b2\x16.clarifai.a\
    pi.WorkflowR\tworkflows\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06actio\
    n\"\x9d\x01\n\x17PatchWorkflowIdsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x03ids\
    \x18\x03\x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSourceR\x03ids\x12\x16\n\
    \x06action\x18\x04\x20\x01(\tR\x06action\"t\n\x15DeleteWorkflowRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\
    \"\x85\x01\n\x16DeleteWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\
    \x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\
    \tdeleteAll\"\x81\x01\n\x16SingleWorkflowResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x122\n\x08w\
    orkflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\x08workflow\"\
    \x88\x01\n\x15MultiWorkflowResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12:\n\tworkflows\x18\
    \x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflowsB\x04\x80\xb5\
    \x18\x01\"\x84\x03\n\x1aPostWorkflowResultsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\
    \n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12\x1d\n\nversion_id\
    \x18\x07\x20\x01(\tR\tversionId\x12+\n\x06inputs\x18\x03\x20\x03(\x0b2\
    \x13.clarifai.api.InputR\x06inputs\x12?\n\routput_config\x18\x04\x20\x01\
    (\x0b2\x1a.clarifai.api.OutputConfigR\x0coutputConfig\x128\n\x18favor_cl\
    arifai_workflows\x18\x05\x20\x01(\x08R\x16favorClarifaiWorkflows\x12B\n\
    \x0eworkflow_state\x18\x06\x20\x01(\x0b2\x1b.clarifai.api.WorkflowStateR\
    \rworkflowState\"\x82\x02\n\x1bPostWorkflowResultsResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x122\
    \n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\x08workf\
    low\x126\n\x07results\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.WorkflowRes\
    ultR\x07results\x12B\n\x0eworkflow_state\x18\x04\x20\x01(\x0b2\x1b.clari\
    fai.api.WorkflowStateR\rworkflowState\"\xf4\x02\n$PostWorkflowResultsSim\
    ilarityRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\t\
    R\nworkflowId\x12\x1d\n\nversion_id\x18\x07\x20\x01(\tR\tversionId\x12(\
    \n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x126\n\x0cp\
    robe_inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.InputR\x0bprobeInputs\
    \x124\n\x0bpool_inputs\x18\x05\x20\x03(\x0b2\x13.clarifai.api.InputR\npo\
    olInputs\x128\n\x18favor_clarifai_workflows\x18\x06\x20\x01(\x08R\x16fav\
    orClarifaiWorkflows\"\x9f\x01\n%PostWorkflowResultsSimilarityResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.clarifai.api.Workflo\
    wResultsSimilarityR\x07results\"\xa9\x01\n\x1bListWorkflowVersionsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\
    \x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x04\x20\x01(\rR\x07perPage\"\xa8\x01\n\x19GetWorkflowVersionRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12\
    .\n\x13workflow_version_id\x18\x03\x20\x01(\tR\x11workflowVersionId\"\
    \xae\x01\n\x1dDeleteWorkflowVersionsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\
    \x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x120\n\x14workflow_versi\
    on_ids\x18\x03\x20\x03(\tR\x12workflowVersionIds\"\xdf\x01\n\x1cPatchWor\
    kflowVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\
    \x01(\tR\nworkflowId\x12J\n\x11workflow_versions\x18\x03\x20\x03(\x0b2\
    \x1d.clarifai.api.WorkflowVersionR\x10workflowVersions\x12\x16\n\x06acti\
    on\x18\x04\x20\x01(\tR\x06action\"\xa5\x01\n\x1cMultiWorkflowVersionResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12P\n\x11workflow_versions\x18\x02\x20\x03(\x0b2\x1d.clar\
    ifai.api.WorkflowVersionR\x10workflowVersionsB\x04\x80\xb5\x18\x01\"\x9e\
    \x01\n\x1dSingleWorkflowVersionResponse\x123\n\x06status\x18\x01\x20\x01\
    (\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12H\n\x10workflow_vers\
    ion\x18\x02\x20\x01(\x0b2\x1d.clarifai.api.WorkflowVersionR\x0fworkflowV\
    ersion\"\xa1\x01\n\x1aPostAppDuplicationsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\
    \x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.AppDuplicati\
    onR\x0fappDuplications\"\x84\x01\n\x18GetAppDuplicationRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12,\n\x12app_duplication_id\x18\x02\x20\x01(\tR\x10appDuplicati\
    onId\"\x87\x01\n\x1aListAppDuplicationsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\x9c\x01\n\x1cMultiAppDuplicationsResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12G\n\x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.App\
    DuplicationR\x0fappDuplications\"\x9a\x01\n\x1cSingleAppDuplicationRespo\
    nse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Statu\
    sR\x06status\x12E\n\x0fapp_duplication\x18\x02\x20\x01(\x0b2\x1c.clarifa\
    i.api.AppDuplicationR\x0eappDuplication\"x\n\x10PostTasksRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12(\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05\
    tasks\"\x92\x01\n\x0eGetTaskRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_i\
    d\x18\x02\x20\x01(\tR\x06taskId\x12+\n\x11additional_fields\x18\x03\x20\
    \x03(\tR\x10additionalFields\"\xe1\x02\n\x10ListTasksRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\x12&\n\x0fworker_user_ids\x18\x04\x20\
    \x03(\tR\rworkerUserIds\x12&\n\x0freview_user_ids\x18\x05\x20\x03(\tR\rr\
    eviewUserIds\x12&\n\x0flabel_order_ids\x18\x08\x20\x03(\tR\rlabelOrderId\
    s\x12=\n\x1bincluding_label_order_tasks\x18\x06\x20\x01(\x08R\x18includi\
    ngLabelOrderTasks\x12+\n\x11additional_fields\x18\x07\x20\x03(\tR\x10add\
    itionalFields\"\x91\x01\n\x11PatchTasksRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12(\n\x05t\
    asks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05tasks\x12\x16\n\x06\
    action\x18\x03\x20\x01(\tR\x06action\"b\n\x12DeleteTasksRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"x\n\x11MultiTaskRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12.\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.Ta\
    skR\x05tasksB\x04\x80\xb5\x18\x01\"q\n\x12SingleTaskResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12&\n\x04task\x18\x02\x20\x01(\x0b2\x12.clarifai.api.TaskR\x04task\"\
    \x85\x01\n\x13GetTaskCountRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\
    \x02\x20\x01(\tR\x06taskId\x12\x19\n\x08user_ids\x18\x03\x20\x03(\tR\x07\
    userIds\"\xbc\x01\n\x17SingleTaskCountResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x15\n\x06ap\
    p_id\x18\x02\x20\x01(\tR\x05appId\x12\x17\n\x07task_id\x18\x03\x20\x01(\
    \tR\x06taskId\x12<\n\x06counts\x18\x04\x20\x03(\x0b2$.clarifai.api.TaskS\
    tatusCountPerUserR\x06counts\"\x91\x01\n\x16PostLabelOrdersRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12;\n\x0clabel_orders\x18\x02\x20\x03(\x0b2\x18.clarifai.api.\
    LabelOrderR\x0blabelOrders\"x\n\x14GetLabelOrderRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12$\n\x0elabel_order_id\x18\x02\x20\x01(\tR\x0clabelOrderId\"\x83\x01\
    \n\x16ListLabelOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\
    \xaa\x01\n\x17PatchLabelOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12;\n\x0clabel_ord\
    ers\x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelOrders\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"h\n\x18DeleteLabelOr\
    dersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\
    \x91\x01\n\x17MultiLabelOrderResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12A\n\x0clabel_orders\
    \x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelOrdersB\x04\
    \x80\xb5\x18\x01\"\x8a\x01\n\x18SingleLabelOrderResponse\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\
    \x0blabel_order\x18\x02\x20\x01(\x0b2\x18.clarifai.api.LabelOrderR\nlabe\
    lOrder\"\x8c\x01\n\x15PostCollectorsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncol\
    lectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\"\
    \xa5\x01\n\x16PatchCollectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncollectors\
    \x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\x86\x01\n\x17DeleteCollectors\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\
    \x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"t\n\x13GetCollector\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12!\n\x0ccollector_id\x18\x02\x20\x01(\tR\x0bcoll\
    ectorId\"\x82\x01\n\x15ListCollectorsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\x86\x01\n\x16MultiCollectorResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\
    \n\ncollectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollec\
    tors\"\x85\x01\n\x17SingleCollectorResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x125\n\tcollector\
    \x18\x02\x20\x01(\x0b2\x17.clarifai.api.CollectorR\tcollector\"\x8d\x01\
    \n\x15PostStatValuesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x128\n\x0bstat_values\x18\x02\
    \x20\x03(\x0b2\x17.clarifai.api.StatValueR\nstatValues\"\x8d\x01\n\x16Mu\
    ltiStatValueResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12>\n\x0bstat_values\x18\x02\x20\x03(\x0b\
    2\x17.clarifai.api.StatValueR\nstatValuesB\x04\x80\xb5\x18\x01\"\xc4\x01\
    \n\x1ePostStatValuesAggregateRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12f\n\x1cstat_valu\
    e_aggregate_queries\x18\x02\x20\x03(\x0b2%.clarifai.api.StatValueAggrega\
    teQueryR\x19statValueAggregateQueries\"\xbf\x01\n\x1fMultiStatValueAggre\
    gateResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12g\n\x1cstat_value_aggregate_results\x18\x02\x20\
    \x03(\x0b2&.clarifai.api.StatValueAggregateResultR\x19statValueAggregate\
    Results\"\x96\x01\n\x1ePostTrendingMetricsViewRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1b\n\tview_type\x18\x02\x20\x01(\tR\x08viewType\x12\x1b\n\tobject_id\
    \x18\x03\x20\x01(\tR\x08objectId\"\xa9\x01\n\x1fListTrendingMetricsViews\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x1b\n\tview_type\x18\x02\x20\x01(\tR\x08viewTy\
    pe\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x04\x20\x01(\rR\x07perPage\"\x8f\x01\n\x20MultiTrendingMetricsViewR\
    esponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.S\
    tatusR\x06status\x126\n\x07metrics\x18\x02\x20\x03(\x0b2\x1c.clarifai.ap\
    i.TrendingMetricR\x07metrics\"\x98\x01\n\x10GetModuleRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\x12+\n\x11additi\
    onal_fields\x18\x03\x20\x03(\tR\x10additionalFields\"\xab\x04\n\x12ListM\
    odulesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04pag\
    e\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12+\n\x11additio\
    nal_fields\x18\x05\x20\x03(\tR\x10additionalFields\x12%\n\x0esort_ascend\
    ing\x18\x06\x20\x01(\x08R\rsortAscending\x12-\n\x12sort_by_created_at\
    \x18\x07\x20\x01(\x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_star_coun\
    t\x18\x08\x20\x01(\x08H\0R\x0fsortByStarCount\x12/\n\x13sort_by_modified\
    _at\x18\t\x20\x01(\x08H\0R\x10sortByModifiedAt\x12\x1e\n\nsort_by_id\x18\
    \x0b\x20\x01(\x08H\0R\x08sortById\x12!\n\x0cstarred_only\x18\x04\x20\x01\
    (\x08R\x0bstarredOnly\x12\x1a\n\x08bookmark\x18\n\x20\x01(\x08R\x08bookm\
    ark\x12\x16\n\x06search\x18\x0e\x20\x01(\tR\x06search\x12\x16\n\x04name\
    \x18\x0c\x20\x01(\tR\x04nameB\x02\x18\x01\x12-\n\x11filter_by_user_id\
    \x18\r\x20\x01(\x08R\x0efilterByUserIdB\x02\x18\x01B\t\n\x07sort_by\"\
    \x80\x01\n\x12PostModulesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x07modules\x18\
    \x03\x20\x03(\x0b2\x14.clarifai.api.ModuleR\x07modules\"\x99\x01\n\x13Pa\
    tchModulesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12.\n\x07modules\x18\x02\x20\x03(\x0b2\
    \x14.clarifai.api.ModuleR\x07modules\x12\x16\n\x06action\x18\x03\x20\x01\
    (\tR\x06action\"d\n\x14DeleteModulesRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\
    \x03ids\x18\x02\x20\x03(\tR\x03ids\"y\n\x14SingleModuleResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12,\n\x06module\x18\x02\x20\x01(\x0b2\x14.clarifai.api.ModuleR\x06mo\
    dule\"\x80\x01\n\x13MultiModuleResponse\x123\n\x06status\x18\x01\x20\x01\
    (\x0b2\x1b.clarifai.api.status.StatusR\x06status\x124\n\x07modules\x18\
    \x02\x20\x03(\x0b2\x14.clarifai.api.ModuleR\x07modulesB\x04\x80\xb5\x18\
    \x01\"\x9e\x01\n\x17GetModuleVersionRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\t\
    module_id\x18\x02\x20\x01(\tR\x08moduleId\x12*\n\x11module_version_id\
    \x18\x03\x20\x01(\tR\x0fmoduleVersionId\"\xa3\x01\n\x19ListModuleVersion\
    sRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08modul\
    eId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x04\x20\x01(\rR\x07perPage\"\xba\x01\n\x19PostModuleVersionsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\x12D\
    \n\x0fmodule_versions\x18\x03\x20\x03(\x0b2\x1b.clarifai.api.ModuleVersi\
    onR\x0emoduleVersions\"\x88\x01\n\x1bDeleteModuleVersionsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\x12\x10\n\
    \x03ids\x18\x03\x20\x03(\tR\x03ids\"\xa8\x01\n!GetModuleVersionUsageCoun\
    tRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08modul\
    eId\x12*\n\x11module_version_id\x18\x03\x20\x01(\tR\x0fmoduleVersionId\"\
    \x96\x01\n\x1bSingleModuleVersionResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12B\n\x0emodule_ve\
    rsion\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.ModuleVersionR\rmoduleVersi\
    on\"\x9d\x01\n\x1aMultiModuleVersionResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12J\n\x0fmodul\
    e_versions\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.ModuleVersionR\x0emodu\
    leVersionsB\x04\x80\xb5\x18\x01\"}\n%SingleModuleVersionUsageCountRespon\
    se\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Status\
    R\x06status\x12\x1f\n\x0busage_count\x18\x02\x20\x01(\rR\nusageCount\"\
    \x9d\x01\n\x20GetInstalledModuleVersionRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12=\n\x1bi\
    nstalled_module_version_id\x18\x02\x20\x01(\tR\x18installedModuleVersion\
    Id\"\x8f\x01\n\"ListInstalledModuleVersionsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\
    \n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\xc2\x01\n\"PostInstalledModuleVersionsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12`\n\x19installed_module_versions\x18\x02\x20\x03(\x0b2$.cla\
    rifai.api.InstalledModuleVersionR\x17installedModuleVersions\"\xa2\x01\n\
    %PostInstalledModuleVersionsKeyRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12=\n\x1binstalled\
    _module_version_id\x18\x02\x20\x01(\tR\x18installedModuleVersionId\"t\n$\
    DeleteInstalledModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\
    \x18\x02\x20\x03(\tR\x03ids\"\xbb\x01\n$SingleInstalledModuleVersionResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12^\n\x18installed_module_version\x18\x02\x20\x01(\x0b2$.\
    clarifai.api.InstalledModuleVersionR\x16installedModuleVersion\"\xc2\x01\
    \n#MultiInstalledModuleVersionResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12f\n\x19installed_modu\
    le_versions\x18\x02\x20\x03(\x0b2$.clarifai.api.InstalledModuleVersionR\
    \x17installedModuleVersionsB\x04\x80\xb5\x18\x01\"u\n\x1eListNextTaskAss\
    ignmentsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\
    \x06taskId\"\x9d\x01\n\x19PostBulkOperationsRequest\x12:\n\x0buser_app_i\
    d\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12D\n\
    \x0fbulk_operations\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.BulkOperation\
    R\x0ebulkOperations\"\x86\x01\n\x19ListBulkOperationsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\"e\n\x17GetBulkOperationRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"j\n\x1aCancelBulkOper\
    ationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\
    j\n\x1aDeleteBulkOperationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\
    \x20\x03(\tR\x03ids\"\x97\x01\n\x1cSingleBulkOperationsResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12B\n\x0ebulk_operation\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.BulkO\
    perationR\rbulkOperation\"\x96\x01\n\x1bMultiBulkOperationsResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12B\n\x0ebulk_operation\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.Bul\
    kOperationR\rbulkOperation\"\x8b\x01\n\x19PutTaskAssignmentsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\x12\x19\n\
    \x08input_id\x18\x03\x20\x01(\tR\x07inputId\"\x85\x01\n\x18ListInputsAdd\
    JobsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"d\n\x16GetInputsA\
    ddJobRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"g\
    \n\x19CancelInputsAddJobRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\
    \x20\x01(\tR\x02id\"\x9a\x01\n\x19MultiInputsAddJobResponse\x123\n\x06st\
    atus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    H\n\x0finputs_add_jobs\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.InputsAddJ\
    obR\rinputsAddJobsB\x04\x80\xb5\x18\x01\"\x93\x01\n\x1aSingleInputsAddJo\
    bResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status\
    .StatusR\x06status\x12@\n\x0einputs_add_job\x18\x02\x20\x01(\x0b2\x1a.cl\
    arifai.api.InputsAddJobR\x0cinputsAddJob\"\x80\x01\n\x12PostUploadsReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12.\n\x07uploads\x18\x02\x20\x03(\x0b2\x14.clarifai.ap\
    i.UploadR\x07uploads\"d\n\x14DeleteUploadsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\
    \n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x7f\n\x12ListUploadsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per\
    _page\x18\x03\x20\x01(\rR\x07perPage\"k\n\x10GetUploadRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12\x1b\n\tupload_id\x18\x02\x20\x01(\tR\x08uploadId\"y\n\x14SingleU\
    ploadResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12,\n\x06upload\x18\x02\x20\x01(\x0b2\x14.clarif\
    ai.api.UploadR\x06upload\"z\n\x13MultiUploadResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12.\n\
    \x07uploads\x18\x02\x20\x03(\x0b2\x14.clarifai.api.UploadR\x07uploads\"\
    \xbd\x01\n\x1cPutUploadContentPartsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tuplo\
    ad_id\x18\x02\x20\x01(\tR\x08uploadId\x12D\n\rcontent_parts\x18\x03\x20\
    \x03(\x0b2\x1f.clarifai.api.UploadContentPartR\x0ccontentParts\"\xda\x01\
    \n\x1cPostInputsDataSourcesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12A\n\x0cdata_sources\
    \x18\x02\x20\x03(\x0b2\x1e.clarifai.api.InputsDataSourceR\x0bdataSources\
    \x12\"\n\rcall_back_url\x18\x03\x20\x01(\tR\x0bcallBackUrl\x12\x17\n\x07\
    app_pat\x18\x04\x20\x01(\tR\x06appPat\"\x94\x01\n\x1dGetInputsExtraction\
    JobRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x127\n\x18inputs_extraction_job_id\x18\x02\x20\
    \x01(\tR\x15inputsExtractionJobId\"\x8c\x01\n\x1fListInputsExtractionJob\
    sRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\
    \x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xaf\x01\n!SingleInpu\
    tsExtractionJobResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12U\n\x15inputs_extraction_job\x18\x02\
    \x20\x01(\x0b2!.clarifai.api.InputsExtractionJobR\x13inputsExtractionJob\
    \"\xb0\x01\n\x20MultiInputsExtractionJobResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12W\n\x16i\
    nputs_extraction_jobs\x18\x02\x20\x03(\x0b2!.clarifai.api.InputsExtracti\
    onJobR\x14inputsExtractionJobs\"q\n!CancelInputsExtractionJobsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x99\x01\n\
    \x18PostInputsUploadsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12A\n\x0einputs_uploads\x18\
    \x02\x20\x03(\x0b2\x1a.clarifai.api.InputsUploadR\rinputsUploads\"k\n\
    \x10GetRunnerRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\trunner_id\x18\x02\x20\x01(\
    \tR\x08runnerId\"\x7f\n\x12ListRunnersRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\x80\x01\n\x12PostRunnersRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\
    \n\x07runners\x18\x03\x20\x03(\x0b2\x14.clarifai.api.RunnerR\x07runners\
    \"d\n\x14DeleteRunnersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\
    \x03(\tR\x03ids\"y\n\x14SingleRunnerResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12,\n\x06runne\
    r\x18\x02\x20\x01(\x0b2\x14.clarifai.api.RunnerR\x06runner\"\x80\x01\n\
    \x13MultiRunnerResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x124\n\x07runners\x18\x02\x20\x03(\x0b2\
    \x14.clarifai.api.RunnerR\x07runnersB\x04\x80\xb5\x18\x01\"q\n\x16ListRu\
    nnerItemsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x1b\n\trunner_id\x18\x02\x20\x01(\tR\
    \x08runnerId\"\xe0\x01\n\x1cPostRunnerItemOutputsRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1b\n\trunner_id\x18\x02\x20\x01(\tR\x08runnerId\x12\x17\n\x07item_\
    id\x18\x03\x20\x01(\tR\x06itemId\x12N\n\x13runner_item_outputs\x18\x04\
    \x20\x03(\x0b2\x1e.clarifai.api.RunnerItemOutputR\x11runnerItemOutputs\"\
    \x84\x01\n\x17MultiRunnerItemResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x124\n\x05items\x18\x02\
    \x20\x03(\x0b2\x18.clarifai.api.RunnerItemR\x05itemsB\x04\x80\xb5\x18\
    \x01\"\xa2\x01\n\nRunnerItem\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12b\n\x1ap\
    ost_model_outputs_request\x18\x03\x20\x01(\x0b2%.clarifai.api.PostModelO\
    utputsRequestR\x17postModelOutputsRequest\"i\n\x10RunnerItemOutput\x12U\
    \n\x15multi_output_response\x18\x01\x20\x01(\x0b2!.clarifai.api.MultiOut\
    putResponseR\x13multiOutputResponse\"\xaa\x01\n\x1dMultiRunnerItemOutput\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x12T\n\x13runner_item_outputs\x18\x02\x20\x03(\x0b2\
    \x1e.clarifai.api.RunnerItemOutputR\x11runnerItemOutputsB\x04\x80\xb5\
    \x18\x01\"\xfc\x01\n,PostModelVersionsTrainingTimeEstimateRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12A\n\x0em\
    odel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\rmode\
    lVersions\x122\n\x15estimated_input_count\x18\x04\x20\x01(\x04R\x13estim\
    atedInputCount\"\xab\x01\n!MultiTrainingTimeEstimateResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12Q\n\x17training_time_estimates\x18\x02\x20\x03(\x0b2\x19.google.prot\
    obuf.DurationR\x15trainingTimeEstimates*p\n\x1cOrganizationInvitationSta\
    tus\x12\x0b\n\x07NOT_SET\x10\0\x12\x0b\n\x07PENDING\x10\x01\x12\x0c\n\
    \x08ACCEPTED\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\x0c\n\x08DECLINED\
    \x10\x04\x12\x0b\n\x07EXPIRED\x10\x052\xe8\x8f\x03\n\x02V2\x12\xae\x02\n\
    \x14ListConceptRelations\x12).clarifai.api.ListConceptRelationsRequest\
    \x1a*.clarifai.api.MultiConceptRelationResponse\"\xbe\x01\x98\x9c'\x05\
    \x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\xab\x01\x12Y/v2/users/{user_\
    app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relation\
    sZN\x12L/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concep\
    ts/relations\x12\xe3\x01\n\x14PostConceptRelations\x12).clarifai.api.Pos\
    tConceptRelationsRequest\x1a*.clarifai.api.MultiConceptRelationResponse\
    \"t\x98\x9c'\x05\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02^\
    \"Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{c\
    oncept_id}/relations:\x01*\x12\xe2\x01\n\x16DeleteConceptRelations\x12+.\
    clarifai.api.DeleteConceptRelationsRequest\x1a!.clarifai.api.status.Base\
    Response\"x\x98\x9c'\x05\x90\x9c'-\x90\x9c'\r\x90\x9c'\n\x90\x9c'\x0b\
    \x82\xd3\xe4\x93\x02^*Y/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/concepts/{concept_id}/relations:\x01*\x12\xe0\x01\n\x10GetConce\
    ptCounts\x12%.clarifai.api.GetConceptCountsRequest\x1a'.clarifai.api.Mul\
    tiConceptCountResponse\"|\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x05\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/concepts/statusZ\x15\x12\x13/v2/concepts/status\
    \x12\xd5\x01\n\nGetConcept\x12\x1f.clarifai.api.GetConceptRequest\x1a#.c\
    larifai.api.SingleConceptResponse\"\x80\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x82\xd3\xe4\x93\x02n\x12O/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/concepts/{concept_id}Z\x1b\x12\x19/v2/concepts/{con\
    cept_id}\x12\xbd\x01\n\x0cListConcepts\x12!.clarifai.api.ListConceptsReq\
    uest\x1a\".clarifai.api.MultiConceptResponse\"f\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0b\x82\xd3\xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/conceptsZ\x0e\x12\x0c/v2/concepts\x12\xbd\x02\n\
    \x11ListModelConcepts\x12&.clarifai.api.ListModelConceptsRequest\x1a\".c\
    larifai.api.MultiConceptResponse\"\xdb\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xc4\x01\x12T/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/conceptsZl\
    \x12j/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{m\
    odel_id}/versions/{version_id}/concepts\x12\xee\x01\n\x14PostConceptsSea\
    rches\x12).clarifai.api.PostConceptsSearchesRequest\x1a\".clarifai.api.M\
    ultiConceptResponse\"\x86\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\
    \x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02l\"K/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/concepts/searches:\x01*Z\x1a\"\x15/v2/co\
    ncepts/searches:\x01*\x12\xc7\x01\n\x0cPostConcepts\x12!.clarifai.api.Po\
    stConceptsRequest\x1a\".clarifai.api.MultiConceptResponse\"p\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02Z\"B/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/concepts:\x01*Z\x11\"\
    \x0c/v2/concepts:\x01*\x12\xc9\x01\n\rPatchConcepts\x12\".clarifai.api.P\
    atchConceptsRequest\x1a\".clarifai.api.MultiConceptResponse\"p\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02Z2B/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/concepts:\x01*Z\x112\x0c/\
    v2/concepts:\x01*\x12\x98\x02\n\x12GetConceptLanguage\x12'.clarifai.api.\
    GetConceptLanguageRequest\x1a+.clarifai.api.SingleConceptLanguageRespons\
    e\"\xab\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\x98\
    \x01\x12d/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/conce\
    pts/{concept_id}/languages/{language}Z0\x12./v2/concepts/{concept_id}/la\
    nguages/{language}\x12\x85\x02\n\x14ListConceptLanguages\x12).clarifai.a\
    pi.ListConceptLanguagesRequest\x1a*.clarifai.api.MultiConceptLanguageRes\
    ponse\"\x95\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\
    \x82\x01\x12Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/c\
    oncepts/{concept_id}/languagesZ%\x12#/v2/concepts/{concept_id}/languages\
    \x12\x8f\x02\n\x14PostConceptLanguages\x12).clarifai.api.PostConceptLang\
    uagesRequest\x1a*.clarifai.api.MultiConceptLanguageResponse\"\x9f\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\x88\
    \x01\"Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concept\
    s/{concept_id}/languages:\x01*Z(\"#/v2/concepts/{concept_id}/languages:\
    \x01*\x12\x91\x02\n\x15PatchConceptLanguages\x12*.clarifai.api.PatchConc\
    eptLanguagesRequest\x1a*.clarifai.api.MultiConceptLanguageResponse\"\x9f\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\
    \x88\x012Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/conc\
    epts/{concept_id}/languages:\x01*Z(2#/v2/concepts/{concept_id}/languages\
    :\x01*\x12\xf5\x01\n\x13ListKnowledgeGraphs\x12(.clarifai.api.ListKnowle\
    dgeGraphsRequest\x1a).clarifai.api.MultiKnowledgeGraphResponse\"\x88\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02v\x12S/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graph\
    sZ\x1f\x12\x1d/v2/concepts/knowledge_graphs\x12\xff\x01\n\x13PostKnowled\
    geGraphs\x12(.clarifai.api.PostKnowledgeGraphsRequest\x1a).clarifai.api.\
    MultiKnowledgeGraphResponse\"\x92\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\
    \x90\x9c'\x0b\x82\xd3\xe4\x93\x02|\"S/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/concepts/knowledge_graphs:\x01*Z\"\"\x1d/v2/conce\
    pts/knowledge_graphs:\x01*\x12\x82\x02\n\x16PostConceptMappingJobs\x12+.\
    clarifai.api.PostConceptMappingJobsRequest\x1a,.clarifai.api.MultiConcep\
    tMappingJobResponse\"\x8c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\
    \x0b\x82\xd3\xe4\x93\x02v\"P/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/concepts/mappings/jobs:\x01*Z\x1f\"\x1a/v2/concepts/mappin\
    gs/jobs:\x01*\x12\x97\x02\n\rGetAnnotation\x12\".clarifai.api.GetAnnotat\
    ionRequest\x1a&.clarifai.api.SingleAnnotationResponse\"\xb9\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\
    \x9e\x01\x12g/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/i\
    nputs/{input_id}/annotations/{annotation_id}Z3\x121/v2/inputs/{input_id}\
    /annotations/{annotation_id}\x12\xd4\x01\n\x0fListAnnotations\x12$.clari\
    fai.api.ListAnnotationsRequest\x1a%.clarifai.api.MultiAnnotationResponse\
    \"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\
    \xe4\x93\x02Z\x12E/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/annotationsZ\x11\x12\x0f/v2/annotations\x12\xe7\x01\n\x0fPostAnnotat\
    ions\x12$.clarifai.api.PostAnnotationsRequest\x1a%.clarifai.api.MultiAnn\
    otationResponse\"\x86\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x90\x9c'%\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02`\"\
    E/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations:\
    \x01*Z\x14\"\x0f/v2/annotations:\x01*\x12\xe9\x01\n\x10PatchAnnotations\
    \x12%.clarifai.api.PatchAnnotationsRequest\x1a%.clarifai.api.MultiAnnota\
    tionResponse\"\x86\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x90\x9c'%\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02`2E/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations:\x01*Z\
    \x142\x0f/v2/annotations:\x01*\x12\xf8\x01\n\x16PatchAnnotationsStatus\
    \x12+.clarifai.api.PatchAnnotationsStatusRequest\x1a,.clarifai.api.Patch\
    AnnotationsStatusResponse\"\x82\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02`2[/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task/{task_id}/ann\
    otations/status:\x01*\x12\xa0\x02\n\x10DeleteAnnotation\x12%.clarifai.ap\
    i.DeleteAnnotationRequest\x1a!.clarifai.api.status.BaseResponse\"\xc1\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x9e\x01*g/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_i\
    d}Z3*1/v2/inputs/{input_id}/annotations/{annotation_id}\x12\xd4\x02\n\
    \x11DeleteAnnotations\x12&.clarifai.api.DeleteAnnotationsRequest\x1a!.cl\
    arifai.api.status.BaseResponse\"\xf3\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    %\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xd0\
    \x01*L/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/a\
    nnotations:\x01*Z\x1b*\x16/v2/inputs/annotations:\x01*ZJ*E/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/annotations:\x01*Z\x14*\x0f/\
    v2/annotations:\x01*\x12\xf7\x01\n\x18PatchAnnotationsSearches\x12-.clar\
    ifai.api.PatchAnnotationsSearchesRequest\x1a!.clarifai.api.MultiSearchRe\
    sponse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\xe4\
    \x93\x02r2N/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/ann\
    otations/searches:\x01*Z\x1d2\x18/v2/annotations/searches:\x01*\x12\x85\
    \x02\n\x17PostAnnotationsSearches\x12,.clarifai.api.PostAnnotationsSearc\
    hesRequest\x1a!.clarifai.api.MultiSearchResponse\"\x98\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02r\"N/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/annotations/searches:\x01*Z\x1d\"\x18/v2/annotati\
    ons/searches:\x01*\x12\xf1\x01\n\x15ListAnnotationWorkers\x12*.clarifai.\
    api.ListAnnotationWorkersRequest\x1a!.clarifai.api.MultiWorkerResponse\"\
    \x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'2\x90\x9c'\x0f\x90\x9c\
    '\x13\x82\xd3\xe4\x93\x02j\x12M/v2/users/{user_app_id.user_id}/apps/{use\
    r_app_id.app_id}/annotations/workersZ\x19\x12\x17/v2/annotations/workers\
    \x12\xd5\x01\n\rGetInputCount\x12\".clarifai.api.GetInputCountRequest\
    \x1a&.clarifai.api.SingleInputCountResponse\"x\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02^\x12G/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/statusZ\x13\x12\
    \x11/v2/inputs/status\x12\xcd\x01\n\x0cStreamInputs\x12!.clarifai.api.St\
    reamInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"x\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02^\
    \x12G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/st\
    reamZ\x13\x12\x11/v2/inputs/stream\x12\x81\x02\n\x0fGetInputSamples\x12$\
    .clarifai.api.GetInputSamplesRequest\x1a*.clarifai.api.MultiInputAnnotat\
    ionResponse\"\x9b\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x82\xd3\xe4\x93\x02\x80\x01\x12X/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/samplesZ$\x12\"/v2/ta\
    sks/{task_id}/inputs/samples\x12\xcf\x01\n\x08GetInput\x12\x1d.clarifai.\
    api.GetInputRequest\x1a!.clarifai.api.SingleInputResponse\"\x80\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\
    \x02f\x12K/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inpu\
    ts/{input_id}Z\x17\x12\x15/v2/inputs/{input_id}\x12\x80\x02\n\x15GetInpu\
    tVideoManifest\x12%.clarifai.api.GetVideoManifestRequest\x1a&.clarifai.a\
    pi.GetVideoManifestResponse\"\x97\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x05\x82\xd3\xe4\x93\x02\x84\x01\x12Z/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/inputs/{input_id}/video_manifestZ&\x12$/v2/inputs\
    /{input_id}/video_manifest\x12\xbb\x01\n\nListInputs\x12\x1f.clarifai.ap\
    i.ListInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"j\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02P\
    \x12@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputsZ\
    \x0c\x12\n/v2/inputs\x12\xd6\x01\n\nPostInputs\x12\x1f.clarifai.api.Post\
    InputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"\x84\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\
    \x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02V\"@/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs:\x01*Z\x0f\"\
    \n/v2/inputs:\x01*\x12\xcf\x01\n\x0bPatchInputs\x12\x20.clarifai.api.Pat\
    chInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"|\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02V2@/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/inputs:\x01*Z\x0f2\n/v2/inputs:\x01*\x12\xe9\x01\n\
    \x0bDeleteInput\x12\x20.clarifai.api.DeleteInputRequest\x1a!.clarifai.ap\
    i.status.BaseResponse\"\x94\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c\
    '(\x90\x9c'&\x90\x9c'\x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c\
    '\x13\x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/inputs/{input_id}Z\x17*\x15/v2/inputs/{input_id}\x12\xdb\
    \x01\n\x0cDeleteInputs\x12!.clarifai.api.DeleteInputsRequest\x1a!.clarif\
    ai.api.status.BaseResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\
    \x90\x9c'(\x90\x9c'&\x90\x9c'\x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02V*@/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/inputs:\x01*Z\x0f*\n/v2/inputs:\x01*\x12\xe2\x01\n\
    \x13PatchInputsSearches\x12(.clarifai.api.PatchInputsSearchesRequest\x1a\
    !.clarifai.api.MultiSearchResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c's\
    \x90\x9c'r\x82\xd3\xe4\x93\x02h2I/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/inputs/searches:\x01*Z\x182\x13/v2/inputs/searches:\
    \x01*\x12\xf1\x01\n\x12PostInputsSearches\x12'.clarifai.api.PostInputsSe\
    archesRequest\x1a!.clarifai.api.MultiSearchResponse\"\x8e\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\
    \x03\x90\x9c'\x13\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}\
    /apps/{user_app_id.app_id}/inputs/searches:\x01*Z\x18\"\x13/v2/inputs/se\
    arches:\x01*\x12\xa0\x03\n\x10PostModelOutputs\x12%.clarifai.api.PostMod\
    elOutputsRequest\x1a!.clarifai.api.MultiOutputResponse\"\xc1\x02\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x02\x82\xd3\xe4\x93\
    \x02\xa6\x02\"i/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /models/{model_id}/versions/{version_id}/outputs:\x01*Z8\"3/v2/models/{m\
    odel_id}/versions/{version_id}/outputs:\x01*ZX\"S/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/models/{model_id}/outputs:\x01*Z\"\"\
    \x1d/v2/models/{model_id}/outputs:\x01*\x12\xef\x01\n\x0cListDatasets\
    \x12!.clarifai.api.ListDatasetsRequest\x1a\".clarifai.api.MultiDatasetRe\
    sponse\"\x97\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\
    \x93\x02\x80\x01\x12B/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/datasetsZ*\x12(/v2/users/{user_app_id.user_id}/datasetsZ\x0e\x12\
    \x0c/v2/datasets\x12\xd9\x01\n\nGetDataset\x12\x1f.clarifai.api.GetDatas\
    etRequest\x1a#.clarifai.api.SingleDatasetResponse\"\x84\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02n\x12O/v2/users/{user_\
    app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}Z\x1b\x12\
    \x19/v2/datasets/{dataset_id}\x12\xcb\x01\n\x0cPostDatasets\x12!.clarifa\
    i.api.PostDatasetsRequest\x1a\".clarifai.api.MultiDatasetResponse\"t\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'r\x82\xd3\xe4\x93\x02Z\"\
    B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets:\x01\
    *Z\x11\"\x0c/v2/datasets:\x01*\x12\xcd\x01\n\rPatchDatasets\x12\".clarif\
    ai.api.PatchDatasetsRequest\x1a\".clarifai.api.MultiDatasetResponse\"t\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'r\x82\xd3\xe4\x93\
    \x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/dataset\
    s:\x01*Z\x112\x0c/v2/datasets:\x01*\x12\xce\x01\n\x0eDeleteDatasets\x12#\
    .clarifai.api.DeleteDatasetsRequest\x1a!.clarifai.api.status.BaseRespons\
    e\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'k\x82\xd3\xe4\
    \x93\x02Z*B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/dat\
    asets:\x01*Z\x11*\x0c/v2/datasets:\x01*\x12\x81\x02\n\x11ListDatasetInpu\
    ts\x12&.clarifai.api.ListDatasetInputsRequest\x1a'.clarifai.api.MultiDat\
    asetInputResponse\"\x9a\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\
    \x05\x90\x9c'&\x90\x9c'\x0b\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputsZ\"\
    \x12\x20/v2/datasets/{dataset_id}/inputs\x12\x95\x02\n\x0fGetDatasetInpu\
    t\x12$.clarifai.api.GetDatasetInputRequest\x1a(.clarifai.api.SingleDatas\
    etInputResponse\"\xb1\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\x05\
    \x90\x9c'&\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_\
    app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs/{\
    input_id}Z-\x12+/v2/datasets/{dataset_id}/inputs/{input_id}\x12\x8c\x02\
    \n\x11PostDatasetInputs\x12&.clarifai.api.PostDatasetInputsRequest\x1a'.\
    clarifai.api.MultiDatasetInputResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'i\x90\x9c'j\x90\x9c'\x05\x90\x9c'&\x90\x9c'\x0b\x82\xd3\xe4\x93\
    \x02\x82\x01\"V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /datasets/{dataset_id}/inputs:\x01*Z%\"\x20/v2/datasets/{dataset_id}/inp\
    uts:\x01*\x12\x86\x02\n\x13DeleteDatasetInputs\x12(.clarifai.api.DeleteD\
    atasetInputsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'k\x90\x9c'\x05\x82\xd3\
    \xe4\x93\x02\x82\x01*V/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/datasets/{dataset_id}/inputs:\x01*Z%*\x20/v2/datasets/{dataset_i\
    d}/inputs:\x01*\x12\x84\x02\n\x13ListDatasetVersions\x12(.clarifai.api.L\
    istDatasetVersionsRequest\x1a).clarifai.api.MultiDatasetVersionResponse\
    \"\x97\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\
    \x02\x80\x01\x12X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_i\
    d}/datasets/{dataset_id}/versionsZ$\x12\"/v2/datasets/{dataset_id}/versi\
    ons\x12\xab\x02\n\x11GetDatasetVersion\x12&.clarifai.api.GetDatasetVersi\
    onRequest\x1a*.clarifai.api.SingleDatasetVersionResponse\"\xc1\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02\xaa\x01\x12m\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{data\
    set_id}/versions/{dataset_version_id}Z9\x127/v2/datasets/{dataset_id}/ve\
    rsions/{dataset_version_id}\x12\xea\x02\n\x1fListDatasetVersionMetricsGr\
    oups\x124.clarifai.api.ListDatasetVersionMetricsGroupsRequest\x1a5.clari\
    fai.api.MultiDatasetVersionMetricsGroupResponse\"\xd9\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'i\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\
    \x02\xba\x01\x12u/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_i\
    d}/datasets/{dataset_id}/versions/{dataset_version_id}/metricsZA\x12?/v2\
    /datasets/{dataset_id}/versions/{dataset_version_id}/metrics\x12\x92\x02\
    \n\x13PostDatasetVersions\x12(.clarifai.api.PostDatasetVersionsRequest\
    \x1a).clarifai.api.MultiDatasetVersionResponse\"\xa5\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02\x86\x01\"X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /datasets/{dataset_id}/versions:\x01*Z'\"\"/v2/datasets/{dataset_id}/ver\
    sions:\x01*\x12\x8c\x02\n\x14PatchDatasetVersions\x12).clarifai.api.Patc\
    hDatasetVersionsRequest\x1a).clarifai.api.MultiDatasetVersionResponse\"\
    \x9d\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x82\xd3\xe4\x93\x02\
    \x86\x012X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/data\
    sets/{dataset_id}/versions:\x01*Z'2\"/v2/datasets/{dataset_id}/versions:\
    \x01*\x12\x8a\x02\n\x15DeleteDatasetVersions\x12*.clarifai.api.DeleteDat\
    asetVersionsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'k\x82\xd3\xe4\x93\x02\
    \x86\x01*X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/data\
    sets/{dataset_id}/versions:\x01*Z'*\"/v2/datasets/{dataset_id}/versions:\
    \x01*\x12\xd4\x02\n\x18PutDatasetVersionExports\x12-.clarifai.api.PutDat\
    asetVersionExportsRequest\x1a/.clarifai.api.MultiDatasetVersionExportRes\
    ponse\"\xd7\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x82\xd3\xe4\
    \x93\x02\xc0\x01\x1au/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/datasets/{dataset_id}/versions/{dataset_version_id}/exports:\x01*\
    ZD\x1a?/v2/datasets/{dataset_id}/versions/{dataset_version_id}/exports:\
    \x01*\x12\xe9\x01\n\x0cGetModelType\x12!.clarifai.api.GetModelTypeReques\
    t\x1a%.clarifai.api.SingleModelTypeResponse\"\x8e\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/models/types/{model_type_id}Z\"\x12\x20/v\
    2/models/types/{model_type_id}\x12\x99\x01\n\x16ListOpenSourceLicenses\
    \x12+.clarifai.api.ListOpenSourceLicensesRequest\x1a,.clarifai.api.ListO\
    penSourceLicensesResponse\"$\x98\x9c'\x01\x82\xd3\xe4\x93\x02\x1a\x12\
    \x18/v2/open_source_licenses\x12\xcb\x01\n\x0eListModelTypes\x12#.clarif\
    ai.api.ListModelTypesRequest\x1a$.clarifai.api.MultiModelTypeResponse\"n\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\\\x12F/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/models/typesZ\x12\x12\
    \x10/v2/models/types\x12\xca\x01\n\x08GetModel\x12\x1d.clarifai.api.GetM\
    odelRequest\x1a!.clarifai.api.SingleModelResponse\"|\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02f\x12K/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}Z\x17\x12\
    \x15/v2/models/{model_id}\x12\x9a\x03\n\x12GetModelOutputInfo\x12\x1d.cl\
    arifai.api.GetModelRequest\x1a!.clarifai.api.SingleModelResponse\"\xc1\
    \x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02\xaa\x02\x12W/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_i\
    d}/models/{model_id}/output_infoZ#\x12!/v2/models/{model_id}/output_info\
    Zo\x12m/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/\
    {model_id}/versions/{version_id}/output_infoZ9\x127/v2/models/{model_id}\
    /versions/{version_id}/output_info\x12\xe2\x01\n\nListModels\x12\x1f.cla\
    rifai.api.ListModelsRequest\x1a\x20.clarifai.api.MultiModelResponse\"\
    \x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02z\x12@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    modelsZ(\x12&/v2/users/{user_app_id.user_id}/modelsZ\x0c\x12\n/v2/models\
    \x12\xeb\x01\n\x11GetResourceCounts\x12&.clarifai.api.GetResourceCountsR\
    equest\x1a'.clarifai.api.GetResourceCountsResponse\"\x84\x01\x98\x9c'\
    \x02\x90\x9c'i\x90\x9c'\x0f\x90\x9c'\x13\x90\x9c'm\x90\x9c'-\x90\x9c'\
    \x05\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/resource_countsZ\x15\x12\x13/v2/resource_counts\x12\xdf\
    \x01\n\x12PostModelsSearches\x12'.clarifai.api.PostModelsSearchesRequest\
    \x1a\x20.clarifai.api.MultiModelResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/models/searches:\x01*Z\x18\"\x13/v2/mode\
    ls/searches:\x01*\x12\xca\x01\n\nPostModels\x12\x1f.clarifai.api.PostMod\
    elsRequest\x1a!.clarifai.api.SingleModelResponse\"x\x98\x9c'\x02\x90\x9c\
    '-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02V\"@/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/models:\x01*Z\x0f\"\n/v2/models:\x01*\x12\xc7\x01\n\x0bPatchModels\
    \x12\x20.clarifai.api.PatchModelsRequest\x1a\x20.clarifai.api.MultiModel\
    Response\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\
    \x0f\x90\x9c'\x1a\x82\xd3\xe4\x93\x02V2@/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/models:\x01*Z\x0f2\n/v2/models:\x01*\x12\xb6\
    \x01\n\rPatchModelIds\x12\".clarifai.api.PatchModelIdsRequest\x1a\x20.cl\
    arifai.api.MultiModelResponse\"_\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0e\x90\
    \x9c'\x0f\x82\xd3\xe4\x93\x02I2D/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/models/ids:\x01*\x12\xdd\x01\n\x0bDeleteModel\x12\x20.\
    clarifai.api.DeleteModelRequest\x1a!.clarifai.api.status.BaseResponse\"\
    \x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\
    \x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/models/{model_id}Z\x17*\x15/v2/models\
    /{model_id}\x12\xce\x01\n\x0cDeleteModels\x12!.clarifai.api.DeleteModels\
    Request\x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02V*@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/models:\x01*Z\x0f*\n/v2/models:\x01*\x12\x95\x02\n\x17PatchModelChe\
    ckConsents\x12,.clarifai.api.PatchModelCheckConsentsRequest\x1a,.clarifa\
    i.api.MultiModelCheckConsentResponse\"\x9d\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x8a\x012Z/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/models/{model_id}/check_consents:\x01*Z)2$/\
    v2/models/{model_id}/check_consents:\x01*\x12\xf9\x01\n\x12PatchModelToo\
    lkits\x12'.clarifai.api.PatchModelToolkitsRequest\x1a'.clarifai.api.Mult\
    iModelToolkitResponse\"\x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\
    \xd3\xe4\x93\x02~2T/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/models/{model_id}/toolkits:\x01*Z#2\x1e/v2/models/{model_id}/toolki\
    ts:\x01*\x12\xf9\x01\n\x12PatchModelUseCases\x12'.clarifai.api.PatchMode\
    lUseCasesRequest\x1a'.clarifai.api.MultiModelUseCaseResponse\"\x90\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02~2T/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/usecases:\
    \x01*Z#2\x1e/v2/models/{model_id}/usecases:\x01*\x12\xff\x01\n\x13PatchM\
    odelLanguages\x12(.clarifai.api.PatchModelLanguagesRequest\x1a(.clarifai\
    .api.MultiModelLanguageResponse\"\x93\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c\
    '\x0f\x82\xd3\xe4\x93\x02\x80\x012U/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/models/{model_id}/languages:\x01*Z$2\x1f/v2/models/\
    {model_id}/languages:\x01*\x12\x94\x03\n\x0fListModelInputs\x12$.clarifa\
    i.api.ListModelInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"\
    \xb8\x02\x88\x02\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x96\x02\x12R/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/inputsZ\x1e\
    \x12\x1c/v2/models/{model_id}/inputsZj\x12h/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/inp\
    utsZ4\x122/v2/models/{model_id}/versions/{version_id}/inputs\x12\x8d\x02\
    \n\x0fGetModelVersion\x12$.clarifai.api.GetModelVersionRequest\x1a(.clar\
    ifai.api.SingleModelVersionResponse\"\xa9\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{ver\
    sion_id}Z-\x12+/v2/models/{model_id}/versions/{version_id}\x12\xf5\x01\n\
    \x11ListModelVersions\x12&.clarifai.api.ListModelVersionsRequest\x1a'.cl\
    arifai.api.MultiModelVersionResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02x\x12T/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versionsZ\x20\
    \x12\x1e/v2/models/{model_id}/versions\x12\xbc\x02\n\x1dPostWorkflowVers\
    ionsUnPublish\x122.clarifai.api.PostWorkflowVersionsUnPublishRequest\x1a\
    !.clarifai.api.status.BaseResponse\"\xc3\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'x\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x8c\x01\"\
    [/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{wo\
    rkflow_id}/unpublish:\x01*Z*\"%/v2/workflows/{workflow_id}/unpublish:\
    \x01*\x12\xb4\x02\n\x1bPostWorkflowVersionsPublish\x120.clarifai.api.Pos\
    tWorkflowVersionsPublishRequest\x1a!.clarifai.api.status.BaseResponse\"\
    \xbf\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'w\x90\x9c'&\x90\x9c'\x0b\x90\x9c\
    '\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\
    \x9c'6\x82\xd3\xe4\x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/workflows/{workflow_id}/publish:\x01*Z(\"#/v2/wor\
    kflows/{workflow_id}/publish:\x01*\x12\xa1\x02\n\x18PostModelVersionsPub\
    lish\x12-.clarifai.api.PostModelVersionsPublishRequest\x1a!.clarifai.api\
    .status.BaseResponse\"\xb2\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'u\x90\x9c'\
    &\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\
    \x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02|\"S/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/publish:\x01*Z\
    \"\"\x1d/v2/models/{model_id}/publish:\x01*\x12\xaa\x02\n\x1aPostModelVe\
    rsionsUnPublish\x12/.clarifai.api.PostModelVersionsUnPublishRequest\x1a!\
    .clarifai.api.status.BaseResponse\"\xb7\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'v\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x80\x01\"\
    U/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model\
    _id}/unpublish:\x01*Z$\"\x1f/v2/models/{model_id}/unpublish:\x01*\x12\
    \x91\x02\n\x11PostModelVersions\x12&.clarifai.api.PostModelVersionsReque\
    st\x1a!.clarifai.api.SingleModelResponse\"\xb0\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\
    \x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02~\"T/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/version\
    s:\x01*Z#\"\x1e/v2/models/{model_id}/versions:\x01*\x12\xdf\x01\n\x12Pat\
    chModelVersions\x12'.clarifai.api.PatchModelVersionsRequest\x1a'.clarifa\
    i.api.MultiModelVersionResponse\"w\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\
    \x90\x9c'\x0f\x90\x9c'\x0e\x90\x9c'\x1a\x82\xd3\xe4\x93\x02Y2T/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versio\
    ns:\x01*\x12\x98\x02\n\x12DeleteModelVersion\x12'.clarifai.api.DeleteMod\
    elVersionRequest\x1a!.clarifai.api.status.BaseResponse\"\xb5\x01\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02\x92\x01*a/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}Z-*+/v2/\
    models/{model_id}/versions/{version_id}\x12\xb7\x02\n\x16GetModelVersion\
    Metrics\x12+.clarifai.api.GetModelVersionMetricsRequest\x1a(.clarifai.ap\
    i.SingleModelVersionResponse\"\xc5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\
    \xa2\x01\x12i/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/m\
    odels/{model_id}/versions/{version_id}/metricsZ5\x123/v2/models/{model_i\
    d}/versions/{version_id}/metrics\x12\xd3\x02\n\x17PostModelVersionMetric\
    s\x12,.clarifai.api.PostModelVersionMetricsRequest\x1a(.clarifai.api.Sin\
    gleModelVersionResponse\"\xdf\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\xa8\x01\"i/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/\
    versions/{version_id}/metrics:\x01*Z8\"3/v2/models/{model_id}/versions/{\
    version_id}/metrics:\x01*\x12\xed\x02\n\x1bPostModelVersionEvaluations\
    \x120.clarifai.api.PostModelVersionEvaluationsRequest\x1a&.clarifai.api.\
    MultiEvalMetricsResponse\"\xf3\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\xbc\x01\"s/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/\
    versions/{model_version_id}/evaluations:\x01*ZB\"=/v2/models/{model_id}/\
    versions/{model_version_id}/evaluations:\x01*\x12\xd3\x02\n\x1bListModel\
    VersionEvaluations\x120.clarifai.api.ListModelVersionEvaluationsRequest\
    \x1a&.clarifai.api.MultiEvalMetricsResponse\"\xd9\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\
    \xd3\xe4\x93\x02\xb6\x01\x12s/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/models/{model_id}/versions/{model_version_id}/evaluations\
    Z?\x12=/v2/models/{model_id}/versions/{model_version_id}/evaluations\x12\
    \xf1\x02\n\x19GetModelVersionEvaluation\x12..clarifai.api.GetModelVersio\
    nEvaluationRequest\x1a'.clarifai.api.SingleEvalMetricsResponse\"\xfa\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\
    \x90\x9c'5\x82\xd3\xe4\x93\x02\xd7\x01\x12\x83\x01/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_ve\
    rsion_id}/evaluations/{evaluation_id}ZO\x12M/v2/models/{model_id}/versio\
    ns/{model_version_id}/evaluations/{evaluation_id}\x12\xf8\x01\n\x0fPostE\
    valuations\x12$.clarifai.api.PostEvaluationsRequest\x1a&.clarifai.api.Mu\
    ltiEvalMetricsResponse\"\x96\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02`\"E/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations:\x01*Z\x14\"\
    \x0f/v2/evaluations:\x01*\x12\x8e\x02\n\x0fListEvaluations\x12$.clarifai\
    .api.ListEvaluationsRequest\x1a&.clarifai.api.MultiEvalMetricsResponse\"\
    \xac\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\
    \x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\x89\x01\x12E/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/evaluationsZ-\x12+/v2/users/{user_\
    app_id.user_id}/evaluationsZ\x11\x12\x0f/v2/evaluations\x12\xfb\x01\n\rG\
    etEvaluation\x12\".clarifai.api.GetEvaluationRequest\x1a'.clarifai.api.S\
    ingleEvalMetricsResponse\"\x9c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02z\x12U/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations/{ev\
    aluation_id}Z!\x12\x1f/v2/evaluations/{evaluation_id}\x12\xfb\x01\n\x13L\
    istModelReferences\x12(.clarifai.api.ListModelReferencesRequest\x1a).cla\
    rifai.api.MultiModelReferenceResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/models/{model_id}/referencesZ\"\x12\x20/v2/mode\
    ls/{model_id}/references\x12\xf2\x02\n\x1bGetModelVersionInputExample\
    \x120.clarifai.api.GetModelVersionInputExampleRequest\x1a4.clarifai.api.\
    SingleModelVersionInputExampleResponse\"\xea\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xd7\x01\x12\x83\x01/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model\
    _version_id}/input_examples/{example_id}ZO\x12M/v2/models/{model_id}/ver\
    sions/{model_version_id}/input_examples/{example_id}\x12\xda\x02\n\x1dLi\
    stModelVersionInputExamples\x122.clarifai.api.ListModelVersionInputExamp\
    lesRequest\x1a3.clarifai.api.MultiModelVersionInputExampleResponse\"\xcf\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xbc\x01\x12\
    v/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model\
    _id}/versions/{model_version_id}/input_examplesZB\x12@/v2/models/{model_\
    id}/versions/{model_version_id}/input_examples\x12\xe0\x01\n\x0bGetWorkf\
    low\x12\x20.clarifai.api.GetWorkflowRequest\x1a$.clarifai.api.SingleWork\
    flowResponse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\
    \x82\xd3\xe4\x93\x02r\x12Q/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/workflows/{workflow_id}Z\x1d\x12\x1b/v2/workflows/{workflow_\
    id}\x12\xf5\x01\n\rListWorkflows\x12\".clarifai.api.ListWorkflowsRequest\
    \x1a#.clarifai.api.MultiWorkflowResponse\"\x9a\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x83\x01\x12C/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/workflowsZ+\x12)/v2/users/\
    {user_app_id.user_id}/workflowsZ\x0f\x12\r/v2/workflows\x12\xd0\x01\n\rP\
    ostWorkflows\x12\".clarifai.api.PostWorkflowsRequest\x1a#.clarifai.api.M\
    ultiWorkflowResponse\"v\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x12\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02\\\"C/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/workflows:\x01*Z\x12\"\r/v2/workflows:\x01*\x12\
    \xd2\x01\n\x0ePatchWorkflows\x12#.clarifai.api.PatchWorkflowsRequest\x1a\
    #.clarifai.api.MultiWorkflowResponse\"v\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\xe4\x93\x02\\2C/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/workflows:\x01*Z\x122\r/v2/workf\
    lows:\x01*\x12\xc2\x01\n\x10PatchWorkflowIds\x12%.clarifai.api.PatchWork\
    flowIdsRequest\x1a#.clarifai.api.MultiWorkflowResponse\"b\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\xe4\x93\x02L2G/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/workflows/ids:\x01*\x12\xe7\
    \x01\n\x0eDeleteWorkflow\x12#.clarifai.api.DeleteWorkflowRequest\x1a!.cl\
    arifai.api.status.BaseResponse\"\x8c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x12\x90\x9c'\x15\x90\x9c'\x13\x82\xd3\xe4\x93\x02r*Q/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}Z\x1d*\x1b\
    /v2/workflows/{workflow_id}\x12\xd2\x01\n\x0fDeleteWorkflows\x12$.clarif\
    ai.api.DeleteWorkflowsRequest\x1a!.clarifai.api.status.BaseResponse\"v\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x12\x90\x9c'\x15\x90\x9c'\x13\x82\xd3\
    \xe4\x93\x02\\*C/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/workflows:\x01*Z\x12*\r/v2/workflows:\x01*\x12\x8a\x03\n\x13PostWorkfl\
    owResults\x12(.clarifai.api.PostWorkflowResultsRequest\x1a).clarifai.api\
    .PostWorkflowResultsResponse\"\x9d\x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02\xfe\x01\
    \"o/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{\
    workflow_id}/versions/{version_id}/results:\x01*Z^\"Y/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results:\
    \x01*Z(\"#/v2/workflows/{workflow_id}/results:\x01*\x12\xc9\x03\n\x1dPos\
    tWorkflowResultsSimilarity\x122.clarifai.api.PostWorkflowResultsSimilari\
    tyRequest\x1a3.clarifai.api.PostWorkflowResultsSimilarityResponse\"\xbe\
    \x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02\x9f\x02\"z/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/\
    results/similarity:\x01*Zi\"d/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/workflows/{workflow_id}/results/similarity:\x01*Z3\"./v2/\
    workflows/{workflow_id}/results/similarity:\x01*\x12\x8b\x02\n\x14ListWo\
    rkflowVersions\x12).clarifai.api.ListWorkflowVersionsRequest\x1a*.clarif\
    ai.api.MultiWorkflowVersionResponse\"\x9b\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x84\x01\x12Z/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/version\
    sZ&\x12$/v2/workflows/{workflow_id}/versions\x12\xb4\x02\n\x12GetWorkflo\
    wVersion\x12'.clarifai.api.GetWorkflowVersionRequest\x1a+.clarifai.api.S\
    ingleWorkflowVersionResponse\"\xc7\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\xb0\x01\x12p/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{wo\
    rkflow_version_id}Z<\x12:/v2/workflows/{workflow_id}/versions/{workflow_\
    version_id}\x12\x90\x02\n\x16DeleteWorkflowVersions\x12+.clarifai.api.De\
    leteWorkflowVersionsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa5\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x13\x90\x9c'\x12\x90\x9c'\x15\x82\
    \xd3\xe4\x93\x02\x8a\x01*Z/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/workflows/{workflow_id}/versions:\x01*Z)*$/v2/workflows/{wor\
    kflow_id}/versions:\x01*\x12\x97\x02\n\x15PatchWorkflowVersions\x12*.cla\
    rifai.api.PatchWorkflowVersionsRequest\x1a*.clarifai.api.MultiWorkflowVe\
    rsionResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\
    \x90\x9c'\x12\x82\xd3\xe4\x93\x02\x8a\x012Z/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions:\x01*Z)2$/\
    v2/workflows/{workflow_id}/versions:\x01*\x12\x85\x01\n\x06GetKey\x12\
    \x1b.clarifai.api.GetKeyRequest\x1a\x1f.clarifai.api.SingleKeyResponse\"\
    =\x98\x9c'\x05\x90\x9c'0\x82\xd3\xe4\x93\x02/\x12-/v2/users/{user_app_id\
    .user_id}/keys/{key_id}\x12\x7f\n\x08ListKeys\x12\x1d.clarifai.api.ListK\
    eysRequest\x1a\x1e.clarifai.api.MultiKeyResponse\"4\x98\x9c'\x05\x90\x9c\
    '0\x82\xd3\xe4\x93\x02&\x12$/v2/users/{user_app_id.user_id}/keys\x12\xa3\
    \x01\n\x0bListAppKeys\x12\x20.clarifai.api.ListAppKeysRequest\x1a\x1e.cl\
    arifai.api.MultiKeyResponse\"R\x98\x9c'\x05\x90\x9c'-\x90\x9c'0\x82\xd3\
    \xe4\x93\x02@\x12>/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/keys\x12\x95\x01\n\tDeleteKey\x12\x1e.clarifai.api.DeleteKeyRequest\
    \x1a!.clarifai.api.status.BaseResponse\"E\x98\x9c'\x05\x90\x9c'/\x90\x9c\
    '1\x90\x9c'0\x82\xd3\xe4\x93\x02/*-/v2/users/{user_app_id.user_id}/keys/\
    {key_id}\x12\x8a\x01\n\x08PostKeys\x12\x1d.clarifai.api.PostKeysRequest\
    \x1a\x1e.clarifai.api.MultiKeyResponse\"?\x98\x9c'\x05\x90\x9c'-\x90\x9c\
    '/\x90\x9c'0\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_id}/keys\
    :\x01*\x12\x88\x01\n\tPatchKeys\x12\x1e.clarifai.api.PatchKeysRequest\
    \x1a\x1e.clarifai.api.MultiKeyResponse\";\x98\x9c'\x05\x90\x9c'/\x90\x9c\
    '0\x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/keys:\x01*\x12\
    \xbc\x01\n\x08MyScopes\x12\x1d.clarifai.api.MyScopesRequest\x1a\x20.clar\
    ifai.api.MultiScopeResponse\"o\x98\x9c'\x02\x82\xd3\xe4\x93\x02e\x12B/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopesZ\x0e\x12\
    \x0c/v2/myscopesZ\x0f\x12\r/v2/my_scopes\x12\x8d\x01\n\x0cMyScopesUser\
    \x12!.clarifai.api.MyScopesUserRequest\x1a$.clarifai.api.MultiScopeUserR\
    esponse\"4\x98\x9c'\x05\x82\xd3\xe4\x93\x02*\x12(/v2/users/{user_app_id.\
    user_id}/myscopes\x12u\n\x0cMyScopesRoot\x12!.clarifai.api.MyScopesRootR\
    equest\x1a$.clarifai.api.MultiScopeRootResponse\"\x1c\x98\x9c'\x05\x82\
    \xd3\xe4\x93\x02\x12\x12\x10/v2/myscopesroot\x12\x87\x01\n\nListScopes\
    \x12\x1f.clarifai.api.ListScopesRequest\x1a$.clarifai.api.MultiScopeDeps\
    Response\"2\x98\x9c'\x03\x82\xd3\xe4\x93\x02(\x12&/v2/users/{user_app_id\
    .user_id}/scopes\x12\x95\x01\n\x06GetApp\x12\x1b.clarifai.api.GetAppRequ\
    est\x1a\x1f.clarifai.api.SingleAppResponse\"M\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02;\x129/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}\x12\x8f\x01\n\x08ListApps\x12\x1d.clarifai.api.List\
    AppsRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\
    \x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x022\x12$/v2/users/{user_app_id.user\
    _id}/appsZ\n\x12\x08/v2/apps\x12\xa5\x01\n\tDeleteApp\x12\x1e.clarifai.a\
    pi.DeleteAppRequest\x1a!.clarifai.api.status.BaseResponse\"U\x98\x9c'\
    \x05\x90\x9c',\x90\x9c'.\x90\x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x02;*9/v\
    2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\x12\x92\x01\n\
    \x08PostApps\x12\x1d.clarifai.api.PostAppsRequest\x1a\x1e.clarifai.api.M\
    ultiAppResponse\"G\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x90\x9c'\x0f\x90\x9c\
    '\x13\x90\x9c'\x12\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_id\
    }/apps:\x01*\x12\x88\x01\n\tPatchApps\x12\x1e.clarifai.api.PatchAppsRequ\
    est\x1a\x1e.clarifai.api.MultiAppResponse\";\x98\x9c'\x05\x90\x9c',\x90\
    \x9c'-\x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/apps:\x01*\
    \x12\x92\x01\n\x0cPatchAppsIds\x12!.clarifai.api.PatchAppsIdsRequest\x1a\
    \x1e.clarifai.api.MultiAppResponse\"?\x98\x9c'\x05\x90\x9c',\x90\x9c'-\
    \x82\xd3\xe4\x93\x02-2(/v2/users/{user_app_id.user_id}/apps/ids:\x01*\
    \x12\x9c\x01\n\x08PatchApp\x12\x1d.clarifai.api.PatchAppRequest\x1a\x1f.\
    clarifai.api.SingleAppResponse\"P\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x82\
    \xd3\xe4\x93\x02>29/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}:\x01*\x12\x9f\x01\n\x10PostAppsSearches\x12%.clarifai.api.PostAppsS\
    earchesRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\
    \x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x022\"-/v2/users/{user_app_id.user_i\
    d}/apps/searches:\x01*\x12v\n\x07GetUser\x12\x1c.clarifai.api.GetUserReq\
    uest\x1a\x20.clarifai.api.SingleUserResponse\"+\x98\x9c'\x05\x82\xd3\xe4\
    \x93\x02!\x12\x1f/v2/users/{user_app_id.user_id}\x12\xcf\x01\n\x14PostVa\
    lidatePassword\x12).clarifai.api.PostValidatePasswordRequest\x1a..clarif\
    ai.api.SinglePasswordValidationResponse\"\\\x98\x9c'\x03\x82\xd3\xe4\x93\
    \x02R\"1/v2/users/{user_app_id.user_id}/validate_password:\x01*Z\x1a\"\
    \x15/v2/validate_password:\x01*\x12\xc1\x01\n\tGetSearch\x12\x1e.clarifa\
    i.api.GetSearchRequest\x1a\".clarifai.api.SingleSearchResponse\"p\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/searches/{id}Z\x13\x12\x11/v2/s\
    earches/{id}\x12\xbc\x01\n\x0cListSearches\x12!.clarifai.api.ListSearche\
    sRequest\x1a!.clarifai.api.MultiSearchResponse\"f\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'r\x82\xd3\xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/searchesZ\x0e\x12\x0c/v2/searches\x12\xc8\x01\n\rP\
    atchSearches\x12\".clarifai.api.PatchSearchesRequest\x1a!.clarifai.api.M\
    ultiSearchResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\
    \xe4\x93\x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /searches:\x01*Z\x112\x0c/v2/searches:\x01*\x12\xda\x01\n\x0cPostSearche\
    s\x12!.clarifai.api.PostSearchesRequest\x1a!.clarifai.api.MultiSearchRes\
    ponse\"\x83\x01\x88\x02\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02Z\"B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/search\
    es:\x01*Z\x11\"\x0c/v2/searches:\x01*\x12\xd8\x01\n\x10PostSearchesByID\
    \x12%.clarifai.api.PostSearchesByIDRequest\x1a!.clarifai.api.MultiSearch\
    Response\"z\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c'\x03\x82\xd3\xe4\
    \x93\x02d\"G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/se\
    arches/{id}:\x01*Z\x16\"\x11/v2/searches/{id}:\x01*\x12\xb3\x02\n\x1bPos\
    tAnnotationSearchMetrics\x120.clarifai.api.PostAnnotationSearchMetricsRe\
    quest\x1a2.clarifai.api.MultiAnnotationSearchMetricsResponse\"\xad\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\
    \x90\x9c'6\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x82\x01\"V/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searche\
    s/metrics:\x01*Z%\"\x20/v2/annotations/searches/metrics:\x01*\x12\xa9\
    \x02\n\x1aGetAnnotationSearchMetrics\x12/.clarifai.api.GetAnnotationSear\
    chMetricsRequest\x1a2.clarifai.api.MultiAnnotationSearchMetricsResponse\
    \"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\
    \x90\x9c'5\x82\xd3\xe4\x93\x02\x86\x01\x12[/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}Z'\x12%/v2\
    /annotations/searches/metrics/{id}\x12\xa0\x02\n\x1bListAnnotationSearch\
    Metrics\x120.clarifai.api.ListAnnotationSearchMetricsRequest\x1a2.clarif\
    ai.api.MultiAnnotationSearchMetricsResponse\"\x9a\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\
    |\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotati\
    ons/searches/metricsZ\"\x12\x20/v2/annotations/searches/metrics\x12\x9a\
    \x02\n\x1dDeleteAnnotationSearchMetrics\x122.clarifai.api.DeleteAnnotati\
    onSearchMetricsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'5\x90\x9c'6\x90\x9c'?\x82\xd3\xe4\x93\
    \x02\x86\x01*[/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    annotations/searches/metrics/{id}Z'*%/v2/annotations/searches/metrics/{i\
    d}\x12\xce\x01\n\x0cDeleteSearch\x12!.clarifai.api.DeleteSearchRequest\
    \x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c\
    'r\x90\x9c's\x90\x9c't\x82\xd3\xe4\x93\x02^*G/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/searches/{id}Z\x13*\x11/v2/searches/{id}\
    \x12\xec\x01\n\x15ListAnnotationFilters\x12*.clarifai.api.ListAnnotation\
    FiltersRequest\x1a+.clarifai.api.MultiAnnotationFilterResponse\"z\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02h\x12L/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/annotation_filtersZ\x18\x12\x16\
    /v2/annotation_filters\x12\x99\x02\n\x13GetAnnotationFilter\x12(.clarifa\
    i.api.GetAnnotationFilterRequest\x1a,.clarifai.api.SingleAnnotationFilte\
    rResponse\"\xa9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02\
    \x96\x01\x12c/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/a\
    nnotation_filters/{annotation_filter_id}Z/\x12-/v2/annotation_filters/{a\
    nnotation_filter_id}\x12\xf7\x01\n\x15PostAnnotationFilters\x12*.clarifa\
    i.api.PostAnnotationFiltersRequest\x1a+.clarifai.api.MultiAnnotationFilt\
    erResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x82\xd3\
    \xe4\x93\x02n\"L/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/annotation_filters:\x01*Z\x1b\"\x16/v2/annotation_filters:\x01*\x12\
    \xf9\x01\n\x16PatchAnnotationFilters\x12+.clarifai.api.PatchAnnotationFi\
    ltersRequest\x1a+.clarifai.api.MultiAnnotationFilterResponse\"\x84\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x82\xd3\xe4\x93\x02n2L/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters:\
    \x01*Z\x1b2\x16/v2/annotation_filters:\x01*\x12\xf1\x01\n\x17DeleteAnnot\
    ationFilters\x12,.clarifai.api.DeleteAnnotationFiltersRequest\x1a!.clari\
    fai.api.status.BaseResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\
    \x90\x9c's\x82\xd3\xe4\x93\x02n*L/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/annotation_filters:\x01*Z\x1b*\x16/v2/annotation_filt\
    ers:\x01*\x12|\n\x0fListStatusCodes\x12$.clarifai.api.ListStatusCodesReq\
    uest\x1a%.clarifai.api.MultiStatusCodeResponse\"\x1c\x98\x9c'\x01\x82\
    \xd3\xe4\x93\x02\x12\x12\x10/v2/status_codes\x12\x8a\x01\n\rGetStatusCod\
    e\x12\".clarifai.api.GetStatusCodeRequest\x1a&.clarifai.api.SingleStatus\
    CodeResponse\"-\x98\x9c'\x01\x82\xd3\xe4\x93\x02#\x12!/v2/status_codes/{\
    status_code_id}\x12\xc2\x01\n\x11ListCollaborators\x12&.clarifai.api.Lis\
    tCollaboratorsRequest\x1a(.clarifai.api.MultiCollaboratorsResponse\"[\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'2\x82\xd3\xe4\x93\x02I\x12G/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/collaborators\x12\xc9\x01\n\
    \x11PostCollaborators\x12&.clarifai.api.PostCollaboratorsRequest\x1a(.cl\
    arifai.api.MultiCollaboratorsResponse\"b\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    3\x90\x9c'2\x82\xd3\xe4\x93\x02L\"G/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/collaborators:\x01*\x12\xcf\x01\n\x12PatchCollabora\
    tors\x12'.clarifai.api.PatchCollaboratorsRequest\x1a(.clarifai.api.Multi\
    CollaboratorsResponse\"f\x98\x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x90\
    \x9c'4\x82\xd3\xe4\x93\x02L2G/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/collaborators:\x01*\x12\xd2\x01\n\x13DeleteCollaborators\
    \x12(.clarifai.api.DeleteCollaboratorsRequest\x1a!.clarifai.api.status.B\
    aseResponse\"n\x98\x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x90\x9c'4\x90\
    \x9c'7\x90\x9c'8\x82\xd3\xe4\x93\x02L*G/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/collaborators:\x01*\x12\xa4\x01\n\x12ListCollab\
    orations\x12'.clarifai.api.ListCollaborationsRequest\x1a).clarifai.api.M\
    ultiCollaborationsResponse\":\x98\x9c'\x03\x82\xd3\xe4\x93\x020\x12./v2/\
    users/{user_app_id.user_id}/collaborations\x12\xf7\x01\n\x13PostAppDupli\
    cations\x12(.clarifai.api.PostAppDuplicationsRequest\x1a*.clarifai.api.M\
    ultiAppDuplicationsResponse\"\x89\x01\x98\x9c'\x05\x90\x9c',\x90\x9c'-\
    \x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\n\x90\x9c'\x0b\x90\x9c'\
    \x04\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\
    \xe4\x93\x02K\"F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/duplications:\x01*\x12\xa5\x01\n\x13ListAppDuplications\x12(.clarifai.\
    api.ListAppDuplicationsRequest\x1a*.clarifai.api.MultiAppDuplicationsRes\
    ponse\"8\x98\x9c'\x05\x82\xd3\xe4\x93\x02.\x12,/v2/users/{user_app_id.us\
    er_id}/duplications\x12\xb6\x01\n\x11GetAppDuplication\x12&.clarifai.api\
    .GetAppDuplicationRequest\x1a*.clarifai.api.SingleAppDuplicationResponse\
    \"M\x98\x9c'\x05\x82\xd3\xe4\x93\x02C\x12A/v2/users/{user_app_id.user_id\
    }/duplications/{app_duplication_id}\x12\xd9\x01\n\tPostTasks\x12\x1e.cla\
    rifai.api.PostTasksRequest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x8a\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'\
    \x03\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'\
    &\x82\xd3\xe4\x93\x02T\"?/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/tasks:\x01*Z\x0e\"\t/v2/tasks:\x01*\x12\xfe\x01\n\x16GetTaskA\
    nnotationCount\x12!.clarifai.api.GetTaskCountRequest\x1a%.clarifai.api.S\
    ingleTaskCountResponse\"\x99\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x82\
    \xd3\xe4\x93\x02\x86\x01\x12[/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/tasks/{task_id}/annotations/countZ'\x12%/v2/tasks/{task_i\
    d}/annotations/count\x12\xee\x01\n\x11GetTaskInputCount\x12!.clarifai.ap\
    i.GetTaskCountRequest\x1a%.clarifai.api.SingleTaskCountResponse\"\x8e\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x82\xd3\xe4\x93\x02|\x12V/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/\
    countZ\"\x12\x20/v2/tasks/{task_id}/inputs/count\x12\xd0\x01\n\x07GetTas\
    k\x12\x1c.clarifai.api.GetTaskRequest\x1a\x20.clarifai.api.SingleTaskRes\
    ponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x90\x9c'r\x90\x9c'\x0b\
    \x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}Z\x15\x12\x13/v2/ta\
    sks/{task_id}\x12\xbe\x01\n\tListTasks\x12\x1e.clarifai.api.ListTasksReq\
    uest\x1a\x1f.clarifai.api.MultiTaskResponse\"p\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'8\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02N\x12?/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    tasksZ\x0b\x12\t/v2/tasks\x12\xd7\x01\n\nPatchTasks\x12\x1f.clarifai.api\
    .PatchTasksRequest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x86\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'r\x90\x9c'\
    \x0b\x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x82\xd3\xe4\x93\x02T2\
    ?/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\
    \x0e2\t/v2/tasks:\x01*\x12\xc2\x01\n\x0bDeleteTasks\x12\x20.clarifai.api\
    .DeleteTasksRequest\x1a!.clarifai.api.status.BaseResponse\"n\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02T*?/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e*\t\
    /v2/tasks:\x01*\x12\xf5\x01\n\x0fPostLabelOrders\x12$.clarifai.api.PostL\
    abelOrdersRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"\x94\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\x9c'8\x90\x9c'\
    \x05\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02b\"F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_\
    orders:\x01*Z\x15\"\x10/v2/label_orders:\x01*\x12\xf6\x01\n\rGetLabelOrd\
    er\x12\".clarifai.api.GetLabelOrderRequest\x1a&.clarifai.api.SingleLabel\
    OrderResponse\"\x98\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'\x0b\
    \x90\x9c'8\x82\xd3\xe4\x93\x02~\x12W/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/label_orders/{label_order_id}Z#\x12!/v2/label_orde\
    rs/{label_order_id}\x12\xd6\x01\n\x0fListLabelOrders\x12$.clarifai.api.L\
    istLabelOrdersRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"v\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'\x0b\x90\x9c'8\x82\xd3\xe4\x93\x02\
    \\\x12F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_o\
    rdersZ\x12\x12\x10/v2/label_orders\x12\xeb\x01\n\x10PatchLabelOrders\x12\
    %.clarifai.api.PatchLabelOrdersRequest\x1a%.clarifai.api.MultiLabelOrder\
    Response\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'D\x90\x9c'\
    \x0b\x90\x9c'7\x90\x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02b2F/v2/users/{user\
    _app_id.user_id}/apps/{user_app_id.app_id}/label_orders:\x01*Z\x152\x10/\
    v2/label_orders:\x01*\x12\xe5\x01\n\x11DeleteLabelOrders\x12&.clarifai.a\
    pi.DeleteLabelOrdersRequest\x1a!.clarifai.api.status.BaseResponse\"\x84\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'E\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\
    \x9c'8\x82\xd3\xe4\x93\x02b*F/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/label_orders:\x01*Z\x15*\x10/v2/label_orders:\x01*\x12\
    \xf2\x01\n\x0ePostCollectors\x12#.clarifai.api.PostCollectorsRequest\x1a\
    $.clarifai.api.MultiCollectorResponse\"\x94\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x04\x90\x9c'%\x90\x9c'&\x90\x9c')\x90\x9c'\x0b\x90\x9c'\x04\
    \x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02\
    ^\"D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors\
    :\x01*Z\x13\"\x0e/v2/collectors:\x01*\x12\xe3\x01\n\x0cGetCollector\x12!\
    .clarifai.api.GetCollectorRequest\x1a%.clarifai.api.SingleCollectorRespo\
    nse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'*\x82\xd3\xe4\x93\x02v\x12S\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors/{co\
    llector_id}Z\x1f\x12\x1d/v2/collectors/{collector_id}\x12\xc7\x01\n\x0eL\
    istCollectors\x12#.clarifai.api.ListCollectorsRequest\x1a$.clarifai.api.\
    MultiCollectorResponse\"j\x98\x9c'\x02\x90\x9c'-\x90\x9c'*\x82\xd3\xe4\
    \x93\x02X\x12D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    collectorsZ\x10\x12\x0e/v2/collectors\x12\xd3\x01\n\x0fPatchCollectors\
    \x12$.clarifai.api.PatchCollectorsRequest\x1a$.clarifai.api.MultiCollect\
    orResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c')\x90\x9c'*\x82\xd3\xe4\x93\
    \x02^2D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collect\
    ors:\x01*Z\x132\x0e/v2/collectors:\x01*\x12\xd6\x01\n\x10DeleteCollector\
    s\x12%.clarifai.api.DeleteCollectorsRequest\x1a!.clarifai.api.status.Bas\
    eResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c')\x90\x9c'+\x90\x9c'*\x82\
    \xd3\xe4\x93\x02^*D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/collectors:\x01*Z\x13*\x0e/v2/collectors:\x01*\x12\xc9\x01\n\x0ePos\
    tStatValues\x12#.clarifai.api.PostStatValuesRequest\x1a$.clarifai.api.Mu\
    ltiStatValueResponse\"l\x98\x9c'\x02\x82\xd3\xe4\x93\x02b\"F/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/stats/values:\x01*Z\x15\"\
    \x10/v2/stats/values:\x01*\x12\xfd\x01\n\x17PostStatValuesAggregate\x12,\
    .clarifai.api.PostStatValuesAggregateRequest\x1a-.clarifai.api.MultiStat\
    ValueAggregateResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x82\xd3\xe4\x93\
    \x02v\"P/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/\
    values/aggregate:\x01*Z\x1f\"\x1a/v2/stats/values/aggregate:\x01*\x12\
    \xe3\x01\n\x17PostTrendingMetricsView\x12,.clarifai.api.PostTrendingMetr\
    icsViewRequest\x1a!.clarifai.api.status.BaseResponse\"w\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02m\"h/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/trending_metrics/views/{view_type}/{object_id}:\x01*\x12\x8f\x02\n\
    \x18ListTrendingMetricsViews\x12-.clarifai.api.ListTrendingMetricsViewsR\
    equest\x1a..clarifai.api.MultiTrendingMetricsViewResponse\"\x93\x01\x98\
    \x9c'\x02\x82\xd3\xe4\x93\x02\x88\x01\x12\\/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}Z(\x12&/v\
    2/trending_metrics/views/{view_type}\x12\xb2\x01\n\tGetModule\x12\x1e.cl\
    arifai.api.GetModuleRequest\x1a\".clarifai.api.SingleModuleResponse\"a\
    \x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\x02O\x12M/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}\x12\xe4\
    \x01\n\x0bListModules\x12\x20.clarifai.api.ListModulesRequest\x1a!.clari\
    fai.api.MultiModuleResponse\"\x8f\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\
    \x82\xd3\xe4\x93\x02}\x12A/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/modulesZ)\x12'/v2/users/{user_app_id.user_id}/modulesZ\r\x12\
    \x0b/v2/modules\x12\xb0\x01\n\x0bPostModules\x12\x20.clarifai.api.PostMo\
    dulesRequest\x1a!.clarifai.api.MultiModuleResponse\"\\\x98\x9c'\x05\x90\
    \x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02F\"A/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/modules:\x01*\x12\xb2\x01\n\x0cPatch\
    Modules\x12!.clarifai.api.PatchModulesRequest\x1a!.clarifai.api.MultiMod\
    uleResponse\"\\\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\
    \x93\x02F2A/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/mod\
    ules:\x01*\x12\xd0\x01\n\rDeleteModules\x12\".clarifai.api.DeleteModules\
    Request\x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x05\x90\x9c'-\
    \x90\x9c'l\x90\x9c'n\x90\x9c'm\x90\x9c'p\x90\x9c'o\x90\x9c'q\x90\x9c'1\
    \x90\x9c'0\x90\x9c'/\x82\xd3\xe4\x93\x02F*A/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/modules:\x01*\x12\xe4\x01\n\x10GetModuleVer\
    sion\x12%.clarifai.api.GetModuleVersionRequest\x1a).clarifai.api.SingleM\
    oduleVersionResponse\"~\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\
    \x02l\x12j/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modu\
    les/{module_id}/versions/{module_version_id}\x12\xd3\x01\n\x12ListModule\
    Versions\x12'.clarifai.api.ListModuleVersionsRequest\x1a(.clarifai.api.M\
    ultiModuleVersionResponse\"j\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\
    \xe4\x93\x02X\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/modules/{module_id}/versions\x12\xda\x01\n\x12PostModuleVersions\x12\
    '.clarifai.api.PostModuleVersionsRequest\x1a(.clarifai.api.MultiModuleVe\
    rsionResponse\"q\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\
    \x93\x02[\"V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/mo\
    dules/{module_id}/versions:\x01*\x12\xf4\x01\n\x14DeleteModuleVersions\
    \x12).clarifai.api.DeleteModuleVersionsRequest\x1a!.clarifai.api.status.\
    BaseResponse\"\x8d\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'n\x90\
    \x9c'm\x90\x9c'p\x90\x9c'o\x90\x9c'q\x90\x9c'1\x90\x9c'0\x90\x9c'/\x82\
    \xd3\xe4\x93\x02[*V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/modules/{module_id}/versions:\x01*\x12\x93\x02\n\x1aGetModuleVersio\
    nUsageCount\x12/.clarifai.api.GetModuleVersionUsageCountRequest\x1a3.cla\
    rifai.api.SingleModuleVersionUsageCountResponse\"\x8e\x01\x98\x9c'\x05\
    \x90\x9c'-\x90\x9c'm\x90\x9c'p\x82\xd3\xe4\x93\x02x\x12v/v2/users/{user_\
    app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions/{\
    module_version_id}/usage_count\x12\x8f\x02\n\x19GetInstalledModuleVersio\
    n\x12..clarifai.api.GetInstalledModuleVersionRequest\x1a2.clarifai.api.S\
    ingleInstalledModuleVersionResponse\"\x8d\x01\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'p\x90\x9c'm\x90\x9c'0\x82\xd3\xe4\x93\x02s\x12q/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/installed_module_versions/{install\
    ed_module_version_id}\x12\xf3\x01\n\x1bListInstalledModuleVersions\x120.\
    clarifai.api.ListInstalledModuleVersionsRequest\x1a1.clarifai.api.MultiI\
    nstalledModuleVersionResponse\"o\x98\x9c'\x05\x90\x9c'-\x90\x9c'p\x90\
    \x9c'm\x90\x9c'0\x82\xd3\xe4\x93\x02U\x12S/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/installed_module_versions\x12\xf6\x01\n\x1bP\
    ostInstalledModuleVersions\x120.clarifai.api.PostInstalledModuleVersions\
    Request\x1a1.clarifai.api.MultiInstalledModuleVersionResponse\"r\x98\x9c\
    '\x05\x90\x9c'o\x90\x9c'p\x90\x9c'm\x90\x9c'-\x82\xd3\xe4\x93\x02X\"S/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_\
    versions:\x01*\x12\xfb\x01\n\x1dDeleteInstalledModuleVersions\x122.clari\
    fai.api.DeleteInstalledModuleVersionsRequest\x1a!.clarifai.api.status.Ba\
    seResponse\"\x82\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x90\x9c'o\x90\x9c'\
    p\x90\x9c'q\x90\x9c'1\x90\x9c'/\x90\x9c'0\x82\xd3\xe4\x93\x02X*S/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versi\
    ons:\x01*\x12\x95\x02\n\x1ePostInstalledModuleVersionsKey\x123.clarifai.\
    api.PostInstalledModuleVersionsKeyRequest\x1a\x1f.clarifai.api.SingleKey\
    Response\"\x9c\x01\x98\x9c'\x05\x90\x9c'o\x90\x9c'p\x90\x9c'm\x90\x9c'-\
    \x90\x9c'/\x90\x9c'0\x82\xd3\xe4\x93\x02z\"u/v2/users/{user_app_id.user_\
    id}/apps/{user_app_id.app_id}/installed_module_versions/{installed_modul\
    e_version_id}/key:\x01*\x12\xf5\x01\n\x12PostBulkOperations\x12'.clarifa\
    i.api.PostBulkOperationsRequest\x1a).clarifai.api.MultiBulkOperationsRes\
    ponse\"\x8a\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'z\x90\x9c'y\x90\x9c'%\x90\
    \x9c'&\x90\x9c'(\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/bulk_operations:\x01*Z\x18\"\x13/v2/bulk_opera\
    tions:\x01*\x12\xde\x01\n\x12ListBulkOperations\x12'.clarifai.api.ListBu\
    lkOperationsRequest\x1a).clarifai.api.MultiBulkOperationsResponse\"t\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'z\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/bulk_operationsZ\x15\x12\x13/v2\
    /bulk_operations\x12\xe5\x01\n\x10GetBulkOperation\x12%.clarifai.api.Get\
    BulkOperationRequest\x1a*.clarifai.api.SingleBulkOperationsResponse\"~\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'z\x82\xd3\xe4\x93\x02l\x12N/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations/{id}Z\x1a\
    \x12\x18/v2/bulk_operations/{id}\x12\xeb\x01\n\x14CancelBulkOperations\
    \x12(.clarifai.api.CancelBulkOperationRequest\x1a).clarifai.api.MultiBul\
    kOperationsResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c'y\x90\x9c'z\x82\
    \xd3\xe4\x93\x02h2I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/bulk_operations:\x01*Z\x182\x13/v2/bulk_operations:\x01*\x12\xf4\
    \x01\n\x14DeleteBulkOperations\x12(.clarifai.api.DeleteBulkOperationRequ\
    est\x1a!.clarifai.api.status.BaseResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c\
    '-\x90\x9c'&\x90\x9c'%\x90\x9c'(\x90\x9c'y\x90\x9c'z\x90\x9c'{\x82\xd3\
    \xe4\x93\x02h*I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /bulk_operations:\x01*Z\x18*\x13/v2/bulk_operations:\x01*\x12\x88\x02\n\
    \x17ListNextTaskAssignments\x12,.clarifai.api.ListNextTaskAssignmentsReq\
    uest\x1a\x20.clarifai.api.MultiInputResponse\"\x9c\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'8\x90\x9c'i\x82\xd3\
    \xe4\x93\x02z\x12U/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/tasks/{task_id}/assignmentsZ!\x12\x1f/v2/tasks/{task_id}/assignments\
    \x12\xe3\x01\n\x12PutTaskAssignments\x12'.clarifai.api.PutTaskAssignment\
    sRequest\x1a!.clarifai.api.status.BaseResponse\"\x80\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'8\x90\
    \x9c'i\x82\xd3\xe4\x93\x02Z\x1aU/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/tasks/{task_id}/assignments:\x01*\x12\xda\x01\n\x11Lis\
    tInputsAddJobs\x12&.clarifai.api.ListInputsAddJobsRequest\x1a'.clarifai.\
    api.MultiInputsAddJobResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\
    \xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/inputs/jobs/addZ\x15\x12\x13/v2/inputs/jobs/add\x12\xe1\x01\n\
    \x0fGetInputsAddJob\x12$.clarifai.api.GetInputsAddJobRequest\x1a(.clarif\
    ai.api.SingleInputsAddJobResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\
    \x82\xd3\xe4\x93\x02l\x12N/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/inputs/jobs/add/{id}Z\x1a\x12\x18/v2/inputs/jobs/add/{id}\
    \x12\xf2\x01\n\x12CancelInputsAddJob\x12'.clarifai.api.CancelInputsAddJo\
    bRequest\x1a(.clarifai.api.SingleInputsAddJobResponse\"\x88\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'\x04\x90\x9c'\x05\x82\xd3\xe4\x93\x02r2N/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add/{id}:\
    \x01*Z\x1d2\x18/v2/inputs/jobs/add/{id}:\x01*\x12\xc4\x01\n\x0bPostUploa\
    ds\x12\x20.clarifai.api.PostUploadsRequest\x1a!.clarifai.api.MultiUpload\
    Response\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x81\x01\x90\x9c'\x80\x01\x82\
    \xd3\xe4\x93\x02X\"A/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/uploads:\x01*Z\x10\"\x0b/v2/uploads:\x01*\x12\x8c\x02\n\x15PutUplo\
    adContentParts\x12*.clarifai.api.PutUploadContentPartsRequest\x1a\".clar\
    ifai.api.SingleUploadResponse\"\xa2\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x81\x01\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02\x89\x01\x1a[/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id}/content_\
    parts:\x01*Z'\x1a%/v2/uploads/{upload_id}/content_parts\x12\xce\x01\n\tG\
    etUpload\x12\x1e.clarifai.api.GetUploadRequest\x1a\".clarifai.api.Single\
    UploadResponse\"}\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x80\x01\x82\xd3\xe4\
    \x93\x02j\x12M/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    uploads/{upload_id}Z\x19\x12\x17/v2/uploads/{upload_id}\x12\xb9\x01\n\
    \x0bListUploads\x12\x20.clarifai.api.ListUploadsRequest\x1a!.clarifai.ap\
    i.MultiUploadResponse\"e\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x80\x01\x82\xd3\
    \xe4\x93\x02R\x12A/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/uploadsZ\r\x12\x0b/v2/uploads\x12\xcd\x01\n\rDeleteUploads\x12\".cla\
    rifai.api.DeleteUploadsRequest\x1a!.clarifai.api.status.BaseResponse\"u\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x80\x01\x90\x9c'\x81\x01\x90\x9c'\x82\
    \x01\x82\xd3\xe4\x93\x02X*A/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/uploads:\x01*Z\x10*\x0b/v2/uploads:\x01*\x12\x8d\x02\n\x15P\
    ostInputsDataSources\x12*.clarifai.api.PostInputsDataSourcesRequest\x1a'\
    .clarifai.api.MultiInputsAddJobResponse\"\x9e\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02p\"M/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/inputs/data_sources:\x01*Z\x1c\"\x17\
    /v2/inputs/data_sources:\x01*\x12\xb2\x02\n\x16GetInputsExtractionJob\
    \x12+.clarifai.api.GetInputsExtractionJobRequest\x1a/.clarifai.api.Singl\
    eInputsExtractionJobResponse\"\xb9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x05\x82\xd3\xe4\x93\x02\xa6\x01\x12k/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/inputs/jobs/extraction/{inputs_extraction_job_id}\
    Z7\x125/v2/inputs/jobs/extraction/{inputs_extraction_job_id}\x12\xfe\x01\
    \n\x18ListInputsExtractionJobs\x12-.clarifai.api.ListInputsExtractionJob\
    sRequest\x1a..clarifai.api.MultiInputsExtractionJobResponse\"\x82\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02p\x12P/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extractionZ\
    \x1c\x12\x1a/v2/inputs/jobs/extraction\x12\x8c\x02\n\x1aCancelInputsExtr\
    actionJobs\x12/.clarifai.api.CancelInputsExtractionJobsRequest\x1a..clar\
    ifai.api.MultiInputsExtractionJobResponse\"\x8c\x01\x98\x9c'\x02\x90\x9c\
    '-\x90\x9c'\x04\x90\x9c'\x05\x82\xd3\xe4\x93\x02v2P/v2/users/{user_app_i\
    d.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extraction:\x01*Z\x1f2\
    \x1a/v2/inputs/jobs/extraction:\x01*\x12\x85\x02\n\x11PostInputsUploads\
    \x12&.clarifai.api.PostInputsUploadsRequest\x1a'.clarifai.api.MultiInput\
    sAddJobResponse\"\x9e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\
    \x13\x90\x9c'\x81\x01\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02f\"H/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/uploads:\x01*Z\
    \x17\"\x12/v2/inputs/uploads:\x01*\x12\x99\x01\n\tGetRunner\x12\x1e.clar\
    ifai.api.GetRunnerRequest\x1a\".clarifai.api.SingleRunnerResponse\"H\x98\
    \x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x82\xd3\xe4\x93\x025\x123/v2/users/\
    {user_app_id.user_id}/runners/{runner_id}\x12\x90\x01\n\x0bListRunners\
    \x12\x20.clarifai.api.ListRunnersRequest\x1a!.clarifai.api.MultiRunnerRe\
    sponse\"<\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x82\xd3\xe4\x93\x02)\
    \x12'/v2/users/{user_app_id.user_id}/runners\x12\x98\x01\n\x0bPostRunner\
    s\x12\x20.clarifai.api.PostRunnersRequest\x1a!.clarifai.api.MultiRunnerR\
    esponse\"D\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x84\x01\x82\
    \xd3\xe4\x93\x02,\"'/v2/users/{user_app_id.user_id}/runners:\x01*\x12\
    \xa1\x01\n\rDeleteRunners\x12\".clarifai.api.DeleteRunnersRequest\x1a!.c\
    larifai.api.status.BaseResponse\"I\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\
    \x01\x90\x9c'\x84\x01\x90\x9c'\x85\x01\x82\xd3\xe4\x93\x02,*'/v2/users/{\
    user_app_id.user_id}/runners:\x01*\x12\xb3\x01\n\x0fListRunnerItems\x12$\
    .clarifai.api.ListRunnerItemsRequest\x1a%.clarifai.api.MultiRunnerItemRe\
    sponse\"S\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x86\x01\x82\
    \xd3\xe4\x93\x02;\x129/v2/users/{user_app_id.user_id}/runners/{runner_id\
    }/items\x12\xdf\x01\n\x15PostRunnerItemOutputs\x12*.clarifai.api.PostRun\
    nerItemOutputsRequest\x1a+.clarifai.api.MultiRunnerItemOutputResponse\"m\
    \x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x86\x01\x90\x9c'\x87\
    \x01\x82\xd3\xe4\x93\x02P\"K/v2/users/{user_app_id.user_id}/runners/{run\
    ner_id}/items/{item_id}/outputs:\x01*\x12\xc4\x02\n%PostModelVersionsTra\
    iningTimeEstimate\x12:.clarifai.api.PostModelVersionsTrainingTimeEstimat\
    eRequest\x1a/.clarifai.api.MultiTrainingTimeEstimateResponse\"\xad\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x9a\x01\"b/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/v\
    ersions/time_estimate:\x01*Z1\",/v2/models/{model_id}/versions/time_esti\
    mate:\x01*BY\n\x15com.clarifai.grpc.apiP\x01Z7github.com/Clarifai/clarif\
    ai-go-grpc/proto/clarifai/api\xa2\x02\x04CAIPJ\xc0\xd3\x0c\n\x07\x12\x05\
    \x02\0\xd68\x01\n\x08\n\x01\x0c\x12\x03\x02\0\x12\n\t\n\x02\x03\0\x12\
    \x03\x04\0,\n\t\n\x02\x03\x01\x12\x03\x05\00\n\t\n\x02\x03\x02\x12\x03\
    \x06\03\n\t\n\x02\x03\x03\x12\x03\x07\0/\n\t\n\x02\x03\x04\x12\x03\x08\0\
    2\n\t\n\x02\x03\x05\x12\x03\t\05\n\t\n\x02\x03\x06\x12\x03\x0c\0&\n\t\n\
    \x02\x03\x07\x12\x03\r\0(\n\t\n\x02\x03\x08\x12\x03\x0e\0&\n\t\n\x02\x03\
    \t\x12\x03\x0f\0)\n\x08\n\x01\x02\x12\x03\x12\0\x15\n\x08\n\x01\x08\x12\
    \x03\x14\0N\n\t\n\x02\x08\x0b\x12\x03\x14\0N\n\x08\n\x01\x08\x12\x03\x15\
    \0\"\n\t\n\x02\x08\n\x12\x03\x15\0\"\n\x08\n\x01\x08\x12\x03\x16\0.\n\t\
    \n\x02\x08\x01\x12\x03\x16\0.\n\x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\
    \x08$\x12\x03\x17\0\"\n\xb4\x06\n\x02\x06\0\x12\x05-\0\x9f\x1c\x042\xa6\
    \x06\nNote:\x20this\x20is\x20based\x20on\x20the\x20google\x20api\x20form\
    at\x20defined\x20here.\x20Please\nread\x20this\x20before\x20contributing\
    \x20to\x20this\x20file\x20and\x20other\x20*.proto\x20files\nfor\x20the\
    \x20API.\nhttps://cloud.google.com/service-management/reference/rpc/goog\
    le.api#google.api.HttpRule\n\nFor\x20the\x20cl_depending_scopes\x20in\
    \x20this\x20file,\x20see\x20the\x20docstring\x20that\x20explains\x20the\
    \x20two\x20types\x20of\nscope\x20dependencies\x20in\x20clarifai/auth/sco\
    pe/scope.proto\n\nFor\x20new\x20endpoints\x20you\x20should\x20typically\
    \x20only\x20add\x20the\x20fully\x20qualified\x20url\x20that\x20includes\
    \x20the\x20user_id\nand\x20app_id.\n\nYou\x20should\x20typicaly\x20use\
    \x20KeyAuth\x20(the\x20most\x20restricted\x20auth\x20type)\x20for\x20new\
    \x20endpoints\x20unless\x20they\x20are\nfor\x20resources\x20not\x20conta\
    ined\x20in\x20an\x20app\x20or\x20need\x20access\x20from\x20things\x20acr\
    oss\x20apps.\x20See\x20more\x20about\x20the\nauth\x20types\x20here:\nhtt\
    ps://clarifai.atlassian.net/wiki/spaces/TT/pages/1821409336/API+Authoriz\
    ers+and+Resource+Access\n\n\n\n\n\x03\x06\0\x01\x12\x03-\x08\n\n\xdd\x01\
    \n\x04\x06\0\x02\0\x12\x044\x02>\x03\x1a\xce\x01\x20List\x20concept\x20r\
    elations\x20between\x20concepts\x20in\x20the\x20platform.\n\x20MUST\x20b\
    e\x20above\x20ListConcepts\x20so\x20that\x20if\x20concept_id\x20is\x20em\
    pty\x20this\x20will\x20still\x20match\n\x20/concepts/relations\x20to\x20\
    list\x20all\x20the\x20concept\x20relations\x20in\x20the\x20app.\n\n\x0c\
    \n\x05\x06\0\x02\0\x01\x12\x034\x06\x1a\n\x0c\n\x05\x06\0\x02\0\x02\x12\
    \x034\x1c7\n\x0c\n\x05\x06\0\x02\0\x03\x12\x034B^\n\r\n\x05\x06\0\x02\0\
    \x04\x12\x045\x04:\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x045\
    \x04:\x06\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03;\x047\n\x0f\n\x08\x06\0\
    \x02\0\x04\xc3\xf3\x04\x12\x03;\x047\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03\
    <\x04?\n\x10\n\t\x06\0\x02\0\x04\xc2\xf3\x04\0\x12\x03<\x04?\n\x0c\n\x05\
    \x06\0\x02\0\x04\x12\x03=\x04C\n\x10\n\t\x06\0\x02\0\x04\xc2\xf3\x04\x01\
    \x12\x03=\x04C\n\\\n\x04\x06\0\x02\x01\x12\x04C\x02L\x03\x1aN\x20Post\
    \x20concept\x20relations\x20to\x20create\x20relations\x20between\x20conc\
    epts\x20in\x20the\x20platform.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03C\
    \x06\x1a\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03C\x1c7\n\x0c\n\x05\x06\0\
    \x02\x01\x03\x12\x03CB^\n\r\n\x05\x06\0\x02\x01\x04\x12\x04D\x04G\x06\n\
    \x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04D\x04G\x06\n\x0c\n\x05\
    \x06\0\x02\x01\x04\x12\x03H\x047\n\x0f\n\x08\x06\0\x02\x01\x04\xc3\xf3\
    \x04\x12\x03H\x047\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03I\x04?\n\x10\n\t\
    \x06\0\x02\x01\x04\xc2\xf3\x04\0\x12\x03I\x04?\n\x0c\n\x05\x06\0\x02\x01\
    \x04\x12\x03J\x04C\n\x10\n\t\x06\0\x02\x01\x04\xc2\xf3\x04\x01\x12\x03J\
    \x04C\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03K\x04C\n\x10\n\t\x06\0\x02\
    \x01\x04\xc2\xf3\x04\x02\x12\x03K\x04C\n\\\n\x04\x06\0\x02\x02\x12\x04O\
    \x02Y\x03\x1aN\x20Post\x20concept\x20relations\x20to\x20create\x20relati\
    ons\x20between\x20concepts\x20in\x20the\x20platform.\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x03O\x06\x1c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03O\x1e\
    ;\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03OFf\n\r\n\x05\x06\0\x02\x02\x04\
    \x12\x04P\x04S\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04P\
    \x04S\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03T\x047\n\x0f\n\x08\x06\0\
    \x02\x02\x04\xc3\xf3\x04\x12\x03T\x047\n\x0c\n\x05\x06\0\x02\x02\x04\x12\
    \x03U\x04?\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\0\x12\x03U\x04?\n\x0c\
    \n\x05\x06\0\x02\x02\x04\x12\x03V\x04F\n\x10\n\t\x06\0\x02\x02\x04\xc2\
    \xf3\x04\x01\x12\x03V\x04F\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03W\x04C\n\
    \x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x02\x12\x03W\x04C\n\x0c\n\x05\x06\
    \0\x02\x02\x04\x12\x03X\x04C\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x03\
    \x12\x03X\x04C\nM\n\x04\x06\0\x02\x03\x12\x04\\\x02h\x03\x1a?\x20List\
    \x20all\x20the\x20concepts\x20with\x20their\x20positive\x20and\x20negati\
    ve\x20counts\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\\\x06\x16\n\x0c\n\
    \x05\x06\0\x02\x03\x02\x12\x03\\\x18/\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03\\:S\n\r\n\x05\x06\0\x02\x03\x04\x12\x04]\x04b\x06\n\x11\n\t\x06\0\
    \x02\x03\x04\xb0\xca\xbc\"\x12\x04]\x04b\x06\n\x0c\n\x05\x06\0\x02\x03\
    \x04\x12\x03c\x047\n\x0f\n\x08\x06\0\x02\x03\x04\xc3\xf3\x04\x12\x03c\
    \x047\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03d\x04?\n\x10\n\t\x06\0\x02\
    \x03\x04\xc2\xf3\x04\0\x12\x03d\x04?\n\x0c\n\x05\x06\0\x02\x03\x04\x12\
    \x03e\x04F\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x01\x12\x03e\x04F\n\
    \x0c\n\x05\x06\0\x02\x03\x04\x12\x03f\x04C\n\x10\n\t\x06\0\x02\x03\x04\
    \xc2\xf3\x04\x02\x12\x03f\x04C\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03g\
    \x04A\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x03\x12\x03g\x04A\n3\n\x04\
    \x06\0\x02\x04\x12\x04k\x02u\x03\x1a%\x20Get\x20a\x20specific\x20concept\
    \x20from\x20an\x20app.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03k\x06\x10\
    \n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03k\x12#\n\x0c\n\x05\x06\0\x02\x04\
    \x03\x12\x03k.C\n\r\n\x05\x06\0\x02\x04\x04\x12\x04l\x04q\x06\n\x11\n\t\
    \x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04l\x04q\x06\n\x0c\n\x05\x06\0\x02\
    \x04\x04\x12\x03r\x047\n\x0f\n\x08\x06\0\x02\x04\x04\xc3\xf3\x04\x12\x03\
    r\x047\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03s\x04?\n\x10\n\t\x06\0\x02\
    \x04\x04\xc2\xf3\x04\0\x12\x03s\x04?\n\x0c\n\x05\x06\0\x02\x04\x04\x12\
    \x03t\x04C\n\x10\n\t\x06\0\x02\x04\x04\xc2\xf3\x04\x01\x12\x03t\x04C\n'\
    \n\x04\x06\0\x02\x05\x12\x05x\x02\x82\x01\x03\x1a\x18\x20List\x20all\x20\
    the\x20concepts.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03x\x06\x12\n\x0c\
    \n\x05\x06\0\x02\x05\x02\x12\x03x\x14'\n\x0c\n\x05\x06\0\x02\x05\x03\x12\
    \x03x2F\n\r\n\x05\x06\0\x02\x05\x04\x12\x04y\x04~\x06\n\x11\n\t\x06\0\
    \x02\x05\x04\xb0\xca\xbc\"\x12\x04y\x04~\x06\n\x0c\n\x05\x06\0\x02\x05\
    \x04\x12\x03\x7f\x047\n\x0f\n\x08\x06\0\x02\x05\x04\xc3\xf3\x04\x12\x03\
    \x7f\x047\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\x80\x01\x04?\n\x11\n\t\x06\
    \0\x02\x05\x04\xc2\xf3\x04\0\x12\x04\x80\x01\x04?\n\r\n\x05\x06\0\x02\
    \x05\x04\x12\x04\x81\x01\x04C\n\x11\n\t\x06\0\x02\x05\x04\xc2\xf3\x04\
    \x01\x12\x04\x81\x01\x04C\n'\n\x04\x06\0\x02\x06\x12\x06\x85\x01\x02\x90\
    \x01\x03\x1a\x17\x20List\x20models\x20concepts.\n\n\r\n\x05\x06\0\x02\
    \x06\x01\x12\x04\x85\x01\x06\x17\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x85\
    \x01\x191\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x85\x01<P\n\x0f\n\x05\x06\
    \0\x02\x06\x04\x12\x06\x86\x01\x04\x8b\x01\x06\n\x13\n\t\x06\0\x02\x06\
    \x04\xb0\xca\xbc\"\x12\x06\x86\x01\x04\x8b\x01\x06\n\r\n\x05\x06\0\x02\
    \x06\x04\x12\x04\x8c\x01\x047\n\x10\n\x08\x06\0\x02\x06\x04\xc3\xf3\x04\
    \x12\x04\x8c\x01\x047\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x8d\x01\x04?\n\
    \x11\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\0\x12\x04\x8d\x01\x04?\n\r\n\x05\
    \x06\0\x02\x06\x04\x12\x04\x8e\x01\x04C\n\x11\n\t\x06\0\x02\x06\x04\xc2\
    \xf3\x04\x01\x12\x04\x8e\x01\x04C\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\
    \x8f\x01\x04A\n\x11\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\x02\x12\x04\x8f\
    \x01\x04A\n\xcd\x01\n\x04\x06\0\x02\x07\x12\x06\x95\x01\x02\xa3\x01\x03\
    \x1a\xbc\x01\x20Search\x20over\x20the\x20concepts\x20to\x20find\x20one\
    \x20or\x20more\x20you're\x20looking\x20for.\n\x20This\x20leverage\x20the\
    \x20\"body\"\x20parameter\x20because\x20we\x20also\x20have\x20page\x20an\
    d\n\x20per_page\x20as\x20url\x20query\x20param\x20variables\x20in\x20thi\
    s\x20request.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x95\x01\x06\x1a\n\r\
    \n\x05\x06\0\x02\x07\x02\x12\x04\x95\x01\x1c7\n\r\n\x05\x06\0\x02\x07\
    \x03\x12\x04\x95\x01BV\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x96\x01\x04\
    \x9d\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\x96\x01\
    \x04\x9d\x01\x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\x9e\x01\x047\n\x10\
    \n\x08\x06\0\x02\x07\x04\xc3\xf3\x04\x12\x04\x9e\x01\x047\n\r\n\x05\x06\
    \0\x02\x07\x04\x12\x04\x9f\x01\x04?\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\
    \x04\0\x12\x04\x9f\x01\x04?\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xa0\x01\
    \x04C\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\x01\x12\x04\xa0\x01\x04C\n\
    \r\n\x05\x06\0\x02\x07\x04\x12\x04\xa1\x01\x04A\n\x11\n\t\x06\0\x02\x07\
    \x04\xc2\xf3\x04\x02\x12\x04\xa1\x01\x04A\n\r\n\x05\x06\0\x02\x07\x04\
    \x12\x04\xa2\x01\x04D\nP\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\x03\x12\x04\
    \xa2\x01\x04D\"=\x20as\x20it\x20needs\x20to\x20know\x20the\x20concepts\
    \x20in\x20your\x20workflow's\x20models.\n\n*\n\x04\x06\0\x02\x08\x12\x06\
    \xa6\x01\x02\xb3\x01\x03\x1a\x1a\x20Add\x20a\x20concept\x20to\x20an\x20a\
    pp.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xa6\x01\x06\x12\n\r\n\x05\x06\
    \0\x02\x08\x02\x12\x04\xa6\x01\x14'\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\
    \xa6\x012F\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xa7\x01\x04\xae\x01\x06\
    \n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xa7\x01\x04\xae\x01\
    \x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xaf\x01\x047\n\x10\n\x08\x06\0\
    \x02\x08\x04\xc3\xf3\x04\x12\x04\xaf\x01\x047\n\r\n\x05\x06\0\x02\x08\
    \x04\x12\x04\xb0\x01\x04?\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\x04\0\x12\
    \x04\xb0\x01\x04?\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xb1\x01\x04C\n\x11\
    \n\t\x06\0\x02\x08\x04\xc2\xf3\x04\x01\x12\x04\xb1\x01\x04C\n\r\n\x05\
    \x06\0\x02\x08\x04\x12\x04\xb2\x01\x04C\n\x11\n\t\x06\0\x02\x08\x04\xc2\
    \xf3\x04\x02\x12\x04\xb2\x01\x04C\n-\n\x04\x06\0\x02\t\x12\x06\xb6\x01\
    \x02\xc3\x01\x03\x1a\x1d\x20Patch\x20one\x20or\x20more\x20concepts.\n\n\
    \r\n\x05\x06\0\x02\t\x01\x12\x04\xb6\x01\x06\x13\n\r\n\x05\x06\0\x02\t\
    \x02\x12\x04\xb6\x01\x15)\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xb6\x014H\n\
    \x0f\n\x05\x06\0\x02\t\x04\x12\x06\xb7\x01\x04\xbe\x01\x06\n\x13\n\t\x06\
    \0\x02\t\x04\xb0\xca\xbc\"\x12\x06\xb7\x01\x04\xbe\x01\x06\n\r\n\x05\x06\
    \0\x02\t\x04\x12\x04\xbf\x01\x047\n\x10\n\x08\x06\0\x02\t\x04\xc3\xf3\
    \x04\x12\x04\xbf\x01\x047\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc0\x01\x04?\
    \n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\0\x12\x04\xc0\x01\x04?\n\r\n\x05\
    \x06\0\x02\t\x04\x12\x04\xc1\x01\x04C\n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\
    \x04\x01\x12\x04\xc1\x01\x04C\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc2\x01\
    \x04C\n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\x02\x12\x04\xc2\x01\x04C\n5\
    \n\x04\x06\0\x02\n\x12\x06\xd0\x01\x02\xda\x01\x03\x1a%\x20Get\x20a\x20s\
    pecific\x20concept\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\n\x01\x12\
    \x04\xd0\x01\x06\x18\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xd0\x01\x1a3\n\r\
    \n\x05\x06\0\x02\n\x03\x12\x04\xd0\x01>[\n\x0f\n\x05\x06\0\x02\n\x04\x12\
    \x06\xd1\x01\x04\xd6\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\
    \x06\xd1\x01\x04\xd6\x01\x06\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xd7\x01\
    \x047\n\x10\n\x08\x06\0\x02\n\x04\xc3\xf3\x04\x12\x04\xd7\x01\x047\n\r\n\
    \x05\x06\0\x02\n\x04\x12\x04\xd8\x01\x04?\n\x11\n\t\x06\0\x02\n\x04\xc2\
    \xf3\x04\0\x12\x04\xd8\x01\x04?\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xd9\
    \x01\x04C\n\x11\n\t\x06\0\x02\n\x04\xc2\xf3\x04\x01\x12\x04\xd9\x01\x04C\
    \nC\n\x04\x06\0\x02\x0b\x12\x06\xdd\x01\x02\xe7\x01\x03\x1a3\x20List\x20\
    the\x20concept\x20in\x20all\x20the\x20translated\x20languages.\n\n\r\n\
    \x05\x06\0\x02\x0b\x01\x12\x04\xdd\x01\x06\x1a\n\r\n\x05\x06\0\x02\x0b\
    \x02\x12\x04\xdd\x01\x1c7\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xdd\x01B^\
    \n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xde\x01\x04\xe3\x01\x06\n\x13\n\t\
    \x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xde\x01\x04\xe3\x01\x06\n\r\n\
    \x05\x06\0\x02\x0b\x04\x12\x04\xe4\x01\x047\n\x10\n\x08\x06\0\x02\x0b\
    \x04\xc3\xf3\x04\x12\x04\xe4\x01\x047\n\r\n\x05\x06\0\x02\x0b\x04\x12\
    \x04\xe5\x01\x04?\n\x11\n\t\x06\0\x02\x0b\x04\xc2\xf3\x04\0\x12\x04\xe5\
    \x01\x04?\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xe6\x01\x04C\n\x11\n\t\x06\
    \0\x02\x0b\x04\xc2\xf3\x04\x01\x12\x04\xe6\x01\x04C\n9\n\x04\x06\0\x02\
    \x0c\x12\x06\xea\x01\x02\xf7\x01\x03\x1a)\x20Add\x20a\x20new\x20translat\
    ion\x20for\x20this\x20concept.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xea\
    \x01\x06\x1a\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xea\x01\x1c7\n\r\n\x05\
    \x06\0\x02\x0c\x03\x12\x04\xea\x01B^\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\
    \x06\xeb\x01\x04\xf2\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\
    \x12\x06\xeb\x01\x04\xf2\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf3\
    \x01\x047\n\x10\n\x08\x06\0\x02\x0c\x04\xc3\xf3\x04\x12\x04\xf3\x01\x047\
    \n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf4\x01\x04?\n\x11\n\t\x06\0\x02\
    \x0c\x04\xc2\xf3\x04\0\x12\x04\xf4\x01\x04?\n\r\n\x05\x06\0\x02\x0c\x04\
    \x12\x04\xf5\x01\x04C\n\x11\n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\x01\x12\
    \x04\xf5\x01\x04C\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf6\x01\x04C\n\x11\
    \n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\x02\x12\x04\xf6\x01\x04C\n\x83\x01\n\
    \x04\x06\0\x02\r\x12\x06\xfb\x01\x02\x88\x02\x03\x1as\x20Patch\x20the\
    \x20name\x20for\x20a\x20given\x20language\x20names\x20by\x20passing\x20i\
    n\x20a\x20list\x20of\x20concepts\x20with\x20the\x20new\x20names\n\x20for\
    \x20the\x20languages.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xfb\x01\x06\
    \x1b\n\r\n\x05\x06\0\x02\r\x02\x12\x04\xfb\x01\x1d9\n\r\n\x05\x06\0\x02\
    \r\x03\x12\x04\xfb\x01D`\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\xfc\x01\x04\
    \x83\x02\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\xfc\x01\x04\
    \x83\x02\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x84\x02\x047\n\x10\n\x08\
    \x06\0\x02\r\x04\xc3\xf3\x04\x12\x04\x84\x02\x047\n\r\n\x05\x06\0\x02\r\
    \x04\x12\x04\x85\x02\x04?\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\0\x12\
    \x04\x85\x02\x04?\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x86\x02\x04C\n\x11\n\
    \t\x06\0\x02\r\x04\xc2\xf3\x04\x01\x12\x04\x86\x02\x04C\n\r\n\x05\x06\0\
    \x02\r\x04\x12\x04\x87\x02\x04C\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\
    \x02\x12\x04\x87\x02\x04C\n)\n\x04\x06\0\x02\x0e\x12\x06\x8e\x02\x02\x98\
    \x02\x03\x1a\x19\x20List\x20all\x20domain\x20graphs.\n\n\r\n\x05\x06\0\
    \x02\x0e\x01\x12\x04\x8e\x02\x06\x19\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\
    \x8e\x02\x1b5\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x8e\x02@[\n\x0f\n\x05\
    \x06\0\x02\x0e\x04\x12\x06\x8f\x02\x04\x94\x02\x06\n\x13\n\t\x06\0\x02\
    \x0e\x04\xb0\xca\xbc\"\x12\x06\x8f\x02\x04\x94\x02\x06\n\r\n\x05\x06\0\
    \x02\x0e\x04\x12\x04\x95\x02\x047\n\x10\n\x08\x06\0\x02\x0e\x04\xc3\xf3\
    \x04\x12\x04\x95\x02\x047\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x96\x02\
    \x04?\n\x11\n\t\x06\0\x02\x0e\x04\xc2\xf3\x04\0\x12\x04\x96\x02\x04?\n\r\
    \n\x05\x06\0\x02\x0e\x04\x12\x04\x97\x02\x04C\n\x11\n\t\x06\0\x02\x0e\
    \x04\xc2\xf3\x04\x01\x12\x04\x97\x02\x04C\n%\n\x04\x06\0\x02\x0f\x12\x06\
    \x9b\x02\x02\xa8\x02\x03\x1a\x15\x20Post\x20domain\x20graphs.\n\n\r\n\
    \x05\x06\0\x02\x0f\x01\x12\x04\x9b\x02\x06\x19\n\r\n\x05\x06\0\x02\x0f\
    \x02\x12\x04\x9b\x02\x1b5\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\x9b\x02@[\
    \n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\x9c\x02\x04\xa3\x02\x06\n\x13\n\t\
    \x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\x9c\x02\x04\xa3\x02\x06\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\xa4\x02\x047\n\x10\n\x08\x06\0\x02\x0f\
    \x04\xc3\xf3\x04\x12\x04\xa4\x02\x047\n\r\n\x05\x06\0\x02\x0f\x04\x12\
    \x04\xa5\x02\x04?\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\0\x12\x04\xa5\
    \x02\x04?\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xa6\x02\x04C\n\x11\n\t\x06\
    \0\x02\x0f\x04\xc2\xf3\x04\x01\x12\x04\xa6\x02\x04C\n\r\n\x05\x06\0\x02\
    \x0f\x04\x12\x04\xa7\x02\x04C\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\
    \x02\x12\x04\xa7\x02\x04C\n-\n\x04\x06\0\x02\x10\x12\x06\xab\x02\x02\xb8\
    \x02\x03\x1a\x1d\x20Start\x20concept\x20mapping\x20jobs.\n\n\r\n\x05\x06\
    \0\x02\x10\x01\x12\x04\xab\x02\x06\x1c\n\r\n\x05\x06\0\x02\x10\x02\x12\
    \x04\xab\x02\x1e;\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xab\x02Fd\n\x0f\n\
    \x05\x06\0\x02\x10\x04\x12\x06\xac\x02\x04\xb3\x02\x06\n\x13\n\t\x06\0\
    \x02\x10\x04\xb0\xca\xbc\"\x12\x06\xac\x02\x04\xb3\x02\x06\n\r\n\x05\x06\
    \0\x02\x10\x04\x12\x04\xb4\x02\x047\n\x10\n\x08\x06\0\x02\x10\x04\xc3\
    \xf3\x04\x12\x04\xb4\x02\x047\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xb5\
    \x02\x04?\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\0\x12\x04\xb5\x02\x04?\
    \n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xb6\x02\x04C\n\x11\n\t\x06\0\x02\
    \x10\x04\xc2\xf3\x04\x01\x12\x04\xb6\x02\x04C\n\r\n\x05\x06\0\x02\x10\
    \x04\x12\x04\xb7\x02\x04C\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\x02\
    \x12\x04\xb7\x02\x04C\n8\n\x04\x06\0\x02\x11\x12\x06\xbd\x02\x02\xc9\x02\
    \x03\x1a(\x20Get\x20a\x20specific\x20annotation\x20from\x20an\x20app.\n\
    \n\r\n\x05\x06\0\x02\x11\x01\x12\x04\xbd\x02\x06\x13\n\r\n\x05\x06\0\x02\
    \x11\x02\x12\x04\xbd\x02\x15)\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\xbd\
    \x024L\n\x0f\n\x05\x06\0\x02\x11\x04\x12\x06\xbe\x02\x04\xc3\x02\x06\n\
    \x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\"\x12\x06\xbe\x02\x04\xc3\x02\x06\
    \n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc4\x02\x047\n\x10\n\x08\x06\0\x02\
    \x11\x04\xc3\xf3\x04\x12\x04\xc4\x02\x047\n\r\n\x05\x06\0\x02\x11\x04\
    \x12\x04\xc5\x02\x04?\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\0\x12\x04\
    \xc5\x02\x04?\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc6\x02\x04F\n\x11\n\t\
    \x06\0\x02\x11\x04\xc2\xf3\x04\x01\x12\x04\xc6\x02\x04F\n\r\n\x05\x06\0\
    \x02\x11\x04\x12\x04\xc7\x02\x04C\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\
    \x04\x02\x12\x04\xc7\x02\x04C\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc8\
    \x02\x04A\n5\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\x03\x12\x04\xc8\x02\x04A\
    \"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20worker.\n\n*\n\x04\
    \x06\0\x02\x12\x12\x06\xcc\x02\x02\xd8\x02\x03\x1a\x1a\x20List\x20all\
    \x20the\x20annotation.\n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xcc\x02\x06\
    \x15\n\r\n\x05\x06\0\x02\x12\x02\x12\x04\xcc\x02\x17-\n\r\n\x05\x06\0\
    \x02\x12\x03\x12\x04\xcc\x028O\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xcd\
    \x02\x04\xd2\x02\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\
    \xcd\x02\x04\xd2\x02\x06\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xd3\x02\x04\
    7\n\x10\n\x08\x06\0\x02\x12\x04\xc3\xf3\x04\x12\x04\xd3\x02\x047\n\r\n\
    \x05\x06\0\x02\x12\x04\x12\x04\xd4\x02\x04?\n\x11\n\t\x06\0\x02\x12\x04\
    \xc2\xf3\x04\0\x12\x04\xd4\x02\x04?\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\
    \xd5\x02\x04F\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x01\x12\x04\xd5\
    \x02\x04F\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xd6\x02\x04C\n\x11\n\t\x06\
    \0\x02\x12\x04\xc2\xf3\x04\x02\x12\x04\xd6\x02\x04C\n\r\n\x05\x06\0\x02\
    \x12\x04\x12\x04\xd7\x02\x04A\n5\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x03\
    \x12\x04\xd7\x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20\
    worker.\n\n#\n\x04\x06\0\x02\x13\x12\x06\xdb\x02\x02\xec\x02\x03\x1a\x13\
    \x20Post\x20annotations.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\xdb\x02\
    \x06\x15\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\xdb\x02\x17-\n\r\n\x05\x06\
    \0\x02\x13\x03\x12\x04\xdb\x028O\n\x0f\n\x05\x06\0\x02\x13\x04\x12\x06\
    \xdc\x02\x04\xe3\x02\x06\n\x13\n\t\x06\0\x02\x13\x04\xb0\xca\xbc\"\x12\
    \x06\xdc\x02\x04\xe3\x02\x06\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe4\x02\
    \x047\n\x10\n\x08\x06\0\x02\x13\x04\xc3\xf3\x04\x12\x04\xe4\x02\x047\n\r\
    \n\x05\x06\0\x02\x13\x04\x12\x04\xe5\x02\x04?\n\x11\n\t\x06\0\x02\x13\
    \x04\xc2\xf3\x04\0\x12\x04\xe5\x02\x04?\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xe6\x02\x04A\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x01\x12\x04\
    \xe6\x02\x04A\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe7\x02\x04F\n\x11\n\t\
    \x06\0\x02\x13\x04\xc2\xf3\x04\x02\x12\x04\xe7\x02\x04F\n\r\n\x05\x06\0\
    \x02\x13\x04\x12\x04\xe8\x02\x04F\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\
    \x04\x03\x12\x04\xe8\x02\x04F\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe9\
    \x02\x04C\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x04\x12\x04\xe9\x02\
    \x04C\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xea\x02\x04A\n\x11\n\t\x06\0\
    \x02\x13\x04\xc2\xf3\x04\x05\x12\x04\xea\x02\x04A\n\r\n\x05\x06\0\x02\
    \x13\x04\x12\x04\xeb\x02\x04D\nA\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x06\
    \x12\x04\xeb\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n0\n\x04\x06\0\x02\x14\x12\x06\xef\x02\x02\
    \x80\x03\x03\x1a\x20\x20Patch\x20one\x20or\x20more\x20annotations.\n\n\r\
    \n\x05\x06\0\x02\x14\x01\x12\x04\xef\x02\x06\x16\n\r\n\x05\x06\0\x02\x14\
    \x02\x12\x04\xef\x02\x18/\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xef\x02:Q\
    \n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\xf0\x02\x04\xf7\x02\x06\n\x13\n\t\
    \x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\xf0\x02\x04\xf7\x02\x06\n\r\n\
    \x05\x06\0\x02\x14\x04\x12\x04\xf8\x02\x047\n\x10\n\x08\x06\0\x02\x14\
    \x04\xc3\xf3\x04\x12\x04\xf8\x02\x047\n\r\n\x05\x06\0\x02\x14\x04\x12\
    \x04\xf9\x02\x04?\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\0\x12\x04\xf9\
    \x02\x04?\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xfa\x02\x04A\n\x11\n\t\x06\
    \0\x02\x14\x04\xc2\xf3\x04\x01\x12\x04\xfa\x02\x04A\n\r\n\x05\x06\0\x02\
    \x14\x04\x12\x04\xfb\x02\x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\
    \x02\x12\x04\xfb\x02\x04F\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xfc\x02\
    \x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x03\x12\x04\xfc\x02\x04F\n\
    \r\n\x05\x06\0\x02\x14\x04\x12\x04\xfd\x02\x04C\n\x11\n\t\x06\0\x02\x14\
    \x04\xc2\xf3\x04\x04\x12\x04\xfd\x02\x04C\n\r\n\x05\x06\0\x02\x14\x04\
    \x12\x04\xfe\x02\x04D\nA\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x05\x12\x04\
    \xfe\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\x20default\
    \x20workflow.\n\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xff\x02\x04A\n5\n\t\
    \x06\0\x02\x14\x04\xc2\xf3\x04\x06\x12\x04\xff\x02\x04A\"\"\x20to\x20get\
    \x20the\x20model\x20for\x20the\x20worker.\n\nD\n\x04\x06\0\x02\x15\x12\
    \x06\x83\x03\x02\x8f\x03\x03\x1a4\x20Patch\x20annotations\x20status\x20b\
    y\x20worker\x20id\x20and\x20task\x20id.\n\n\r\n\x05\x06\0\x02\x15\x01\
    \x12\x04\x83\x03\x06\x1c\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\x83\x03\x1e\
    ;\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\x83\x03Fd\n\x0f\n\x05\x06\0\x02\
    \x15\x04\x12\x06\x84\x03\x04\x87\x03\x06\n\x13\n\t\x06\0\x02\x15\x04\xb0\
    \xca\xbc\"\x12\x06\x84\x03\x04\x87\x03\x06\n\r\n\x05\x06\0\x02\x15\x04\
    \x12\x04\x88\x03\x047\n\x10\n\x08\x06\0\x02\x15\x04\xc3\xf3\x04\x12\x04\
    \x88\x03\x047\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x89\x03\x04?\n\x11\n\t\
    \x06\0\x02\x15\x04\xc2\xf3\x04\0\x12\x04\x89\x03\x04?\n\r\n\x05\x06\0\
    \x02\x15\x04\x12\x04\x8a\x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\
    \x04\x01\x12\x04\x8a\x03\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x8b\
    \x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x02\x12\x04\x8b\x03\
    \x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x8c\x03\x04C\n\x11\n\t\x06\0\
    \x02\x15\x04\xc2\xf3\x04\x03\x12\x04\x8c\x03\x04C\n\r\n\x05\x06\0\x02\
    \x15\x04\x12\x04\x8d\x03\x04D\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\
    \x04\x12\x04\x8d\x03\x04D\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x8e\x03\
    \x04A\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x05\x12\x04\x8e\x03\x04A\n\
    -\n\x04\x06\0\x02\x16\x12\x06\x92\x03\x02\xa0\x03\x03\x1a\x1d\x20Delete\
    \x20a\x20single\x20annotation.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\x92\
    \x03\x06\x16\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\x92\x03\x18/\n\r\n\x05\
    \x06\0\x02\x16\x03\x12\x04\x92\x03:Z\n\x0f\n\x05\x06\0\x02\x16\x04\x12\
    \x06\x93\x03\x04\x98\x03\x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\
    \x12\x06\x93\x03\x04\x98\x03\x06\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x99\
    \x03\x047\n\x10\n\x08\x06\0\x02\x16\x04\xc3\xf3\x04\x12\x04\x99\x03\x047\
    \n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x9a\x03\x04?\n\x11\n\t\x06\0\x02\
    \x16\x04\xc2\xf3\x04\0\x12\x04\x9a\x03\x04?\n\r\n\x05\x06\0\x02\x16\x04\
    \x12\x04\x9b\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x01\x12\
    \x04\x9b\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x9c\x03\x04I\n\x11\
    \n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x02\x12\x04\x9c\x03\x04I\n\r\n\x05\
    \x06\0\x02\x16\x04\x12\x04\x9d\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\xc2\
    \xf3\x04\x03\x12\x04\x9d\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\
    \x9e\x03\x04D\n\\\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x04\x12\x04\x9e\x03\
    \x04D\"I\x20for\x20cleaning\x20up\x20some\x20optimizations\x20we\x20have\
    \x20in\x20DB\x20layer\x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\x16\
    \x04\x12\x04\x9f\x03\x04A\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x05\
    \x12\x04\x9f\x03\x04A\n=\n\x04\x06\0\x02\x17\x12\x06\xa3\x03\x02\xbb\x03\
    \x03\x1a-\x20Delete\x20multiple\x20annotations\x20in\x20one\x20request.\
    \n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\xa3\x03\x06\x17\n\r\n\x05\x06\0\
    \x02\x17\x02\x12\x04\xa3\x03\x191\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\
    \xa3\x03<\\\n\x0f\n\x05\x06\0\x02\x17\x04\x12\x06\xa4\x03\x04\xb3\x03\
    \x06\n\x13\n\t\x06\0\x02\x17\x04\xb0\xca\xbc\"\x12\x06\xa4\x03\x04\xb3\
    \x03\x06\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xb4\x03\x047\n\x10\n\x08\
    \x06\0\x02\x17\x04\xc3\xf3\x04\x12\x04\xb4\x03\x047\n\r\n\x05\x06\0\x02\
    \x17\x04\x12\x04\xb5\x03\x04?\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\0\
    \x12\x04\xb5\x03\x04?\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xb6\x03\x04F\n\
    \x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x01\x12\x04\xb6\x03\x04F\n\r\n\
    \x05\x06\0\x02\x17\x04\x12\x04\xb7\x03\x04I\n\x11\n\t\x06\0\x02\x17\x04\
    \xc2\xf3\x04\x02\x12\x04\xb7\x03\x04I\n\r\n\x05\x06\0\x02\x17\x04\x12\
    \x04\xb8\x03\x04F\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x03\x12\x04\
    \xb8\x03\x04F\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xb9\x03\x04D\n\\\n\t\
    \x06\0\x02\x17\x04\xc2\xf3\x04\x04\x12\x04\xb9\x03\x04D\"I\x20for\x20cle\
    aning\x20up\x20some\x20optimizations\x20we\x20have\x20in\x20DB\x20layer\
    \x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xba\x03\
    \x04A\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x05\x12\x04\xba\x03\x04A\n\
    :\n\x04\x06\0\x02\x18\x12\x06\xbe\x03\x02\xcb\x03\x03\x1a*\x20Patch\x20s\
    aved\x20annotations\x20searches\x20by\x20ids.\n\n\r\n\x05\x06\0\x02\x18\
    \x01\x12\x04\xbe\x03\x06\x1e\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\xbe\x03\
    \x20?\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\xbe\x03J]\n\x0f\n\x05\x06\0\
    \x02\x18\x04\x12\x06\xbf\x03\x04\xc6\x03\x06\n\x13\n\t\x06\0\x02\x18\x04\
    \xb0\xca\xbc\"\x12\x06\xbf\x03\x04\xc6\x03\x06\n\r\n\x05\x06\0\x02\x18\
    \x04\x12\x04\xc7\x03\x047\n\x10\n\x08\x06\0\x02\x18\x04\xc3\xf3\x04\x12\
    \x04\xc7\x03\x047\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xc8\x03\x04?\n\x11\
    \n\t\x06\0\x02\x18\x04\xc2\xf3\x04\0\x12\x04\xc8\x03\x04?\n\r\n\x05\x06\
    \0\x02\x18\x04\x12\x04\xc9\x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\
    \x04\x01\x12\x04\xc9\x03\x04F\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xca\
    \x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\x04\x02\x12\x04\xca\x03\
    \x04F\n3\n\x04\x06\0\x02\x19\x12\x06\xce\x03\x02\xdf\x03\x03\x1a#\x20Exe\
    cute\x20a\x20search\x20over\x20annotations\n\n\r\n\x05\x06\0\x02\x19\x01\
    \x12\x04\xce\x03\x06\x1d\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xce\x03\x1e\
    <\n\r\n\x05\x06\0\x02\x19\x03\x12\x04\xce\x03GZ\n\x0f\n\x05\x06\0\x02\
    \x19\x04\x12\x06\xcf\x03\x04\xd6\x03\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\
    \xca\xbc\"\x12\x06\xcf\x03\x04\xd6\x03\x06\n\r\n\x05\x06\0\x02\x19\x04\
    \x12\x04\xd7\x03\x047\n\x10\n\x08\x06\0\x02\x19\x04\xc3\xf3\x04\x12\x04\
    \xd7\x03\x047\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xd8\x03\x04?\n\x11\n\t\
    \x06\0\x02\x19\x04\xc2\xf3\x04\0\x12\x04\xd8\x03\x04?\n\r\n\x05\x06\0\
    \x02\x19\x04\x12\x04\xd9\x03\x04F\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\
    \x04\x01\x12\x04\xd9\x03\x04F\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xda\
    \x03\x04C\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x02\x12\x04\xda\x03\
    \x04C\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xdb\x03\x04A\n\x11\n\t\x06\0\
    \x02\x19\x04\xc2\xf3\x04\x03\x12\x04\xdb\x03\x04A\n\r\n\x05\x06\0\x02\
    \x19\x04\x12\x04\xdc\x03\x04A\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\
    \x04\x12\x04\xdc\x03\x04A\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xdd\x03\
    \x04=\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x05\x12\x04\xdd\x03\x04=\n\
    \r\n\x05\x06\0\x02\x19\x04\x12\x04\xde\x03\x04D\nN\n\t\x06\0\x02\x19\x04\
    \xc2\xf3\x04\x06\x12\x04\xde\x03\x04D\";\x20to\x20know\x20the\x20concept\
    s\x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n\x9e\x01\n\
    \x04\x06\0\x02\x1a\x12\x06\xe3\x03\x02\xf0\x03\x03\x1a\x8d\x01\x20ListAn\
    notationWorkers\x20lists\x20users,\x20models,\x20and\x20workflows\x20(co\
    llectively\n\x20known\x20as\x20\"workers\")\x20that\x20have\x20added\x20\
    annotations\x20to\x20the\x20application.\n\n\r\n\x05\x06\0\x02\x1a\x01\
    \x12\x04\xe3\x03\x06\x1b\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xe3\x03\x1d\
    9\n\r\n\x05\x06\0\x02\x1a\x03\x12\x04\xe3\x03DW\n\x0f\n\x05\x06\0\x02\
    \x1a\x04\x12\x06\xe4\x03\x04\xe9\x03\x06\n\x13\n\t\x06\0\x02\x1a\x04\xb0\
    \xca\xbc\"\x12\x06\xe4\x03\x04\xe9\x03\x06\n\r\n\x05\x06\0\x02\x1a\x04\
    \x12\x04\xea\x03\x047\n\x10\n\x08\x06\0\x02\x1a\x04\xc3\xf3\x04\x12\x04\
    \xea\x03\x047\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xeb\x03\x04?\n\x11\n\t\
    \x06\0\x02\x1a\x04\xc2\xf3\x04\0\x12\x04\xeb\x03\x04?\n\r\n\x05\x06\0\
    \x02\x1a\x04\x12\x04\xec\x03\x04F\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\
    \x04\x01\x12\x04\xec\x03\x04F\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xed\
    \x03\x04H\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\x02\x12\x04\xed\x03\
    \x04H\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xee\x03\x04A\n\x11\n\t\x06\0\
    \x02\x1a\x04\xc2\xf3\x04\x03\x12\x04\xee\x03\x04A\n\r\n\x05\x06\0\x02\
    \x1a\x04\x12\x04\xef\x03\x04D\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\
    \x04\x12\x04\xef\x03\x04D\n-\n\x04\x06\0\x02\x1b\x12\x06\xf3\x03\x02\xff\
    \x03\x03\x1a\x1d\x20Get\x20input\x20count\x20per\x20status.\n\n\r\n\x05\
    \x06\0\x02\x1b\x01\x12\x04\xf3\x03\x06\x13\n\r\n\x05\x06\0\x02\x1b\x02\
    \x12\x04\xf3\x03\x15)\n\r\n\x05\x06\0\x02\x1b\x03\x12\x04\xf3\x034L\n\
    \x0f\n\x05\x06\0\x02\x1b\x04\x12\x06\xf4\x03\x04\xf9\x03\x06\n\x13\n\t\
    \x06\0\x02\x1b\x04\xb0\xca\xbc\"\x12\x06\xf4\x03\x04\xf9\x03\x06\n\r\n\
    \x05\x06\0\x02\x1b\x04\x12\x04\xfa\x03\x047\n\x10\n\x08\x06\0\x02\x1b\
    \x04\xc3\xf3\x04\x12\x04\xfa\x03\x047\n\r\n\x05\x06\0\x02\x1b\x04\x12\
    \x04\xfb\x03\x04?\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\0\x12\x04\xfb\
    \x03\x04?\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xfc\x03\x04F\n\x11\n\t\x06\
    \0\x02\x1b\x04\xc2\xf3\x04\x01\x12\x04\xfc\x03\x04F\n\r\n\x05\x06\0\x02\
    \x1b\x04\x12\x04\xfd\x03\x04C\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\
    \x02\x12\x04\xfd\x03\x04C\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xfe\x03\
    \x04A\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\x03\x12\x04\xfe\x03\x04A\n\
    E\n\x04\x06\0\x02\x1c\x12\x06\x82\x04\x02\x8e\x04\x03\x1a5\x20Streams\
    \x20all\x20the\x20inputs\x20starting\x20from\x20oldest\x20assets.\n\n\r\
    \n\x05\x06\0\x02\x1c\x01\x12\x04\x82\x04\x06\x12\n\r\n\x05\x06\0\x02\x1c\
    \x02\x12\x04\x82\x04\x14'\n\r\n\x05\x06\0\x02\x1c\x03\x12\x04\x82\x042D\
    \n\x0f\n\x05\x06\0\x02\x1c\x04\x12\x06\x83\x04\x04\x88\x04\x06\n\x13\n\t\
    \x06\0\x02\x1c\x04\xb0\xca\xbc\"\x12\x06\x83\x04\x04\x88\x04\x06\n\r\n\
    \x05\x06\0\x02\x1c\x04\x12\x04\x89\x04\x047\n\x10\n\x08\x06\0\x02\x1c\
    \x04\xc3\xf3\x04\x12\x04\x89\x04\x047\n\r\n\x05\x06\0\x02\x1c\x04\x12\
    \x04\x8a\x04\x04?\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\0\x12\x04\x8a\
    \x04\x04?\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x8b\x04\x04F\n\x11\n\t\x06\
    \0\x02\x1c\x04\xc2\xf3\x04\x01\x12\x04\x8b\x04\x04F\n\r\n\x05\x06\0\x02\
    \x1c\x04\x12\x04\x8c\x04\x04C\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\
    \x02\x12\x04\x8c\x04\x04C\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x8d\x04\
    \x04A\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\x03\x12\x04\x8d\x04\x04A\n\
    3\n\x04\x06\0\x02\x1d\x12\x06\x91\x04\x02\x9d\x04\x03\x1a#\x20Get\x20a\
    \x20specific\x20input\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\x1d\
    \x01\x12\x04\x91\x04\x06\x15\n\r\n\x05\x06\0\x02\x1d\x02\x12\x04\x91\x04\
    \x17-\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\x91\x048T\n\x0f\n\x05\x06\0\
    \x02\x1d\x04\x12\x06\x92\x04\x04\x97\x04\x06\n\x13\n\t\x06\0\x02\x1d\x04\
    \xb0\xca\xbc\"\x12\x06\x92\x04\x04\x97\x04\x06\n\r\n\x05\x06\0\x02\x1d\
    \x04\x12\x04\x98\x04\x047\n\x10\n\x08\x06\0\x02\x1d\x04\xc3\xf3\x04\x12\
    \x04\x98\x04\x047\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x99\x04\x04?\n\x11\
    \n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\0\x12\x04\x99\x04\x04?\n\r\n\x05\x06\
    \0\x02\x1d\x04\x12\x04\x9a\x04\x04F\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\
    \x04\x01\x12\x04\x9a\x04\x04F\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x9b\
    \x04\x04C\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x02\x12\x04\x9b\x04\
    \x04C\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x9c\x04\x04A\n\x11\n\t\x06\0\
    \x02\x1d\x04\xc2\xf3\x04\x03\x12\x04\x9c\x04\x04A\n3\n\x04\x06\0\x02\x1e\
    \x12\x06\xa0\x04\x02\xac\x04\x03\x1a#\x20Get\x20a\x20specific\x20input\
    \x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\x1e\x01\x12\x04\xa0\x04\x06\
    \x0e\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\xa0\x04\x10\x1f\n\r\n\x05\x06\0\
    \x02\x1e\x03\x12\x04\xa0\x04*=\n\x0f\n\x05\x06\0\x02\x1e\x04\x12\x06\xa1\
    \x04\x04\xa6\x04\x06\n\x13\n\t\x06\0\x02\x1e\x04\xb0\xca\xbc\"\x12\x06\
    \xa1\x04\x04\xa6\x04\x06\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xa7\x04\x04\
    7\n\x10\n\x08\x06\0\x02\x1e\x04\xc3\xf3\x04\x12\x04\xa7\x04\x047\n\r\n\
    \x05\x06\0\x02\x1e\x04\x12\x04\xa8\x04\x04?\n\x11\n\t\x06\0\x02\x1e\x04\
    \xc2\xf3\x04\0\x12\x04\xa8\x04\x04?\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\
    \xa9\x04\x04F\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x01\x12\x04\xa9\
    \x04\x04F\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xaa\x04\x04C\n\x11\n\t\x06\
    \0\x02\x1e\x04\xc2\xf3\x04\x02\x12\x04\xaa\x04\x04C\n\r\n\x05\x06\0\x02\
    \x1e\x04\x12\x04\xab\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\
    \x03\x12\x04\xab\x04\x04A\n-\n\x04\x06\0\x02\x1f\x12\x06\xaf\x04\x02\xb9\
    \x04\x03\x1a\x1d\x20Get\x20a\x20video\x20input\x20manifest.\n\n\r\n\x05\
    \x06\0\x02\x1f\x01\x12\x04\xaf\x04\x06\x1b\n\r\n\x05\x06\0\x02\x1f\x02\
    \x12\x04\xaf\x04\x1d4\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\xaf\x04?W\n\
    \x0f\n\x05\x06\0\x02\x1f\x04\x12\x06\xb0\x04\x04\xb5\x04\x06\n\x13\n\t\
    \x06\0\x02\x1f\x04\xb0\xca\xbc\"\x12\x06\xb0\x04\x04\xb5\x04\x06\n\r\n\
    \x05\x06\0\x02\x1f\x04\x12\x04\xb6\x04\x047\n\x10\n\x08\x06\0\x02\x1f\
    \x04\xc3\xf3\x04\x12\x04\xb6\x04\x047\n\r\n\x05\x06\0\x02\x1f\x04\x12\
    \x04\xb7\x04\x04?\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\0\x12\x04\xb7\
    \x04\x04?\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xb8\x04\x04A\n\x11\n\t\x06\
    \0\x02\x1f\x04\xc2\xf3\x04\x01\x12\x04\xb8\x04\x04A\n&\n\x04\x06\0\x02\
    \x20\x12\x06\xbc\x04\x02\xc8\x04\x03\x1a\x16\x20List\x20all\x20the\x20in\
    puts.\n\n\r\n\x05\x06\0\x02\x20\x01\x12\x04\xbc\x04\x06\x10\n\r\n\x05\
    \x06\0\x02\x20\x02\x12\x04\xbc\x04\x12#\n\r\n\x05\x06\0\x02\x20\x03\x12\
    \x04\xbc\x04.@\n\x0f\n\x05\x06\0\x02\x20\x04\x12\x06\xbd\x04\x04\xc2\x04\
    \x06\n\x13\n\t\x06\0\x02\x20\x04\xb0\xca\xbc\"\x12\x06\xbd\x04\x04\xc2\
    \x04\x06\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xc3\x04\x047\n\x10\n\x08\
    \x06\0\x02\x20\x04\xc3\xf3\x04\x12\x04\xc3\x04\x047\n\r\n\x05\x06\0\x02\
    \x20\x04\x12\x04\xc4\x04\x04?\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\0\
    \x12\x04\xc4\x04\x04?\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xc5\x04\x04F\n\
    \x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x01\x12\x04\xc5\x04\x04F\n\r\n\
    \x05\x06\0\x02\x20\x04\x12\x04\xc6\x04\x04C\n\x11\n\t\x06\0\x02\x20\x04\
    \xc2\xf3\x04\x02\x12\x04\xc6\x04\x04C\n\r\n\x05\x06\0\x02\x20\x04\x12\
    \x04\xc7\x04\x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x03\x12\x04\
    \xc7\x04\x04A\n_\n\x04\x06\0\x02!\x12\x06\xcc\x04\x02\xdf\x04\x03\x1aO\
    \x20Add\x201\x20or\x20more\x20input\x20to\x20an\x20app.\n\x20The\x20actu\
    al\x20inputs\x20processing\x20is\x20asynchronous.\n\n\r\n\x05\x06\0\x02!\
    \x01\x12\x04\xcc\x04\x06\x10\n\r\n\x05\x06\0\x02!\x02\x12\x04\xcc\x04\
    \x12#\n\r\n\x05\x06\0\x02!\x03\x12\x04\xcc\x04.@\n\x0f\n\x05\x06\0\x02!\
    \x04\x12\x06\xcd\x04\x04\xd4\x04\x06\n\x13\n\t\x06\0\x02!\x04\xb0\xca\
    \xbc\"\x12\x06\xcd\x04\x04\xd4\x04\x06\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xd5\x04\x047\n\x10\n\x08\x06\0\x02!\x04\xc3\xf3\x04\x12\x04\xd5\x04\x04\
    7\n\r\n\x05\x06\0\x02!\x04\x12\x04\xd6\x04\x04?\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\0\x12\x04\xd6\x04\x04?\n\r\n\x05\x06\0\x02!\x04\x12\x04\xd7\
    \x04\x04F\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x01\x12\x04\xd7\x04\x04F\
    \n\r\n\x05\x06\0\x02!\x04\x12\x04\xd8\x04\x04F\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\x02\x12\x04\xd8\x04\x04F\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xd9\x04\x04C\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x03\x12\x04\xd9\x04\
    \x04C\n\r\n\x05\x06\0\x02!\x04\x12\x04\xda\x04\x04A\n\x11\n\t\x06\0\x02!\
    \x04\xc2\xf3\x04\x04\x12\x04\xda\x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\
    \x04\xdb\x04\x04A\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x05\x12\x04\xdb\
    \x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\x04\xdc\x04\x04A\n\x11\n\t\x06\0\
    \x02!\x04\xc2\xf3\x04\x06\x12\x04\xdc\x04\x04A\n\r\n\x05\x06\0\x02!\x04\
    \x12\x04\xdd\x04\x04>\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x07\x12\x04\
    \xdd\x04\x04>\n\r\n\x05\x06\0\x02!\x04\x12\x04\xde\x04\x04D\n\x11\n\t\
    \x06\0\x02!\x04\xc2\xf3\x04\x08\x12\x04\xde\x04\x04D\n+\n\x04\x06\0\x02\
    \"\x12\x06\xe5\x04\x02\xf6\x04\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\
    \x20inputs.\n\n\r\n\x05\x06\0\x02\"\x01\x12\x04\xe5\x04\x06\x11\n\r\n\
    \x05\x06\0\x02\"\x02\x12\x04\xe5\x04\x13%\n\r\n\x05\x06\0\x02\"\x03\x12\
    \x04\xe5\x040B\n\x0f\n\x05\x06\0\x02\"\x04\x12\x06\xe6\x04\x04\xed\x04\
    \x06\n\x13\n\t\x06\0\x02\"\x04\xb0\xca\xbc\"\x12\x06\xe6\x04\x04\xed\x04\
    \x06\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xee\x04\x047\n\x10\n\x08\x06\0\
    \x02\"\x04\xc3\xf3\x04\x12\x04\xee\x04\x047\n\r\n\x05\x06\0\x02\"\x04\
    \x12\x04\xef\x04\x04?\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\0\x12\x04\
    \xef\x04\x04?\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf0\x04\x04F\n\x11\n\t\
    \x06\0\x02\"\x04\xc2\xf3\x04\x01\x12\x04\xf0\x04\x04F\n\r\n\x05\x06\0\
    \x02\"\x04\x12\x04\xf1\x04\x04F\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\
    \x02\x12\x04\xf1\x04\x04F\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf2\x04\x04C\
    \n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x03\x12\x04\xf2\x04\x04C\n\r\n\
    \x05\x06\0\x02\"\x04\x12\x04\xf3\x04\x04A\n\x11\n\t\x06\0\x02\"\x04\xc2\
    \xf3\x04\x04\x12\x04\xf3\x04\x04A\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf4\
    \x04\x04A\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x05\x12\x04\xf4\x04\x04A\
    \n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf5\x04\x04A\n\x11\n\t\x06\0\x02\"\
    \x04\xc2\xf3\x04\x06\x12\x04\xf5\x04\x04A\n7\n\x04\x06\0\x02#\x12\x06\
    \xf9\x04\x02\x8a\x05\x03\x1a'\x20Delete\x20a\x20single\x20input\x20async\
    hronously.\n\n\r\n\x05\x06\0\x02#\x01\x12\x04\xf9\x04\x06\x11\n\r\n\x05\
    \x06\0\x02#\x02\x12\x04\xf9\x04\x13%\n\r\n\x05\x06\0\x02#\x03\x12\x04\
    \xf9\x040P\n\x0f\n\x05\x06\0\x02#\x04\x12\x06\xfa\x04\x04\xff\x04\x06\n\
    \x13\n\t\x06\0\x02#\x04\xb0\xca\xbc\"\x12\x06\xfa\x04\x04\xff\x04\x06\n\
    \r\n\x05\x06\0\x02#\x04\x12\x04\x80\x05\x047\n\x10\n\x08\x06\0\x02#\x04\
    \xc3\xf3\x04\x12\x04\x80\x05\x047\n\r\n\x05\x06\0\x02#\x04\x12\x04\x81\
    \x05\x04?\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\0\x12\x04\x81\x05\x04?\n\
    \r\n\x05\x06\0\x02#\x04\x12\x04\x82\x05\x04F\n\x11\n\t\x06\0\x02#\x04\
    \xc2\xf3\x04\x01\x12\x04\x82\x05\x04F\n\r\n\x05\x06\0\x02#\x04\x12\x04\
    \x83\x05\x04I\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x02\x12\x04\x83\x05\
    \x04I\n\r\n\x05\x06\0\x02#\x04\x12\x04\x84\x05\x04F\n\x11\n\t\x06\0\x02#\
    \x04\xc2\xf3\x04\x03\x12\x04\x84\x05\x04F\n\r\n\x05\x06\0\x02#\x04\x12\
    \x04\x85\x05\x04A\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x04\x12\x04\x85\
    \x05\x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\x86\x05\x04D\n\x11\n\t\x06\0\
    \x02#\x04\xc2\xf3\x04\x05\x12\x04\x86\x05\x04D\n\r\n\x05\x06\0\x02#\x04\
    \x12\x04\x87\x05\x04A\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x06\x12\x04\
    \x87\x05\x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\x88\x05\x04A\n\x11\n\t\
    \x06\0\x02#\x04\xc2\xf3\x04\x07\x12\x04\x88\x05\x04A\n\r\n\x05\x06\0\x02\
    #\x04\x12\x04\x89\x05\x04D\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x08\x12\
    \x04\x89\x05\x04D\nT\n\x04\x06\0\x02$\x12\x06\x8e\x05\x02\xa1\x05\x03\
    \x1aD\x20Delete\x20multiple\x20inputs\x20in\x20one\x20request.\n\x20This\
    \x20call\x20is\x20asynchronous.\n\n\r\n\x05\x06\0\x02$\x01\x12\x04\x8e\
    \x05\x06\x12\n\r\n\x05\x06\0\x02$\x02\x12\x04\x8e\x05\x14'\n\r\n\x05\x06\
    \0\x02$\x03\x12\x04\x8e\x052R\n\x0f\n\x05\x06\0\x02$\x04\x12\x06\x8f\x05\
    \x04\x96\x05\x06\n\x13\n\t\x06\0\x02$\x04\xb0\xca\xbc\"\x12\x06\x8f\x05\
    \x04\x96\x05\x06\n\r\n\x05\x06\0\x02$\x04\x12\x04\x97\x05\x047\n\x10\n\
    \x08\x06\0\x02$\x04\xc3\xf3\x04\x12\x04\x97\x05\x047\n\r\n\x05\x06\0\x02\
    $\x04\x12\x04\x98\x05\x04?\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\0\x12\
    \x04\x98\x05\x04?\n\r\n\x05\x06\0\x02$\x04\x12\x04\x99\x05\x04F\n\x11\n\
    \t\x06\0\x02$\x04\xc2\xf3\x04\x01\x12\x04\x99\x05\x04F\n\r\n\x05\x06\0\
    \x02$\x04\x12\x04\x9a\x05\x04I\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x02\
    \x12\x04\x9a\x05\x04I\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9b\x05\x04F\n\
    \x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x03\x12\x04\x9b\x05\x04F\n\r\n\x05\
    \x06\0\x02$\x04\x12\x04\x9c\x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\
    \x04\x04\x12\x04\x9c\x05\x04A\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9d\x05\
    \x04D\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x05\x12\x04\x9d\x05\x04D\n\r\
    \n\x05\x06\0\x02$\x04\x12\x04\x9e\x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\
    \xf3\x04\x06\x12\x04\x9e\x05\x04A\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9f\
    \x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x07\x12\x04\x9f\x05\x04A\
    \n\r\n\x05\x06\0\x02$\x04\x12\x04\xa0\x05\x04D\n\x11\n\t\x06\0\x02$\x04\
    \xc2\xf3\x04\x08\x12\x04\xa0\x05\x04D\n5\n\x04\x06\0\x02%\x12\x06\xa4\
    \x05\x02\xb1\x05\x03\x1a%\x20Patch\x20saved\x20inputs\x20searches\x20by\
    \x20ids.\n\n\r\n\x05\x06\0\x02%\x01\x12\x04\xa4\x05\x06\x19\n\r\n\x05\
    \x06\0\x02%\x02\x12\x04\xa4\x05\x1b5\n\r\n\x05\x06\0\x02%\x03\x12\x04\
    \xa4\x05@S\n\x0f\n\x05\x06\0\x02%\x04\x12\x06\xa5\x05\x04\xac\x05\x06\n\
    \x13\n\t\x06\0\x02%\x04\xb0\xca\xbc\"\x12\x06\xa5\x05\x04\xac\x05\x06\n\
    \r\n\x05\x06\0\x02%\x04\x12\x04\xad\x05\x047\n\x10\n\x08\x06\0\x02%\x04\
    \xc3\xf3\x04\x12\x04\xad\x05\x047\n\r\n\x05\x06\0\x02%\x04\x12\x04\xae\
    \x05\x04?\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\0\x12\x04\xae\x05\x04?\n\
    \r\n\x05\x06\0\x02%\x04\x12\x04\xaf\x05\x04F\n\x11\n\t\x06\0\x02%\x04\
    \xc2\xf3\x04\x01\x12\x04\xaf\x05\x04F\n\r\n\x05\x06\0\x02%\x04\x12\x04\
    \xb0\x05\x04F\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\x02\x12\x04\xb0\x05\
    \x04F\n.\n\x04\x06\0\x02&\x12\x06\xb4\x05\x02\xc5\x05\x03\x1a\x1e\x20Exe\
    cute\x20a\x20search\x20over\x20inputs\n\n\r\n\x05\x06\0\x02&\x01\x12\x04\
    \xb4\x05\x06\x18\n\r\n\x05\x06\0\x02&\x02\x12\x04\xb4\x05\x192\n\r\n\x05\
    \x06\0\x02&\x03\x12\x04\xb4\x05=P\n\x0f\n\x05\x06\0\x02&\x04\x12\x06\xb5\
    \x05\x04\xbc\x05\x06\n\x13\n\t\x06\0\x02&\x04\xb0\xca\xbc\"\x12\x06\xb5\
    \x05\x04\xbc\x05\x06\n\r\n\x05\x06\0\x02&\x04\x12\x04\xbd\x05\x047\n\x10\
    \n\x08\x06\0\x02&\x04\xc3\xf3\x04\x12\x04\xbd\x05\x047\n\r\n\x05\x06\0\
    \x02&\x04\x12\x04\xbe\x05\x04?\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\0\
    \x12\x04\xbe\x05\x04?\n\r\n\x05\x06\0\x02&\x04\x12\x04\xbf\x05\x04F\n\
    \x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x01\x12\x04\xbf\x05\x04F\n\r\n\x05\
    \x06\0\x02&\x04\x12\x04\xc0\x05\x04C\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\
    \x04\x02\x12\x04\xc0\x05\x04C\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc1\x05\
    \x04A\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x03\x12\x04\xc1\x05\x04A\n\r\
    \n\x05\x06\0\x02&\x04\x12\x04\xc2\x05\x04A\n\x11\n\t\x06\0\x02&\x04\xc2\
    \xf3\x04\x04\x12\x04\xc2\x05\x04A\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc3\
    \x05\x04=\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x05\x12\x04\xc3\x05\x04=\
    \n\r\n\x05\x06\0\x02&\x04\x12\x04\xc4\x05\x04D\nN\n\t\x06\0\x02&\x04\xc2\
    \xf3\x04\x06\x12\x04\xc4\x05\x04D\";\x20to\x20know\x20the\x20concepts\
    \x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n7\n\x04\x06\0\
    \x02'\x12\x06\xc8\x05\x02\xde\x05\x03\x1a'\x20Get\x20predicted\x20output\
    s\x20from\x20the\x20model.\n\n\r\n\x05\x06\0\x02'\x01\x12\x04\xc8\x05\
    \x06\x16\n\r\n\x05\x06\0\x02'\x02\x12\x04\xc8\x05\x18/\n\r\n\x05\x06\0\
    \x02'\x03\x12\x04\xc8\x05:M\n\x0f\n\x05\x06\0\x02'\x04\x12\x06\xc9\x05\
    \x04\xd8\x05\x06\n\x13\n\t\x06\0\x02'\x04\xb0\xca\xbc\"\x12\x06\xc9\x05\
    \x04\xd8\x05\x06\n\r\n\x05\x06\0\x02'\x04\x12\x04\xd9\x05\x047\n\x10\n\
    \x08\x06\0\x02'\x04\xc3\xf3\x04\x12\x04\xd9\x05\x047\n\r\n\x05\x06\0\x02\
    '\x04\x12\x04\xda\x05\x04?\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\0\x12\
    \x04\xda\x05\x04?\n\r\n\x05\x06\0\x02'\x04\x12\x04\xdb\x05\x04C\n\x11\n\
    \t\x06\0\x02'\x04\xc2\xf3\x04\x01\x12\x04\xdb\x05\x04C\n\r\n\x05\x06\0\
    \x02'\x04\x12\x04\xdc\x05\x04A\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\x02\
    \x12\x04\xdc\x05\x04A\n\r\n\x05\x06\0\x02'\x04\x12\x04\xdd\x05\x04>\n\
    \x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\x03\x12\x04\xdd\x05\x04>\n(\n\x04\
    \x06\0\x02(\x12\x06\xe1\x05\x02\xef\x05\x03\x1a\x18\x20List\x20all\x20th\
    e\x20datasets.\n\n\r\n\x05\x06\0\x02(\x01\x12\x04\xe1\x05\x06\x12\n\r\n\
    \x05\x06\0\x02(\x02\x12\x04\xe1\x05\x14'\n\r\n\x05\x06\0\x02(\x03\x12\
    \x04\xe1\x052F\n\x0f\n\x05\x06\0\x02(\x04\x12\x06\xe2\x05\x04\xea\x05\
    \x06\n\x13\n\t\x06\0\x02(\x04\xb0\xca\xbc\"\x12\x06\xe2\x05\x04\xea\x05\
    \x06\n\r\n\x05\x06\0\x02(\x04\x12\x04\xeb\x05\x047\n\x10\n\x08\x06\0\x02\
    (\x04\xc3\xf3\x04\x12\x04\xeb\x05\x047\n\r\n\x05\x06\0\x02(\x04\x12\x04\
    \xec\x05\x04?\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\0\x12\x04\xec\x05\x04\
    ?\n\r\n\x05\x06\0\x02(\x04\x12\x04\xed\x05\x04C\n\x11\n\t\x06\0\x02(\x04\
    \xc2\xf3\x04\x01\x12\x04\xed\x05\x04C\n\r\n\x05\x06\0\x02(\x04\x12\x04\
    \xee\x05\x04F\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\x02\x12\x04\xee\x05\
    \x04F\n)\n\x04\x06\0\x02)\x12\x06\xf2\x05\x02\xfd\x05\x03\x1a\x19\x20Get\
    \x20a\x20specific\x20dataset.\n\n\r\n\x05\x06\0\x02)\x01\x12\x04\xf2\x05\
    \x06\x10\n\r\n\x05\x06\0\x02)\x02\x12\x04\xf2\x05\x12#\n\r\n\x05\x06\0\
    \x02)\x03\x12\x04\xf2\x05.C\n\x0f\n\x05\x06\0\x02)\x04\x12\x06\xf3\x05\
    \x04\xf8\x05\x06\n\x13\n\t\x06\0\x02)\x04\xb0\xca\xbc\"\x12\x06\xf3\x05\
    \x04\xf8\x05\x06\n\r\n\x05\x06\0\x02)\x04\x12\x04\xf9\x05\x047\n\x10\n\
    \x08\x06\0\x02)\x04\xc3\xf3\x04\x12\x04\xf9\x05\x047\n\r\n\x05\x06\0\x02\
    )\x04\x12\x04\xfa\x05\x04?\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\0\x12\
    \x04\xfa\x05\x04?\n\r\n\x05\x06\0\x02)\x04\x12\x04\xfb\x05\x04C\n\x11\n\
    \t\x06\0\x02)\x04\xc2\xf3\x04\x01\x12\x04\xfb\x05\x04C\n\r\n\x05\x06\0\
    \x02)\x04\x12\x04\xfc\x05\x04F\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\x02\
    \x12\x04\xfc\x05\x04F\n\xd8\x01\n\x04\x06\0\x02*\x12\x06\x83\x06\x02\x91\
    \x06\x03\x1a\xc7\x01\x20Add\x20datasets\x20to\x20an\x20app.\n\x20The\x20\
    process\x20is\x20atomic,\x20i.e.\x20either\x20all\x20or\x20no\x20dataset\
    s\x20are\x20added.\n\x20If\x20there\x20is\x20an\x20error\x20for\x20one\
    \x20dataset,\n\x20the\x20process\x20will\x20stop,\x20revert\x20the\x20tr\
    ansaction\x20and\x20return\x20the\x20error.\n\n\r\n\x05\x06\0\x02*\x01\
    \x12\x04\x83\x06\x06\x12\n\r\n\x05\x06\0\x02*\x02\x12\x04\x83\x06\x14'\n\
    \r\n\x05\x06\0\x02*\x03\x12\x04\x83\x062F\n\x0f\n\x05\x06\0\x02*\x04\x12\
    \x06\x84\x06\x04\x8b\x06\x06\n\x13\n\t\x06\0\x02*\x04\xb0\xca\xbc\"\x12\
    \x06\x84\x06\x04\x8b\x06\x06\n\r\n\x05\x06\0\x02*\x04\x12\x04\x8c\x06\
    \x047\n\x10\n\x08\x06\0\x02*\x04\xc3\xf3\x04\x12\x04\x8c\x06\x047\n\r\n\
    \x05\x06\0\x02*\x04\x12\x04\x8d\x06\x04?\n\x11\n\t\x06\0\x02*\x04\xc2\
    \xf3\x04\0\x12\x04\x8d\x06\x04?\n\r\n\x05\x06\0\x02*\x04\x12\x04\x8e\x06\
    \x04C\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x01\x12\x04\x8e\x06\x04C\n\r\
    \n\x05\x06\0\x02*\x04\x12\x04\x8f\x06\x04C\n\x11\n\t\x06\0\x02*\x04\xc2\
    \xf3\x04\x02\x12\x04\x8f\x06\x04C\n\r\n\x05\x06\0\x02*\x04\x12\x04\x90\
    \x06\x04F\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x03\x12\x04\x90\x06\x04F\
    \n\xde\x01\n\x04\x06\0\x02+\x12\x06\x97\x06\x02\xa5\x06\x03\x1a\xcd\x01\
    \x20Patch\x20one\x20or\x20more\x20datasets.\n\x20The\x20process\x20is\
    \x20atomic,\x20i.e.\x20either\x20all\x20or\x20no\x20datasets\x20are\x20p\
    atched.\n\x20If\x20there\x20is\x20an\x20error\x20for\x20one\x20dataset,\
    \n\x20the\x20process\x20will\x20stop,\x20revert\x20the\x20transaction\
    \x20and\x20return\x20the\x20error.\n\n\r\n\x05\x06\0\x02+\x01\x12\x04\
    \x97\x06\x06\x13\n\r\n\x05\x06\0\x02+\x02\x12\x04\x97\x06\x15)\n\r\n\x05\
    \x06\0\x02+\x03\x12\x04\x97\x064H\n\x0f\n\x05\x06\0\x02+\x04\x12\x06\x98\
    \x06\x04\x9f\x06\x06\n\x13\n\t\x06\0\x02+\x04\xb0\xca\xbc\"\x12\x06\x98\
    \x06\x04\x9f\x06\x06\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa0\x06\x047\n\x10\
    \n\x08\x06\0\x02+\x04\xc3\xf3\x04\x12\x04\xa0\x06\x047\n\r\n\x05\x06\0\
    \x02+\x04\x12\x04\xa1\x06\x04?\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\0\
    \x12\x04\xa1\x06\x04?\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa2\x06\x04C\n\
    \x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x01\x12\x04\xa2\x06\x04C\n\r\n\x05\
    \x06\0\x02+\x04\x12\x04\xa3\x06\x04C\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\
    \x04\x02\x12\x04\xa3\x06\x04C\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa4\x06\
    \x04F\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x03\x12\x04\xa4\x06\x04F\nB\n\
    \x04\x06\0\x02,\x12\x06\xa8\x06\x02\xb6\x06\x03\x1a2\x20Delete\x20one\
    \x20or\x20more\x20datasets\x20in\x20a\x20single\x20request.\n\n\r\n\x05\
    \x06\0\x02,\x01\x12\x04\xa8\x06\x06\x14\n\r\n\x05\x06\0\x02,\x02\x12\x04\
    \xa8\x06\x16+\n\r\n\x05\x06\0\x02,\x03\x12\x04\xa8\x066V\n\x0f\n\x05\x06\
    \0\x02,\x04\x12\x06\xa9\x06\x04\xb0\x06\x06\n\x13\n\t\x06\0\x02,\x04\xb0\
    \xca\xbc\"\x12\x06\xa9\x06\x04\xb0\x06\x06\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xb1\x06\x047\n\x10\n\x08\x06\0\x02,\x04\xc3\xf3\x04\x12\x04\xb1\x06\
    \x047\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb2\x06\x04?\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\0\x12\x04\xb2\x06\x04?\n\r\n\x05\x06\0\x02,\x04\x12\x04\
    \xb3\x06\x04C\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x01\x12\x04\xb3\x06\
    \x04C\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb4\x06\x04C\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\x02\x12\x04\xb4\x06\x04C\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xb5\x06\x04F\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x03\x12\x04\xb5\
    \x06\x04F\n;\n\x04\x06\0\x02-\x12\x06\xb9\x06\x02\xc6\x06\x03\x1a+\x20Li\
    st\x20all\x20the\x20dataset\x20inputs\x20in\x20a\x20dataset.\n\n\r\n\x05\
    \x06\0\x02-\x01\x12\x04\xb9\x06\x06\x17\n\r\n\x05\x06\0\x02-\x02\x12\x04\
    \xb9\x06\x191\n\r\n\x05\x06\0\x02-\x03\x12\x04\xb9\x06<U\n\x0f\n\x05\x06\
    \0\x02-\x04\x12\x06\xba\x06\x04\xbf\x06\x06\n\x13\n\t\x06\0\x02-\x04\xb0\
    \xca\xbc\"\x12\x06\xba\x06\x04\xbf\x06\x06\n\r\n\x05\x06\0\x02-\x04\x12\
    \x04\xc0\x06\x047\n\x10\n\x08\x06\0\x02-\x04\xc3\xf3\x04\x12\x04\xc0\x06\
    \x047\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc1\x06\x04?\n\x11\n\t\x06\0\x02-\
    \x04\xc2\xf3\x04\0\x12\x04\xc1\x06\x04?\n\r\n\x05\x06\0\x02-\x04\x12\x04\
    \xc2\x06\x04C\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x01\x12\x04\xc2\x06\
    \x04C\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc3\x06\x04A\n\x11\n\t\x06\0\x02-\
    \x04\xc2\xf3\x04\x02\x12\x04\xc3\x06\x04A\n\r\n\x05\x06\0\x02-\x04\x12\
    \x04\xc4\x06\x04F\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x03\x12\x04\xc4\
    \x06\x04F\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc5\x06\x04C\n\x11\n\t\x06\0\
    \x02-\x04\xc2\xf3\x04\x04\x12\x04\xc5\x06\x04C\n/\n\x04\x06\0\x02.\x12\
    \x06\xc9\x06\x02\xd6\x06\x03\x1a\x1f\x20Get\x20a\x20specific\x20dataset\
    \x20input.\n\n\r\n\x05\x06\0\x02.\x01\x12\x04\xc9\x06\x06\x15\n\r\n\x05\
    \x06\0\x02.\x02\x12\x04\xc9\x06\x17-\n\r\n\x05\x06\0\x02.\x03\x12\x04\
    \xc9\x068R\n\x0f\n\x05\x06\0\x02.\x04\x12\x06\xca\x06\x04\xcf\x06\x06\n\
    \x13\n\t\x06\0\x02.\x04\xb0\xca\xbc\"\x12\x06\xca\x06\x04\xcf\x06\x06\n\
    \r\n\x05\x06\0\x02.\x04\x12\x04\xd0\x06\x047\n\x10\n\x08\x06\0\x02.\x04\
    \xc3\xf3\x04\x12\x04\xd0\x06\x047\n\r\n\x05\x06\0\x02.\x04\x12\x04\xd1\
    \x06\x04?\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\0\x12\x04\xd1\x06\x04?\n\
    \r\n\x05\x06\0\x02.\x04\x12\x04\xd2\x06\x04C\n\x11\n\t\x06\0\x02.\x04\
    \xc2\xf3\x04\x01\x12\x04\xd2\x06\x04C\n\r\n\x05\x06\0\x02.\x04\x12\x04\
    \xd3\x06\x04A\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x02\x12\x04\xd3\x06\
    \x04A\n\r\n\x05\x06\0\x02.\x04\x12\x04\xd4\x06\x04F\n\x11\n\t\x06\0\x02.\
    \x04\xc2\xf3\x04\x03\x12\x04\xd4\x06\x04F\n\r\n\x05\x06\0\x02.\x04\x12\
    \x04\xd5\x06\x04C\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x04\x12\x04\xd5\
    \x06\x04C\n\xce\x03\n\x04\x06\0\x02/\x12\x06\xe0\x06\x02\xf0\x06\x03\x1a\
    \xbd\x03\x20Add\x20dataset\x20inputs\x20to\x20a\x20dataset.\n\x20The\x20\
    process\x20is\x20not\x20atomic,\x20i.e.\x20if\x20there\x20are\x20errors\
    \x20with\x20some\x20dataset\n\x20inputs,\x20others\x20might\x20still\x20\
    be\x20added.\x20The\x20response\x20reports\n\x20\x20\x20-\x20SUCCESS\x20\
    if\x20all\x20dataset\x20inputs\x20were\x20added,\n\x20\x20\x20-\x20MIXED\
    _STATUS\x20if\x20only\x20some\x20dataset\x20inputs\x20were\x20added,\x20\
    and\n\x20\x20\x20-\x20FAILURE\x20if\x20no\x20dataset\x20inputs\x20were\
    \x20added.\n\x20Each\x20individual\x20dataset\x20input\x20in\x20the\x20r\
    esponse\x20has\x20the\x20status\x20set\x20to\n\x20indicate\x20if\x20it\
    \x20was\x20successful\x20or\x20if\x20there\x20was\x20an\x20error.\n\n\r\
    \n\x05\x06\0\x02/\x01\x12\x04\xe0\x06\x06\x17\n\r\n\x05\x06\0\x02/\x02\
    \x12\x04\xe0\x06\x191\n\r\n\x05\x06\0\x02/\x03\x12\x04\xe0\x06<U\n\x0f\n\
    \x05\x06\0\x02/\x04\x12\x06\xe1\x06\x04\xe8\x06\x06\n\x13\n\t\x06\0\x02/\
    \x04\xb0\xca\xbc\"\x12\x06\xe1\x06\x04\xe8\x06\x06\n\r\n\x05\x06\0\x02/\
    \x04\x12\x04\xe9\x06\x047\n\x10\n\x08\x06\0\x02/\x04\xc3\xf3\x04\x12\x04\
    \xe9\x06\x047\n\r\n\x05\x06\0\x02/\x04\x12\x04\xea\x06\x04?\n\x11\n\t\
    \x06\0\x02/\x04\xc2\xf3\x04\0\x12\x04\xea\x06\x04?\n\r\n\x05\x06\0\x02/\
    \x04\x12\x04\xeb\x06\x04C\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x01\x12\
    \x04\xeb\x06\x04C\n\r\n\x05\x06\0\x02/\x04\x12\x04\xec\x06\x04C\n\x11\n\
    \t\x06\0\x02/\x04\xc2\xf3\x04\x02\x12\x04\xec\x06\x04C\n\r\n\x05\x06\0\
    \x02/\x04\x12\x04\xed\x06\x04A\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x03\
    \x12\x04\xed\x06\x04A\n\r\n\x05\x06\0\x02/\x04\x12\x04\xee\x06\x04F\n\
    \x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x04\x12\x04\xee\x06\x04F\n\r\n\x05\
    \x06\0\x02/\x04\x12\x04\xef\x06\x04C\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\
    \x04\x05\x12\x04\xef\x06\x04C\nH\n\x04\x06\0\x020\x12\x06\xf3\x06\x02\
    \x82\x07\x03\x1a8\x20Delete\x20one\x20or\x20more\x20dataset\x20inputs\
    \x20in\x20a\x20single\x20request.\n\n\r\n\x05\x06\0\x020\x01\x12\x04\xf3\
    \x06\x06\x19\n\r\n\x05\x06\0\x020\x02\x12\x04\xf3\x06\x1b5\n\r\n\x05\x06\
    \0\x020\x03\x12\x04\xf3\x06@`\n\x0f\n\x05\x06\0\x020\x04\x12\x06\xf4\x06\
    \x04\xfb\x06\x06\n\x13\n\t\x06\0\x020\x04\xb0\xca\xbc\"\x12\x06\xf4\x06\
    \x04\xfb\x06\x06\n\r\n\x05\x06\0\x020\x04\x12\x04\xfc\x06\x047\n\x10\n\
    \x08\x06\0\x020\x04\xc3\xf3\x04\x12\x04\xfc\x06\x047\n\r\n\x05\x06\0\x02\
    0\x04\x12\x04\xfd\x06\x04?\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\0\x12\
    \x04\xfd\x06\x04?\n\r\n\x05\x06\0\x020\x04\x12\x04\xfe\x06\x04C\n\x11\n\
    \t\x06\0\x020\x04\xc2\xf3\x04\x01\x12\x04\xfe\x06\x04C\n\r\n\x05\x06\0\
    \x020\x04\x12\x04\xff\x06\x04C\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x02\
    \x12\x04\xff\x06\x04C\n\r\n\x05\x06\0\x020\x04\x12\x04\x80\x07\x04F\n\
    \x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x03\x12\x04\x80\x07\x04F\n\r\n\x05\
    \x06\0\x020\x04\x12\x04\x81\x07\x04A\n\x11\n\t\x06\0\x020\x04\xc2\xf3\
    \x04\x04\x12\x04\x81\x07\x04A\n0\n\x04\x06\0\x021\x12\x06\x85\x07\x02\
    \x90\x07\x03\x1a\x20\x20List\x20all\x20the\x20dataset\x20versions.\n\n\r\
    \n\x05\x06\0\x021\x01\x12\x04\x85\x07\x06\x19\n\r\n\x05\x06\0\x021\x02\
    \x12\x04\x85\x07\x1b5\n\r\n\x05\x06\0\x021\x03\x12\x04\x85\x07@[\n\x0f\n\
    \x05\x06\0\x021\x04\x12\x06\x86\x07\x04\x8b\x07\x06\n\x13\n\t\x06\0\x021\
    \x04\xb0\xca\xbc\"\x12\x06\x86\x07\x04\x8b\x07\x06\n\r\n\x05\x06\0\x021\
    \x04\x12\x04\x8c\x07\x047\n\x10\n\x08\x06\0\x021\x04\xc3\xf3\x04\x12\x04\
    \x8c\x07\x047\n\r\n\x05\x06\0\x021\x04\x12\x04\x8d\x07\x04?\n\x11\n\t\
    \x06\0\x021\x04\xc2\xf3\x04\0\x12\x04\x8d\x07\x04?\n\r\n\x05\x06\0\x021\
    \x04\x12\x04\x8e\x07\x04C\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x01\x12\
    \x04\x8e\x07\x04C\n\r\n\x05\x06\0\x021\x04\x12\x04\x8f\x07\x04F\n\x11\n\
    \t\x06\0\x021\x04\xc2\xf3\x04\x02\x12\x04\x8f\x07\x04F\n1\n\x04\x06\0\
    \x022\x12\x06\x93\x07\x02\x9e\x07\x03\x1a!\x20Get\x20a\x20specific\x20da\
    taset\x20version.\n\n\r\n\x05\x06\0\x022\x01\x12\x04\x93\x07\x06\x17\n\r\
    \n\x05\x06\0\x022\x02\x12\x04\x93\x07\x191\n\r\n\x05\x06\0\x022\x03\x12\
    \x04\x93\x07<X\n\x0f\n\x05\x06\0\x022\x04\x12\x06\x94\x07\x04\x99\x07\
    \x06\n\x13\n\t\x06\0\x022\x04\xb0\xca\xbc\"\x12\x06\x94\x07\x04\x99\x07\
    \x06\n\r\n\x05\x06\0\x022\x04\x12\x04\x9a\x07\x047\n\x10\n\x08\x06\0\x02\
    2\x04\xc3\xf3\x04\x12\x04\x9a\x07\x047\n\r\n\x05\x06\0\x022\x04\x12\x04\
    \x9b\x07\x04?\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\0\x12\x04\x9b\x07\x04\
    ?\n\r\n\x05\x06\0\x022\x04\x12\x04\x9c\x07\x04C\n\x11\n\t\x06\0\x022\x04\
    \xc2\xf3\x04\x01\x12\x04\x9c\x07\x04C\n\r\n\x05\x06\0\x022\x04\x12\x04\
    \x9d\x07\x04F\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x02\x12\x04\x9d\x07\
    \x04F\n\x0e\n\x04\x06\0\x023\x12\x06\xa0\x07\x02\xad\x07\x03\n\r\n\x05\
    \x06\0\x023\x01\x12\x04\xa0\x07\x06%\n\r\n\x05\x06\0\x023\x02\x12\x04\
    \xa0\x07'M\n\r\n\x05\x06\0\x023\x03\x12\x04\xa0\x07X\x7f\n\x0f\n\x05\x06\
    \0\x023\x04\x12\x06\xa1\x07\x04\xa6\x07\x06\n\x13\n\t\x06\0\x023\x04\xb0\
    \xca\xbc\"\x12\x06\xa1\x07\x04\xa6\x07\x06\n\r\n\x05\x06\0\x023\x04\x12\
    \x04\xa7\x07\x047\n\x10\n\x08\x06\0\x023\x04\xc3\xf3\x04\x12\x04\xa7\x07\
    \x047\n\r\n\x05\x06\0\x023\x04\x12\x04\xa8\x07\x04?\n\x11\n\t\x06\0\x023\
    \x04\xc2\xf3\x04\0\x12\x04\xa8\x07\x04?\n\r\n\x05\x06\0\x023\x04\x12\x04\
    \xa9\x07\x04C\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x01\x12\x04\xa9\x07\
    \x04C\n\r\n\x05\x06\0\x023\x04\x12\x04\xaa\x07\x04F\n\x11\n\t\x06\0\x023\
    \x04\xc2\xf3\x04\x02\x12\x04\xaa\x07\x04F\n\r\n\x05\x06\0\x023\x04\x12\
    \x04\xab\x07\x04C\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x03\x12\x04\xab\
    \x07\x04C\n\r\n\x05\x06\0\x023\x04\x12\x04\xac\x07\x04A\n\x11\n\t\x06\0\
    \x023\x04\xc2\xf3\x04\x04\x12\x04\xac\x07\x04A\n4\n\x04\x06\0\x024\x12\
    \x06\xb0\x07\x02\xbf\x07\x03\x1a$\x20Add\x20dataset\x20versions\x20to\
    \x20a\x20dataset.\n\n\r\n\x05\x06\0\x024\x01\x12\x04\xb0\x07\x06\x19\n\r\
    \n\x05\x06\0\x024\x02\x12\x04\xb0\x07\x1b5\n\r\n\x05\x06\0\x024\x03\x12\
    \x04\xb0\x07@[\n\x0f\n\x05\x06\0\x024\x04\x12\x06\xb1\x07\x04\xb8\x07\
    \x06\n\x13\n\t\x06\0\x024\x04\xb0\xca\xbc\"\x12\x06\xb1\x07\x04\xb8\x07\
    \x06\n\r\n\x05\x06\0\x024\x04\x12\x04\xb9\x07\x047\n\x10\n\x08\x06\0\x02\
    4\x04\xc3\xf3\x04\x12\x04\xb9\x07\x047\n\r\n\x05\x06\0\x024\x04\x12\x04\
    \xba\x07\x04?\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\0\x12\x04\xba\x07\x04\
    ?\n\r\n\x05\x06\0\x024\x04\x12\x04\xbb\x07\x04C\n\x11\n\t\x06\0\x024\x04\
    \xc2\xf3\x04\x01\x12\x04\xbb\x07\x04C\n\r\n\x05\x06\0\x024\x04\x12\x04\
    \xbc\x07\x04C\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x02\x12\x04\xbc\x07\
    \x04C\n\r\n\x05\x06\0\x024\x04\x12\x04\xbd\x07\x04A\n\x11\n\t\x06\0\x024\
    \x04\xc2\xf3\x04\x03\x12\x04\xbd\x07\x04A\n\r\n\x05\x06\0\x024\x04\x12\
    \x04\xbe\x07\x04D\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x04\x12\x04\xbe\
    \x07\x04D\n5\n\x04\x06\0\x025\x12\x06\xc2\x07\x02\xcf\x07\x03\x1a%\x20Pa\
    tch\x20one\x20or\x20more\x20dataset\x20versions.\n\n\r\n\x05\x06\0\x025\
    \x01\x12\x04\xc2\x07\x06\x1a\n\r\n\x05\x06\0\x025\x02\x12\x04\xc2\x07\
    \x1c7\n\r\n\x05\x06\0\x025\x03\x12\x04\xc2\x07B]\n\x0f\n\x05\x06\0\x025\
    \x04\x12\x06\xc3\x07\x04\xca\x07\x06\n\x13\n\t\x06\0\x025\x04\xb0\xca\
    \xbc\"\x12\x06\xc3\x07\x04\xca\x07\x06\n\r\n\x05\x06\0\x025\x04\x12\x04\
    \xcb\x07\x047\n\x10\n\x08\x06\0\x025\x04\xc3\xf3\x04\x12\x04\xcb\x07\x04\
    7\n\r\n\x05\x06\0\x025\x04\x12\x04\xcc\x07\x04?\n\x11\n\t\x06\0\x025\x04\
    \xc2\xf3\x04\0\x12\x04\xcc\x07\x04?\n\r\n\x05\x06\0\x025\x04\x12\x04\xcd\
    \x07\x04C\n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\x01\x12\x04\xcd\x07\x04C\
    \n\r\n\x05\x06\0\x025\x04\x12\x04\xce\x07\x04C\n\x11\n\t\x06\0\x025\x04\
    \xc2\xf3\x04\x02\x12\x04\xce\x07\x04C\nJ\n\x04\x06\0\x026\x12\x06\xd2\
    \x07\x02\xe0\x07\x03\x1a:\x20Delete\x20one\x20or\x20more\x20dataset\x20v\
    ersions\x20in\x20a\x20single\x20request.\n\n\r\n\x05\x06\0\x026\x01\x12\
    \x04\xd2\x07\x06\x1b\n\r\n\x05\x06\0\x026\x02\x12\x04\xd2\x07\x1d9\n\r\n\
    \x05\x06\0\x026\x03\x12\x04\xd2\x07Dd\n\x0f\n\x05\x06\0\x026\x04\x12\x06\
    \xd3\x07\x04\xda\x07\x06\n\x13\n\t\x06\0\x026\x04\xb0\xca\xbc\"\x12\x06\
    \xd3\x07\x04\xda\x07\x06\n\r\n\x05\x06\0\x026\x04\x12\x04\xdb\x07\x047\n\
    \x10\n\x08\x06\0\x026\x04\xc3\xf3\x04\x12\x04\xdb\x07\x047\n\r\n\x05\x06\
    \0\x026\x04\x12\x04\xdc\x07\x04?\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\0\
    \x12\x04\xdc\x07\x04?\n\r\n\x05\x06\0\x026\x04\x12\x04\xdd\x07\x04C\n\
    \x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x01\x12\x04\xdd\x07\x04C\n\r\n\x05\
    \x06\0\x026\x04\x12\x04\xde\x07\x04C\n\x11\n\t\x06\0\x026\x04\xc2\xf3\
    \x04\x02\x12\x04\xde\x07\x04C\n\r\n\x05\x06\0\x026\x04\x12\x04\xdf\x07\
    \x04F\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x03\x12\x04\xdf\x07\x04F\n5\n\
    \x04\x06\0\x027\x12\x06\xe3\x07\x02\xf0\x07\x03\x1a%\x20Create\x20export\
    \x20of\x20a\x20dataset\x20version.\n\n\r\n\x05\x06\0\x027\x01\x12\x04\
    \xe3\x07\x06\x1e\n\r\n\x05\x06\0\x027\x02\x12\x04\xe3\x07\x20?\n\r\n\x05\
    \x06\0\x027\x03\x12\x04\xe3\x07Jk\n\x0f\n\x05\x06\0\x027\x04\x12\x06\xe4\
    \x07\x04\xeb\x07\x06\n\x13\n\t\x06\0\x027\x04\xb0\xca\xbc\"\x12\x06\xe4\
    \x07\x04\xeb\x07\x06\n\r\n\x05\x06\0\x027\x04\x12\x04\xec\x07\x047\n\x10\
    \n\x08\x06\0\x027\x04\xc3\xf3\x04\x12\x04\xec\x07\x047\n\r\n\x05\x06\0\
    \x027\x04\x12\x04\xed\x07\x04?\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\0\
    \x12\x04\xed\x07\x04?\n\r\n\x05\x06\0\x027\x04\x12\x04\xee\x07\x04C\n\
    \x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x01\x12\x04\xee\x07\x04C\n\r\n\x05\
    \x06\0\x027\x04\x12\x04\xef\x07\x04C\n\x11\n\t\x06\0\x027\x04\xc2\xf3\
    \x04\x02\x12\x04\xef\x07\x04C\n\x84\x01\n\x04\x06\0\x028\x12\x06\xf8\x07\
    \x02\x82\x08\x03\x1a\x1c\x20Get\x20a\x20specific\x20model\x20type.\n2V//\
    ////////////////////////////////////\n\x20Models\n//////////////////////\
    ////////////////\n\n\r\n\x05\x06\0\x028\x01\x12\x04\xf8\x07\x06\x12\n\r\
    \n\x05\x06\0\x028\x02\x12\x04\xf8\x07\x14'\n\r\n\x05\x06\0\x028\x03\x12\
    \x04\xf8\x072I\n\x0f\n\x05\x06\0\x028\x04\x12\x06\xf9\x07\x04\xfe\x07\
    \x06\n\x13\n\t\x06\0\x028\x04\xb0\xca\xbc\"\x12\x06\xf9\x07\x04\xfe\x07\
    \x06\n\r\n\x05\x06\0\x028\x04\x12\x04\xff\x07\x047\n\x10\n\x08\x06\0\x02\
    8\x04\xc3\xf3\x04\x12\x04\xff\x07\x047\n\r\n\x05\x06\0\x028\x04\x12\x04\
    \x80\x08\x04?\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\0\x12\x04\x80\x08\x04\
    ?\n\r\n\x05\x06\0\x028\x04\x12\x04\x81\x08\x04A\n\x11\n\t\x06\0\x028\x04\
    \xc2\xf3\x04\x01\x12\x04\x81\x08\x04A\nN\n\x04\x06\0\x029\x12\x06\x85\
    \x08\x02\x8a\x08\x03\x1a>\x20List\x20all\x20the\x20supported\x20open\x20\
    source\x20licenses\x20in\x20the\x20platform.\n\n\r\n\x05\x06\0\x029\x01\
    \x12\x04\x85\x08\x06\x1c\n\r\n\x05\x06\0\x029\x02\x12\x04\x85\x08\x1e;\n\
    \r\n\x05\x06\0\x029\x03\x12\x04\x85\x08Fd\n\x0f\n\x05\x06\0\x029\x04\x12\
    \x06\x86\x08\x04\x88\x08\x06\n\x13\n\t\x06\0\x029\x04\xb0\xca\xbc\"\x12\
    \x06\x86\x08\x04\x88\x08\x06\n\r\n\x05\x06\0\x029\x04\x12\x04\x89\x08\
    \x046\n\x10\n\x08\x06\0\x029\x04\xc3\xf3\x04\x12\x04\x89\x08\x046\n\x9a\
    \x01\n\x04\x06\0\x02:\x12\x06\x8e\x08\x02\x98\x08\x03\x1a\x89\x01\x20Lis\
    t\x20all\x20the\x20model\x20types\x20available\x20in\x20the\x20platform.\
    \n\x20This\x20MUST\x20be\x20above\x20ListModels\x20so\x20that\x20the\x20\
    /models/types\x20endpoint\x20takes\x20precedence.\n\n\r\n\x05\x06\0\x02:\
    \x01\x12\x04\x8e\x08\x06\x14\n\r\n\x05\x06\0\x02:\x02\x12\x04\x8e\x08\
    \x16+\n\r\n\x05\x06\0\x02:\x03\x12\x04\x8e\x086L\n\x0f\n\x05\x06\0\x02:\
    \x04\x12\x06\x8f\x08\x04\x94\x08\x06\n\x13\n\t\x06\0\x02:\x04\xb0\xca\
    \xbc\"\x12\x06\x8f\x08\x04\x94\x08\x06\n\r\n\x05\x06\0\x02:\x04\x12\x04\
    \x95\x08\x047\n\x10\n\x08\x06\0\x02:\x04\xc3\xf3\x04\x12\x04\x95\x08\x04\
    7\n\r\n\x05\x06\0\x02:\x04\x12\x04\x96\x08\x04?\n\x11\n\t\x06\0\x02:\x04\
    \xc2\xf3\x04\0\x12\x04\x96\x08\x04?\n\r\n\x05\x06\0\x02:\x04\x12\x04\x97\
    \x08\x04A\n\x11\n\t\x06\0\x02:\x04\xc2\xf3\x04\x01\x12\x04\x97\x08\x04A\
    \n3\n\x04\x06\0\x02;\x12\x06\x9b\x08\x02\xa6\x08\x03\x1a#\x20Get\x20a\
    \x20specific\x20model\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02;\x01\
    \x12\x04\x9b\x08\x06\x0e\n\r\n\x05\x06\0\x02;\x02\x12\x04\x9b\x08\x10\
    \x1f\n\r\n\x05\x06\0\x02;\x03\x12\x04\x9b\x08*=\n\x0f\n\x05\x06\0\x02;\
    \x04\x12\x06\x9c\x08\x04\xa1\x08\x06\n\x13\n\t\x06\0\x02;\x04\xb0\xca\
    \xbc\"\x12\x06\x9c\x08\x04\xa1\x08\x06\n\r\n\x05\x06\0\x02;\x04\x12\x04\
    \xa2\x08\x047\n\x10\n\x08\x06\0\x02;\x04\xc3\xf3\x04\x12\x04\xa2\x08\x04\
    7\n\r\n\x05\x06\0\x02;\x04\x12\x04\xa3\x08\x04?\n\x11\n\t\x06\0\x02;\x04\
    \xc2\xf3\x04\0\x12\x04\xa3\x08\x04?\n\r\n\x05\x06\0\x02;\x04\x12\x04\xa4\
    \x08\x04C\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\x01\x12\x04\xa4\x08\x04C\
    \n\r\n\x05\x06\0\x02;\x04\x12\x04\xa5\x08\x04A\n\x11\n\t\x06\0\x02;\x04\
    \xc2\xf3\x04\x02\x12\x04\xa5\x08\x04A\n[\n\x04\x06\0\x02<\x12\x06\xaa\
    \x08\x02\xbb\x08\x03\x1aK\x20Get\x20a\x20the\x20output\x20info\x20for\
    \x20a\x20given\x20model_id\x20or\x20model_id/version_id\n\x20combo.\n\n\
    \r\n\x05\x06\0\x02<\x01\x12\x04\xaa\x08\x06\x18\n\r\n\x05\x06\0\x02<\x02\
    \x12\x04\xaa\x08\x1a)\n\r\n\x05\x06\0\x02<\x03\x12\x04\xaa\x084G\n\x0f\n\
    \x05\x06\0\x02<\x04\x12\x06\xab\x08\x04\xb6\x08\x06\n\x13\n\t\x06\0\x02<\
    \x04\xb0\xca\xbc\"\x12\x06\xab\x08\x04\xb6\x08\x06\n\r\n\x05\x06\0\x02<\
    \x04\x12\x04\xb7\x08\x047\n\x10\n\x08\x06\0\x02<\x04\xc3\xf3\x04\x12\x04\
    \xb7\x08\x047\n\r\n\x05\x06\0\x02<\x04\x12\x04\xb8\x08\x04?\n\x11\n\t\
    \x06\0\x02<\x04\xc2\xf3\x04\0\x12\x04\xb8\x08\x04?\n\r\n\x05\x06\0\x02<\
    \x04\x12\x04\xb9\x08\x04C\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x01\x12\
    \x04\xb9\x08\x04C\n\r\n\x05\x06\0\x02<\x04\x12\x04\xba\x08\x04A\n\x11\n\
    \t\x06\0\x02<\x04\xc2\xf3\x04\x02\x12\x04\xba\x08\x04A\n&\n\x04\x06\0\
    \x02=\x12\x06\xbe\x08\x02\xcc\x08\x03\x1a\x16\x20List\x20all\x20the\x20m\
    odels.\n\n\r\n\x05\x06\0\x02=\x01\x12\x04\xbe\x08\x06\x10\n\r\n\x05\x06\
    \0\x02=\x02\x12\x04\xbe\x08\x12#\n\r\n\x05\x06\0\x02=\x03\x12\x04\xbe\
    \x08.@\n\x0f\n\x05\x06\0\x02=\x04\x12\x06\xbf\x08\x04\xc7\x08\x06\n\x13\
    \n\t\x06\0\x02=\x04\xb0\xca\xbc\"\x12\x06\xbf\x08\x04\xc7\x08\x06\n\r\n\
    \x05\x06\0\x02=\x04\x12\x04\xc8\x08\x047\n\x10\n\x08\x06\0\x02=\x04\xc3\
    \xf3\x04\x12\x04\xc8\x08\x047\n\r\n\x05\x06\0\x02=\x04\x12\x04\xc9\x08\
    \x04?\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\0\x12\x04\xc9\x08\x04?\n\r\n\
    \x05\x06\0\x02=\x04\x12\x04\xca\x08\x04C\n\x11\n\t\x06\0\x02=\x04\xc2\
    \xf3\x04\x01\x12\x04\xca\x08\x04C\n\r\n\x05\x06\0\x02=\x04\x12\x04\xcb\
    \x08\x04A\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x02\x12\x04\xcb\x08\x04A\
    \n7\n\x04\x06\0\x02>\x12\x06\xcf\x08\x02\xdd\x08\x03\x1a'\x20List\x20the\
    \x20resource\x20counts\x20for\x20the\x20app.\n\n\r\n\x05\x06\0\x02>\x01\
    \x12\x04\xcf\x08\x06\x17\n\r\n\x05\x06\0\x02>\x02\x12\x04\xcf\x08\x191\n\
    \r\n\x05\x06\0\x02>\x03\x12\x04\xcf\x08<U\n\x0f\n\x05\x06\0\x02>\x04\x12\
    \x06\xd0\x08\x04\xd5\x08\x06\n\x13\n\t\x06\0\x02>\x04\xb0\xca\xbc\"\x12\
    \x06\xd0\x08\x04\xd5\x08\x06\n\r\n\x05\x06\0\x02>\x04\x12\x04\xd6\x08\
    \x047\n\x10\n\x08\x06\0\x02>\x04\xc3\xf3\x04\x12\x04\xd6\x08\x047\n\r\n\
    \x05\x06\0\x02>\x04\x12\x04\xd7\x08\x04C\n\x11\n\t\x06\0\x02>\x04\xc2\
    \xf3\x04\0\x12\x04\xd7\x08\x04C\n\r\n\x05\x06\0\x02>\x04\x12\x04\xd8\x08\
    \x04A\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\x01\x12\x04\xd8\x08\x04A\n\r\
    \n\x05\x06\0\x02>\x04\x12\x04\xd9\x08\x04D\n\x11\n\t\x06\0\x02>\x04\xc2\
    \xf3\x04\x02\x12\x04\xd9\x08\x04D\n\r\n\x05\x06\0\x02>\x04\x12\x04\xda\
    \x08\x04B\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\x03\x12\x04\xda\x08\x04B\
    \n\r\n\x05\x06\0\x02>\x04\x12\x04\xdb\x08\x04?\n\x11\n\t\x06\0\x02>\x04\
    \xc2\xf3\x04\x04\x12\x04\xdb\x08\x04?\n\r\n\x05\x06\0\x02>\x04\x12\x04\
    \xdc\x08\x04A\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\x05\x12\x04\xdc\x08\
    \x04A\n\xcb\x01\n\x04\x06\0\x02?\x12\x06\xe2\x08\x02\xef\x08\x03\x1a\xba\
    \x01\x20Search\x20over\x20the\x20models\x20to\x20find\x20one\x20or\x20mo\
    re\x20you're\x20looking\x20for.\n\x20This\x20leverage\x20the\x20\"body\"\
    \x20parameter\x20because\x20we\x20also\x20have\x20page\x20and\n\x20per_p\
    age\x20as\x20url\x20query\x20param\x20variables\x20in\x20this\x20request\
    .\n\n\r\n\x05\x06\0\x02?\x01\x12\x04\xe2\x08\x06\x18\n\r\n\x05\x06\0\x02\
    ?\x02\x12\x04\xe2\x08\x1a3\n\r\n\x05\x06\0\x02?\x03\x12\x04\xe2\x08>P\n\
    \x0f\n\x05\x06\0\x02?\x04\x12\x06\xe3\x08\x04\xea\x08\x06\n\x13\n\t\x06\
    \0\x02?\x04\xb0\xca\xbc\"\x12\x06\xe3\x08\x04\xea\x08\x06\n\r\n\x05\x06\
    \0\x02?\x04\x12\x04\xeb\x08\x047\n\x10\n\x08\x06\0\x02?\x04\xc3\xf3\x04\
    \x12\x04\xeb\x08\x047\n\r\n\x05\x06\0\x02?\x04\x12\x04\xec\x08\x04?\n\
    \x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\0\x12\x04\xec\x08\x04?\n\r\n\x05\x06\
    \0\x02?\x04\x12\x04\xed\x08\x04C\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\
    \x01\x12\x04\xed\x08\x04C\n\r\n\x05\x06\0\x02?\x04\x12\x04\xee\x08\x04A\
    \n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\x02\x12\x04\xee\x08\x04A\n)\n\x04\
    \x06\0\x02@\x12\x06\xf2\x08\x02\x82\t\x03\x1a\x19\x20Add\x20a\x20models\
    \x20to\x20an\x20app.\n\n\r\n\x05\x06\0\x02@\x01\x12\x04\xf2\x08\x06\x10\
    \n\r\n\x05\x06\0\x02@\x02\x12\x04\xf2\x08\x12#\n\r\n\x05\x06\0\x02@\x03\
    \x12\x04\xf2\x08.A\n\x0f\n\x05\x06\0\x02@\x04\x12\x06\xf3\x08\x04\xfa\
    \x08\x06\n\x13\n\t\x06\0\x02@\x04\xb0\xca\xbc\"\x12\x06\xf3\x08\x04\xfa\
    \x08\x06\n\r\n\x05\x06\0\x02@\x04\x12\x04\xfb\x08\x047\n\x10\n\x08\x06\0\
    \x02@\x04\xc3\xf3\x04\x12\x04\xfb\x08\x047\n\r\n\x05\x06\0\x02@\x04\x12\
    \x04\xfc\x08\x04?\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\0\x12\x04\xfc\x08\
    \x04?\n\r\n\x05\x06\0\x02@\x04\x12\x04\xfd\x08\x04C\n\x11\n\t\x06\0\x02@\
    \x04\xc2\xf3\x04\x01\x12\x04\xfd\x08\x04C\n\r\n\x05\x06\0\x02@\x04\x12\
    \x04\xfe\x08\x04A\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\x02\x12\x04\xfe\
    \x08\x04A\n\r\n\x05\x06\0\x02@\x04\x12\x04\xff\x08\x04A\n\x11\n\t\x06\0\
    \x02@\x04\xc2\xf3\x04\x03\x12\x04\xff\x08\x04A\n\r\n\x05\x06\0\x02@\x04\
    \x12\x04\x80\t\x04C\nF\n\t\x06\0\x02@\x04\xc2\xf3\x04\x04\x12\x04\x80\t\
    \x04C\"3\x20Train\x20is\x20needed\x20because\x20it\x20creates\x20a\x20ne\
    w\x20version.\n\n\r\n\x05\x06\0\x02@\x04\x12\x04\x81\t\x04D\nF\n\t\x06\0\
    \x02@\x04\xc2\xf3\x04\x05\x12\x04\x81\t\x04D\"3\x20Needs\x20to\x20check\
    \x20the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n+\n\x04\x06\
    \0\x02A\x12\x06\x85\t\x02\x94\t\x03\x1a\x1b\x20Patch\x20one\x20or\x20mor\
    e\x20models.\n\n\r\n\x05\x06\0\x02A\x01\x12\x04\x85\t\x06\x11\n\r\n\x05\
    \x06\0\x02A\x02\x12\x04\x85\t\x13%\n\r\n\x05\x06\0\x02A\x03\x12\x04\x85\
    \t0B\n\x0f\n\x05\x06\0\x02A\x04\x12\x06\x86\t\x04\x8d\t\x06\n\x13\n\t\
    \x06\0\x02A\x04\xb0\xca\xbc\"\x12\x06\x86\t\x04\x8d\t\x06\n\r\n\x05\x06\
    \0\x02A\x04\x12\x04\x8e\t\x047\n\x10\n\x08\x06\0\x02A\x04\xc3\xf3\x04\
    \x12\x04\x8e\t\x047\n\r\n\x05\x06\0\x02A\x04\x12\x04\x8f\t\x04?\n\x11\n\
    \t\x06\0\x02A\x04\xc2\xf3\x04\0\x12\x04\x8f\t\x04?\n\r\n\x05\x06\0\x02A\
    \x04\x12\x04\x90\t\x04C\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\x01\x12\x04\
    \x90\t\x04C\n\r\n\x05\x06\0\x02A\x04\x12\x04\x91\t\x04A\n\x11\n\t\x06\0\
    \x02A\x04\xc2\xf3\x04\x02\x12\x04\x91\t\x04A\n\r\n\x05\x06\0\x02A\x04\
    \x12\x04\x92\t\x04A\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\x03\x12\x04\x92\
    \t\x04A\n\r\n\x05\x06\0\x02A\x04\x12\x04\x93\t\x04C\n\x11\n\t\x06\0\x02A\
    \x04\xc2\xf3\x04\x04\x12\x04\x93\t\x04C\n/\n\x04\x06\0\x02B\x12\x06\x97\
    \t\x02\xa0\t\x03\x1a\x1f\x20Patch\x20one\x20or\x20more\x20models\x20ids.\
    \n\n\r\n\x05\x06\0\x02B\x01\x12\x04\x97\t\x06\x13\n\r\n\x05\x06\0\x02B\
    \x02\x12\x04\x97\t\x15)\n\r\n\x05\x06\0\x02B\x03\x12\x04\x97\t4F\n\x0f\n\
    \x05\x06\0\x02B\x04\x12\x06\x98\t\x04\x9b\t\x06\n\x13\n\t\x06\0\x02B\x04\
    \xb0\xca\xbc\"\x12\x06\x98\t\x04\x9b\t\x06\n\r\n\x05\x06\0\x02B\x04\x12\
    \x04\x9c\t\x047\n\x10\n\x08\x06\0\x02B\x04\xc3\xf3\x04\x12\x04\x9c\t\x04\
    7\n\r\n\x05\x06\0\x02B\x04\x12\x04\x9d\t\x04?\n\x11\n\t\x06\0\x02B\x04\
    \xc2\xf3\x04\0\x12\x04\x9d\t\x04?\n\r\n\x05\x06\0\x02B\x04\x12\x04\x9e\t\
    \x04A\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\x01\x12\x04\x9e\t\x04A\n\r\n\
    \x05\x06\0\x02B\x04\x12\x04\x9f\t\x04A\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\
    \x04\x02\x12\x04\x9f\t\x04A\n(\n\x04\x06\0\x02C\x12\x06\xa3\t\x02\xb1\t\
    \x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\x05\x06\0\x02C\
    \x01\x12\x04\xa3\t\x06\x11\n\r\n\x05\x06\0\x02C\x02\x12\x04\xa3\t\x13%\n\
    \r\n\x05\x06\0\x02C\x03\x12\x04\xa3\t0P\n\x0f\n\x05\x06\0\x02C\x04\x12\
    \x06\xa4\t\x04\xa9\t\x06\n\x13\n\t\x06\0\x02C\x04\xb0\xca\xbc\"\x12\x06\
    \xa4\t\x04\xa9\t\x06\n\r\n\x05\x06\0\x02C\x04\x12\x04\xaa\t\x047\n\x10\n\
    \x08\x06\0\x02C\x04\xc3\xf3\x04\x12\x04\xaa\t\x047\n\r\n\x05\x06\0\x02C\
    \x04\x12\x04\xab\t\x04?\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\0\x12\x04\
    \xab\t\x04?\n\r\n\x05\x06\0\x02C\x04\x12\x04\xac\t\x04C\n\x11\n\t\x06\0\
    \x02C\x04\xc2\xf3\x04\x01\x12\x04\xac\t\x04C\n\r\n\x05\x06\0\x02C\x04\
    \x12\x04\xad\t\x04A\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x02\x12\x04\xad\
    \t\x04A\n\r\n\x05\x06\0\x02C\x04\x12\x04\xae\t\x04D\n\x11\n\t\x06\0\x02C\
    \x04\xc2\xf3\x04\x03\x12\x04\xae\t\x04D\n\r\n\x05\x06\0\x02C\x04\x12\x04\
    \xaf\t\x04A\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x04\x12\x04\xaf\t\x04A\
    \n\r\n\x05\x06\0\x02C\x04\x12\x04\xb0\t\x04D\n\x11\n\t\x06\0\x02C\x04\
    \xc2\xf3\x04\x05\x12\x04\xb0\t\x04D\n8\n\x04\x06\0\x02D\x12\x06\xb4\t\
    \x02\xc4\t\x03\x1a(\x20Delete\x20multiple\x20models\x20in\x20one\x20requ\
    est.\n\n\r\n\x05\x06\0\x02D\x01\x12\x04\xb4\t\x06\x12\n\r\n\x05\x06\0\
    \x02D\x02\x12\x04\xb4\t\x14'\n\r\n\x05\x06\0\x02D\x03\x12\x04\xb4\t2R\n\
    \x0f\n\x05\x06\0\x02D\x04\x12\x06\xb5\t\x04\xbc\t\x06\n\x13\n\t\x06\0\
    \x02D\x04\xb0\xca\xbc\"\x12\x06\xb5\t\x04\xbc\t\x06\n\r\n\x05\x06\0\x02D\
    \x04\x12\x04\xbd\t\x047\n\x10\n\x08\x06\0\x02D\x04\xc3\xf3\x04\x12\x04\
    \xbd\t\x047\n\r\n\x05\x06\0\x02D\x04\x12\x04\xbe\t\x04?\n\x11\n\t\x06\0\
    \x02D\x04\xc2\xf3\x04\0\x12\x04\xbe\t\x04?\n\r\n\x05\x06\0\x02D\x04\x12\
    \x04\xbf\t\x04C\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\x01\x12\x04\xbf\t\
    \x04C\n\r\n\x05\x06\0\x02D\x04\x12\x04\xc0\t\x04A\n\x11\n\t\x06\0\x02D\
    \x04\xc2\xf3\x04\x02\x12\x04\xc0\t\x04A\n\r\n\x05\x06\0\x02D\x04\x12\x04\
    \xc1\t\x04D\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\x03\x12\x04\xc1\t\x04D\
    \n\r\n\x05\x06\0\x02D\x04\x12\x04\xc2\t\x04A\n\x11\n\t\x06\0\x02D\x04\
    \xc2\xf3\x04\x04\x12\x04\xc2\t\x04A\n\r\n\x05\x06\0\x02D\x04\x12\x04\xc3\
    \t\x04D\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\x05\x12\x04\xc3\t\x04D\n-\n\
    \x04\x06\0\x02E\x12\x06\xc7\t\x02\xd3\t\x03\x1a\x1d\x20Update\x20model\
    \x20check\x20consents\n\n\r\n\x05\x06\0\x02E\x01\x12\x04\xc7\t\x06\x1d\n\
    \r\n\x05\x06\0\x02E\x02\x12\x04\xc7\t\x1f=\n\r\n\x05\x06\0\x02E\x03\x12\
    \x04\xc7\tHf\n\x0f\n\x05\x06\0\x02E\x04\x12\x06\xc8\t\x04\xcf\t\x06\n\
    \x13\n\t\x06\0\x02E\x04\xb0\xca\xbc\"\x12\x06\xc8\t\x04\xcf\t\x06\n\r\n\
    \x05\x06\0\x02E\x04\x12\x04\xd0\t\x047\n\x10\n\x08\x06\0\x02E\x04\xc3\
    \xf3\x04\x12\x04\xd0\t\x047\n\r\n\x05\x06\0\x02E\x04\x12\x04\xd1\t\x04?\
    \n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\0\x12\x04\xd1\t\x04?\n\r\n\x05\x06\
    \0\x02E\x04\x12\x04\xd2\t\x04A\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\x01\
    \x12\x04\xd2\t\x04A\n,\n\x04\x06\0\x02F\x12\x06\xd6\t\x02\xe2\t\x03\x1a\
    \x1c\x20Update\x20model\x20toolkits\x20tags\n\n\r\n\x05\x06\0\x02F\x01\
    \x12\x04\xd6\t\x06\x18\n\r\n\x05\x06\0\x02F\x02\x12\x04\xd6\t\x1a3\n\r\n\
    \x05\x06\0\x02F\x03\x12\x04\xd6\t>W\n\x0f\n\x05\x06\0\x02F\x04\x12\x06\
    \xd7\t\x04\xde\t\x06\n\x13\n\t\x06\0\x02F\x04\xb0\xca\xbc\"\x12\x06\xd7\
    \t\x04\xde\t\x06\n\r\n\x05\x06\0\x02F\x04\x12\x04\xdf\t\x047\n\x10\n\x08\
    \x06\0\x02F\x04\xc3\xf3\x04\x12\x04\xdf\t\x047\n\r\n\x05\x06\0\x02F\x04\
    \x12\x04\xe0\t\x04?\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\0\x12\x04\xe0\t\
    \x04?\n\r\n\x05\x06\0\x02F\x04\x12\x04\xe1\t\x04A\n\x11\n\t\x06\0\x02F\
    \x04\xc2\xf3\x04\x01\x12\x04\xe1\t\x04A\n-\n\x04\x06\0\x02G\x12\x06\xe5\
    \t\x02\xf1\t\x03\x1a\x1d\x20Update\x20model\x20use_cases\x20tags\n\n\r\n\
    \x05\x06\0\x02G\x01\x12\x04\xe5\t\x06\x18\n\r\n\x05\x06\0\x02G\x02\x12\
    \x04\xe5\t\x1a3\n\r\n\x05\x06\0\x02G\x03\x12\x04\xe5\t>W\n\x0f\n\x05\x06\
    \0\x02G\x04\x12\x06\xe6\t\x04\xed\t\x06\n\x13\n\t\x06\0\x02G\x04\xb0\xca\
    \xbc\"\x12\x06\xe6\t\x04\xed\t\x06\n\r\n\x05\x06\0\x02G\x04\x12\x04\xee\
    \t\x047\n\x10\n\x08\x06\0\x02G\x04\xc3\xf3\x04\x12\x04\xee\t\x047\n\r\n\
    \x05\x06\0\x02G\x04\x12\x04\xef\t\x04?\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\
    \x04\0\x12\x04\xef\t\x04?\n\r\n\x05\x06\0\x02G\x04\x12\x04\xf0\t\x04A\n\
    \x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\x01\x12\x04\xf0\t\x04A\n-\n\x04\x06\
    \0\x02H\x12\x06\xf4\t\x02\x80\n\x03\x1a\x1d\x20Update\x20model\x20langua\
    ges\x20tags\n\n\r\n\x05\x06\0\x02H\x01\x12\x04\xf4\t\x06\x19\n\r\n\x05\
    \x06\0\x02H\x02\x12\x04\xf4\t\x1b5\n\r\n\x05\x06\0\x02H\x03\x12\x04\xf4\
    \t@Z\n\x0f\n\x05\x06\0\x02H\x04\x12\x06\xf5\t\x04\xfc\t\x06\n\x13\n\t\
    \x06\0\x02H\x04\xb0\xca\xbc\"\x12\x06\xf5\t\x04\xfc\t\x06\n\r\n\x05\x06\
    \0\x02H\x04\x12\x04\xfd\t\x047\n\x10\n\x08\x06\0\x02H\x04\xc3\xf3\x04\
    \x12\x04\xfd\t\x047\n\r\n\x05\x06\0\x02H\x04\x12\x04\xfe\t\x04?\n\x11\n\
    \t\x06\0\x02H\x04\xc2\xf3\x04\0\x12\x04\xfe\t\x04?\n\r\n\x05\x06\0\x02H\
    \x04\x12\x04\xff\t\x04A\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x01\x12\x04\
    \xff\t\x04A\nV\n\x04\x06\0\x02I\x12\x06\x83\n\x02\x97\n\x03\x1aF\x20Depr\
    ecated:\x20Unmaintained\x20and\x20ideally\x20replaced\x20with\x20usage\
    \x20of\x20datasets\n\n\r\n\x05\x06\0\x02I\x01\x12\x04\x83\n\x06\x15\n\r\
    \n\x05\x06\0\x02I\x02\x12\x04\x83\n\x17-\n\r\n\x05\x06\0\x02I\x03\x12\
    \x04\x83\n8J\n\x0f\n\x05\x06\0\x02I\x04\x12\x06\x84\n\x04\x8f\n\x06\n\
    \x13\n\t\x06\0\x02I\x04\xb0\xca\xbc\"\x12\x06\x84\n\x04\x8f\n\x06\n\r\n\
    \x05\x06\0\x02I\x04\x12\x04\x90\n\x047\n\x10\n\x08\x06\0\x02I\x04\xc3\
    \xf3\x04\x12\x04\x90\n\x047\n\r\n\x05\x06\0\x02I\x04\x12\x04\x91\n\x04?\
    \n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\0\x12\x04\x91\n\x04?\n\r\n\x05\x06\
    \0\x02I\x04\x12\x04\x92\n\x04F\n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\x01\
    \x12\x04\x92\n\x04F\n\r\n\x05\x06\0\x02I\x04\x12\x04\x93\n\x04C\n\x11\n\
    \t\x06\0\x02I\x04\xc2\xf3\x04\x02\x12\x04\x93\n\x04C\n\r\n\x05\x06\0\x02\
    I\x04\x12\x04\x94\n\x04A\n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\x03\x12\
    \x04\x94\n\x04A\n\r\n\x05\x06\0\x02I\x04\x12\x04\x95\n\x04A\n\x11\n\t\
    \x06\0\x02I\x04\xc2\xf3\x04\x04\x12\x04\x95\n\x04A\n\r\n\x05\x06\0\x02I\
    \x04\x12\x04\x96\n\x04\x1d\n\x0e\n\x06\x06\0\x02I\x04!\x12\x04\x96\n\x04\
    \x1d\n3\n\x04\x06\0\x02J\x12\x06\x9a\n\x02\xa5\n\x03\x1a#\x20Get\x20a\
    \x20specific\x20model\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02J\x01\
    \x12\x04\x9a\n\x06\x15\n\r\n\x05\x06\0\x02J\x02\x12\x04\x9a\n\x17-\n\r\n\
    \x05\x06\0\x02J\x03\x12\x04\x9a\n8R\n\x0f\n\x05\x06\0\x02J\x04\x12\x06\
    \x9b\n\x04\xa0\n\x06\n\x13\n\t\x06\0\x02J\x04\xb0\xca\xbc\"\x12\x06\x9b\
    \n\x04\xa0\n\x06\n\r\n\x05\x06\0\x02J\x04\x12\x04\xa1\n\x047\n\x10\n\x08\
    \x06\0\x02J\x04\xc3\xf3\x04\x12\x04\xa1\n\x047\n\r\n\x05\x06\0\x02J\x04\
    \x12\x04\xa2\n\x04?\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\0\x12\x04\xa2\n\
    \x04?\n\r\n\x05\x06\0\x02J\x04\x12\x04\xa3\n\x04C\n\x11\n\t\x06\0\x02J\
    \x04\xc2\xf3\x04\x01\x12\x04\xa3\n\x04C\n\r\n\x05\x06\0\x02J\x04\x12\x04\
    \xa4\n\x04A\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\x02\x12\x04\xa4\n\x04A\
    \n&\n\x04\x06\0\x02K\x12\x06\xa8\n\x02\xb3\n\x03\x1a\x16\x20List\x20all\
    \x20the\x20models.\n\n\r\n\x05\x06\0\x02K\x01\x12\x04\xa8\n\x06\x17\n\r\
    \n\x05\x06\0\x02K\x02\x12\x04\xa8\n\x191\n\r\n\x05\x06\0\x02K\x03\x12\
    \x04\xa8\n<U\n\x0f\n\x05\x06\0\x02K\x04\x12\x06\xa9\n\x04\xae\n\x06\n\
    \x13\n\t\x06\0\x02K\x04\xb0\xca\xbc\"\x12\x06\xa9\n\x04\xae\n\x06\n\r\n\
    \x05\x06\0\x02K\x04\x12\x04\xaf\n\x047\n\x10\n\x08\x06\0\x02K\x04\xc3\
    \xf3\x04\x12\x04\xaf\n\x047\n\r\n\x05\x06\0\x02K\x04\x12\x04\xb0\n\x04?\
    \n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\0\x12\x04\xb0\n\x04?\n\r\n\x05\x06\
    \0\x02K\x04\x12\x04\xb1\n\x04C\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x01\
    \x12\x04\xb1\n\x04C\n\r\n\x05\x06\0\x02K\x04\x12\x04\xb2\n\x04A\n\x11\n\
    \t\x06\0\x02K\x04\xc2\xf3\x04\x02\x12\x04\xb2\n\x04A\n\x0e\n\x04\x06\0\
    \x02L\x12\x06\xb5\n\x02\xca\n\x03\n\r\n\x05\x06\0\x02L\x01\x12\x04\xb5\n\
    \x06#\n\r\n\x05\x06\0\x02L\x02\x12\x04\xb5\n%I\n\r\n\x05\x06\0\x02L\x03\
    \x12\x04\xb5\nTt\n\x0f\n\x05\x06\0\x02L\x04\x12\x06\xb6\n\x04\xbd\n\x06\
    \n\x13\n\t\x06\0\x02L\x04\xb0\xca\xbc\"\x12\x06\xb6\n\x04\xbd\n\x06\n\r\
    \n\x05\x06\0\x02L\x04\x12\x04\xbe\n\x047\n\x10\n\x08\x06\0\x02L\x04\xc3\
    \xf3\x04\x12\x04\xbe\n\x047\n\r\n\x05\x06\0\x02L\x04\x12\x04\xbf\n\x04?\
    \n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\0\x12\x04\xbf\n\x04?\n\r\n\x05\x06\
    \0\x02L\x04\x12\x04\xc0\n\x04R\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x01\
    \x12\x04\xc0\n\x04R\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc1\n\x04F\n\x11\n\
    \t\x06\0\x02L\x04\xc2\xf3\x04\x02\x12\x04\xc1\n\x04F\n\r\n\x05\x06\0\x02\
    L\x04\x12\x04\xc2\n\x04C\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x03\x12\
    \x04\xc2\n\x04C\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc3\n\x04A\n\x11\n\t\
    \x06\0\x02L\x04\xc2\xf3\x04\x04\x12\x04\xc3\n\x04A\n\r\n\x05\x06\0\x02L\
    \x04\x12\x04\xc4\n\x04A\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x05\x12\x04\
    \xc4\n\x04A\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc5\n\x04A\n\x11\n\t\x06\0\
    \x02L\x04\xc2\xf3\x04\x06\x12\x04\xc5\n\x04A\n\r\n\x05\x06\0\x02L\x04\
    \x12\x04\xc6\n\x04C\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x07\x12\x04\xc6\
    \n\x04C\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc7\n\x04D\n\x11\n\t\x06\0\x02L\
    \x04\xc2\xf3\x04\x08\x12\x04\xc7\n\x04D\n\r\n\x05\x06\0\x02L\x04\x12\x04\
    \xc8\n\x04B\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\t\x12\x04\xc8\n\x04B\n\
    \r\n\x05\x06\0\x02L\x04\x12\x04\xc9\n\x04B\n\x11\n\t\x06\0\x02L\x04\xc2\
    \xf3\x04\n\x12\x04\xc9\n\x04B\n\x0e\n\x04\x06\0\x02M\x12\x06\xcc\n\x02\
    \xe1\n\x03\n\r\n\x05\x06\0\x02M\x01\x12\x04\xcc\n\x06!\n\r\n\x05\x06\0\
    \x02M\x02\x12\x04\xcc\n#E\n\r\n\x05\x06\0\x02M\x03\x12\x04\xcc\nPp\n\x0f\
    \n\x05\x06\0\x02M\x04\x12\x06\xcd\n\x04\xd4\n\x06\n\x13\n\t\x06\0\x02M\
    \x04\xb0\xca\xbc\"\x12\x06\xcd\n\x04\xd4\n\x06\n\r\n\x05\x06\0\x02M\x04\
    \x12\x04\xd5\n\x047\n\x10\n\x08\x06\0\x02M\x04\xc3\xf3\x04\x12\x04\xd5\n\
    \x047\n\r\n\x05\x06\0\x02M\x04\x12\x04\xd6\n\x04?\n\x11\n\t\x06\0\x02M\
    \x04\xc2\xf3\x04\0\x12\x04\xd6\n\x04?\n\r\n\x05\x06\0\x02M\x04\x12\x04\
    \xd7\n\x04O\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x01\x12\x04\xd7\n\x04O\
    \n\r\n\x05\x06\0\x02M\x04\x12\x04\xd8\n\x04F\n\x11\n\t\x06\0\x02M\x04\
    \xc2\xf3\x04\x02\x12\x04\xd8\n\x04F\n\r\n\x05\x06\0\x02M\x04\x12\x04\xd9\
    \n\x04C\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x03\x12\x04\xd9\n\x04C\n\r\
    \n\x05\x06\0\x02M\x04\x12\x04\xda\n\x04A\n\x11\n\t\x06\0\x02M\x04\xc2\
    \xf3\x04\x04\x12\x04\xda\n\x04A\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdb\n\
    \x04A\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x05\x12\x04\xdb\n\x04A\n\r\n\
    \x05\x06\0\x02M\x04\x12\x04\xdc\n\x04A\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\
    \x04\x06\x12\x04\xdc\n\x04A\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdd\n\x04C\
    \n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x07\x12\x04\xdd\n\x04C\n\r\n\x05\
    \x06\0\x02M\x04\x12\x04\xde\n\x04D\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\
    \x08\x12\x04\xde\n\x04D\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdf\n\x04B\n\
    \x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\t\x12\x04\xdf\n\x04B\n\r\n\x05\x06\0\
    \x02M\x04\x12\x04\xe0\n\x04B\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\n\x12\
    \x04\xe0\n\x04B\n*\n\x04\x06\0\x02N\x12\x06\xe4\n\x02\xf9\n\x03\x1a\x1a\
    \x20PostModelVersionsPublish\n\n\r\n\x05\x06\0\x02N\x01\x12\x04\xe4\n\
    \x06\x1e\n\r\n\x05\x06\0\x02N\x02\x12\x04\xe4\n\x20?\n\r\n\x05\x06\0\x02\
    N\x03\x12\x04\xe4\nJj\n\x0f\n\x05\x06\0\x02N\x04\x12\x06\xe5\n\x04\xec\n\
    \x06\n\x13\n\t\x06\0\x02N\x04\xb0\xca\xbc\"\x12\x06\xe5\n\x04\xec\n\x06\
    \n\r\n\x05\x06\0\x02N\x04\x12\x04\xed\n\x047\n\x10\n\x08\x06\0\x02N\x04\
    \xc3\xf3\x04\x12\x04\xed\n\x047\n\r\n\x05\x06\0\x02N\x04\x12\x04\xee\n\
    \x04?\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\0\x12\x04\xee\n\x04?\n\r\n\
    \x05\x06\0\x02N\x04\x12\x04\xef\n\x04S\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\
    \x04\x01\x12\x04\xef\n\x04S\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf0\n\x04F\
    \n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x02\x12\x04\xf0\n\x04F\n\r\n\x05\
    \x06\0\x02N\x04\x12\x04\xf1\n\x04C\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\
    \x03\x12\x04\xf1\n\x04C\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf2\n\x04A\n\
    \x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x04\x12\x04\xf2\n\x04A\n\r\n\x05\x06\
    \0\x02N\x04\x12\x04\xf3\n\x04A\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x05\
    \x12\x04\xf3\n\x04A\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf4\n\x04A\n\x11\n\
    \t\x06\0\x02N\x04\xc2\xf3\x04\x06\x12\x04\xf4\n\x04A\n\r\n\x05\x06\0\x02\
    N\x04\x12\x04\xf5\n\x04C\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x07\x12\
    \x04\xf5\n\x04C\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf6\n\x04D\n\x11\n\t\
    \x06\0\x02N\x04\xc2\xf3\x04\x08\x12\x04\xf6\n\x04D\n\r\n\x05\x06\0\x02N\
    \x04\x12\x04\xf7\n\x04B\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\t\x12\x04\
    \xf7\n\x04B\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf8\n\x04B\n\x11\n\t\x06\0\
    \x02N\x04\xc2\xf3\x04\n\x12\x04\xf8\n\x04B\n,\n\x04\x06\0\x02O\x12\x06\
    \xfc\n\x02\x91\x0b\x03\x1a\x1c\x20PostModelVersionsUnPublish\n\n\r\n\x05\
    \x06\0\x02O\x01\x12\x04\xfc\n\x06\x20\n\r\n\x05\x06\0\x02O\x02\x12\x04\
    \xfc\n\"C\n\r\n\x05\x06\0\x02O\x03\x12\x04\xfc\nNn\n\x0f\n\x05\x06\0\x02\
    O\x04\x12\x06\xfd\n\x04\x84\x0b\x06\n\x13\n\t\x06\0\x02O\x04\xb0\xca\xbc\
    \"\x12\x06\xfd\n\x04\x84\x0b\x06\n\r\n\x05\x06\0\x02O\x04\x12\x04\x85\
    \x0b\x047\n\x10\n\x08\x06\0\x02O\x04\xc3\xf3\x04\x12\x04\x85\x0b\x047\n\
    \r\n\x05\x06\0\x02O\x04\x12\x04\x86\x0b\x04?\n\x11\n\t\x06\0\x02O\x04\
    \xc2\xf3\x04\0\x12\x04\x86\x0b\x04?\n\r\n\x05\x06\0\x02O\x04\x12\x04\x87\
    \x0b\x04V\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x01\x12\x04\x87\x0b\x04V\
    \n\r\n\x05\x06\0\x02O\x04\x12\x04\x88\x0b\x04F\n\x11\n\t\x06\0\x02O\x04\
    \xc2\xf3\x04\x02\x12\x04\x88\x0b\x04F\n\r\n\x05\x06\0\x02O\x04\x12\x04\
    \x89\x0b\x04C\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x03\x12\x04\x89\x0b\
    \x04C\n\r\n\x05\x06\0\x02O\x04\x12\x04\x8a\x0b\x04A\n\x11\n\t\x06\0\x02O\
    \x04\xc2\xf3\x04\x04\x12\x04\x8a\x0b\x04A\n\r\n\x05\x06\0\x02O\x04\x12\
    \x04\x8b\x0b\x04A\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x05\x12\x04\x8b\
    \x0b\x04A\n\r\n\x05\x06\0\x02O\x04\x12\x04\x8c\x0b\x04A\n\x11\n\t\x06\0\
    \x02O\x04\xc2\xf3\x04\x06\x12\x04\x8c\x0b\x04A\n\r\n\x05\x06\0\x02O\x04\
    \x12\x04\x8d\x0b\x04C\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x07\x12\x04\
    \x8d\x0b\x04C\n\r\n\x05\x06\0\x02O\x04\x12\x04\x8e\x0b\x04D\n\x11\n\t\
    \x06\0\x02O\x04\xc2\xf3\x04\x08\x12\x04\x8e\x0b\x04D\n\r\n\x05\x06\0\x02\
    O\x04\x12\x04\x8f\x0b\x04B\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\t\x12\
    \x04\x8f\x0b\x04B\n\r\n\x05\x06\0\x02O\x04\x12\x04\x90\x0b\x04B\n\x11\n\
    \t\x06\0\x02O\x04\xc2\xf3\x04\n\x12\x04\x90\x0b\x04B\n\x97\x01\n\x04\x06\
    \0\x02P\x12\x06\x97\x0b\x02\xab\x0b\x03\x1a>\x20Create\x20a\x20new\x20mo\
    del\x20version\x20to\x20trigger\x20training\x20of\x20the\x20model.\n2G\
    \x20NOTE:\x20inconsistency:\x20do\x20we\x20want\x20this\x20to\x20return\
    \x20a\x20SingleModelResponse?\n\n\r\n\x05\x06\0\x02P\x01\x12\x04\x97\x0b\
    \x06\x17\n\r\n\x05\x06\0\x02P\x02\x12\x04\x97\x0b\x191\n\r\n\x05\x06\0\
    \x02P\x03\x12\x04\x97\x0b<O\n\x0f\n\x05\x06\0\x02P\x04\x12\x06\x98\x0b\
    \x04\x9f\x0b\x06\n\x13\n\t\x06\0\x02P\x04\xb0\xca\xbc\"\x12\x06\x98\x0b\
    \x04\x9f\x0b\x06\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa0\x0b\x047\n\x10\n\
    \x08\x06\0\x02P\x04\xc3\xf3\x04\x12\x04\xa0\x0b\x047\n\r\n\x05\x06\0\x02\
    P\x04\x12\x04\xa1\x0b\x04?\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\0\x12\
    \x04\xa1\x0b\x04?\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa2\x0b\x04F\n\x11\n\
    \t\x06\0\x02P\x04\xc2\xf3\x04\x01\x12\x04\xa2\x0b\x04F\n\r\n\x05\x06\0\
    \x02P\x04\x12\x04\xa3\x0b\x04C\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x02\
    \x12\x04\xa3\x0b\x04C\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa4\x0b\x04A\n\
    \x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x03\x12\x04\xa4\x0b\x04A\n\r\n\x05\
    \x06\0\x02P\x04\x12\x04\xa5\x0b\x04A\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\
    \x04\x04\x12\x04\xa5\x0b\x04A\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa6\x0b\
    \x04A\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x05\x12\x04\xa6\x0b\x04A\n\r\
    \n\x05\x06\0\x02P\x04\x12\x04\xa7\x0b\x04C\n\x11\n\t\x06\0\x02P\x04\xc2\
    \xf3\x04\x06\x12\x04\xa7\x0b\x04C\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa8\
    \x0b\x04D\nF\n\t\x06\0\x02P\x04\xc2\xf3\x04\x07\x12\x04\xa8\x0b\x04D\"3\
    \x20Needs\x20to\x20check\x20the\x20base\x20workflow\x20to\x20build\x20of\
    f\x20of.\n\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa9\x0b\x04B\n\x11\n\t\x06\0\
    \x02P\x04\xc2\xf3\x04\x08\x12\x04\xa9\x0b\x04B\n\r\n\x05\x06\0\x02P\x04\
    \x12\x04\xaa\x0b\x04B\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\t\x12\x04\xaa\
    \x0b\x04B\n$\n\x04\x06\0\x02Q\x12\x06\xae\x0b\x02\xb9\x0b\x03\x1a\x14\
    \x20PatchModelVersions\n\n\r\n\x05\x06\0\x02Q\x01\x12\x04\xae\x0b\x06\
    \x18\n\r\n\x05\x06\0\x02Q\x02\x12\x04\xae\x0b\x1a3\n\r\n\x05\x06\0\x02Q\
    \x03\x12\x04\xae\x0b>W\n\x0f\n\x05\x06\0\x02Q\x04\x12\x06\xaf\x0b\x04\
    \xb2\x0b\x06\n\x13\n\t\x06\0\x02Q\x04\xb0\xca\xbc\"\x12\x06\xaf\x0b\x04\
    \xb2\x0b\x06\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xb3\x0b\x047\n\x10\n\x08\
    \x06\0\x02Q\x04\xc3\xf3\x04\x12\x04\xb3\x0b\x047\n\r\n\x05\x06\0\x02Q\
    \x04\x12\x04\xb4\x0b\x04?\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\0\x12\x04\
    \xb4\x0b\x04?\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xb5\x0b\x04C\n\x11\n\t\
    \x06\0\x02Q\x04\xc2\xf3\x04\x01\x12\x04\xb5\x0b\x04C\n\r\n\x05\x06\0\x02\
    Q\x04\x12\x04\xb6\x0b\x04A\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x02\x12\
    \x04\xb6\x0b\x04A\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xb7\x0b\x04A\n\x11\n\
    \t\x06\0\x02Q\x04\xc2\xf3\x04\x03\x12\x04\xb7\x0b\x04A\n\r\n\x05\x06\0\
    \x02Q\x04\x12\x04\xb8\x0b\x04C\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x04\
    \x12\x04\xb8\x0b\x04C\n(\n\x04\x06\0\x02R\x12\x06\xbc\x0b\x02\xca\x0b\
    \x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\x05\x06\0\x02R\
    \x01\x12\x04\xbc\x0b\x06\x18\n\r\n\x05\x06\0\x02R\x02\x12\x04\xbc\x0b\
    \x1a3\n\r\n\x05\x06\0\x02R\x03\x12\x04\xbc\x0b>^\n\x0f\n\x05\x06\0\x02R\
    \x04\x12\x06\xbd\x0b\x04\xc2\x0b\x06\n\x13\n\t\x06\0\x02R\x04\xb0\xca\
    \xbc\"\x12\x06\xbd\x0b\x04\xc2\x0b\x06\n\r\n\x05\x06\0\x02R\x04\x12\x04\
    \xc3\x0b\x047\n\x10\n\x08\x06\0\x02R\x04\xc3\xf3\x04\x12\x04\xc3\x0b\x04\
    7\n\r\n\x05\x06\0\x02R\x04\x12\x04\xc4\x0b\x04?\n\x11\n\t\x06\0\x02R\x04\
    \xc2\xf3\x04\0\x12\x04\xc4\x0b\x04?\n\r\n\x05\x06\0\x02R\x04\x12\x04\xc5\
    \x0b\x04C\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x01\x12\x04\xc5\x0b\x04C\
    \n\r\n\x05\x06\0\x02R\x04\x12\x04\xc6\x0b\x04A\n\x11\n\t\x06\0\x02R\x04\
    \xc2\xf3\x04\x02\x12\x04\xc6\x0b\x04A\n\r\n\x05\x06\0\x02R\x04\x12\x04\
    \xc7\x0b\x04D\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x03\x12\x04\xc7\x0b\
    \x04D\n\r\n\x05\x06\0\x02R\x04\x12\x04\xc8\x0b\x04A\n\x11\n\t\x06\0\x02R\
    \x04\xc2\xf3\x04\x04\x12\x04\xc8\x0b\x04A\n\r\n\x05\x06\0\x02R\x04\x12\
    \x04\xc9\x0b\x04D\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x05\x12\x04\xc9\
    \x0b\x04D\nh\n\x04\x06\0\x02S\x12\x06\xce\x0b\x02\xdc\x0b\x03\x1aX\x20De\
    precated:\x20Use\x20GetEvaluation\x20instead\n\x20Get\x20the\x20evaluati\
    on\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\x02S\
    \x01\x12\x04\xce\x0b\x06\x1c\n\r\n\x05\x06\0\x02S\x02\x12\x04\xce\x0b\
    \x1e;\n\r\n\x05\x06\0\x02S\x03\x12\x04\xce\x0bF`\n\x0f\n\x05\x06\0\x02S\
    \x04\x12\x06\xcf\x0b\x04\xd4\x0b\x06\n\x13\n\t\x06\0\x02S\x04\xb0\xca\
    \xbc\"\x12\x06\xcf\x0b\x04\xd4\x0b\x06\n\r\n\x05\x06\0\x02S\x04\x12\x04\
    \xd5\x0b\x047\n\x10\n\x08\x06\0\x02S\x04\xc3\xf3\x04\x12\x04\xd5\x0b\x04\
    7\n\r\n\x05\x06\0\x02S\x04\x12\x04\xd6\x0b\x04?\n\x11\n\t\x06\0\x02S\x04\
    \xc2\xf3\x04\0\x12\x04\xd6\x0b\x04?\n\r\n\x05\x06\0\x02S\x04\x12\x04\xd7\
    \x0b\x04F\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x01\x12\x04\xd7\x0b\x04F\
    \n\r\n\x05\x06\0\x02S\x04\x12\x04\xd8\x0b\x04C\n\x11\n\t\x06\0\x02S\x04\
    \xc2\xf3\x04\x02\x12\x04\xd8\x0b\x04C\n\r\n\x05\x06\0\x02S\x04\x12\x04\
    \xd9\x0b\x04A\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x03\x12\x04\xd9\x0b\
    \x04A\n\r\n\x05\x06\0\x02S\x04\x12\x04\xda\x0b\x04A\n\x11\n\t\x06\0\x02S\
    \x04\xc2\xf3\x04\x04\x12\x04\xda\x0b\x04A\n\r\n\x05\x06\0\x02S\x04\x12\
    \x04\xdb\x0b\x04B\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x05\x12\x04\xdb\
    \x0b\x04B\nj\n\x04\x06\0\x02T\x12\x06\xe0\x0b\x02\xf5\x0b\x03\x1aZ\x20De\
    precated,\x20use\x20PostEvaluations\x20instead\n\x20Run\x20the\x20evalua\
    tion\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\x02T\
    \x01\x12\x04\xe0\x0b\x06\x1d\n\r\n\x05\x06\0\x02T\x02\x12\x04\xe0\x0b\
    \x1f=\n\r\n\x05\x06\0\x02T\x03\x12\x04\xe0\x0bHb\n\x0f\n\x05\x06\0\x02T\
    \x04\x12\x06\xe1\x0b\x04\xe8\x0b\x06\n\x13\n\t\x06\0\x02T\x04\xb0\xca\
    \xbc\"\x12\x06\xe1\x0b\x04\xe8\x0b\x06\n\r\n\x05\x06\0\x02T\x04\x12\x04\
    \xe9\x0b\x047\n\x10\n\x08\x06\0\x02T\x04\xc3\xf3\x04\x12\x04\xe9\x0b\x04\
    7\n\r\n\x05\x06\0\x02T\x04\x12\x04\xea\x0b\x04?\n\x11\n\t\x06\0\x02T\x04\
    \xc2\xf3\x04\0\x12\x04\xea\x0b\x04?\n\r\n\x05\x06\0\x02T\x04\x12\x04\xeb\
    \x0b\x04F\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x01\x12\x04\xeb\x0b\x04F\
    \n\r\n\x05\x06\0\x02T\x04\x12\x04\xec\x0b\x04C\n\x11\n\t\x06\0\x02T\x04\
    \xc2\xf3\x04\x02\x12\x04\xec\x0b\x04C\n\r\n\x05\x06\0\x02T\x04\x12\x04\
    \xed\x0b\x04A\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x03\x12\x04\xed\x0b\
    \x04A\n\r\n\x05\x06\0\x02T\x04\x12\x04\xee\x0b\x04A\n\x11\n\t\x06\0\x02T\
    \x04\xc2\xf3\x04\x04\x12\x04\xee\x0b\x04A\n\r\n\x05\x06\0\x02T\x04\x12\
    \x04\xef\x0b\x04A\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x05\x12\x04\xef\
    \x0b\x04A\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf0\x0b\x04C\n\x11\n\t\x06\0\
    \x02T\x04\xc2\xf3\x04\x06\x12\x04\xf0\x0b\x04C\n\r\n\x05\x06\0\x02T\x04\
    \x12\x04\xf1\x0b\x04>\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x07\x12\x04\
    \xf1\x0b\x04>\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf2\x0b\x04D\nF\n\t\x06\0\
    \x02T\x04\xc2\xf3\x04\x08\x12\x04\xf2\x0b\x04D\"3\x20Needs\x20to\x20chec\
    k\x20the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n\r\n\x05\
    \x06\0\x02T\x04\x12\x04\xf3\x0b\x04B\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\
    \x04\t\x12\x04\xf3\x0b\x04B\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf4\x0b\x04\
    B\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\n\x12\x04\xf4\x0b\x04B\n9\n\x04\
    \x06\0\x02U\x12\x06\xf8\x0b\x02\x8d\x0c\x03\x1a)\x20Deprecated,\x20use\
    \x20PostEvaluations\x20instead\n\n\r\n\x05\x06\0\x02U\x01\x12\x04\xf8\
    \x0b\x06!\n\r\n\x05\x06\0\x02U\x02\x12\x04\xf8\x0b#E\n\r\n\x05\x06\0\x02\
    U\x03\x12\x04\xf8\x0bPh\n\x0f\n\x05\x06\0\x02U\x04\x12\x06\xf9\x0b\x04\
    \x80\x0c\x06\n\x13\n\t\x06\0\x02U\x04\xb0\xca\xbc\"\x12\x06\xf9\x0b\x04\
    \x80\x0c\x06\n\r\n\x05\x06\0\x02U\x04\x12\x04\x81\x0c\x047\n\x10\n\x08\
    \x06\0\x02U\x04\xc3\xf3\x04\x12\x04\x81\x0c\x047\n\r\n\x05\x06\0\x02U\
    \x04\x12\x04\x82\x0c\x04?\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\0\x12\x04\
    \x82\x0c\x04?\n\r\n\x05\x06\0\x02U\x04\x12\x04\x83\x0c\x04F\n\x11\n\t\
    \x06\0\x02U\x04\xc2\xf3\x04\x01\x12\x04\x83\x0c\x04F\n\r\n\x05\x06\0\x02\
    U\x04\x12\x04\x84\x0c\x04C\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x02\x12\
    \x04\x84\x0c\x04C\n\r\n\x05\x06\0\x02U\x04\x12\x04\x85\x0c\x04A\n\x11\n\
    \t\x06\0\x02U\x04\xc2\xf3\x04\x03\x12\x04\x85\x0c\x04A\n\r\n\x05\x06\0\
    \x02U\x04\x12\x04\x86\x0c\x04A\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x04\
    \x12\x04\x86\x0c\x04A\n\r\n\x05\x06\0\x02U\x04\x12\x04\x87\x0c\x04A\n\
    \x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x05\x12\x04\x87\x0c\x04A\n\r\n\x05\
    \x06\0\x02U\x04\x12\x04\x88\x0c\x04C\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\
    \x04\x06\x12\x04\x88\x0c\x04C\n\r\n\x05\x06\0\x02U\x04\x12\x04\x89\x0c\
    \x04>\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x07\x12\x04\x89\x0c\x04>\n\r\
    \n\x05\x06\0\x02U\x04\x12\x04\x8a\x0c\x04D\n\x11\n\t\x06\0\x02U\x04\xc2\
    \xf3\x04\x08\x12\x04\x8a\x0c\x04D\n\r\n\x05\x06\0\x02U\x04\x12\x04\x8b\
    \x0c\x04B\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\t\x12\x04\x8b\x0c\x04B\n\
    \r\n\x05\x06\0\x02U\x04\x12\x04\x8c\x0c\x04B\n\x11\n\t\x06\0\x02U\x04\
    \xc2\xf3\x04\n\x12\x04\x8c\x0c\x04B\ni\n\x04\x06\0\x02V\x12\x06\x91\x0c\
    \x02\x9f\x0c\x03\x1aY\x20Deprecated,\x20use\x20GetEvaluation\x20instead\
    \n\x20List\x20the\x20evaluation\x20metrics\x20for\x20a\x20model\x20versi\
    on.\n\n\r\n\x05\x06\0\x02V\x01\x12\x04\x91\x0c\x06!\n\r\n\x05\x06\0\x02V\
    \x02\x12\x04\x91\x0c#E\n\r\n\x05\x06\0\x02V\x03\x12\x04\x91\x0cPh\n\x0f\
    \n\x05\x06\0\x02V\x04\x12\x06\x92\x0c\x04\x97\x0c\x06\n\x13\n\t\x06\0\
    \x02V\x04\xb0\xca\xbc\"\x12\x06\x92\x0c\x04\x97\x0c\x06\n\r\n\x05\x06\0\
    \x02V\x04\x12\x04\x98\x0c\x047\n\x10\n\x08\x06\0\x02V\x04\xc3\xf3\x04\
    \x12\x04\x98\x0c\x047\n\r\n\x05\x06\0\x02V\x04\x12\x04\x99\x0c\x04?\n\
    \x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\0\x12\x04\x99\x0c\x04?\n\r\n\x05\x06\
    \0\x02V\x04\x12\x04\x9a\x0c\x04F\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\
    \x01\x12\x04\x9a\x0c\x04F\n\r\n\x05\x06\0\x02V\x04\x12\x04\x9b\x0c\x04C\
    \n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\x02\x12\x04\x9b\x0c\x04C\n\r\n\x05\
    \x06\0\x02V\x04\x12\x04\x9c\x0c\x04A\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\
    \x04\x03\x12\x04\x9c\x0c\x04A\n\r\n\x05\x06\0\x02V\x04\x12\x04\x9d\x0c\
    \x04A\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\x04\x12\x04\x9d\x0c\x04A\n\r\
    \n\x05\x06\0\x02V\x04\x12\x04\x9e\x0c\x04B\n\x11\n\t\x06\0\x02V\x04\xc2\
    \xf3\x04\x05\x12\x04\x9e\x0c\x04B\ng\n\x04\x06\0\x02W\x12\x06\xa3\x0c\
    \x02\xb1\x0c\x03\x1aW\x20Deprecated,\x20use\x20GetEvaluation\x20instead\
    \n\x20Get\x20an\x20evaluation\x20metrics\x20for\x20a\x20model\x20version\
    .\n\n\r\n\x05\x06\0\x02W\x01\x12\x04\xa3\x0c\x06\x1f\n\r\n\x05\x06\0\x02\
    W\x02\x12\x04\xa3\x0c!A\n\r\n\x05\x06\0\x02W\x03\x12\x04\xa3\x0cLe\n\x0f\
    \n\x05\x06\0\x02W\x04\x12\x06\xa4\x0c\x04\xa9\x0c\x06\n\x13\n\t\x06\0\
    \x02W\x04\xb0\xca\xbc\"\x12\x06\xa4\x0c\x04\xa9\x0c\x06\n\r\n\x05\x06\0\
    \x02W\x04\x12\x04\xaa\x0c\x047\n\x10\n\x08\x06\0\x02W\x04\xc3\xf3\x04\
    \x12\x04\xaa\x0c\x047\n\r\n\x05\x06\0\x02W\x04\x12\x04\xab\x0c\x04?\n\
    \x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\0\x12\x04\xab\x0c\x04?\n\r\n\x05\x06\
    \0\x02W\x04\x12\x04\xac\x0c\x04F\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\
    \x01\x12\x04\xac\x0c\x04F\n\r\n\x05\x06\0\x02W\x04\x12\x04\xad\x0c\x04C\
    \n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x02\x12\x04\xad\x0c\x04C\n\r\n\x05\
    \x06\0\x02W\x04\x12\x04\xae\x0c\x04A\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\
    \x04\x03\x12\x04\xae\x0c\x04A\n\r\n\x05\x06\0\x02W\x04\x12\x04\xaf\x0c\
    \x04A\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x04\x12\x04\xaf\x0c\x04A\n\r\
    \n\x05\x06\0\x02W\x04\x12\x04\xb0\x0c\x04B\n\x11\n\t\x06\0\x02W\x04\xc2\
    \xf3\x04\x05\x12\x04\xb0\x0c\x04B\n\x0e\n\x04\x06\0\x02X\x12\x06\xb3\x0c\
    \x02\xc8\x0c\x03\n\r\n\x05\x06\0\x02X\x01\x12\x04\xb3\x0c\x06\x15\n\r\n\
    \x05\x06\0\x02X\x02\x12\x04\xb3\x0c\x17-\n\r\n\x05\x06\0\x02X\x03\x12\
    \x04\xb3\x0c8P\n\x0f\n\x05\x06\0\x02X\x04\x12\x06\xb4\x0c\x04\xbb\x0c\
    \x06\n\x13\n\t\x06\0\x02X\x04\xb0\xca\xbc\"\x12\x06\xb4\x0c\x04\xbb\x0c\
    \x06\n\r\n\x05\x06\0\x02X\x04\x12\x04\xbc\x0c\x047\n\x10\n\x08\x06\0\x02\
    X\x04\xc3\xf3\x04\x12\x04\xbc\x0c\x047\n\r\n\x05\x06\0\x02X\x04\x12\x04\
    \xbd\x0c\x04?\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\0\x12\x04\xbd\x0c\x04\
    ?\n\r\n\x05\x06\0\x02X\x04\x12\x04\xbe\x0c\x04F\n\x11\n\t\x06\0\x02X\x04\
    \xc2\xf3\x04\x01\x12\x04\xbe\x0c\x04F\n\r\n\x05\x06\0\x02X\x04\x12\x04\
    \xbf\x0c\x04C\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x02\x12\x04\xbf\x0c\
    \x04C\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc0\x0c\x04A\n\x11\n\t\x06\0\x02X\
    \x04\xc2\xf3\x04\x03\x12\x04\xc0\x0c\x04A\n\r\n\x05\x06\0\x02X\x04\x12\
    \x04\xc1\x0c\x04A\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x04\x12\x04\xc1\
    \x0c\x04A\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc2\x0c\x04A\n\x11\n\t\x06\0\
    \x02X\x04\xc2\xf3\x04\x05\x12\x04\xc2\x0c\x04A\n\r\n\x05\x06\0\x02X\x04\
    \x12\x04\xc3\x0c\x04C\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x06\x12\x04\
    \xc3\x0c\x04C\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc4\x0c\x04>\n\x11\n\t\
    \x06\0\x02X\x04\xc2\xf3\x04\x07\x12\x04\xc4\x0c\x04>\n\r\n\x05\x06\0\x02\
    X\x04\x12\x04\xc5\x0c\x04D\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x08\x12\
    \x04\xc5\x0c\x04D\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc6\x0c\x04B\n\x11\n\
    \t\x06\0\x02X\x04\xc2\xf3\x04\t\x12\x04\xc6\x0c\x04B\n\r\n\x05\x06\0\x02\
    X\x04\x12\x04\xc7\x0c\x04B\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\n\x12\
    \x04\xc7\x0c\x04B\n\x0e\n\x04\x06\0\x02Y\x12\x06\xca\x0c\x02\xdb\x0c\x03\
    \n\r\n\x05\x06\0\x02Y\x01\x12\x04\xca\x0c\x06\x15\n\r\n\x05\x06\0\x02Y\
    \x02\x12\x04\xca\x0c\x17-\n\r\n\x05\x06\0\x02Y\x03\x12\x04\xca\x0c8P\n\
    \x0f\n\x05\x06\0\x02Y\x04\x12\x06\xcb\x0c\x04\xd3\x0c\x06\n\x13\n\t\x06\
    \0\x02Y\x04\xb0\xca\xbc\"\x12\x06\xcb\x0c\x04\xd3\x0c\x06\n\r\n\x05\x06\
    \0\x02Y\x04\x12\x04\xd4\x0c\x047\n\x10\n\x08\x06\0\x02Y\x04\xc3\xf3\x04\
    \x12\x04\xd4\x0c\x047\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd5\x0c\x04?\n\
    \x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\0\x12\x04\xd5\x0c\x04?\n\r\n\x05\x06\
    \0\x02Y\x04\x12\x04\xd6\x0c\x04F\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\
    \x01\x12\x04\xd6\x0c\x04F\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd7\x0c\x04C\
    \n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x02\x12\x04\xd7\x0c\x04C\n\r\n\x05\
    \x06\0\x02Y\x04\x12\x04\xd8\x0c\x04A\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\
    \x04\x03\x12\x04\xd8\x0c\x04A\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd9\x0c\
    \x04A\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x04\x12\x04\xd9\x0c\x04A\n\r\
    \n\x05\x06\0\x02Y\x04\x12\x04\xda\x0c\x04B\n\x11\n\t\x06\0\x02Y\x04\xc2\
    \xf3\x04\x05\x12\x04\xda\x0c\x04B\n\x0e\n\x04\x06\0\x02Z\x12\x06\xdd\x0c\
    \x02\xeb\x0c\x03\n\r\n\x05\x06\0\x02Z\x01\x12\x04\xdd\x0c\x06\x13\n\r\n\
    \x05\x06\0\x02Z\x02\x12\x04\xdd\x0c\x15)\n\r\n\x05\x06\0\x02Z\x03\x12\
    \x04\xdd\x0c4M\n\x0f\n\x05\x06\0\x02Z\x04\x12\x06\xde\x0c\x04\xe3\x0c\
    \x06\n\x13\n\t\x06\0\x02Z\x04\xb0\xca\xbc\"\x12\x06\xde\x0c\x04\xe3\x0c\
    \x06\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xe4\x0c\x047\n\x10\n\x08\x06\0\x02\
    Z\x04\xc3\xf3\x04\x12\x04\xe4\x0c\x047\n\r\n\x05\x06\0\x02Z\x04\x12\x04\
    \xe5\x0c\x04?\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\0\x12\x04\xe5\x0c\x04\
    ?\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xe6\x0c\x04F\n\x11\n\t\x06\0\x02Z\x04\
    \xc2\xf3\x04\x01\x12\x04\xe6\x0c\x04F\n\r\n\x05\x06\0\x02Z\x04\x12\x04\
    \xe7\x0c\x04C\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x02\x12\x04\xe7\x0c\
    \x04C\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xe8\x0c\x04A\n\x11\n\t\x06\0\x02Z\
    \x04\xc2\xf3\x04\x03\x12\x04\xe8\x0c\x04A\n\r\n\x05\x06\0\x02Z\x04\x12\
    \x04\xe9\x0c\x04A\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x04\x12\x04\xe9\
    \x0c\x04A\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xea\x0c\x04B\n\x11\n\t\x06\0\
    \x02Z\x04\xc2\xf3\x04\x05\x12\x04\xea\x0c\x04B\nG\n\x04\x06\0\x02[\x12\
    \x06\xee\x0c\x02\xf8\x0c\x03\x1a7\x20Lists\x20model\x20references\x20tie\
    d\x20to\x20a\x20particular\x20model\x20id.\n\n\r\n\x05\x06\0\x02[\x01\
    \x12\x04\xee\x0c\x06\x19\n\r\n\x05\x06\0\x02[\x02\x12\x04\xee\x0c\x1b5\n\
    \r\n\x05\x06\0\x02[\x03\x12\x04\xee\x0c@[\n\x0f\n\x05\x06\0\x02[\x04\x12\
    \x06\xef\x0c\x04\xf4\x0c\x06\n\x13\n\t\x06\0\x02[\x04\xb0\xca\xbc\"\x12\
    \x06\xef\x0c\x04\xf4\x0c\x06\n\r\n\x05\x06\0\x02[\x04\x12\x04\xf5\x0c\
    \x047\n\x10\n\x08\x06\0\x02[\x04\xc3\xf3\x04\x12\x04\xf5\x0c\x047\n\r\n\
    \x05\x06\0\x02[\x04\x12\x04\xf6\x0c\x04?\n\x11\n\t\x06\0\x02[\x04\xc2\
    \xf3\x04\0\x12\x04\xf6\x0c\x04?\n\r\n\x05\x06\0\x02[\x04\x12\x04\xf7\x0c\
    \x04A\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\x01\x12\x04\xf7\x0c\x04A\n-\n\
    \x04\x06\0\x02\\\x12\x06\xfd\x0c\x02\x87\r\x03\x1a\x1d\x20GetModelVersio\
    nInputExample\n\n\r\n\x05\x06\0\x02\\\x01\x12\x04\xfd\x0c\x06!\n\r\n\x05\
    \x06\0\x02\\\x02\x12\x04\xfd\x0c#E\n\r\n\x05\x06\0\x02\\\x03\x12\x04\xfd\
    \x0cPv\n\x0f\n\x05\x06\0\x02\\\x04\x12\x06\xfe\x0c\x04\x83\r\x06\n\x13\n\
    \t\x06\0\x02\\\x04\xb0\xca\xbc\"\x12\x06\xfe\x0c\x04\x83\r\x06\n\r\n\x05\
    \x06\0\x02\\\x04\x12\x04\x84\r\x047\n\x10\n\x08\x06\0\x02\\\x04\xc3\xf3\
    \x04\x12\x04\x84\r\x047\n\r\n\x05\x06\0\x02\\\x04\x12\x04\x85\r\x04?\n\
    \x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\0\x12\x04\x85\r\x04?\n\r\n\x05\x06\
    \0\x02\\\x04\x12\x04\x86\r\x04A\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\
    \x01\x12\x04\x86\r\x04A\n/\n\x04\x06\0\x02]\x12\x06\x8a\r\x02\x94\r\x03\
    \x1a\x1f\x20ListModelVersionInputExamples\n\n\r\n\x05\x06\0\x02]\x01\x12\
    \x04\x8a\r\x06#\n\r\n\x05\x06\0\x02]\x02\x12\x04\x8a\r%I\n\r\n\x05\x06\0\
    \x02]\x03\x12\x04\x8a\rTy\n\x0f\n\x05\x06\0\x02]\x04\x12\x06\x8b\r\x04\
    \x90\r\x06\n\x13\n\t\x06\0\x02]\x04\xb0\xca\xbc\"\x12\x06\x8b\r\x04\x90\
    \r\x06\n\r\n\x05\x06\0\x02]\x04\x12\x04\x91\r\x047\n\x10\n\x08\x06\0\x02\
    ]\x04\xc3\xf3\x04\x12\x04\x91\r\x047\n\r\n\x05\x06\0\x02]\x04\x12\x04\
    \x92\r\x04?\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\0\x12\x04\x92\r\x04?\n\
    \r\n\x05\x06\0\x02]\x04\x12\x04\x93\r\x04A\n\x11\n\t\x06\0\x02]\x04\xc2\
    \xf3\x04\x01\x12\x04\x93\r\x04A\n\xba\x01\n\x04\x06\0\x02^\x12\x06\xab\r\
    \x02\xb6\r\x03\x1a&\x20Get\x20a\x20specific\x20workflow\x20from\x20an\
    \x20app.\n2'//////////////////////////////////////\n2Y//////////////////\
    ////////////////////\n\x20Workflows\n///////////////////////////////////\
    ///\n\n\r\n\x05\x06\0\x02^\x01\x12\x04\xab\r\x06\x11\n\r\n\x05\x06\0\x02\
    ^\x02\x12\x04\xab\r\x13%\n\r\n\x05\x06\0\x02^\x03\x12\x04\xab\r0F\n\x0f\
    \n\x05\x06\0\x02^\x04\x12\x06\xac\r\x04\xb1\r\x06\n\x13\n\t\x06\0\x02^\
    \x04\xb0\xca\xbc\"\x12\x06\xac\r\x04\xb1\r\x06\n\r\n\x05\x06\0\x02^\x04\
    \x12\x04\xb2\r\x047\n\x10\n\x08\x06\0\x02^\x04\xc3\xf3\x04\x12\x04\xb2\r\
    \x047\n\r\n\x05\x06\0\x02^\x04\x12\x04\xb3\r\x04?\n\x11\n\t\x06\0\x02^\
    \x04\xc2\xf3\x04\0\x12\x04\xb3\r\x04?\n\r\n\x05\x06\0\x02^\x04\x12\x04\
    \xb4\r\x04A\n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\x01\x12\x04\xb4\r\x04A\
    \n\r\n\x05\x06\0\x02^\x04\x12\x04\xb5\r\x04D\n\x11\n\t\x06\0\x02^\x04\
    \xc2\xf3\x04\x02\x12\x04\xb5\r\x04D\n)\n\x04\x06\0\x02_\x12\x06\xb9\r\
    \x02\xc7\r\x03\x1a\x19\x20List\x20all\x20the\x20workflows.\n\n\r\n\x05\
    \x06\0\x02_\x01\x12\x04\xb9\r\x06\x13\n\r\n\x05\x06\0\x02_\x02\x12\x04\
    \xb9\r\x15)\n\r\n\x05\x06\0\x02_\x03\x12\x04\xb9\r4I\n\x0f\n\x05\x06\0\
    \x02_\x04\x12\x06\xba\r\x04\xc2\r\x06\n\x13\n\t\x06\0\x02_\x04\xb0\xca\
    \xbc\"\x12\x06\xba\r\x04\xc2\r\x06\n\r\n\x05\x06\0\x02_\x04\x12\x04\xc3\
    \r\x047\n\x10\n\x08\x06\0\x02_\x04\xc3\xf3\x04\x12\x04\xc3\r\x047\n\r\n\
    \x05\x06\0\x02_\x04\x12\x04\xc4\r\x04?\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\
    \x04\0\x12\x04\xc4\r\x04?\n\r\n\x05\x06\0\x02_\x04\x12\x04\xc5\r\x04A\n\
    \x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x01\x12\x04\xc5\r\x04A\n\r\n\x05\x06\
    \0\x02_\x04\x12\x04\xc6\r\x04D\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x02\
    \x12\x04\xc6\r\x04D\n+\n\x04\x06\0\x02`\x12\x06\xcb\r\x02\xd9\r\x03\x1a\
    \x1b\x20Add\x20a\x20workflow\x20to\x20an\x20app.\n\n\r\n\x05\x06\0\x02`\
    \x01\x12\x04\xcb\r\x06\x13\n\r\n\x05\x06\0\x02`\x02\x12\x04\xcb\r\x15)\n\
    \r\n\x05\x06\0\x02`\x03\x12\x04\xcb\r4I\n\x0f\n\x05\x06\0\x02`\x04\x12\
    \x06\xcc\r\x04\xd3\r\x06\n\x13\n\t\x06\0\x02`\x04\xb0\xca\xbc\"\x12\x06\
    \xcc\r\x04\xd3\r\x06\n\r\n\x05\x06\0\x02`\x04\x12\x04\xd4\r\x047\n\x10\n\
    \x08\x06\0\x02`\x04\xc3\xf3\x04\x12\x04\xd4\r\x047\n\r\n\x05\x06\0\x02`\
    \x04\x12\x04\xd5\r\x04?\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\0\x12\x04\
    \xd5\r\x04?\n\r\n\x05\x06\0\x02`\x04\x12\x04\xd6\r\x04A\n\x11\n\t\x06\0\
    \x02`\x04\xc2\xf3\x04\x01\x12\x04\xd6\r\x04A\n\r\n\x05\x06\0\x02`\x04\
    \x12\x04\xd7\r\x04D\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\x02\x12\x04\xd7\
    \r\x04D\n\r\n\x05\x06\0\x02`\x04\x12\x04\xd8\r\x04D\n\x11\n\t\x06\0\x02`\
    \x04\xc2\xf3\x04\x03\x12\x04\xd8\r\x04D\n.\n\x04\x06\0\x02a\x12\x06\xdc\
    \r\x02\xea\r\x03\x1a\x1e\x20Patch\x20one\x20or\x20more\x20workflows.\n\n\
    \r\n\x05\x06\0\x02a\x01\x12\x04\xdc\r\x06\x14\n\r\n\x05\x06\0\x02a\x02\
    \x12\x04\xdc\r\x16+\n\r\n\x05\x06\0\x02a\x03\x12\x04\xdc\r6K\n\x0f\n\x05\
    \x06\0\x02a\x04\x12\x06\xdd\r\x04\xe4\r\x06\n\x13\n\t\x06\0\x02a\x04\xb0\
    \xca\xbc\"\x12\x06\xdd\r\x04\xe4\r\x06\n\r\n\x05\x06\0\x02a\x04\x12\x04\
    \xe5\r\x047\n\x10\n\x08\x06\0\x02a\x04\xc3\xf3\x04\x12\x04\xe5\r\x047\n\
    \r\n\x05\x06\0\x02a\x04\x12\x04\xe6\r\x04?\n\x11\n\t\x06\0\x02a\x04\xc2\
    \xf3\x04\0\x12\x04\xe6\r\x04?\n\r\n\x05\x06\0\x02a\x04\x12\x04\xe7\r\x04\
    A\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\x01\x12\x04\xe7\r\x04A\n\r\n\x05\
    \x06\0\x02a\x04\x12\x04\xe8\r\x04D\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\
    \x02\x12\x04\xe8\r\x04D\n\r\n\x05\x06\0\x02a\x04\x12\x04\xe9\r\x04D\n\
    \x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\x03\x12\x04\xe9\r\x04D\n2\n\x04\x06\
    \0\x02b\x12\x06\xed\r\x02\xf6\r\x03\x1a\"\x20Patch\x20one\x20or\x20more\
    \x20workflows\x20ids.\n\n\r\n\x05\x06\0\x02b\x01\x12\x04\xed\r\x06\x16\n\
    \r\n\x05\x06\0\x02b\x02\x12\x04\xed\r\x18/\n\r\n\x05\x06\0\x02b\x03\x12\
    \x04\xed\r:O\n\x0f\n\x05\x06\0\x02b\x04\x12\x06\xee\r\x04\xf1\r\x06\n\
    \x13\n\t\x06\0\x02b\x04\xb0\xca\xbc\"\x12\x06\xee\r\x04\xf1\r\x06\n\r\n\
    \x05\x06\0\x02b\x04\x12\x04\xf2\r\x047\n\x10\n\x08\x06\0\x02b\x04\xc3\
    \xf3\x04\x12\x04\xf2\r\x047\n\r\n\x05\x06\0\x02b\x04\x12\x04\xf3\r\x04?\
    \n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\0\x12\x04\xf3\r\x04?\n\r\n\x05\x06\
    \0\x02b\x04\x12\x04\xf4\r\x04D\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\x01\
    \x12\x04\xf4\r\x04D\n\r\n\x05\x06\0\x02b\x04\x12\x04\xf5\r\x04D\n\x11\n\
    \t\x06\0\x02b\x04\xc2\xf3\x04\x02\x12\x04\xf5\r\x04D\n+\n\x04\x06\0\x02c\
    \x12\x06\xf9\r\x02\x85\x0e\x03\x1a\x1b\x20Delete\x20a\x20single\x20workf\
    low.\n\n\r\n\x05\x06\0\x02c\x01\x12\x04\xf9\r\x06\x14\n\r\n\x05\x06\0\
    \x02c\x02\x12\x04\xf9\r\x16+\n\r\n\x05\x06\0\x02c\x03\x12\x04\xf9\r6V\n\
    \x0f\n\x05\x06\0\x02c\x04\x12\x06\xfa\r\x04\xff\r\x06\n\x13\n\t\x06\0\
    \x02c\x04\xb0\xca\xbc\"\x12\x06\xfa\r\x04\xff\r\x06\n\r\n\x05\x06\0\x02c\
    \x04\x12\x04\x80\x0e\x047\n\x10\n\x08\x06\0\x02c\x04\xc3\xf3\x04\x12\x04\
    \x80\x0e\x047\n\r\n\x05\x06\0\x02c\x04\x12\x04\x81\x0e\x04?\n\x11\n\t\
    \x06\0\x02c\x04\xc2\xf3\x04\0\x12\x04\x81\x0e\x04?\n\r\n\x05\x06\0\x02c\
    \x04\x12\x04\x82\x0e\x04D\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x01\x12\
    \x04\x82\x0e\x04D\n\r\n\x05\x06\0\x02c\x04\x12\x04\x83\x0e\x04G\n\x11\n\
    \t\x06\0\x02c\x04\xc2\xf3\x04\x02\x12\x04\x83\x0e\x04G\n\r\n\x05\x06\0\
    \x02c\x04\x12\x04\x84\x0e\x04D\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x03\
    \x12\x04\x84\x0e\x04D\n;\n\x04\x06\0\x02d\x12\x06\x88\x0e\x02\x96\x0e\
    \x03\x1a+\x20Delete\x20multiple\x20workflows\x20in\x20one\x20request.\n\
    \n\r\n\x05\x06\0\x02d\x01\x12\x04\x88\x0e\x06\x15\n\r\n\x05\x06\0\x02d\
    \x02\x12\x04\x88\x0e\x17-\n\r\n\x05\x06\0\x02d\x03\x12\x04\x88\x0e8X\n\
    \x0f\n\x05\x06\0\x02d\x04\x12\x06\x89\x0e\x04\x90\x0e\x06\n\x13\n\t\x06\
    \0\x02d\x04\xb0\xca\xbc\"\x12\x06\x89\x0e\x04\x90\x0e\x06\n\r\n\x05\x06\
    \0\x02d\x04\x12\x04\x91\x0e\x047\n\x10\n\x08\x06\0\x02d\x04\xc3\xf3\x04\
    \x12\x04\x91\x0e\x047\n\r\n\x05\x06\0\x02d\x04\x12\x04\x92\x0e\x04?\n\
    \x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\0\x12\x04\x92\x0e\x04?\n\r\n\x05\x06\
    \0\x02d\x04\x12\x04\x93\x0e\x04D\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\
    \x01\x12\x04\x93\x0e\x04D\n\r\n\x05\x06\0\x02d\x04\x12\x04\x94\x0e\x04G\
    \n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x02\x12\x04\x94\x0e\x04G\n\r\n\x05\
    \x06\0\x02d\x04\x12\x04\x95\x0e\x04D\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\
    \x04\x03\x12\x04\x95\x0e\x04D\n+\n\x04\x06\0\x02e\x12\x06\x99\x0e\x02\
    \xac\x0e\x03\x1a\x1b\x20Predict\x20using\x20a\x20workflow.\n\n\r\n\x05\
    \x06\0\x02e\x01\x12\x04\x99\x0e\x06\x19\n\r\n\x05\x06\0\x02e\x02\x12\x04\
    \x99\x0e\x1b5\n\r\n\x05\x06\0\x02e\x03\x12\x04\x99\x0e@[\n\x0f\n\x05\x06\
    \0\x02e\x04\x12\x06\x9a\x0e\x04\xa5\x0e\x06\n\x13\n\t\x06\0\x02e\x04\xb0\
    \xca\xbc\"\x12\x06\x9a\x0e\x04\xa5\x0e\x06\n\r\n\x05\x06\0\x02e\x04\x12\
    \x04\xa6\x0e\x047\n\x10\n\x08\x06\0\x02e\x04\xc3\xf3\x04\x12\x04\xa6\x0e\
    \x047\n\r\n\x05\x06\0\x02e\x04\x12\x04\xa7\x0e\x04?\n\x11\n\t\x06\0\x02e\
    \x04\xc2\xf3\x04\0\x12\x04\xa7\x0e\x04?\n\r\n\x05\x06\0\x02e\x04\x12\x04\
    \xa8\x0e\x04A\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x01\x12\x04\xa8\x0e\
    \x04A\n\r\n\x05\x06\0\x02e\x04\x12\x04\xa9\x0e\x04C\n\x11\n\t\x06\0\x02e\
    \x04\xc2\xf3\x04\x02\x12\x04\xa9\x0e\x04C\n\r\n\x05\x06\0\x02e\x04\x12\
    \x04\xaa\x0e\x04>\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x03\x12\x04\xaa\
    \x0e\x04>\n\r\n\x05\x06\0\x02e\x04\x12\x04\xab\x0e\x04D\n\x11\n\t\x06\0\
    \x02e\x04\xc2\xf3\x04\x04\x12\x04\xab\x0e\x04D\n?\n\x04\x06\0\x02f\x12\
    \x06\xaf\x0e\x02\xc2\x0e\x03\x1a/\x20Compare\x20embeddings\x20distances\
    \x20using\x20a\x20workflow\n\n\r\n\x05\x06\0\x02f\x01\x12\x04\xaf\x0e\
    \x06#\n\r\n\x05\x06\0\x02f\x02\x12\x04\xaf\x0e$H\n\r\n\x05\x06\0\x02f\
    \x03\x12\x04\xaf\x0eSx\n\x0f\n\x05\x06\0\x02f\x04\x12\x06\xb0\x0e\x04\
    \xbb\x0e\x06\n\x13\n\t\x06\0\x02f\x04\xb0\xca\xbc\"\x12\x06\xb0\x0e\x04\
    \xbb\x0e\x06\n\r\n\x05\x06\0\x02f\x04\x12\x04\xbc\x0e\x047\n\x10\n\x08\
    \x06\0\x02f\x04\xc3\xf3\x04\x12\x04\xbc\x0e\x047\n\r\n\x05\x06\0\x02f\
    \x04\x12\x04\xbd\x0e\x04?\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\0\x12\x04\
    \xbd\x0e\x04?\n\r\n\x05\x06\0\x02f\x04\x12\x04\xbe\x0e\x04A\n\x11\n\t\
    \x06\0\x02f\x04\xc2\xf3\x04\x01\x12\x04\xbe\x0e\x04A\n\r\n\x05\x06\0\x02\
    f\x04\x12\x04\xbf\x0e\x04C\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x02\x12\
    \x04\xbf\x0e\x04C\n\r\n\x05\x06\0\x02f\x04\x12\x04\xc0\x0e\x04>\n\x11\n\
    \t\x06\0\x02f\x04\xc2\xf3\x04\x03\x12\x04\xc0\x0e\x04>\n\r\n\x05\x06\0\
    \x02f\x04\x12\x04\xc1\x0e\x04D\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x04\
    \x12\x04\xc1\x0e\x04D\n)\n\x04\x06\0\x02g\x12\x06\xc5\x0e\x02\xd0\x0e\
    \x03\x1a\x19\x20List\x20workflow\x20versions.\n\n\r\n\x05\x06\0\x02g\x01\
    \x12\x04\xc5\x0e\x06\x1a\n\r\n\x05\x06\0\x02g\x02\x12\x04\xc5\x0e\x1c7\n\
    \r\n\x05\x06\0\x02g\x03\x12\x04\xc5\x0eB^\n\x0f\n\x05\x06\0\x02g\x04\x12\
    \x06\xc6\x0e\x04\xcb\x0e\x06\n\x13\n\t\x06\0\x02g\x04\xb0\xca\xbc\"\x12\
    \x06\xc6\x0e\x04\xcb\x0e\x06\n\r\n\x05\x06\0\x02g\x04\x12\x04\xcc\x0e\
    \x047\n\x10\n\x08\x06\0\x02g\x04\xc3\xf3\x04\x12\x04\xcc\x0e\x047\n\r\n\
    \x05\x06\0\x02g\x04\x12\x04\xcd\x0e\x04?\n\x11\n\t\x06\0\x02g\x04\xc2\
    \xf3\x04\0\x12\x04\xcd\x0e\x04?\n\r\n\x05\x06\0\x02g\x04\x12\x04\xce\x0e\
    \x04A\n\x11\n\t\x06\0\x02g\x04\xc2\xf3\x04\x01\x12\x04\xce\x0e\x04A\n\r\
    \n\x05\x06\0\x02g\x04\x12\x04\xcf\x0e\x04D\n\x11\n\t\x06\0\x02g\x04\xc2\
    \xf3\x04\x02\x12\x04\xcf\x0e\x04D\n.\n\x04\x06\0\x02h\x12\x06\xd3\x0e\
    \x02\xde\x0e\x03\x1a\x1e\x20Get\x20single\x20workflow\x20version.\n\n\r\
    \n\x05\x06\0\x02h\x01\x12\x04\xd3\x0e\x06\x18\n\r\n\x05\x06\0\x02h\x02\
    \x12\x04\xd3\x0e\x1a3\n\r\n\x05\x06\0\x02h\x03\x12\x04\xd3\x0e>[\n\x0f\n\
    \x05\x06\0\x02h\x04\x12\x06\xd4\x0e\x04\xd9\x0e\x06\n\x13\n\t\x06\0\x02h\
    \x04\xb0\xca\xbc\"\x12\x06\xd4\x0e\x04\xd9\x0e\x06\n\r\n\x05\x06\0\x02h\
    \x04\x12\x04\xda\x0e\x047\n\x10\n\x08\x06\0\x02h\x04\xc3\xf3\x04\x12\x04\
    \xda\x0e\x047\n\r\n\x05\x06\0\x02h\x04\x12\x04\xdb\x0e\x04?\n\x11\n\t\
    \x06\0\x02h\x04\xc2\xf3\x04\0\x12\x04\xdb\x0e\x04?\n\r\n\x05\x06\0\x02h\
    \x04\x12\x04\xdc\x0e\x04A\n\x11\n\t\x06\0\x02h\x04\xc2\xf3\x04\x01\x12\
    \x04\xdc\x0e\x04A\n\r\n\x05\x06\0\x02h\x04\x12\x04\xdd\x0e\x04D\n\x11\n\
    \t\x06\0\x02h\x04\xc2\xf3\x04\x02\x12\x04\xdd\x0e\x04D\n+\n\x04\x06\0\
    \x02i\x12\x06\xe1\x0e\x02\xef\x0e\x03\x1a\x1b\x20Delete\x20workflow\x20v\
    ersions.\n\n\r\n\x05\x06\0\x02i\x01\x12\x04\xe1\x0e\x06\x1c\n\r\n\x05\
    \x06\0\x02i\x02\x12\x04\xe1\x0e\x1e;\n\r\n\x05\x06\0\x02i\x03\x12\x04\
    \xe1\x0eFf\n\x0f\n\x05\x06\0\x02i\x04\x12\x06\xe2\x0e\x04\xe9\x0e\x06\n\
    \x13\n\t\x06\0\x02i\x04\xb0\xca\xbc\"\x12\x06\xe2\x0e\x04\xe9\x0e\x06\n\
    \r\n\x05\x06\0\x02i\x04\x12\x04\xea\x0e\x047\n\x10\n\x08\x06\0\x02i\x04\
    \xc3\xf3\x04\x12\x04\xea\x0e\x047\n\r\n\x05\x06\0\x02i\x04\x12\x04\xeb\
    \x0e\x04?\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\0\x12\x04\xeb\x0e\x04?\n\
    \r\n\x05\x06\0\x02i\x04\x12\x04\xec\x0e\x04D\n\x11\n\t\x06\0\x02i\x04\
    \xc2\xf3\x04\x01\x12\x04\xec\x0e\x04D\n\r\n\x05\x06\0\x02i\x04\x12\x04\
    \xed\x0e\x04D\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\x02\x12\x04\xed\x0e\
    \x04D\n\r\n\x05\x06\0\x02i\x04\x12\x04\xee\x0e\x04G\n\x11\n\t\x06\0\x02i\
    \x04\xc2\xf3\x04\x03\x12\x04\xee\x0e\x04G\n*\n\x04\x06\0\x02j\x12\x06\
    \xf2\x0e\x02\x80\x0f\x03\x1a\x1a\x20Patch\x20workflow\x20versions.\n\n\r\
    \n\x05\x06\0\x02j\x01\x12\x04\xf2\x0e\x06\x1b\n\r\n\x05\x06\0\x02j\x02\
    \x12\x04\xf2\x0e\x1d9\n\r\n\x05\x06\0\x02j\x03\x12\x04\xf2\x0eD`\n\x0f\n\
    \x05\x06\0\x02j\x04\x12\x06\xf3\x0e\x04\xfa\x0e\x06\n\x13\n\t\x06\0\x02j\
    \x04\xb0\xca\xbc\"\x12\x06\xf3\x0e\x04\xfa\x0e\x06\n\r\n\x05\x06\0\x02j\
    \x04\x12\x04\xfb\x0e\x047\n\x10\n\x08\x06\0\x02j\x04\xc3\xf3\x04\x12\x04\
    \xfb\x0e\x047\n\r\n\x05\x06\0\x02j\x04\x12\x04\xfc\x0e\x04?\n\x11\n\t\
    \x06\0\x02j\x04\xc2\xf3\x04\0\x12\x04\xfc\x0e\x04?\n\r\n\x05\x06\0\x02j\
    \x04\x12\x04\xfd\x0e\x04A\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\x01\x12\
    \x04\xfd\x0e\x04A\n\r\n\x05\x06\0\x02j\x04\x12\x04\xfe\x0e\x04D\n\x11\n\
    \t\x06\0\x02j\x04\xc2\xf3\x04\x02\x12\x04\xfe\x0e\x04D\n\r\n\x05\x06\0\
    \x02j\x04\x12\x04\xff\x0e\x04D\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\x03\
    \x12\x04\xff\x0e\x04D\n1\n\x04\x06\0\x02k\x12\x06\x88\x0f\x02\x8e\x0f\
    \x03\x1a!\x20Get\x20a\x20specific\x20key\x20from\x20an\x20app.\n\n\r\n\
    \x05\x06\0\x02k\x01\x12\x04\x88\x0f\x06\x0c\n\r\n\x05\x06\0\x02k\x02\x12\
    \x04\x88\x0f\x0e\x1b\n\r\n\x05\x06\0\x02k\x03\x12\x04\x88\x0f&7\n\x0f\n\
    \x05\x06\0\x02k\x04\x12\x06\x89\x0f\x04\x8b\x0f\x06\n\x13\n\t\x06\0\x02k\
    \x04\xb0\xca\xbc\"\x12\x06\x89\x0f\x04\x8b\x0f\x06\n\r\n\x05\x06\0\x02k\
    \x04\x12\x04\x8c\x0f\x047\n\x10\n\x08\x06\0\x02k\x04\xc3\xf3\x04\x12\x04\
    \x8c\x0f\x047\n\r\n\x05\x06\0\x02k\x04\x12\x04\x8d\x0f\x04?\n\x11\n\t\
    \x06\0\x02k\x04\xc2\xf3\x04\0\x12\x04\x8d\x0f\x04?\n$\n\x04\x06\0\x02l\
    \x12\x06\x91\x0f\x02\x97\x0f\x03\x1a\x14\x20List\x20all\x20the\x20keys.\
    \n\n\r\n\x05\x06\0\x02l\x01\x12\x04\x91\x0f\x06\x0e\n\r\n\x05\x06\0\x02l\
    \x02\x12\x04\x91\x0f\x10\x1f\n\r\n\x05\x06\0\x02l\x03\x12\x04\x91\x0f*:\
    \n\x0f\n\x05\x06\0\x02l\x04\x12\x06\x92\x0f\x04\x94\x0f\x06\n\x13\n\t\
    \x06\0\x02l\x04\xb0\xca\xbc\"\x12\x06\x92\x0f\x04\x94\x0f\x06\n\r\n\x05\
    \x06\0\x02l\x04\x12\x04\x95\x0f\x047\n\x10\n\x08\x06\0\x02l\x04\xc3\xf3\
    \x04\x12\x04\x95\x0f\x047\n\r\n\x05\x06\0\x02l\x04\x12\x04\x96\x0f\x04?\
    \n\x11\n\t\x06\0\x02l\x04\xc2\xf3\x04\0\x12\x04\x96\x0f\x04?\n%\n\x04\
    \x06\0\x02m\x12\x06\x9a\x0f\x02\xa1\x0f\x03\x1a\x15\x20List\x20keys\x20b\
    y\x20app_id\n\n\r\n\x05\x06\0\x02m\x01\x12\x04\x9a\x0f\x06\x11\n\r\n\x05\
    \x06\0\x02m\x02\x12\x04\x9a\x0f\x13%\n\r\n\x05\x06\0\x02m\x03\x12\x04\
    \x9a\x0f0@\n\x0f\n\x05\x06\0\x02m\x04\x12\x06\x9b\x0f\x04\x9d\x0f\x06\n\
    \x13\n\t\x06\0\x02m\x04\xb0\xca\xbc\"\x12\x06\x9b\x0f\x04\x9d\x0f\x06\n\
    \r\n\x05\x06\0\x02m\x04\x12\x04\x9e\x0f\x047\n\x10\n\x08\x06\0\x02m\x04\
    \xc3\xf3\x04\x12\x04\x9e\x0f\x047\n\r\n\x05\x06\0\x02m\x04\x12\x04\x9f\
    \x0f\x04?\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\0\x12\x04\x9f\x0f\x04?\n\
    \r\n\x05\x06\0\x02m\x04\x12\x04\xa0\x0f\x04?\n\x11\n\t\x06\0\x02m\x04\
    \xc2\xf3\x04\x01\x12\x04\xa0\x0f\x04?\n\xc9\x01\n\x04\x06\0\x02n\x12\x06\
    \xa6\x0f\x02\xae\x0f\x03\x1a\xb8\x01\x20Search\x20over\x20the\x20keys\
    \x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20Th\
    is\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\
    \x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20\
    variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02n\x01\x12\x04\
    \xa6\x0f\x06\x0f\n\r\n\x05\x06\0\x02n\x02\x12\x04\xa6\x0f\x11!\n\r\n\x05\
    \x06\0\x02n\x03\x12\x04\xa6\x0f,L\n\x0f\n\x05\x06\0\x02n\x04\x12\x06\xa7\
    \x0f\x04\xa9\x0f\x06\n\x13\n\t\x06\0\x02n\x04\xb0\xca\xbc\"\x12\x06\xa7\
    \x0f\x04\xa9\x0f\x06\n\r\n\x05\x06\0\x02n\x04\x12\x04\xaa\x0f\x047\n\x10\
    \n\x08\x06\0\x02n\x04\xc3\xf3\x04\x12\x04\xaa\x0f\x047\n\r\n\x05\x06\0\
    \x02n\x04\x12\x04\xab\x0f\x04?\n\x11\n\t\x06\0\x02n\x04\xc2\xf3\x04\0\
    \x12\x04\xab\x0f\x04?\n\r\n\x05\x06\0\x02n\x04\x12\x04\xac\x0f\x04B\n\
    \x11\n\t\x06\0\x02n\x04\xc2\xf3\x04\x01\x12\x04\xac\x0f\x04B\n\r\n\x05\
    \x06\0\x02n\x04\x12\x04\xad\x0f\x04?\n\x11\n\t\x06\0\x02n\x04\xc2\xf3\
    \x04\x02\x12\x04\xad\x0f\x04?\n&\n\x04\x06\0\x02o\x12\x06\xb1\x0f\x02\
    \xba\x0f\x03\x1a\x16\x20Add\x20a\x20key\x20to\x20an\x20app.\n\n\r\n\x05\
    \x06\0\x02o\x01\x12\x04\xb1\x0f\x06\x0e\n\r\n\x05\x06\0\x02o\x02\x12\x04\
    \xb1\x0f\x10\x1f\n\r\n\x05\x06\0\x02o\x03\x12\x04\xb1\x0f*:\n\x0f\n\x05\
    \x06\0\x02o\x04\x12\x06\xb2\x0f\x04\xb5\x0f\x06\n\x13\n\t\x06\0\x02o\x04\
    \xb0\xca\xbc\"\x12\x06\xb2\x0f\x04\xb5\x0f\x06\n\r\n\x05\x06\0\x02o\x04\
    \x12\x04\xb6\x0f\x047\n\x10\n\x08\x06\0\x02o\x04\xc3\xf3\x04\x12\x04\xb6\
    \x0f\x047\n\r\n\x05\x06\0\x02o\x04\x12\x04\xb7\x0f\x04?\n\x11\n\t\x06\0\
    \x02o\x04\xc2\xf3\x04\0\x12\x04\xb7\x0f\x04?\n\r\n\x05\x06\0\x02o\x04\
    \x12\x04\xb8\x0f\x04?\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x01\x12\x04\
    \xb8\x0f\x04?\n\r\n\x05\x06\0\x02o\x04\x12\x04\xb9\x0f\x04?\n\x11\n\t\
    \x06\0\x02o\x04\xc2\xf3\x04\x02\x12\x04\xb9\x0f\x04?\n)\n\x04\x06\0\x02p\
    \x12\x06\xbd\x0f\x02\xc5\x0f\x03\x1a\x19\x20Patch\x20one\x20or\x20more\
    \x20keys.\n\n\r\n\x05\x06\0\x02p\x01\x12\x04\xbd\x0f\x06\x0f\n\r\n\x05\
    \x06\0\x02p\x02\x12\x04\xbd\x0f\x11!\n\r\n\x05\x06\0\x02p\x03\x12\x04\
    \xbd\x0f,<\n\x0f\n\x05\x06\0\x02p\x04\x12\x06\xbe\x0f\x04\xc1\x0f\x06\n\
    \x13\n\t\x06\0\x02p\x04\xb0\xca\xbc\"\x12\x06\xbe\x0f\x04\xc1\x0f\x06\n\
    \r\n\x05\x06\0\x02p\x04\x12\x04\xc2\x0f\x047\n\x10\n\x08\x06\0\x02p\x04\
    \xc3\xf3\x04\x12\x04\xc2\x0f\x047\n\r\n\x05\x06\0\x02p\x04\x12\x04\xc3\
    \x0f\x04?\n\x11\n\t\x06\0\x02p\x04\xc2\xf3\x04\0\x12\x04\xc3\x0f\x04?\n\
    \r\n\x05\x06\0\x02p\x04\x12\x04\xc4\x0f\x04?\n\x11\n\t\x06\0\x02p\x04\
    \xc2\xf3\x04\x01\x12\x04\xc4\x0f\x04?\n\xc5\x01\n\x04\x06\0\x02q\x12\x06\
    \xca\x0f\x02\xd5\x0f\x03\x1a\xb4\x01\x20API\x20Keys\x20in\x20the\x20publ\
    ic\x20API\x20--\x20request\x20is\x20itself\x20Key\x20authorized,\x20and\
    \x20will\x20tell\n\x20the\x20user\x20the\x20scopes/access\x20of\x20the\
    \x20key/credential\x20they're\x20providing,\x20as\x20computed\x20by\n\
    \x20our\x20authorizer:\n\n\r\n\x05\x06\0\x02q\x01\x12\x04\xca\x0f\x06\
    \x0e\n\r\n\x05\x06\0\x02q\x02\x12\x04\xca\x0f\x10\x1f\n\r\n\x05\x06\0\
    \x02q\x03\x12\x04\xca\x0f*<\n\x0f\n\x05\x06\0\x02q\x04\x12\x06\xcb\x0f\
    \x04\xd3\x0f\x06\n\x13\n\t\x06\0\x02q\x04\xb0\xca\xbc\"\x12\x06\xcb\x0f\
    \x04\xd3\x0f\x06\n\r\n\x05\x06\0\x02q\x04\x12\x04\xd4\x0f\x047\n\x10\n\
    \x08\x06\0\x02q\x04\xc3\xf3\x04\x12\x04\xd4\x0f\x047\n\x0e\n\x04\x06\0\
    \x02r\x12\x06\xd7\x0f\x02\xdc\x0f\x03\n\r\n\x05\x06\0\x02r\x01\x12\x04\
    \xd7\x0f\x06\x12\n\r\n\x05\x06\0\x02r\x02\x12\x04\xd7\x0f\x14'\n\r\n\x05\
    \x06\0\x02r\x03\x12\x04\xd7\x0f2H\n\x0f\n\x05\x06\0\x02r\x04\x12\x06\xd8\
    \x0f\x04\xda\x0f\x06\n\x13\n\t\x06\0\x02r\x04\xb0\xca\xbc\"\x12\x06\xd8\
    \x0f\x04\xda\x0f\x06\n\r\n\x05\x06\0\x02r\x04\x12\x04\xdb\x0f\x047\n\x10\
    \n\x08\x06\0\x02r\x04\xc3\xf3\x04\x12\x04\xdb\x0f\x047\n\x0e\n\x04\x06\0\
    \x02s\x12\x06\xde\x0f\x02\xe3\x0f\x03\n\r\n\x05\x06\0\x02s\x01\x12\x04\
    \xde\x0f\x06\x12\n\r\n\x05\x06\0\x02s\x02\x12\x04\xde\x0f\x14'\n\r\n\x05\
    \x06\0\x02s\x03\x12\x04\xde\x0f2H\n\x0f\n\x05\x06\0\x02s\x04\x12\x06\xdf\
    \x0f\x04\xe1\x0f\x06\n\x13\n\t\x06\0\x02s\x04\xb0\xca\xbc\"\x12\x06\xdf\
    \x0f\x04\xe1\x0f\x06\n\r\n\x05\x06\0\x02s\x04\x12\x04\xe2\x0f\x047\n\x10\
    \n\x08\x06\0\x02s\x04\xc3\xf3\x04\x12\x04\xe2\x0f\x047\nA\n\x04\x06\0\
    \x02t\x12\x06\xe6\x0f\x02\xeb\x0f\x03\x1a1\x20List\x20all\x20auth\x20sco\
    pes\x20available\x20to\x20me\x20as\x20a\x20user.\n\n\r\n\x05\x06\0\x02t\
    \x01\x12\x04\xe6\x0f\x06\x10\n\r\n\x05\x06\0\x02t\x02\x12\x04\xe6\x0f\
    \x12#\n\r\n\x05\x06\0\x02t\x03\x12\x04\xe6\x0f.D\n\x0f\n\x05\x06\0\x02t\
    \x04\x12\x06\xe7\x0f\x04\xe9\x0f\x06\n\x13\n\t\x06\0\x02t\x04\xb0\xca\
    \xbc\"\x12\x06\xe7\x0f\x04\xe9\x0f\x06\n\r\n\x05\x06\0\x02t\x04\x12\x04\
    \xea\x0f\x04@\n\x10\n\x08\x06\0\x02t\x04\xc3\xf3\x04\x12\x04\xea\x0f\x04\
    @\n1\n\x04\x06\0\x02u\x12\x06\xee\x0f\x02\xf5\x0f\x03\x1a!\x20Get\x20a\
    \x20specific\x20app\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02u\x01\x12\
    \x04\xee\x0f\x06\x0c\n\r\n\x05\x06\0\x02u\x02\x12\x04\xee\x0f\x0e\x1b\n\
    \r\n\x05\x06\0\x02u\x03\x12\x04\xee\x0f&7\n\x0f\n\x05\x06\0\x02u\x04\x12\
    \x06\xef\x0f\x04\xf1\x0f\x06\n\x13\n\t\x06\0\x02u\x04\xb0\xca\xbc\"\x12\
    \x06\xef\x0f\x04\xf1\x0f\x06\n\r\n\x05\x06\0\x02u\x04\x12\x04\xf2\x0f\
    \x047\n\x10\n\x08\x06\0\x02u\x04\xc3\xf3\x04\x12\x04\xf2\x0f\x047\n\r\n\
    \x05\x06\0\x02u\x04\x12\x04\xf3\x0f\x04?\n\x11\n\t\x06\0\x02u\x04\xc2\
    \xf3\x04\0\x12\x04\xf3\x0f\x04?\n\r\n\x05\x06\0\x02u\x04\x12\x04\xf4\x0f\
    \x04D\n\x11\n\t\x06\0\x02u\x04\xc2\xf3\x04\x01\x12\x04\xf4\x0f\x04D\n$\n\
    \x04\x06\0\x02v\x12\x06\xf8\x0f\x02\x82\x10\x03\x1a\x14\x20List\x20all\
    \x20the\x20apps.\n\n\r\n\x05\x06\0\x02v\x01\x12\x04\xf8\x0f\x06\x0e\n\r\
    \n\x05\x06\0\x02v\x02\x12\x04\xf8\x0f\x10\x1f\n\r\n\x05\x06\0\x02v\x03\
    \x12\x04\xf8\x0f*:\n\x0f\n\x05\x06\0\x02v\x04\x12\x06\xf9\x0f\x04\xfe\
    \x0f\x06\n\x13\n\t\x06\0\x02v\x04\xb0\xca\xbc\"\x12\x06\xf9\x0f\x04\xfe\
    \x0f\x06\n\r\n\x05\x06\0\x02v\x04\x12\x04\xff\x0f\x047\n\x10\n\x08\x06\0\
    \x02v\x04\xc3\xf3\x04\x12\x04\xff\x0f\x047\n\r\n\x05\x06\0\x02v\x04\x12\
    \x04\x80\x10\x04?\n\x11\n\t\x06\0\x02v\x04\xc2\xf3\x04\0\x12\x04\x80\x10\
    \x04?\n\r\n\x05\x06\0\x02v\x04\x12\x04\x81\x10\x04D\n\x11\n\t\x06\0\x02v\
    \x04\xc2\xf3\x04\x01\x12\x04\x81\x10\x04D\n\xc9\x01\n\x04\x06\0\x02w\x12\
    \x06\x87\x10\x02\x90\x10\x03\x1a\xb8\x01\x20Search\x20over\x20the\x20app\
    s\x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20T\
    his\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\
    \x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20\
    variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02w\x01\x12\x04\
    \x87\x10\x06\x0f\n\r\n\x05\x06\0\x02w\x02\x12\x04\x87\x10\x11!\n\r\n\x05\
    \x06\0\x02w\x03\x12\x04\x87\x10,L\n\x0f\n\x05\x06\0\x02w\x04\x12\x06\x88\
    \x10\x04\x8a\x10\x06\n\x13\n\t\x06\0\x02w\x04\xb0\xca\xbc\"\x12\x06\x88\
    \x10\x04\x8a\x10\x06\n\r\n\x05\x06\0\x02w\x04\x12\x04\x8b\x10\x047\n\x10\
    \n\x08\x06\0\x02w\x04\xc3\xf3\x04\x12\x04\x8b\x10\x047\n\r\n\x05\x06\0\
    \x02w\x04\x12\x04\x8c\x10\x04?\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\0\
    \x12\x04\x8c\x10\x04?\n\r\n\x05\x06\0\x02w\x04\x12\x04\x8d\x10\x04B\n\
    \x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x01\x12\x04\x8d\x10\x04B\n\r\n\x05\
    \x06\0\x02w\x04\x12\x04\x8e\x10\x04?\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\
    \x04\x02\x12\x04\x8e\x10\x04?\n\r\n\x05\x06\0\x02w\x04\x12\x04\x8f\x10\
    \x04D\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x03\x12\x04\x8f\x10\x04D\n\
    \xba\x01\n\x04\x06\0\x02x\x12\x06\x95\x10\x02\xa0\x10\x03\x1a\xa9\x01\
    \x20Add\x20a\x20app\x20to\x20an\x20app.\n\x20This\x20needs\x20to\x20load\
    \x20the\x20default\x20workflow\x20to\x20make\x20a\x20copy,\x20validating\
    \x20all\x20the\x20models\x20in\x20it,\x20and\n\x20then\x20writing\x20the\
    \x20new\x20workflow\x20back\x20to\x20this\x20new\x20app.\n\n\r\n\x05\x06\
    \0\x02x\x01\x12\x04\x95\x10\x06\x0e\n\r\n\x05\x06\0\x02x\x02\x12\x04\x95\
    \x10\x10\x1f\n\r\n\x05\x06\0\x02x\x03\x12\x04\x95\x10*:\n\x0f\n\x05\x06\
    \0\x02x\x04\x12\x06\x96\x10\x04\x99\x10\x06\n\x13\n\t\x06\0\x02x\x04\xb0\
    \xca\xbc\"\x12\x06\x96\x10\x04\x99\x10\x06\n\r\n\x05\x06\0\x02x\x04\x12\
    \x04\x9a\x10\x047\n\x10\n\x08\x06\0\x02x\x04\xc3\xf3\x04\x12\x04\x9a\x10\
    \x047\n\r\n\x05\x06\0\x02x\x04\x12\x04\x9b\x10\x04?\n\x11\n\t\x06\0\x02x\
    \x04\xc2\xf3\x04\0\x12\x04\x9b\x10\x04?\n\r\n\x05\x06\0\x02x\x04\x12\x04\
    \x9c\x10\x04?\n\x11\n\t\x06\0\x02x\x04\xc2\xf3\x04\x01\x12\x04\x9c\x10\
    \x04?\n\r\n\x05\x06\0\x02x\x04\x12\x04\x9d\x10\x04A\n\x11\n\t\x06\0\x02x\
    \x04\xc2\xf3\x04\x02\x12\x04\x9d\x10\x04A\n\r\n\x05\x06\0\x02x\x04\x12\
    \x04\x9e\x10\x04D\n\x11\n\t\x06\0\x02x\x04\xc2\xf3\x04\x03\x12\x04\x9e\
    \x10\x04D\n\r\n\x05\x06\0\x02x\x04\x12\x04\x9f\x10\x04D\n\x11\n\t\x06\0\
    \x02x\x04\xc2\xf3\x04\x04\x12\x04\x9f\x10\x04D\n)\n\x04\x06\0\x02y\x12\
    \x06\xa3\x10\x02\xab\x10\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20ap\
    ps.\n\n\r\n\x05\x06\0\x02y\x01\x12\x04\xa3\x10\x06\x0f\n\r\n\x05\x06\0\
    \x02y\x02\x12\x04\xa3\x10\x11!\n\r\n\x05\x06\0\x02y\x03\x12\x04\xa3\x10,\
    <\n\x0f\n\x05\x06\0\x02y\x04\x12\x06\xa4\x10\x04\xa7\x10\x06\n\x13\n\t\
    \x06\0\x02y\x04\xb0\xca\xbc\"\x12\x06\xa4\x10\x04\xa7\x10\x06\n\r\n\x05\
    \x06\0\x02y\x04\x12\x04\xa8\x10\x047\n\x10\n\x08\x06\0\x02y\x04\xc3\xf3\
    \x04\x12\x04\xa8\x10\x047\n\r\n\x05\x06\0\x02y\x04\x12\x04\xa9\x10\x04?\
    \n\x11\n\t\x06\0\x02y\x04\xc2\xf3\x04\0\x12\x04\xa9\x10\x04?\n\r\n\x05\
    \x06\0\x02y\x04\x12\x04\xaa\x10\x04?\n\x11\n\t\x06\0\x02y\x04\xc2\xf3\
    \x04\x01\x12\x04\xaa\x10\x04?\n!\n\x04\x06\0\x02z\x12\x06\xae\x10\x02\
    \xb6\x10\x03\x1a\x11\x20Patch\x20apps\x20ids.\n\n\r\n\x05\x06\0\x02z\x01\
    \x12\x04\xae\x10\x06\x12\n\r\n\x05\x06\0\x02z\x02\x12\x04\xae\x10\x14'\n\
    \r\n\x05\x06\0\x02z\x03\x12\x04\xae\x102B\n\x0f\n\x05\x06\0\x02z\x04\x12\
    \x06\xaf\x10\x04\xb2\x10\x06\n\x13\n\t\x06\0\x02z\x04\xb0\xca\xbc\"\x12\
    \x06\xaf\x10\x04\xb2\x10\x06\n\r\n\x05\x06\0\x02z\x04\x12\x04\xb3\x10\
    \x047\n\x10\n\x08\x06\0\x02z\x04\xc3\xf3\x04\x12\x04\xb3\x10\x047\n\r\n\
    \x05\x06\0\x02z\x04\x12\x04\xb4\x10\x04?\n\x11\n\t\x06\0\x02z\x04\xc2\
    \xf3\x04\0\x12\x04\xb4\x10\x04?\n\r\n\x05\x06\0\x02z\x04\x12\x04\xb5\x10\
    \x04?\n\x11\n\t\x06\0\x02z\x04\xc2\xf3\x04\x01\x12\x04\xb5\x10\x04?\n\
    \x20\n\x04\x06\0\x02{\x12\x06\xb9\x10\x02\xc1\x10\x03\x1a\x10\x20Patch\
    \x20one\x20app.\n\n\r\n\x05\x06\0\x02{\x01\x12\x04\xb9\x10\x06\x0e\n\r\n\
    \x05\x06\0\x02{\x02\x12\x04\xb9\x10\x10\x1f\n\r\n\x05\x06\0\x02{\x03\x12\
    \x04\xb9\x10*;\n\x0f\n\x05\x06\0\x02{\x04\x12\x06\xba\x10\x04\xbd\x10\
    \x06\n\x13\n\t\x06\0\x02{\x04\xb0\xca\xbc\"\x12\x06\xba\x10\x04\xbd\x10\
    \x06\n\r\n\x05\x06\0\x02{\x04\x12\x04\xbe\x10\x047\n\x10\n\x08\x06\0\x02\
    {\x04\xc3\xf3\x04\x12\x04\xbe\x10\x047\n\r\n\x05\x06\0\x02{\x04\x12\x04\
    \xbf\x10\x04?\n\x11\n\t\x06\0\x02{\x04\xc2\xf3\x04\0\x12\x04\xbf\x10\x04\
    ?\n\r\n\x05\x06\0\x02{\x04\x12\x04\xc0\x10\x04?\n\x11\n\t\x06\0\x02{\x04\
    \xc2\xf3\x04\x01\x12\x04\xc0\x10\x04?\nV\n\x04\x06\0\x02|\x12\x06\xc5\
    \x10\x02\xcd\x10\x03\x1aF\x20Search\x20over\x20the\x20applications\x20to\
    \x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\n\r\n\x05\
    \x06\0\x02|\x01\x12\x04\xc5\x10\x06\x16\n\r\n\x05\x06\0\x02|\x02\x12\x04\
    \xc5\x10\x18/\n\r\n\x05\x06\0\x02|\x03\x12\x04\xc5\x10:J\n\x0f\n\x05\x06\
    \0\x02|\x04\x12\x06\xc6\x10\x04\xc9\x10\x06\n\x13\n\t\x06\0\x02|\x04\xb0\
    \xca\xbc\"\x12\x06\xc6\x10\x04\xc9\x10\x06\n\r\n\x05\x06\0\x02|\x04\x12\
    \x04\xca\x10\x047\n\x10\n\x08\x06\0\x02|\x04\xc3\xf3\x04\x12\x04\xca\x10\
    \x047\n\r\n\x05\x06\0\x02|\x04\x12\x04\xcb\x10\x04?\n\x11\n\t\x06\0\x02|\
    \x04\xc2\xf3\x04\0\x12\x04\xcb\x10\x04?\n\r\n\x05\x06\0\x02|\x04\x12\x04\
    \xcc\x10\x04D\n\x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\x01\x12\x04\xcc\x10\
    \x04D\n&\n\x04\x06\0\x02}\x12\x06\xd0\x10\x02\xd5\x10\x03\x1a\x16\x20Get\
    \x20user\x20information\n\n\r\n\x05\x06\0\x02}\x01\x12\x04\xd0\x10\x06\r\
    \n\r\n\x05\x06\0\x02}\x02\x12\x04\xd0\x10\x0f\x1d\n\r\n\x05\x06\0\x02}\
    \x03\x12\x04\xd0\x10(:\n\x0f\n\x05\x06\0\x02}\x04\x12\x06\xd1\x10\x04\
    \xd3\x10\x06\n\x13\n\t\x06\0\x02}\x04\xb0\xca\xbc\"\x12\x06\xd1\x10\x04\
    \xd3\x10\x06\n\r\n\x05\x06\0\x02}\x04\x12\x04\xd4\x10\x047\n\x10\n\x08\
    \x06\0\x02}\x04\xc3\xf3\x04\x12\x04\xd4\x10\x047\n?\n\x04\x06\0\x02~\x12\
    \x06\xe3\x10\x02\xed\x10\x03\x1a/\x20Validate\x20new\x20password\x20in\
    \x20real-time\x20for\x20a\x20user\n\n\r\n\x05\x06\0\x02~\x01\x12\x04\xe3\
    \x10\x06\x1a\n\r\n\x05\x06\0\x02~\x02\x12\x04\xe3\x10\x1c7\n\r\n\x05\x06\
    \0\x02~\x03\x12\x04\xe3\x10Bb\n\x0f\n\x05\x06\0\x02~\x04\x12\x06\xe4\x10\
    \x04\xeb\x10\x06\n\x13\n\t\x06\0\x02~\x04\xb0\xca\xbc\"\x12\x06\xe4\x10\
    \x04\xeb\x10\x06\n\r\n\x05\x06\0\x02~\x04\x12\x04\xec\x10\x04@\n\x10\n\
    \x08\x06\0\x02~\x04\xc3\xf3\x04\x12\x04\xec\x10\x04@\n,\n\x04\x06\0\x02\
    \x7f\x12\x06\x9d\x11\x02\xa7\x11\x03\x1a\x1c\x20Get\x20a\x20saved\x20leg\
    acy\x20search.\n\n\r\n\x05\x06\0\x02\x7f\x01\x12\x04\x9d\x11\x06\x0f\n\r\
    \n\x05\x06\0\x02\x7f\x02\x12\x04\x9d\x11\x11!\n\r\n\x05\x06\0\x02\x7f\
    \x03\x12\x04\x9d\x11,@\n\x0f\n\x05\x06\0\x02\x7f\x04\x12\x06\x9e\x11\x04\
    \xa3\x11\x06\n\x13\n\t\x06\0\x02\x7f\x04\xb0\xca\xbc\"\x12\x06\x9e\x11\
    \x04\xa3\x11\x06\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\xa4\x11\x047\n\x10\
    \n\x08\x06\0\x02\x7f\x04\xc3\xf3\x04\x12\x04\xa4\x11\x047\n\r\n\x05\x06\
    \0\x02\x7f\x04\x12\x04\xa5\x11\x04?\n\x11\n\t\x06\0\x02\x7f\x04\xc2\xf3\
    \x04\0\x12\x04\xa5\x11\x04?\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\xa6\x11\
    \x04F\n\x11\n\t\x06\0\x02\x7f\x04\xc2\xf3\x04\x01\x12\x04\xa6\x11\x04F\n\
    2\n\x05\x06\0\x02\x80\x01\x12\x06\xaa\x11\x02\xb4\x11\x03\x1a!\x20List\
    \x20all\x20saved\x20legacy\x20searches.\n\n\x0e\n\x06\x06\0\x02\x80\x01\
    \x01\x12\x04\xaa\x11\x06\x12\n\x0e\n\x06\x06\0\x02\x80\x01\x02\x12\x04\
    \xaa\x11\x14'\n\x0e\n\x06\x06\0\x02\x80\x01\x03\x12\x04\xaa\x112E\n\x10\
    \n\x06\x06\0\x02\x80\x01\x04\x12\x06\xab\x11\x04\xb0\x11\x06\n\x14\n\n\
    \x06\0\x02\x80\x01\x04\xb0\xca\xbc\"\x12\x06\xab\x11\x04\xb0\x11\x06\n\
    \x0e\n\x06\x06\0\x02\x80\x01\x04\x12\x04\xb1\x11\x047\n\x11\n\t\x06\0\
    \x02\x80\x01\x04\xc3\xf3\x04\x12\x04\xb1\x11\x047\n\x0e\n\x06\x06\0\x02\
    \x80\x01\x04\x12\x04\xb2\x11\x04?\n\x12\n\n\x06\0\x02\x80\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xb2\x11\x04?\n\x0e\n\x06\x06\0\x02\x80\x01\x04\x12\
    \x04\xb3\x11\x04F\n\x12\n\n\x06\0\x02\x80\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xb3\x11\x04F\n6\n\x05\x06\0\x02\x81\x01\x12\x06\xb7\x11\x02\xc4\x11\
    \x03\x1a%\x20Patch\x20saved\x20legacy\x20searches\x20by\x20ids.\n\n\x0e\
    \n\x06\x06\0\x02\x81\x01\x01\x12\x04\xb7\x11\x06\x13\n\x0e\n\x06\x06\0\
    \x02\x81\x01\x02\x12\x04\xb7\x11\x15)\n\x0e\n\x06\x06\0\x02\x81\x01\x03\
    \x12\x04\xb7\x114G\n\x10\n\x06\x06\0\x02\x81\x01\x04\x12\x06\xb8\x11\x04\
    \xbf\x11\x06\n\x14\n\n\x06\0\x02\x81\x01\x04\xb0\xca\xbc\"\x12\x06\xb8\
    \x11\x04\xbf\x11\x06\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc0\x11\
    \x047\n\x11\n\t\x06\0\x02\x81\x01\x04\xc3\xf3\x04\x12\x04\xc0\x11\x047\n\
    \x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc1\x11\x04?\n\x12\n\n\x06\0\
    \x02\x81\x01\x04\xc2\xf3\x04\0\x12\x04\xc1\x11\x04?\n\x0e\n\x06\x06\0\
    \x02\x81\x01\x04\x12\x04\xc2\x11\x04F\n\x12\n\n\x06\0\x02\x81\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\xc2\x11\x04F\n\x0e\n\x06\x06\0\x02\x81\x01\x04\
    \x12\x04\xc3\x11\x04F\n\x12\n\n\x06\0\x02\x81\x01\x04\xc2\xf3\x04\x02\
    \x12\x04\xc3\x11\x04F\n\x88\x01\n\x05\x06\0\x02\x82\x01\x12\x06\xc9\x11\
    \x02\xdc\x11\x03\x1aw\x20Execute\x20a\x20new\x20search\x20and\x20optiona\
    lly\x20save\x20it.\n\n\x20Deprecated:\x20Use\x20PostInputsSearches\x20or\
    \x20PostAnnotationsSearches\x20instead.\n\n\x0e\n\x06\x06\0\x02\x82\x01\
    \x01\x12\x04\xc9\x11\x06\x12\n\x0e\n\x06\x06\0\x02\x82\x01\x02\x12\x04\
    \xc9\x11\x14'\n\x0e\n\x06\x06\0\x02\x82\x01\x03\x12\x04\xc9\x112E\n\x10\
    \n\x06\x06\0\x02\x82\x01\x04\x12\x06\xca\x11\x04\xd1\x11\x06\n\x14\n\n\
    \x06\0\x02\x82\x01\x04\xb0\xca\xbc\"\x12\x06\xca\x11\x04\xd1\x11\x06\n\
    \x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xd2\x11\x047\n\x11\n\t\x06\0\
    \x02\x82\x01\x04\xc3\xf3\x04\x12\x04\xd2\x11\x047\n\x0e\n\x06\x06\0\x02\
    \x82\x01\x04\x12\x04\xd3\x11\x04?\n\x12\n\n\x06\0\x02\x82\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xd3\x11\x04?\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\
    \x04\xd4\x11\x04F\n\x12\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xd4\x11\x04F\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xd5\x11\x04C\
    \n\x12\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\x02\x12\x04\xd5\x11\x04C\n\
    \x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xd6\x11\x04A\n\x12\n\n\x06\0\
    \x02\x82\x01\x04\xc2\xf3\x04\x03\x12\x04\xd6\x11\x04A\n\x0e\n\x06\x06\0\
    \x02\x82\x01\x04\x12\x04\xd7\x11\x04A\n\x12\n\n\x06\0\x02\x82\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xd7\x11\x04A\n\x0e\n\x06\x06\0\x02\x82\x01\x04\
    \x12\x04\xd9\x11\x04=\n\\\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\x05\x12\
    \x04\xd9\x11\x04=\x1aH\x20option\x20(clarifai.auth.util.cl_depending_sco\
    pes)\x20=\x20Predict;\x20//\x20optional\n\n\x0e\n\x06\x06\0\x02\x82\x01\
    \x04\x12\x04\xda\x11\x04D\nO\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\xda\x11\x04D\";\x20to\x20know\x20the\x20concepts\x20and\x20mode\
    ls\x20in\x20your\x20default\x20workflow.\n\n\x0e\n\x06\x06\0\x02\x82\x01\
    \x04\x12\x04\xdb\x11\x04\x1d\n\x0f\n\x07\x06\0\x02\x82\x01\x04!\x12\x04\
    \xdb\x11\x04\x1d\n<\n\x05\x06\0\x02\x83\x01\x12\x06\xdf\x11\x02\xec\x11\
    \x03\x1a+\x20Execute\x20a\x20previously\x20saved\x20legacy\x20search.\n\
    \n\x0e\n\x06\x06\0\x02\x83\x01\x01\x12\x04\xdf\x11\x06\x16\n\x0e\n\x06\
    \x06\0\x02\x83\x01\x02\x12\x04\xdf\x11\x18/\n\x0e\n\x06\x06\0\x02\x83\
    \x01\x03\x12\x04\xdf\x11:M\n\x10\n\x06\x06\0\x02\x83\x01\x04\x12\x06\xe0\
    \x11\x04\xe7\x11\x06\n\x14\n\n\x06\0\x02\x83\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xe0\x11\x04\xe7\x11\x06\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\
    \xe8\x11\x047\n\x11\n\t\x06\0\x02\x83\x01\x04\xc3\xf3\x04\x12\x04\xe8\
    \x11\x047\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\xe9\x11\x04?\n\x12\n\
    \n\x06\0\x02\x83\x01\x04\xc2\xf3\x04\0\x12\x04\xe9\x11\x04?\n\x0e\n\x06\
    \x06\0\x02\x83\x01\x04\x12\x04\xea\x11\x04F\n\x12\n\n\x06\0\x02\x83\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xea\x11\x04F\n\x0e\n\x06\x06\0\x02\x83\x01\
    \x04\x12\x04\xeb\x11\x04=\n\x12\n\n\x06\0\x02\x83\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xeb\x11\x04=\n>\n\x05\x06\0\x02\x84\x01\x12\x06\xef\x11\x02\
    \x81\x12\x03\x1a-\x20Evaluate\x20the\x20results\x20of\x20two\x20search\
    \x20requests\n\n\x0e\n\x06\x06\0\x02\x84\x01\x01\x12\x04\xef\x11\x06!\n\
    \x0e\n\x06\x06\0\x02\x84\x01\x02\x12\x04\xef\x11\"D\n\x0e\n\x06\x06\0\
    \x02\x84\x01\x03\x12\x04\xef\x11Os\n\x10\n\x06\x06\0\x02\x84\x01\x04\x12\
    \x06\xf0\x11\x04\xf7\x11\x06\n\x14\n\n\x06\0\x02\x84\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xf0\x11\x04\xf7\x11\x06\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\
    \x04\xf8\x11\x047\n\x11\n\t\x06\0\x02\x84\x01\x04\xc3\xf3\x04\x12\x04\
    \xf8\x11\x047\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\xf9\x11\x04?\n\
    \x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\0\x12\x04\xf9\x11\x04?\n\x0e\
    \n\x06\x06\0\x02\x84\x01\x04\x12\x04\xfa\x11\x04F\n\x12\n\n\x06\0\x02\
    \x84\x01\x04\xc2\xf3\x04\x01\x12\x04\xfa\x11\x04F\n\x0e\n\x06\x06\0\x02\
    \x84\x01\x04\x12\x04\xfb\x11\x04C\n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xfb\x11\x04C\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\
    \x04\xfc\x11\x04A\n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xfc\x11\x04A\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\xfd\x11\x04B\
    \n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\x04\x12\x04\xfd\x11\x04B\n\
    \x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\xfe\x11\x04B\n\x12\n\n\x06\0\
    \x02\x84\x01\x04\xc2\xf3\x04\x05\x12\x04\xfe\x11\x04B\n\x0e\n\x06\x06\0\
    \x02\x84\x01\x04\x12\x04\xff\x11\x04A\n\x12\n\n\x06\0\x02\x84\x01\x04\
    \xc2\xf3\x04\x06\x12\x04\xff\x11\x04A\n\x0e\n\x06\x06\0\x02\x84\x01\x04\
    \x12\x04\x80\x12\x04D\nQ\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\x07\x12\
    \x04\x80\x12\x04D\"=\x20as\x20it\x20needs\x20to\x20know\x20the\x20concep\
    ts\x20in\x20your\x20workflow's\x20models.\n\nI\n\x05\x06\0\x02\x85\x01\
    \x12\x06\x84\x12\x02\x91\x12\x03\x1a8\x20Get\x20the\x20evaluation\x20res\
    ults\x20between\x20two\x20search\x20requests\n\n\x0e\n\x06\x06\0\x02\x85\
    \x01\x01\x12\x04\x84\x12\x06\x20\n\x0e\n\x06\x06\0\x02\x85\x01\x02\x12\
    \x04\x84\x12!B\n\x0e\n\x06\x06\0\x02\x85\x01\x03\x12\x04\x84\x12Mq\n\x10\
    \n\x06\x06\0\x02\x85\x01\x04\x12\x06\x85\x12\x04\x8a\x12\x06\n\x14\n\n\
    \x06\0\x02\x85\x01\x04\xb0\xca\xbc\"\x12\x06\x85\x12\x04\x8a\x12\x06\n\
    \x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8b\x12\x047\n\x11\n\t\x06\0\
    \x02\x85\x01\x04\xc3\xf3\x04\x12\x04\x8b\x12\x047\n\x0e\n\x06\x06\0\x02\
    \x85\x01\x04\x12\x04\x8c\x12\x04?\n\x12\n\n\x06\0\x02\x85\x01\x04\xc2\
    \xf3\x04\0\x12\x04\x8c\x12\x04?\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\
    \x04\x8d\x12\x04F\n\x12\n\n\x06\0\x02\x85\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\x8d\x12\x04F\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8e\x12\x04C\
    \n\x12\n\n\x06\0\x02\x85\x01\x04\xc2\xf3\x04\x02\x12\x04\x8e\x12\x04C\n\
    \x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8f\x12\x04A\n\x12\n\n\x06\0\
    \x02\x85\x01\x04\xc2\xf3\x04\x03\x12\x04\x8f\x12\x04A\n\x0e\n\x06\x06\0\
    \x02\x85\x01\x04\x12\x04\x90\x12\x04B\n\x12\n\n\x06\0\x02\x85\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\x90\x12\x04B\nJ\n\x05\x06\0\x02\x86\x01\x12\x06\
    \x96\x12\x02\xa3\x12\x03\x1a9\x20List\x20the\x20evaluation\x20results\
    \x20between\x20two\x20search\x20requests\n\n\x0e\n\x06\x06\0\x02\x86\x01\
    \x01\x12\x04\x96\x12\x06!\n\x0e\n\x06\x06\0\x02\x86\x01\x02\x12\x04\x96\
    \x12\"D\n\x0e\n\x06\x06\0\x02\x86\x01\x03\x12\x04\x96\x12Os\n\x10\n\x06\
    \x06\0\x02\x86\x01\x04\x12\x06\x97\x12\x04\x9c\x12\x06\n\x14\n\n\x06\0\
    \x02\x86\x01\x04\xb0\xca\xbc\"\x12\x06\x97\x12\x04\x9c\x12\x06\n\x0e\n\
    \x06\x06\0\x02\x86\x01\x04\x12\x04\x9d\x12\x047\n\x11\n\t\x06\0\x02\x86\
    \x01\x04\xc3\xf3\x04\x12\x04\x9d\x12\x047\n\x0e\n\x06\x06\0\x02\x86\x01\
    \x04\x12\x04\x9e\x12\x04?\n\x12\n\n\x06\0\x02\x86\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x9e\x12\x04?\n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\x04\x9f\x12\
    \x04F\n\x12\n\n\x06\0\x02\x86\x01\x04\xc2\xf3\x04\x01\x12\x04\x9f\x12\
    \x04F\n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\x04\xa0\x12\x04C\n\x12\n\n\
    \x06\0\x02\x86\x01\x04\xc2\xf3\x04\x02\x12\x04\xa0\x12\x04C\n\x0e\n\x06\
    \x06\0\x02\x86\x01\x04\x12\x04\xa1\x12\x04A\n\x12\n\n\x06\0\x02\x86\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\xa1\x12\x04A\n\x0e\n\x06\x06\0\x02\x86\x01\
    \x04\x12\x04\xa2\x12\x04B\n\x12\n\n\x06\0\x02\x86\x01\x04\xc2\xf3\x04\
    \x04\x12\x04\xa2\x12\x04B\n0\n\x05\x06\0\x02\x87\x01\x12\x06\xa6\x12\x02\
    \xb2\x12\x03\x1a\x1f\x20DeleteAnnotationSearchMetrics\n\n\x0e\n\x06\x06\
    \0\x02\x87\x01\x01\x12\x04\xa6\x12\x06#\n\x0e\n\x06\x06\0\x02\x87\x01\
    \x02\x12\x04\xa6\x12%I\n\x0e\n\x06\x06\0\x02\x87\x01\x03\x12\x04\xa6\x12\
    Tt\n\x10\n\x06\x06\0\x02\x87\x01\x04\x12\x06\xa7\x12\x04\xac\x12\x06\n\
    \x14\n\n\x06\0\x02\x87\x01\x04\xb0\xca\xbc\"\x12\x06\xa7\x12\x04\xac\x12\
    \x06\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xad\x12\x047\n\x11\n\t\
    \x06\0\x02\x87\x01\x04\xc3\xf3\x04\x12\x04\xad\x12\x047\n\x0e\n\x06\x06\
    \0\x02\x87\x01\x04\x12\x04\xae\x12\x04?\n\x12\n\n\x06\0\x02\x87\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xae\x12\x04?\n\x0e\n\x06\x06\0\x02\x87\x01\x04\
    \x12\x04\xaf\x12\x04B\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xaf\x12\x04B\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xb0\x12\
    \x04B\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\x02\x12\x04\xb0\x12\
    \x04B\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xb1\x12\x04E\n\x12\n\n\
    \x06\0\x02\x87\x01\x04\xc2\xf3\x04\x03\x12\x04\xb1\x12\x04E\n)\n\x05\x06\
    \0\x02\x88\x01\x12\x06\xb5\x12\x02\xc1\x12\x03\x1a\x18\x20Delete\x20a\
    \x20saved\x20search.\n\n\x0e\n\x06\x06\0\x02\x88\x01\x01\x12\x04\xb5\x12\
    \x06\x12\n\x0e\n\x06\x06\0\x02\x88\x01\x02\x12\x04\xb5\x12\x14'\n\x0e\n\
    \x06\x06\0\x02\x88\x01\x03\x12\x04\xb5\x122R\n\x10\n\x06\x06\0\x02\x88\
    \x01\x04\x12\x06\xb6\x12\x04\xbb\x12\x06\n\x14\n\n\x06\0\x02\x88\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xb6\x12\x04\xbb\x12\x06\n\x0e\n\x06\x06\0\x02\x88\
    \x01\x04\x12\x04\xbc\x12\x047\n\x11\n\t\x06\0\x02\x88\x01\x04\xc3\xf3\
    \x04\x12\x04\xbc\x12\x047\n\x0e\n\x06\x06\0\x02\x88\x01\x04\x12\x04\xbd\
    \x12\x04?\n\x12\n\n\x06\0\x02\x88\x01\x04\xc2\xf3\x04\0\x12\x04\xbd\x12\
    \x04?\n\x0e\n\x06\x06\0\x02\x88\x01\x04\x12\x04\xbe\x12\x04F\n\x12\n\n\
    \x06\0\x02\x88\x01\x04\xc2\xf3\x04\x01\x12\x04\xbe\x12\x04F\n\x0e\n\x06\
    \x06\0\x02\x88\x01\x04\x12\x04\xbf\x12\x04F\n\x12\n\n\x06\0\x02\x88\x01\
    \x04\xc2\xf3\x04\x02\x12\x04\xbf\x12\x04F\n\x0e\n\x06\x06\0\x02\x88\x01\
    \x04\x12\x04\xc0\x12\x04I\n\x12\n\n\x06\0\x02\x88\x01\x04\xc2\xf3\x04\
    \x03\x12\x04\xc0\x12\x04I\n3\n\x05\x06\0\x02\x89\x01\x12\x06\xc5\x12\x02\
    \xcf\x12\x03\x1a\"\x20List\x20all\x20the\x20annotation\x20filters.\n\n\
    \x0e\n\x06\x06\0\x02\x89\x01\x01\x12\x04\xc5\x12\x06\x1b\n\x0e\n\x06\x06\
    \0\x02\x89\x01\x02\x12\x04\xc5\x12\x1d9\n\x0e\n\x06\x06\0\x02\x89\x01\
    \x03\x12\x04\xc5\x12Da\n\x10\n\x06\x06\0\x02\x89\x01\x04\x12\x06\xc6\x12\
    \x04\xcb\x12\x06\n\x14\n\n\x06\0\x02\x89\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xc6\x12\x04\xcb\x12\x06\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xcc\
    \x12\x047\n\x11\n\t\x06\0\x02\x89\x01\x04\xc3\xf3\x04\x12\x04\xcc\x12\
    \x047\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xcd\x12\x04?\n\x12\n\n\
    \x06\0\x02\x89\x01\x04\xc2\xf3\x04\0\x12\x04\xcd\x12\x04?\n\x0e\n\x06\
    \x06\0\x02\x89\x01\x04\x12\x04\xce\x12\x04F\n\x12\n\n\x06\0\x02\x89\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xce\x12\x04F\n4\n\x05\x06\0\x02\x8a\x01\x12\
    \x06\xd2\x12\x02\xdc\x12\x03\x1a#\x20Get\x20a\x20specific\x20annotation\
    \x20filter.\n\n\x0e\n\x06\x06\0\x02\x8a\x01\x01\x12\x04\xd2\x12\x06\x19\
    \n\x0e\n\x06\x06\0\x02\x8a\x01\x02\x12\x04\xd2\x12\x1b5\n\x0e\n\x06\x06\
    \0\x02\x8a\x01\x03\x12\x04\xd2\x12@^\n\x10\n\x06\x06\0\x02\x8a\x01\x04\
    \x12\x06\xd3\x12\x04\xd8\x12\x06\n\x14\n\n\x06\0\x02\x8a\x01\x04\xb0\xca\
    \xbc\"\x12\x06\xd3\x12\x04\xd8\x12\x06\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\
    \x12\x04\xd9\x12\x047\n\x11\n\t\x06\0\x02\x8a\x01\x04\xc3\xf3\x04\x12\
    \x04\xd9\x12\x047\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\x04\xda\x12\x04?\
    \n\x12\n\n\x06\0\x02\x8a\x01\x04\xc2\xf3\x04\0\x12\x04\xda\x12\x04?\n\
    \x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\x04\xdb\x12\x04F\n\x12\n\n\x06\0\
    \x02\x8a\x01\x04\xc2\xf3\x04\x01\x12\x04\xdb\x12\x04F\n*\n\x05\x06\0\x02\
    \x8b\x01\x12\x06\xdf\x12\x02\xec\x12\x03\x1a\x19\x20Add\x20annotation\
    \x20filters.\n\n\x0e\n\x06\x06\0\x02\x8b\x01\x01\x12\x04\xdf\x12\x06\x1b\
    \n\x0e\n\x06\x06\0\x02\x8b\x01\x02\x12\x04\xdf\x12\x1d9\n\x0e\n\x06\x06\
    \0\x02\x8b\x01\x03\x12\x04\xdf\x12Da\n\x10\n\x06\x06\0\x02\x8b\x01\x04\
    \x12\x06\xe0\x12\x04\xe7\x12\x06\n\x14\n\n\x06\0\x02\x8b\x01\x04\xb0\xca\
    \xbc\"\x12\x06\xe0\x12\x04\xe7\x12\x06\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\
    \x12\x04\xe8\x12\x047\n\x11\n\t\x06\0\x02\x8b\x01\x04\xc3\xf3\x04\x12\
    \x04\xe8\x12\x047\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\xe9\x12\x04?\
    \n\x12\n\n\x06\0\x02\x8b\x01\x04\xc2\xf3\x04\0\x12\x04\xe9\x12\x04?\n\
    \x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\xea\x12\x04F\n\x12\n\n\x06\0\
    \x02\x8b\x01\x04\xc2\xf3\x04\x01\x12\x04\xea\x12\x04F\n\x0e\n\x06\x06\0\
    \x02\x8b\x01\x04\x12\x04\xeb\x12\x04F\n\x12\n\n\x06\0\x02\x8b\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xeb\x12\x04F\n8\n\x05\x06\0\x02\x8c\x01\x12\x06\
    \xef\x12\x02\xfc\x12\x03\x1a'\x20Patch\x20one\x20or\x20more\x20annotatio\
    n\x20filters.\n\n\x0e\n\x06\x06\0\x02\x8c\x01\x01\x12\x04\xef\x12\x06\
    \x1c\n\x0e\n\x06\x06\0\x02\x8c\x01\x02\x12\x04\xef\x12\x1e;\n\x0e\n\x06\
    \x06\0\x02\x8c\x01\x03\x12\x04\xef\x12Fc\n\x10\n\x06\x06\0\x02\x8c\x01\
    \x04\x12\x06\xf0\x12\x04\xf7\x12\x06\n\x14\n\n\x06\0\x02\x8c\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xf0\x12\x04\xf7\x12\x06\n\x0e\n\x06\x06\0\x02\x8c\x01\
    \x04\x12\x04\xf8\x12\x047\n\x11\n\t\x06\0\x02\x8c\x01\x04\xc3\xf3\x04\
    \x12\x04\xf8\x12\x047\n\x0e\n\x06\x06\0\x02\x8c\x01\x04\x12\x04\xf9\x12\
    \x04?\n\x12\n\n\x06\0\x02\x8c\x01\x04\xc2\xf3\x04\0\x12\x04\xf9\x12\x04?\
    \n\x0e\n\x06\x06\0\x02\x8c\x01\x04\x12\x04\xfa\x12\x04F\n\x12\n\n\x06\0\
    \x02\x8c\x01\x04\xc2\xf3\x04\x01\x12\x04\xfa\x12\x04F\n\x0e\n\x06\x06\0\
    \x02\x8c\x01\x04\x12\x04\xfb\x12\x04F\n\x12\n\n\x06\0\x02\x8c\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xfb\x12\x04F\nM\n\x05\x06\0\x02\x8d\x01\x12\x06\
    \xff\x12\x02\x8c\x13\x03\x1a<\x20Delete\x20one\x20or\x20more\x20annotati\
    on\x20filters\x20in\x20a\x20single\x20request.\n\n\x0e\n\x06\x06\0\x02\
    \x8d\x01\x01\x12\x04\xff\x12\x06\x1d\n\x0e\n\x06\x06\0\x02\x8d\x01\x02\
    \x12\x04\xff\x12\x1f=\n\x0e\n\x06\x06\0\x02\x8d\x01\x03\x12\x04\xff\x12H\
    h\n\x10\n\x06\x06\0\x02\x8d\x01\x04\x12\x06\x80\x13\x04\x87\x13\x06\n\
    \x14\n\n\x06\0\x02\x8d\x01\x04\xb0\xca\xbc\"\x12\x06\x80\x13\x04\x87\x13\
    \x06\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\x12\x04\x88\x13\x047\n\x11\n\t\
    \x06\0\x02\x8d\x01\x04\xc3\xf3\x04\x12\x04\x88\x13\x047\n\x0e\n\x06\x06\
    \0\x02\x8d\x01\x04\x12\x04\x89\x13\x04?\n\x12\n\n\x06\0\x02\x8d\x01\x04\
    \xc2\xf3\x04\0\x12\x04\x89\x13\x04?\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\
    \x12\x04\x8a\x13\x04F\n\x12\n\n\x06\0\x02\x8d\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\x8a\x13\x04F\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\x12\x04\x8b\x13\
    \x04F\n\x12\n\n\x06\0\x02\x8d\x01\x04\xc2\xf3\x04\x02\x12\x04\x8b\x13\
    \x04F\n)\n\x05\x06\0\x02\x8e\x01\x12\x06\xad\x13\x02\xb2\x13\x03\x1a\x18\
    \x20List\x20all\x20status\x20codes.\n\n\x0e\n\x06\x06\0\x02\x8e\x01\x01\
    \x12\x04\xad\x13\x06\x15\n\x0e\n\x06\x06\0\x02\x8e\x01\x02\x12\x04\xad\
    \x13\x17-\n\x0e\n\x06\x06\0\x02\x8e\x01\x03\x12\x04\xad\x138O\n\x10\n\
    \x06\x06\0\x02\x8e\x01\x04\x12\x06\xae\x13\x04\xb0\x13\x06\n\x14\n\n\x06\
    \0\x02\x8e\x01\x04\xb0\xca\xbc\"\x12\x06\xae\x13\x04\xb0\x13\x06\n\x0e\n\
    \x06\x06\0\x02\x8e\x01\x04\x12\x04\xb1\x13\x046\n\x11\n\t\x06\0\x02\x8e\
    \x01\x04\xc3\xf3\x04\x12\x04\xb1\x13\x046\n6\n\x05\x06\0\x02\x8f\x01\x12\
    \x06\xb5\x13\x02\xba\x13\x03\x1a%\x20Get\x20more\x20details\x20for\x20a\
    \x20status\x20code.\n\n\x0e\n\x06\x06\0\x02\x8f\x01\x01\x12\x04\xb5\x13\
    \x06\x13\n\x0e\n\x06\x06\0\x02\x8f\x01\x02\x12\x04\xb5\x13\x15)\n\x0e\n\
    \x06\x06\0\x02\x8f\x01\x03\x12\x04\xb5\x134L\n\x10\n\x06\x06\0\x02\x8f\
    \x01\x04\x12\x06\xb6\x13\x04\xb8\x13\x06\n\x14\n\n\x06\0\x02\x8f\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xb6\x13\x04\xb8\x13\x06\n\x0e\n\x06\x06\0\x02\x8f\
    \x01\x04\x12\x04\xb9\x13\x046\n\x11\n\t\x06\0\x02\x8f\x01\x04\xc3\xf3\
    \x04\x12\x04\xb9\x13\x046\n>\n\x05\x06\0\x02\x90\x01\x12\x06\xc8\x13\x02\
    \xcf\x13\x03\x1a-\x20owner\x20list\x20users\x20who\x20the\x20app\x20is\
    \x20shared\x20with\n\n\x0e\n\x06\x06\0\x02\x90\x01\x01\x12\x04\xc8\x13\
    \x06\x17\n\x0e\n\x06\x06\0\x02\x90\x01\x02\x12\x04\xc8\x13\x191\n\x0e\n\
    \x06\x06\0\x02\x90\x01\x03\x12\x04\xc8\x13<V\n\x10\n\x06\x06\0\x02\x90\
    \x01\x04\x12\x06\xc9\x13\x04\xcb\x13\x06\n\x14\n\n\x06\0\x02\x90\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xc9\x13\x04\xcb\x13\x06\n\x0e\n\x06\x06\0\x02\x90\
    \x01\x04\x12\x04\xcc\x13\x047\n\x11\n\t\x06\0\x02\x90\x01\x04\xc3\xf3\
    \x04\x12\x04\xcc\x13\x047\n\x0e\n\x06\x06\0\x02\x90\x01\x04\x12\x04\xcd\
    \x13\x04?\n\x12\n\n\x06\0\x02\x90\x01\x04\xc2\xf3\x04\0\x12\x04\xcd\x13\
    \x04?\n\x0e\n\x06\x06\0\x02\x90\x01\x04\x12\x04\xce\x13\x04H\n\x12\n\n\
    \x06\0\x02\x90\x01\x04\xc2\xf3\x04\x01\x12\x04\xce\x13\x04H\n/\n\x05\x06\
    \0\x02\x91\x01\x12\x06\xd2\x13\x02\xdb\x13\x03\x1a\x1e\x20add\x20collabo\
    rators\x20to\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\x91\x01\x01\x12\x04\
    \xd2\x13\x06\x17\n\x0e\n\x06\x06\0\x02\x91\x01\x02\x12\x04\xd2\x13\x191\
    \n\x0e\n\x06\x06\0\x02\x91\x01\x03\x12\x04\xd2\x13<V\n\x10\n\x06\x06\0\
    \x02\x91\x01\x04\x12\x06\xd3\x13\x04\xd6\x13\x06\n\x14\n\n\x06\0\x02\x91\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xd3\x13\x04\xd6\x13\x06\n\x0e\n\x06\x06\0\
    \x02\x91\x01\x04\x12\x04\xd7\x13\x047\n\x11\n\t\x06\0\x02\x91\x01\x04\
    \xc3\xf3\x04\x12\x04\xd7\x13\x047\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\
    \x04\xd8\x13\x04?\n\x12\n\n\x06\0\x02\x91\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xd8\x13\x04?\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\x04\xd9\x13\x04H\n\
    \x12\n\n\x06\0\x02\x91\x01\x04\xc2\xf3\x04\x01\x12\x04\xd9\x13\x04H\n\
    \x0e\n\x06\x06\0\x02\x91\x01\x04\x12\x04\xda\x13\x04H\n\x12\n\n\x06\0\
    \x02\x91\x01\x04\xc2\xf3\x04\x02\x12\x04\xda\x13\x04H\n0\n\x05\x06\0\x02\
    \x92\x01\x12\x06\xde\x13\x02\xe8\x13\x03\x1a\x1f\x20Patch\x20existing\
    \x20collaborators.\n\n\x0e\n\x06\x06\0\x02\x92\x01\x01\x12\x04\xde\x13\
    \x06\x18\n\x0e\n\x06\x06\0\x02\x92\x01\x02\x12\x04\xde\x13\x1a3\n\x0e\n\
    \x06\x06\0\x02\x92\x01\x03\x12\x04\xde\x13>X\n\x10\n\x06\x06\0\x02\x92\
    \x01\x04\x12\x06\xdf\x13\x04\xe2\x13\x06\n\x14\n\n\x06\0\x02\x92\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xdf\x13\x04\xe2\x13\x06\n\x0e\n\x06\x06\0\x02\x92\
    \x01\x04\x12\x04\xe3\x13\x047\n\x11\n\t\x06\0\x02\x92\x01\x04\xc3\xf3\
    \x04\x12\x04\xe3\x13\x047\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\xe4\
    \x13\x04?\n\x12\n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\0\x12\x04\xe4\x13\
    \x04?\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\xe5\x13\x04H\n\x12\n\n\
    \x06\0\x02\x92\x01\x04\xc2\xf3\x04\x01\x12\x04\xe5\x13\x04H\n\x0e\n\x06\
    \x06\0\x02\x92\x01\x04\x12\x04\xe6\x13\x04H\n\x12\n\n\x06\0\x02\x92\x01\
    \x04\xc2\xf3\x04\x02\x12\x04\xe6\x13\x04H\n\x0e\n\x06\x06\0\x02\x92\x01\
    \x04\x12\x04\xe7\x13\x04K\n\x12\n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\
    \x03\x12\x04\xe7\x13\x04K\n1\n\x05\x06\0\x02\x93\x01\x12\x06\xeb\x13\x02\
    \xf7\x13\x03\x1a\x20\x20Delete\x20existing\x20collaborators.\n\n\x0e\n\
    \x06\x06\0\x02\x93\x01\x01\x12\x04\xeb\x13\x06\x19\n\x0e\n\x06\x06\0\x02\
    \x93\x01\x02\x12\x04\xeb\x13\x1b5\n\x0e\n\x06\x06\0\x02\x93\x01\x03\x12\
    \x04\xeb\x13@`\n\x10\n\x06\x06\0\x02\x93\x01\x04\x12\x06\xec\x13\x04\xef\
    \x13\x06\n\x14\n\n\x06\0\x02\x93\x01\x04\xb0\xca\xbc\"\x12\x06\xec\x13\
    \x04\xef\x13\x06\n\x0e\n\x06\x06\0\x02\x93\x01\x04\x12\x04\xf0\x13\x047\
    \n\x11\n\t\x06\0\x02\x93\x01\x04\xc3\xf3\x04\x12\x04\xf0\x13\x047\n\x0e\
    \n\x06\x06\0\x02\x93\x01\x04\x12\x04\xf1\x13\x04?\n\x12\n\n\x06\0\x02\
    \x93\x01\x04\xc2\xf3\x04\0\x12\x04\xf1\x13\x04?\n\x0e\n\x06\x06\0\x02\
    \x93\x01\x04\x12\x04\xf2\x13\x04H\n\x12\n\n\x06\0\x02\x93\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xf2\x13\x04H\n\x0e\n\x06\x06\0\x02\x93\x01\x04\x12\
    \x04\xf3\x13\x04H\n\x12\n\n\x06\0\x02\x93\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xf3\x13\x04H\n\x0e\n\x06\x06\0\x02\x93\x01\x04\x12\x04\xf4\x13\x04K\
    \n\x12\n\n\x06\0\x02\x93\x01\x04\xc2\xf3\x04\x03\x12\x04\xf4\x13\x04K\n\
    \x0e\n\x06\x06\0\x02\x93\x01\x04\x12\x04\xf5\x13\x04@\no\n\n\x06\0\x02\
    \x93\x01\x04\xc2\xf3\x04\x04\x12\x04\xf5\x13\x04@\"[\x20when\x20deleting\
    \x20a\x20collaborator,\x20we\x20also\x20delete\x20task\x20workers\x20ass\
    ociated\x20to\x20this\x20collaborator\n\n\x0e\n\x06\x06\0\x02\x93\x01\
    \x04\x12\x04\xf6\x13\x04@\n\x12\n\n\x06\0\x02\x93\x01\x04\xc2\xf3\x04\
    \x05\x12\x04\xf6\x13\x04@\nN\n\x05\x06\0\x02\x94\x01\x12\x06\xfa\x13\x02\
    \xff\x13\x03\x1a=\x20Collaboration\x20includes\x20the\x20app\x20user\x20\
    are\x20invitied\x20to\x20work\x20on\n\n\x0e\n\x06\x06\0\x02\x94\x01\x01\
    \x12\x04\xfa\x13\x06\x18\n\x0e\n\x06\x06\0\x02\x94\x01\x02\x12\x04\xfa\
    \x13\x1a3\n\x0e\n\x06\x06\0\x02\x94\x01\x03\x12\x04\xfa\x13>Y\n\x10\n\
    \x06\x06\0\x02\x94\x01\x04\x12\x06\xfb\x13\x04\xfd\x13\x06\n\x14\n\n\x06\
    \0\x02\x94\x01\x04\xb0\xca\xbc\"\x12\x06\xfb\x13\x04\xfd\x13\x06\n\x0e\n\
    \x06\x06\0\x02\x94\x01\x04\x12\x04\xfe\x13\x04@\n\x11\n\t\x06\0\x02\x94\
    \x01\x04\xc3\xf3\x04\x12\x04\xfe\x13\x04@\n\xe5\x05\n\x05\x06\0\x02\x95\
    \x01\x12\x06\x90\x14\x02\xa3\x14\x03\x1a\xd3\x05\x20PostAppDuplications\
    \x20starts\x20async\x20app\x20duplication\x20jobs\x20which\x20copy\x20re\
    sources\n\x20(inputs,\x20annotations,\x20models\x20etc)\x20from\x20one\
    \x20application\x20to\x20another.\x20It\x20can\n\x20also\x20create\x20th\
    e\x20destination\x20application\x20if\x20it\x20does\x20not\x20exist,\x20\
    with\x20fields\n\x20(description,\x20metadata\x20etc)\x20copied\x20from\
    \x20the\x20source\x20application.\n\n\x20A\x20duplication\x20job\x20can\
    \x20be\x20started\x20by\x20any\x20user\x20that\x20can\x20read\x20from\
    \x20the\x20source\n\x20application\x20(the\x20target\x20of\x20this\x20ca\
    ll)\x20and\x20can\x20create\x20and\x20write\x20to\x20the\n\x20destinatio\
    n\x20application.\x20The\x20duplication\x20is\x20associated\x20with\x20t\
    he\x20user\x20that\n\x20created\x20it,\x20so\x20in\x20order\x20to\x20rea\
    d\x20the\x20status\x20and\x20progress\x20of\x20the\x20job,\x20that\n\x20\
    user's\x20ID\x20has\x20to\x20be\x20used\x20in\x20the\x20call\x20to\x20Ge\
    tAppDuplication,\x20which\x20might\x20be\n\x20different\x20to\x20the\x20\
    source\x20application\x20owner\x20ID\x20in\x20this\x20call.\n\n\x0e\n\
    \x06\x06\0\x02\x95\x01\x01\x12\x04\x90\x14\x06\x19\n\x0e\n\x06\x06\0\x02\
    \x95\x01\x02\x12\x04\x90\x14\x1b5\n\x0e\n\x06\x06\0\x02\x95\x01\x03\x12\
    \x04\x90\x14@\\\n\x10\n\x06\x06\0\x02\x95\x01\x04\x12\x06\x91\x14\x04\
    \x94\x14\x06\n\x14\n\n\x06\0\x02\x95\x01\x04\xb0\xca\xbc\"\x12\x06\x91\
    \x14\x04\x94\x14\x06\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x95\x14\
    \x047\n\x11\n\t\x06\0\x02\x95\x01\x04\xc3\xf3\x04\x12\x04\x95\x14\x047\n\
    \x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x96\x14\x04?\n\x12\n\n\x06\0\
    \x02\x95\x01\x04\xc2\xf3\x04\0\x12\x04\x96\x14\x04?\n\x0e\n\x06\x06\0\
    \x02\x95\x01\x04\x12\x04\x97\x14\x04?\n\x12\n\n\x06\0\x02\x95\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\x97\x14\x04?\n\x0e\n\x06\x06\0\x02\x95\x01\x04\
    \x12\x04\x98\x14\x04A\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\x02\
    \x12\x04\x98\x14\x04A\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x99\x14\
    \x04A\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\x03\x12\x04\x99\x14\
    \x04A\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x9a\x14\x04C\n\x12\n\n\
    \x06\0\x02\x95\x01\x04\xc2\xf3\x04\x04\x12\x04\x9a\x14\x04C\n\x0e\n\x06\
    \x06\0\x02\x95\x01\x04\x12\x04\x9b\x14\x04C\n\x12\n\n\x06\0\x02\x95\x01\
    \x04\xc2\xf3\x04\x05\x12\x04\x9b\x14\x04C\n\x0e\n\x06\x06\0\x02\x95\x01\
    \x04\x12\x04\x9c\x14\x04C\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\
    \x06\x12\x04\x9c\x14\x04C\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x9d\
    \x14\x04A\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\x07\x12\x04\x9d\
    \x14\x04A\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x9e\x14\x04A\n\x12\n\
    \n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\x08\x12\x04\x9e\x14\x04A\n\x0e\n\
    \x06\x06\0\x02\x95\x01\x04\x12\x04\x9f\x14\x04F\n\x12\n\n\x06\0\x02\x95\
    \x01\x04\xc2\xf3\x04\t\x12\x04\x9f\x14\x04F\n\x0e\n\x06\x06\0\x02\x95\
    \x01\x04\x12\x04\xa0\x14\x04F\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\
    \x04\n\x12\x04\xa0\x14\x04F\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\
    \xa1\x14\x04D\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\x0b\x12\x04\
    \xa1\x14\x04D\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\xa2\x14\x04D\n\
    \x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\x04\x0c\x12\x04\xa2\x14\x04D\nZ\n\
    \x05\x06\0\x02\x96\x01\x12\x06\xa6\x14\x02\xab\x14\x03\x1aI\x20ListAppDu\
    plications\x20lists\x20all\x20app\x20duplication\x20jobs\x20created\x20b\
    y\x20the\x20user.\n\n\x0e\n\x06\x06\0\x02\x96\x01\x01\x12\x04\xa6\x14\
    \x06\x19\n\x0e\n\x06\x06\0\x02\x96\x01\x02\x12\x04\xa6\x14\x1b5\n\x0e\n\
    \x06\x06\0\x02\x96\x01\x03\x12\x04\xa6\x14@\\\n\x10\n\x06\x06\0\x02\x96\
    \x01\x04\x12\x06\xa7\x14\x04\xa9\x14\x06\n\x14\n\n\x06\0\x02\x96\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xa7\x14\x04\xa9\x14\x06\n\x0e\n\x06\x06\0\x02\x96\
    \x01\x04\x12\x04\xaa\x14\x047\n\x11\n\t\x06\0\x02\x96\x01\x04\xc3\xf3\
    \x04\x12\x04\xaa\x14\x047\nX\n\x05\x06\0\x02\x97\x01\x12\x06\xae\x14\x02\
    \xb3\x14\x03\x1aG\x20GetAppDuplication\x20returns\x20an\x20app\x20duplic\
    ation\x20job\x20created\x20by\x20the\x20user.\n\n\x0e\n\x06\x06\0\x02\
    \x97\x01\x01\x12\x04\xae\x14\x06\x17\n\x0e\n\x06\x06\0\x02\x97\x01\x02\
    \x12\x04\xae\x14\x191\n\x0e\n\x06\x06\0\x02\x97\x01\x03\x12\x04\xae\x14<\
    X\n\x10\n\x06\x06\0\x02\x97\x01\x04\x12\x06\xaf\x14\x04\xb1\x14\x06\n\
    \x14\n\n\x06\0\x02\x97\x01\x04\xb0\xca\xbc\"\x12\x06\xaf\x14\x04\xb1\x14\
    \x06\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xb2\x14\x047\n\x11\n\t\
    \x06\0\x02\x97\x01\x04\xc3\xf3\x04\x12\x04\xb2\x14\x047\n'\n\x05\x06\0\
    \x02\x98\x01\x12\x06\xb6\x14\x02\xcc\x14\x03\x1a\x16\x20Add\x20tasks\x20\
    to\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\x98\x01\x01\x12\x04\xb6\x14\x06\
    \x0f\n\x0e\n\x06\x06\0\x02\x98\x01\x02\x12\x04\xb6\x14\x11!\n\x0e\n\x06\
    \x06\0\x02\x98\x01\x03\x12\x04\xb6\x14,=\n\x10\n\x06\x06\0\x02\x98\x01\
    \x04\x12\x06\xb7\x14\x04\xbe\x14\x06\n\x14\n\n\x06\0\x02\x98\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xb7\x14\x04\xbe\x14\x06\n\x0e\n\x06\x06\0\x02\x98\x01\
    \x04\x12\x04\xbf\x14\x047\n\x11\n\t\x06\0\x02\x98\x01\x04\xc3\xf3\x04\
    \x12\x04\xbf\x14\x047\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xc0\x14\
    \x04?\n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\0\x12\x04\xc0\x14\x04?\
    \n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xc1\x14\x04@\n\x12\n\n\x06\0\
    \x02\x98\x01\x04\xc2\xf3\x04\x01\x12\x04\xc1\x14\x04@\n\x0e\n\x06\x06\0\
    \x02\x98\x01\x04\x12\x04\xc2\x14\x04@\n\x12\n\n\x06\0\x02\x98\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xc2\x14\x04@\n\x0e\n\x06\x06\0\x02\x98\x01\x04\
    \x12\x04\xc3\x14\x04A\n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\xc3\x14\x04A\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xc4\x14\
    \x04=\n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\x04\x12\x04\xc4\x14\
    \x04=\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xc5\x14\x04F\n\x12\n\n\
    \x06\0\x02\x98\x01\x04\xc2\xf3\x04\x05\x12\x04\xc5\x14\x04F\n\x0e\n\x06\
    \x06\0\x02\x98\x01\x04\x12\x04\xc6\x14\x04C\n\x12\n\n\x06\0\x02\x98\x01\
    \x04\xc2\xf3\x04\x06\x12\x04\xc6\x14\x04C\n\x0e\n\x06\x06\0\x02\x98\x01\
    \x04\x12\x04\xc7\x14\x04D\n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\
    \x07\x12\x04\xc7\x14\x04D\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xc8\
    \x14\x04A\nP\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\x08\x12\x04\xc8\x14\
    \x04A\"<\x20needed\x20for\x20converting\x20workers\x20internal\x20ids\
    \x20to\x20external\x20ids\n\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\
    \xca\x14\x04F\n\xcc\x01\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\t\x12\x04\
    \xca\x14\x04F\x1a\x91\x01\x20option\x20(clarifai.auth.util.cl_depending_\
    scopes)\x20=\x20Predict;\x20//\x20optional,\x20needed\x20for\x20add_task\
    _annotations.go\x20when\x20saved\x20search\x20uses\x20visual\x20search\n\
    \"$\x20needed\x20for\x20add_task_annotations.go\n\n\x0e\n\x06\x06\0\x02\
    \x98\x01\x04\x12\x04\xcb\x14\x04F\n8\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\
    \x04\n\x12\x04\xcb\x14\x04F\"$\x20needed\x20for\x20add_task_annotations.\
    go\n\n(\n\x05\x06\0\x02\x99\x01\x12\x06\xcf\x14\x02\xd9\x14\x03\x1a\x17\
    \x20Task\x20annotation\x20count\n\n\x0e\n\x06\x06\0\x02\x99\x01\x01\x12\
    \x04\xcf\x14\x06\x1c\n\x0e\n\x06\x06\0\x02\x99\x01\x02\x12\x04\xcf\x14\
    \x1e1\n\x0e\n\x06\x06\0\x02\x99\x01\x03\x12\x04\xcf\x14<S\n\x10\n\x06\
    \x06\0\x02\x99\x01\x04\x12\x06\xd0\x14\x04\xd5\x14\x06\n\x14\n\n\x06\0\
    \x02\x99\x01\x04\xb0\xca\xbc\"\x12\x06\xd0\x14\x04\xd5\x14\x06\n\x0e\n\
    \x06\x06\0\x02\x99\x01\x04\x12\x04\xd6\x14\x047\n\x11\n\t\x06\0\x02\x99\
    \x01\x04\xc3\xf3\x04\x12\x04\xd6\x14\x047\n\x0e\n\x06\x06\0\x02\x99\x01\
    \x04\x12\x04\xd7\x14\x04?\n\x12\n\n\x06\0\x02\x99\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xd7\x14\x04?\n\x0e\n\x06\x06\0\x02\x99\x01\x04\x12\x04\xd8\x14\
    \x04@\n\x12\n\n\x06\0\x02\x99\x01\x04\xc2\xf3\x04\x01\x12\x04\xd8\x14\
    \x04@\n#\n\x05\x06\0\x02\x9a\x01\x12\x06\xdc\x14\x02\xe6\x14\x03\x1a\x12\
    \x20Task\x20Input\x20count\n\n\x0e\n\x06\x06\0\x02\x9a\x01\x01\x12\x04\
    \xdc\x14\x06\x17\n\x0e\n\x06\x06\0\x02\x9a\x01\x02\x12\x04\xdc\x14\x19,\
    \n\x0e\n\x06\x06\0\x02\x9a\x01\x03\x12\x04\xdc\x147N\n\x10\n\x06\x06\0\
    \x02\x9a\x01\x04\x12\x06\xdd\x14\x04\xe2\x14\x06\n\x14\n\n\x06\0\x02\x9a\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xdd\x14\x04\xe2\x14\x06\n\x0e\n\x06\x06\0\
    \x02\x9a\x01\x04\x12\x04\xe3\x14\x047\n\x11\n\t\x06\0\x02\x9a\x01\x04\
    \xc3\xf3\x04\x12\x04\xe3\x14\x047\n\x0e\n\x06\x06\0\x02\x9a\x01\x04\x12\
    \x04\xe4\x14\x04?\n\x12\n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xe4\x14\x04?\n\x0e\n\x06\x06\0\x02\x9a\x01\x04\x12\x04\xe5\x14\x04@\n\
    \x12\n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\x01\x12\x04\xe5\x14\x04@\n3\n\
    \x05\x06\0\x02\x9b\x01\x12\x06\xe9\x14\x02\xf7\x14\x03\x1a\"\x20Get\x20a\
    \x20specific\x20task\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\x9b\
    \x01\x01\x12\x04\xe9\x14\x06\r\n\x0e\n\x06\x06\0\x02\x9b\x01\x02\x12\x04\
    \xe9\x14\x0f\x1d\n\x0e\n\x06\x06\0\x02\x9b\x01\x03\x12\x04\xe9\x14(:\n\
    \x10\n\x06\x06\0\x02\x9b\x01\x04\x12\x06\xea\x14\x04\xef\x14\x06\n\x14\n\
    \n\x06\0\x02\x9b\x01\x04\xb0\xca\xbc\"\x12\x06\xea\x14\x04\xef\x14\x06\n\
    \x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\xf0\x14\x047\n\x11\n\t\x06\0\
    \x02\x9b\x01\x04\xc3\xf3\x04\x12\x04\xf0\x14\x047\n\x0e\n\x06\x06\0\x02\
    \x9b\x01\x04\x12\x04\xf1\x14\x04?\n\x12\n\n\x06\0\x02\x9b\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xf1\x14\x04?\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\
    \x04\xf2\x14\x04@\n\x12\n\n\x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xf2\x14\x04@\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\xf3\x14\x04F\
    \n\x12\n\n\x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x02\x12\x04\xf3\x14\x04F\n\
    \x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\xf4\x14\x04C\n\x12\n\n\x06\0\
    \x02\x9b\x01\x04\xc2\xf3\x04\x03\x12\x04\xf4\x14\x04C\n\x0e\n\x06\x06\0\
    \x02\x9b\x01\x04\x12\x04\xf5\x14\x04D\n\x12\n\n\x06\0\x02\x9b\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xf5\x14\x04D\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\
    \x12\x04\xf6\x14\x04A\nP\n\n\x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x05\x12\
    \x04\xf6\x14\x04A\"<\x20needed\x20for\x20converting\x20workers\x20intern\
    al\x20ids\x20to\x20external\x20ids\n\n*\n\x05\x06\0\x02\x9c\x01\x12\x06\
    \xfa\x14\x02\x88\x15\x03\x1a\x19\x20List\x20tasks\x20from\x20an\x20app.\
    \n\n\x0e\n\x06\x06\0\x02\x9c\x01\x01\x12\x04\xfa\x14\x06\x0f\n\x0e\n\x06\
    \x06\0\x02\x9c\x01\x02\x12\x04\xfa\x14\x11!\n\x0e\n\x06\x06\0\x02\x9c\
    \x01\x03\x12\x04\xfa\x14,=\n\x10\n\x06\x06\0\x02\x9c\x01\x04\x12\x06\xfb\
    \x14\x04\x80\x15\x06\n\x14\n\n\x06\0\x02\x9c\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xfb\x14\x04\x80\x15\x06\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\
    \x81\x15\x047\n\x11\n\t\x06\0\x02\x9c\x01\x04\xc3\xf3\x04\x12\x04\x81\
    \x15\x047\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\x82\x15\x04?\n\x12\n\
    \n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\0\x12\x04\x82\x15\x04?\n\x0e\n\x06\
    \x06\0\x02\x9c\x01\x04\x12\x04\x83\x15\x04@\n\x12\n\n\x06\0\x02\x9c\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x83\x15\x04@\n\x0e\n\x06\x06\0\x02\x9c\x01\
    \x04\x12\x04\x84\x15\x04F\n\x12\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\x84\x15\x04F\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\x85\
    \x15\x04C\n\x12\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\x03\x12\x04\x85\
    \x15\x04C\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\x86\x15\x04D\n\x12\n\
    \n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\x04\x12\x04\x86\x15\x04D\n\x0e\n\
    \x06\x06\0\x02\x9c\x01\x04\x12\x04\x87\x15\x04A\nP\n\n\x06\0\x02\x9c\x01\
    \x04\xc2\xf3\x04\x05\x12\x04\x87\x15\x04A\"<\x20needed\x20for\x20convert\
    ing\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n+\n\x05\
    \x06\0\x02\x9d\x01\x12\x06\x8b\x15\x02\xa0\x15\x03\x1a\x1a\x20Patch\x20o\
    ne\x20or\x20more\x20tasks.\n\n\x0e\n\x06\x06\0\x02\x9d\x01\x01\x12\x04\
    \x8b\x15\x06\x10\n\x0e\n\x06\x06\0\x02\x9d\x01\x02\x12\x04\x8b\x15\x12#\
    \n\x0e\n\x06\x06\0\x02\x9d\x01\x03\x12\x04\x8b\x15.?\n\x10\n\x06\x06\0\
    \x02\x9d\x01\x04\x12\x06\x8c\x15\x04\x93\x15\x06\n\x14\n\n\x06\0\x02\x9d\
    \x01\x04\xb0\xca\xbc\"\x12\x06\x8c\x15\x04\x93\x15\x06\n\x0e\n\x06\x06\0\
    \x02\x9d\x01\x04\x12\x04\x94\x15\x047\n\x11\n\t\x06\0\x02\x9d\x01\x04\
    \xc3\xf3\x04\x12\x04\x94\x15\x047\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\
    \x04\x95\x15\x04?\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\0\x12\x04\
    \x95\x15\x04?\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x96\x15\x04@\n\
    \x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x01\x12\x04\x96\x15\x04@\n\
    \x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x97\x15\x04@\n\x12\n\n\x06\0\
    \x02\x9d\x01\x04\xc2\xf3\x04\x02\x12\x04\x97\x15\x04@\n\x0e\n\x06\x06\0\
    \x02\x9d\x01\x04\x12\x04\x98\x15\x04A\n\x12\n\n\x06\0\x02\x9d\x01\x04\
    \xc2\xf3\x04\x03\x12\x04\x98\x15\x04A\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\
    \x12\x04\x99\x15\x04F\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x04\
    \x12\x04\x99\x15\x04F\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x9a\x15\
    \x04C\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x05\x12\x04\x9a\x15\
    \x04C\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x9b\x15\x04D\n\x12\n\n\
    \x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x06\x12\x04\x9b\x15\x04D\n\x0e\n\x06\
    \x06\0\x02\x9d\x01\x04\x12\x04\x9c\x15\x04A\nP\n\n\x06\0\x02\x9d\x01\x04\
    \xc2\xf3\x04\x07\x12\x04\x9c\x15\x04A\"<\x20needed\x20for\x20converting\
    \x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n\x0e\n\x06\
    \x06\0\x02\x9d\x01\x04\x12\x04\x9e\x15\x04F\n\xcc\x01\n\n\x06\0\x02\x9d\
    \x01\x04\xc2\xf3\x04\x08\x12\x04\x9e\x15\x04F\x1a\x91\x01\x20option\x20(\
    clarifai.auth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20option\
    al,\x20needed\x20for\x20add_task_annotations.go\x20when\x20saved\x20sear\
    ch\x20uses\x20visual\x20search\n\"$\x20needed\x20for\x20add_task_annotat\
    ions.go\n\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x9f\x15\x04F\n8\n\n\
    \x06\0\x02\x9d\x01\x04\xc2\xf3\x04\t\x12\x04\x9f\x15\x04F\"$\x20needed\
    \x20for\x20add_task_annotations.go\n\n8\n\x05\x06\0\x02\x9e\x01\x12\x06\
    \xa3\x15\x02\xb1\x15\x03\x1a'\x20Delete\x20multiple\x20tasks\x20in\x20on\
    e\x20request.\n\n\x0e\n\x06\x06\0\x02\x9e\x01\x01\x12\x04\xa3\x15\x06\
    \x11\n\x0e\n\x06\x06\0\x02\x9e\x01\x02\x12\x04\xa3\x15\x13%\n\x0e\n\x06\
    \x06\0\x02\x9e\x01\x03\x12\x04\xa3\x150P\n\x10\n\x06\x06\0\x02\x9e\x01\
    \x04\x12\x06\xa4\x15\x04\xab\x15\x06\n\x14\n\n\x06\0\x02\x9e\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xa4\x15\x04\xab\x15\x06\n\x0e\n\x06\x06\0\x02\x9e\x01\
    \x04\x12\x04\xac\x15\x047\n\x11\n\t\x06\0\x02\x9e\x01\x04\xc3\xf3\x04\
    \x12\x04\xac\x15\x047\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xad\x15\
    \x04?\n\x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\0\x12\x04\xad\x15\x04?\
    \n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xae\x15\x04@\n\x12\n\n\x06\0\
    \x02\x9e\x01\x04\xc2\xf3\x04\x01\x12\x04\xae\x15\x04@\n\x0e\n\x06\x06\0\
    \x02\x9e\x01\x04\x12\x04\xaf\x15\x04@\n\x12\n\n\x06\0\x02\x9e\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xaf\x15\x04@\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\
    \x12\x04\xb0\x15\x04C\n\x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\xb0\x15\x04C\n\x81\x01\n\x05\x06\0\x02\x9f\x01\x12\x06\xba\x15\
    \x02\xcf\x15\x03\x1a\x13\x20Add\x20Label\x20orders.\n2[/////////////////\
    /////////////////////\n\x20Label\x20Order\n/////////////////////////////\
    /////////\n\n\x0e\n\x06\x06\0\x02\x9f\x01\x01\x12\x04\xba\x15\x06\x15\n\
    \x0e\n\x06\x06\0\x02\x9f\x01\x02\x12\x04\xba\x15\x17-\n\x0e\n\x06\x06\0\
    \x02\x9f\x01\x03\x12\x04\xba\x158O\n\x10\n\x06\x06\0\x02\x9f\x01\x04\x12\
    \x06\xbb\x15\x04\xc2\x15\x06\n\x14\n\n\x06\0\x02\x9f\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xbb\x15\x04\xc2\x15\x06\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\
    \x04\xc4\x15\x047\n\x11\n\t\x06\0\x02\x9f\x01\x04\xc3\xf3\x04\x12\x04\
    \xc4\x15\x047\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xc5\x15\x04?\n\
    \x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\0\x12\x04\xc5\x15\x04?\n\x0e\
    \n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xc6\x15\x04F\n\x12\n\n\x06\0\x02\
    \x9f\x01\x04\xc2\xf3\x04\x01\x12\x04\xc6\x15\x04F\n\x0e\n\x06\x06\0\x02\
    \x9f\x01\x04\x12\x04\xc7\x15\x04F\n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xc7\x15\x04F\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\
    \x04\xc8\x15\x04@\n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xc8\x15\x04@\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xc9\x15\x04@\
    \n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\x04\x12\x04\xc9\x15\x04@\n\
    \x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xca\x15\x04A\n\x12\n\n\x06\0\
    \x02\x9f\x01\x04\xc2\xf3\x04\x05\x12\x04\xca\x15\x04A\n\x0e\n\x06\x06\0\
    \x02\x9f\x01\x04\x12\x04\xcb\x15\x04F\n\x12\n\n\x06\0\x02\x9f\x01\x04\
    \xc2\xf3\x04\x06\x12\x04\xcb\x15\x04F\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\
    \x12\x04\xcc\x15\x04C\n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\x07\
    \x12\x04\xcc\x15\x04C\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xcd\x15\
    \x04D\n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\x08\x12\x04\xcd\x15\
    \x04D\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xce\x15\x04A\nP\n\n\x06\
    \0\x02\x9f\x01\x04\xc2\xf3\x04\t\x12\x04\xce\x15\x04A\"<\x20needed\x20fo\
    r\x20converting\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\
    \n%\n\x05\x06\0\x02\xa0\x01\x12\x06\xd2\x15\x02\xdf\x15\x03\x1a\x14\x20G\
    et\x20a\x20label\x20order.\n\n\x0e\n\x06\x06\0\x02\xa0\x01\x01\x12\x04\
    \xd2\x15\x06\x13\n\x0e\n\x06\x06\0\x02\xa0\x01\x02\x12\x04\xd2\x15\x15)\
    \n\x0e\n\x06\x06\0\x02\xa0\x01\x03\x12\x04\xd2\x154L\n\x10\n\x06\x06\0\
    \x02\xa0\x01\x04\x12\x06\xd3\x15\x04\xd8\x15\x06\n\x14\n\n\x06\0\x02\xa0\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xd3\x15\x04\xd8\x15\x06\n\x0e\n\x06\x06\0\
    \x02\xa0\x01\x04\x12\x04\xda\x15\x047\n\x11\n\t\x06\0\x02\xa0\x01\x04\
    \xc3\xf3\x04\x12\x04\xda\x15\x047\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\
    \x04\xdb\x15\x04?\n\x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xdb\x15\x04?\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xdc\x15\x04F\n\
    \x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\x01\x12\x04\xdc\x15\x04F\n\
    \x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xdd\x15\x04C\n\x12\n\n\x06\0\
    \x02\xa0\x01\x04\xc2\xf3\x04\x02\x12\x04\xdd\x15\x04C\n\x0e\n\x06\x06\0\
    \x02\xa0\x01\x04\x12\x04\xde\x15\x04@\n5\n\n\x06\0\x02\xa0\x01\x04\xc2\
    \xf3\x04\x03\x12\x04\xde\x15\x04@\"!\x20needed\x20because\x20task\x20is\
    \x20embedded\n\n%\n\x05\x06\0\x02\xa1\x01\x12\x06\xe2\x15\x02\xef\x15\
    \x03\x1a\x14\x20List\x20label\x20orders.\n\n\x0e\n\x06\x06\0\x02\xa1\x01\
    \x01\x12\x04\xe2\x15\x06\x15\n\x0e\n\x06\x06\0\x02\xa1\x01\x02\x12\x04\
    \xe2\x15\x17-\n\x0e\n\x06\x06\0\x02\xa1\x01\x03\x12\x04\xe2\x158O\n\x10\
    \n\x06\x06\0\x02\xa1\x01\x04\x12\x06\xe3\x15\x04\xe8\x15\x06\n\x14\n\n\
    \x06\0\x02\xa1\x01\x04\xb0\xca\xbc\"\x12\x06\xe3\x15\x04\xe8\x15\x06\n\
    \x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xea\x15\x047\n\x11\n\t\x06\0\
    \x02\xa1\x01\x04\xc3\xf3\x04\x12\x04\xea\x15\x047\n\x0e\n\x06\x06\0\x02\
    \xa1\x01\x04\x12\x04\xeb\x15\x04?\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xeb\x15\x04?\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\
    \x04\xec\x15\x04F\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xec\x15\x04F\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xed\x15\x04C\
    \n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x02\x12\x04\xed\x15\x04C\n\
    \x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xee\x15\x04@\n5\n\n\x06\0\x02\
    \xa1\x01\x04\xc2\xf3\x04\x03\x12\x04\xee\x15\x04@\"!\x20needed\x20becaus\
    e\x20task\x20is\x20embedded\n\n2\n\x05\x06\0\x02\xa2\x01\x12\x06\xf2\x15\
    \x02\x84\x16\x03\x1a!\x20Patch\x20one\x20or\x20more\x20label\x20orders.\
    \n\n\x0e\n\x06\x06\0\x02\xa2\x01\x01\x12\x04\xf2\x15\x06\x16\n\x0e\n\x06\
    \x06\0\x02\xa2\x01\x02\x12\x04\xf2\x15\x18/\n\x0e\n\x06\x06\0\x02\xa2\
    \x01\x03\x12\x04\xf2\x15:Q\n\x10\n\x06\x06\0\x02\xa2\x01\x04\x12\x06\xf3\
    \x15\x04\xfa\x15\x06\n\x14\n\n\x06\0\x02\xa2\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xf3\x15\x04\xfa\x15\x06\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\
    \xfc\x15\x047\n\x11\n\t\x06\0\x02\xa2\x01\x04\xc3\xf3\x04\x12\x04\xfc\
    \x15\x047\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\xfd\x15\x04?\n\x12\n\
    \n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\0\x12\x04\xfd\x15\x04?\n\x0e\n\x06\
    \x06\0\x02\xa2\x01\x04\x12\x04\xfe\x15\x04F\n\x12\n\n\x06\0\x02\xa2\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xfe\x15\x04F\n\x0e\n\x06\x06\0\x02\xa2\x01\
    \x04\x12\x04\xff\x15\x04F\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xff\x15\x04F\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x80\
    \x16\x04C\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x03\x12\x04\x80\
    \x16\x04C\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x81\x16\x04@\n\x12\n\
    \n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x04\x12\x04\x81\x16\x04@\n\x0e\n\
    \x06\x06\0\x02\xa2\x01\x04\x12\x04\x82\x16\x04@\n\x12\n\n\x06\0\x02\xa2\
    \x01\x04\xc2\xf3\x04\x05\x12\x04\x82\x16\x04@\n\x0e\n\x06\x06\0\x02\xa2\
    \x01\x04\x12\x04\x83\x16\x04C\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\
    \x04\x06\x12\x04\x83\x16\x04C\n_\n\x05\x06\0\x02\xa3\x01\x12\x06\x88\x16\
    \x02\x99\x16\x03\x1aN\x20Delete\x20multiple\x20label\x20orders\x20in\x20\
    one\x20request.\n\x20this\x20do\x20not\x20change\x20task\x20status\n\n\
    \x0e\n\x06\x06\0\x02\xa3\x01\x01\x12\x04\x88\x16\x06\x17\n\x0e\n\x06\x06\
    \0\x02\xa3\x01\x02\x12\x04\x88\x16\x191\n\x0e\n\x06\x06\0\x02\xa3\x01\
    \x03\x12\x04\x88\x16<\\\n\x10\n\x06\x06\0\x02\xa3\x01\x04\x12\x06\x89\
    \x16\x04\x90\x16\x06\n\x14\n\n\x06\0\x02\xa3\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x89\x16\x04\x90\x16\x06\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\
    \x92\x16\x047\n\x11\n\t\x06\0\x02\xa3\x01\x04\xc3\xf3\x04\x12\x04\x92\
    \x16\x047\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x93\x16\x04?\n\x12\n\
    \n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\0\x12\x04\x93\x16\x04?\n\x0e\n\x06\
    \x06\0\x02\xa3\x01\x04\x12\x04\x94\x16\x04I\n\x12\n\n\x06\0\x02\xa3\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x94\x16\x04I\n\x0e\n\x06\x06\0\x02\xa3\x01\
    \x04\x12\x04\x95\x16\x04F\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\x95\x16\x04F\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x96\
    \x16\x04F\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x03\x12\x04\x96\
    \x16\x04F\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x97\x16\x04@\n\x12\n\
    \n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x04\x12\x04\x97\x16\x04@\n\x0e\n\
    \x06\x06\0\x02\xa3\x01\x04\x12\x04\x98\x16\x04@\n\x12\n\n\x06\0\x02\xa3\
    \x01\x04\xc2\xf3\x04\x05\x12\x04\x98\x16\x04@\n\xf3\x02\n\x05\x06\0\x02\
    \xa4\x01\x12\x06\xa1\x16\x02\xb6\x16\x03\x1a\xe1\x02\x20Add\x20a\x20list\
    \x20of\x20Collectors\x20to\x20an\x20app.\n\x20In\x20the\x20handler\x20of\
    \x20this\x20endpoint\x20we\x20also\x20check\x20for\x20all\x20the\x20scop\
    es\x20of\x20the\x20\x20POST\x20/inputs\n\x20endpoint.\n\x20Those\x20curr\
    ent\x20scopes\x20are\x20listed\x20here\x20as\x20a\x20hard\x20requirement\
    .\n\x20They\x20are\x20needed\x20when\x20adding\x20the\x20collectors\x20j\
    ust\x20so\x20we\x20now\x20that\x20you\x20have\x20permission\x20with\n\
    \x20that\x20key\x20at\x20least\x20to\x20do\x20the\x20writing\x20to\x20th\
    is\x20app\x20with\x20POST\x20/inputs.\n\n\x0e\n\x06\x06\0\x02\xa4\x01\
    \x01\x12\x04\xa1\x16\x06\x14\n\x0e\n\x06\x06\0\x02\xa4\x01\x02\x12\x04\
    \xa1\x16\x16+\n\x0e\n\x06\x06\0\x02\xa4\x01\x03\x12\x04\xa1\x166L\n\x10\
    \n\x06\x06\0\x02\xa4\x01\x04\x12\x06\xa2\x16\x04\xa9\x16\x06\n\x14\n\n\
    \x06\0\x02\xa4\x01\x04\xb0\xca\xbc\"\x12\x06\xa2\x16\x04\xa9\x16\x06\n\
    \x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xaa\x16\x047\n\x11\n\t\x06\0\
    \x02\xa4\x01\x04\xc3\xf3\x04\x12\x04\xaa\x16\x047\n\x0e\n\x06\x06\0\x02\
    \xa4\x01\x04\x12\x04\xab\x16\x04?\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xab\x16\x04?\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\
    \x04\xac\x16\x04A\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xac\x16\x04A\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xad\x16\x04F\
    \n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x02\x12\x04\xad\x16\x04F\n\
    \x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xae\x16\x04F\n\x12\n\n\x06\0\
    \x02\xa4\x01\x04\xc2\xf3\x04\x03\x12\x04\xae\x16\x04F\n\x0e\n\x06\x06\0\
    \x02\xa4\x01\x04\x12\x04\xaf\x16\x04E\n\x12\n\n\x06\0\x02\xa4\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xaf\x16\x04E\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\
    \x12\x04\xb0\x16\x04C\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xb0\x16\x04C\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xb1\x16\
    \x04A\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x06\x12\x04\xb1\x16\
    \x04A\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xb2\x16\x04A\n\x12\n\n\
    \x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x07\x12\x04\xb2\x16\x04A\n\x0e\n\x06\
    \x06\0\x02\xa4\x01\x04\x12\x04\xb3\x16\x04A\n\x12\n\n\x06\0\x02\xa4\x01\
    \x04\xc2\xf3\x04\x08\x12\x04\xb3\x16\x04A\n\x0e\n\x06\x06\0\x02\xa4\x01\
    \x04\x12\x04\xb4\x16\x04>\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\t\
    \x12\x04\xb4\x16\x04>\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xb5\x16\
    \x04D\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\n\x12\x04\xb5\x16\x04D\
    \n8\n\x05\x06\0\x02\xa5\x01\x12\x06\xb9\x16\x02\xc3\x16\x03\x1a'\x20Get\
    \x20a\x20specific\x20collector\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\
    \x02\xa5\x01\x01\x12\x04\xb9\x16\x06\x12\n\x0e\n\x06\x06\0\x02\xa5\x01\
    \x02\x12\x04\xb9\x16\x14'\n\x0e\n\x06\x06\0\x02\xa5\x01\x03\x12\x04\xb9\
    \x162I\n\x10\n\x06\x06\0\x02\xa5\x01\x04\x12\x06\xba\x16\x04\xbf\x16\x06\
    \n\x14\n\n\x06\0\x02\xa5\x01\x04\xb0\xca\xbc\"\x12\x06\xba\x16\x04\xbf\
    \x16\x06\n\x0e\n\x06\x06\0\x02\xa5\x01\x04\x12\x04\xc0\x16\x047\n\x11\n\
    \t\x06\0\x02\xa5\x01\x04\xc3\xf3\x04\x12\x04\xc0\x16\x047\n\x0e\n\x06\
    \x06\0\x02\xa5\x01\x04\x12\x04\xc1\x16\x04?\n\x12\n\n\x06\0\x02\xa5\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xc1\x16\x04?\n\x0e\n\x06\x06\0\x02\xa5\x01\
    \x04\x12\x04\xc2\x16\x04E\n\x12\n\n\x06\0\x02\xa5\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xc2\x16\x04E\n+\n\x05\x06\0\x02\xa6\x01\x12\x06\xc6\x16\x02\
    \xd0\x16\x03\x1a\x1a\x20List\x20all\x20the\x20collectors.\n\n\x0e\n\x06\
    \x06\0\x02\xa6\x01\x01\x12\x04\xc6\x16\x06\x14\n\x0e\n\x06\x06\0\x02\xa6\
    \x01\x02\x12\x04\xc6\x16\x16+\n\x0e\n\x06\x06\0\x02\xa6\x01\x03\x12\x04\
    \xc6\x166L\n\x10\n\x06\x06\0\x02\xa6\x01\x04\x12\x06\xc7\x16\x04\xcc\x16\
    \x06\n\x14\n\n\x06\0\x02\xa6\x01\x04\xb0\xca\xbc\"\x12\x06\xc7\x16\x04\
    \xcc\x16\x06\n\x0e\n\x06\x06\0\x02\xa6\x01\x04\x12\x04\xcd\x16\x047\n\
    \x11\n\t\x06\0\x02\xa6\x01\x04\xc3\xf3\x04\x12\x04\xcd\x16\x047\n\x0e\n\
    \x06\x06\0\x02\xa6\x01\x04\x12\x04\xce\x16\x04?\n\x12\n\n\x06\0\x02\xa6\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xce\x16\x04?\n\x0e\n\x06\x06\0\x02\xa6\
    \x01\x04\x12\x04\xcf\x16\x04E\n\x12\n\n\x06\0\x02\xa6\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xcf\x16\x04E\n0\n\x05\x06\0\x02\xa7\x01\x12\x06\xd3\x16\
    \x02\xe0\x16\x03\x1a\x1f\x20Patch\x20one\x20or\x20more\x20collectors.\n\
    \n\x0e\n\x06\x06\0\x02\xa7\x01\x01\x12\x04\xd3\x16\x06\x15\n\x0e\n\x06\
    \x06\0\x02\xa7\x01\x02\x12\x04\xd3\x16\x17-\n\x0e\n\x06\x06\0\x02\xa7\
    \x01\x03\x12\x04\xd3\x168N\n\x10\n\x06\x06\0\x02\xa7\x01\x04\x12\x06\xd4\
    \x16\x04\xdb\x16\x06\n\x14\n\n\x06\0\x02\xa7\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xd4\x16\x04\xdb\x16\x06\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\
    \xdc\x16\x047\n\x11\n\t\x06\0\x02\xa7\x01\x04\xc3\xf3\x04\x12\x04\xdc\
    \x16\x047\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xdd\x16\x04?\n\x12\n\
    \n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\0\x12\x04\xdd\x16\x04?\n\x0e\n\x06\
    \x06\0\x02\xa7\x01\x04\x12\x04\xde\x16\x04E\n\x12\n\n\x06\0\x02\xa7\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xde\x16\x04E\n\x0e\n\x06\x06\0\x02\xa7\x01\
    \x04\x12\x04\xdf\x16\x04E\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xdf\x16\x04E\n\x90\x01\n\x05\x06\0\x02\xa8\x01\x12\x06\xe6\
    \x16\x02\xf4\x16\x03\x1a\x7f\x20Delete\x20multiple\x20collectors\x20in\
    \x20one\x20request.\n\x20This\x20call\x20is\x20asynchronous.\x20Use\x20D\
    eleteCollector\x20if\x20you\x20want\x20a\x20synchronous\x20version.\n\n\
    \x0e\n\x06\x06\0\x02\xa8\x01\x01\x12\x04\xe6\x16\x06\x16\n\x0e\n\x06\x06\
    \0\x02\xa8\x01\x02\x12\x04\xe6\x16\x18/\n\x0e\n\x06\x06\0\x02\xa8\x01\
    \x03\x12\x04\xe6\x16:Z\n\x10\n\x06\x06\0\x02\xa8\x01\x04\x12\x06\xe7\x16\
    \x04\xee\x16\x06\n\x14\n\n\x06\0\x02\xa8\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xe7\x16\x04\xee\x16\x06\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\x12\x04\xef\
    \x16\x047\n\x11\n\t\x06\0\x02\xa8\x01\x04\xc3\xf3\x04\x12\x04\xef\x16\
    \x047\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\x12\x04\xf0\x16\x04?\n\x12\n\n\
    \x06\0\x02\xa8\x01\x04\xc2\xf3\x04\0\x12\x04\xf0\x16\x04?\n\x0e\n\x06\
    \x06\0\x02\xa8\x01\x04\x12\x04\xf1\x16\x04E\n\x12\n\n\x06\0\x02\xa8\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xf1\x16\x04E\n\x0e\n\x06\x06\0\x02\xa8\x01\
    \x04\x12\x04\xf2\x16\x04H\n\x12\n\n\x06\0\x02\xa8\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xf2\x16\x04H\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\x12\x04\xf3\
    \x16\x04E\n\x12\n\n\x06\0\x02\xa8\x01\x04\xc2\xf3\x04\x03\x12\x04\xf3\
    \x16\x04E\n!\n\x05\x06\0\x02\xa9\x01\x12\x06\xf7\x16\x02\x81\x17\x03\x1a\
    \x10\x20PostStatValues\n\n\x0e\n\x06\x06\0\x02\xa9\x01\x01\x12\x04\xf7\
    \x16\x06\x14\n\x0e\n\x06\x06\0\x02\xa9\x01\x02\x12\x04\xf7\x16\x16+\n\
    \x0e\n\x06\x06\0\x02\xa9\x01\x03\x12\x04\xf7\x166L\n\x10\n\x06\x06\0\x02\
    \xa9\x01\x04\x12\x06\xf8\x16\x04\xff\x16\x06\n\x14\n\n\x06\0\x02\xa9\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xf8\x16\x04\xff\x16\x06\n\x0e\n\x06\x06\0\x02\
    \xa9\x01\x04\x12\x04\x80\x17\x047\n\x11\n\t\x06\0\x02\xa9\x01\x04\xc3\
    \xf3\x04\x12\x04\x80\x17\x047\n*\n\x05\x06\0\x02\xaa\x01\x12\x06\x84\x17\
    \x02\x8f\x17\x03\x1a\x19\x20PostStatValuesAggregate\n\n\x0e\n\x06\x06\0\
    \x02\xaa\x01\x01\x12\x04\x84\x17\x06\x1d\n\x0e\n\x06\x06\0\x02\xaa\x01\
    \x02\x12\x04\x84\x17\x1f=\n\x0e\n\x06\x06\0\x02\xaa\x01\x03\x12\x04\x84\
    \x17Hg\n\x10\n\x06\x06\0\x02\xaa\x01\x04\x12\x06\x85\x17\x04\x8c\x17\x06\
    \n\x14\n\n\x06\0\x02\xaa\x01\x04\xb0\xca\xbc\"\x12\x06\x85\x17\x04\x8c\
    \x17\x06\n\x0e\n\x06\x06\0\x02\xaa\x01\x04\x12\x04\x8d\x17\x047\n\x11\n\
    \t\x06\0\x02\xaa\x01\x04\xc3\xf3\x04\x12\x04\x8d\x17\x047\n\x0e\n\x06\
    \x06\0\x02\xaa\x01\x04\x12\x04\x8e\x17\x04?\n\x12\n\n\x06\0\x02\xaa\x01\
    \x04\xc2\xf3\x04\0\x12\x04\x8e\x17\x04?\n=\n\x05\x06\0\x02\xab\x01\x12\
    \x06\x99\x17\x02\x9f\x17\x03\x1a,\x20Increase\x20the\x20view\x20metric\
    \x20for\x20a\x20detail\x20view\n\n\x0e\n\x06\x06\0\x02\xab\x01\x01\x12\
    \x04\x99\x17\x06\x1d\n\x0e\n\x06\x06\0\x02\xab\x01\x02\x12\x04\x99\x17\
    \x1f=\n\x0e\n\x06\x06\0\x02\xab\x01\x03\x12\x04\x99\x17Hh\n\x10\n\x06\
    \x06\0\x02\xab\x01\x04\x12\x06\x9a\x17\x04\x9d\x17\x06\n\x14\n\n\x06\0\
    \x02\xab\x01\x04\xb0\xca\xbc\"\x12\x06\x9a\x17\x04\x9d\x17\x06\n\x0e\n\
    \x06\x06\0\x02\xab\x01\x04\x12\x04\x9e\x17\x047\n\x11\n\t\x06\0\x02\xab\
    \x01\x04\xc3\xf3\x04\x12\x04\x9e\x17\x047\n:\n\x05\x06\0\x02\xac\x01\x12\
    \x06\xa2\x17\x02\xaa\x17\x03\x1a)\x20List\x20the\x20view\x20metrics\x20f\
    or\x20a\x20detail\x20view\n\n\x0e\n\x06\x06\0\x02\xac\x01\x01\x12\x04\
    \xa2\x17\x06\x1e\n\x0e\n\x06\x06\0\x02\xac\x01\x02\x12\x04\xa2\x17\x20?\
    \n\x0e\n\x06\x06\0\x02\xac\x01\x03\x12\x04\xa2\x17Jj\n\x10\n\x06\x06\0\
    \x02\xac\x01\x04\x12\x06\xa3\x17\x04\xa8\x17\x06\n\x14\n\n\x06\0\x02\xac\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x17\x04\xa8\x17\x06\n\x0e\n\x06\x06\0\
    \x02\xac\x01\x04\x12\x04\xa9\x17\x047\n\x11\n\t\x06\0\x02\xac\x01\x04\
    \xc3\xf3\x04\x12\x04\xa9\x17\x047\n5\n\x05\x06\0\x02\xad\x01\x12\x06\xb5\
    \x17\x02\xbc\x17\x03\x1a$\x20Get\x20a\x20specific\x20module\x20from\x20a\
    n\x20app.\n\n\x0e\n\x06\x06\0\x02\xad\x01\x01\x12\x04\xb5\x17\x06\x0f\n\
    \x0e\n\x06\x06\0\x02\xad\x01\x02\x12\x04\xb5\x17\x11!\n\x0e\n\x06\x06\0\
    \x02\xad\x01\x03\x12\x04\xb5\x17,@\n\x10\n\x06\x06\0\x02\xad\x01\x04\x12\
    \x06\xb6\x17\x04\xb8\x17\x06\n\x14\n\n\x06\0\x02\xad\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xb6\x17\x04\xb8\x17\x06\n\x0e\n\x06\x06\0\x02\xad\x01\x04\x12\
    \x04\xb9\x17\x047\n\x11\n\t\x06\0\x02\xad\x01\x04\xc3\xf3\x04\x12\x04\
    \xb9\x17\x047\n\x0e\n\x06\x06\0\x02\xad\x01\x04\x12\x04\xba\x17\x04?\n\
    \x12\n\n\x06\0\x02\xad\x01\x04\xc2\xf3\x04\0\x12\x04\xba\x17\x04?\n\x0e\
    \n\x06\x06\0\x02\xad\x01\x04\x12\x04\xbb\x17\x04B\n\x12\n\n\x06\0\x02\
    \xad\x01\x04\xc2\xf3\x04\x01\x12\x04\xbb\x17\x04B\nH\n\x05\x06\0\x02\xae\
    \x01\x12\x06\xbf\x17\x02\xcc\x17\x03\x1a7\x20List\x20all\x20the\x20modul\
    es\x20in\x20community,\x20by\x20user\x20or\x20by\x20app.\n\n\x0e\n\x06\
    \x06\0\x02\xae\x01\x01\x12\x04\xbf\x17\x06\x11\n\x0e\n\x06\x06\0\x02\xae\
    \x01\x02\x12\x04\xbf\x17\x13%\n\x0e\n\x06\x06\0\x02\xae\x01\x03\x12\x04\
    \xbf\x170C\n\x10\n\x06\x06\0\x02\xae\x01\x04\x12\x06\xc0\x17\x04\xc8\x17\
    \x06\n\x14\n\n\x06\0\x02\xae\x01\x04\xb0\xca\xbc\"\x12\x06\xc0\x17\x04\
    \xc8\x17\x06\n\x0e\n\x06\x06\0\x02\xae\x01\x04\x12\x04\xc9\x17\x047\n\
    \x11\n\t\x06\0\x02\xae\x01\x04\xc3\xf3\x04\x12\x04\xc9\x17\x047\n\x0e\n\
    \x06\x06\0\x02\xae\x01\x04\x12\x04\xca\x17\x04?\n\x12\n\n\x06\0\x02\xae\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xca\x17\x04?\n\x0e\n\x06\x06\0\x02\xae\
    \x01\x04\x12\x04\xcb\x17\x04B\n\x12\n\n\x06\0\x02\xae\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xcb\x17\x04B\n+\n\x05\x06\0\x02\xaf\x01\x12\x06\xcf\x17\
    \x02\xd8\x17\x03\x1a\x1a\x20Add\x20a\x20modules\x20to\x20an\x20app.\n\n\
    \x0e\n\x06\x06\0\x02\xaf\x01\x01\x12\x04\xcf\x17\x06\x11\n\x0e\n\x06\x06\
    \0\x02\xaf\x01\x02\x12\x04\xcf\x17\x13%\n\x0e\n\x06\x06\0\x02\xaf\x01\
    \x03\x12\x04\xcf\x170C\n\x10\n\x06\x06\0\x02\xaf\x01\x04\x12\x06\xd0\x17\
    \x04\xd3\x17\x06\n\x14\n\n\x06\0\x02\xaf\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xd0\x17\x04\xd3\x17\x06\n\x0e\n\x06\x06\0\x02\xaf\x01\x04\x12\x04\xd4\
    \x17\x047\n\x11\n\t\x06\0\x02\xaf\x01\x04\xc3\xf3\x04\x12\x04\xd4\x17\
    \x047\n\x0e\n\x06\x06\0\x02\xaf\x01\x04\x12\x04\xd5\x17\x04?\n\x12\n\n\
    \x06\0\x02\xaf\x01\x04\xc2\xf3\x04\0\x12\x04\xd5\x17\x04?\n\x0e\n\x06\
    \x06\0\x02\xaf\x01\x04\x12\x04\xd6\x17\x04B\n\x12\n\n\x06\0\x02\xaf\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xd6\x17\x04B\n\x0e\n\x06\x06\0\x02\xaf\x01\
    \x04\x12\x04\xd7\x17\x04B\n\x12\n\n\x06\0\x02\xaf\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xd7\x17\x04B\n-\n\x05\x06\0\x02\xb0\x01\x12\x06\xdb\x17\x02\
    \xe4\x17\x03\x1a\x1c\x20Patch\x20one\x20or\x20more\x20modules.\n\n\x0e\n\
    \x06\x06\0\x02\xb0\x01\x01\x12\x04\xdb\x17\x06\x12\n\x0e\n\x06\x06\0\x02\
    \xb0\x01\x02\x12\x04\xdb\x17\x14'\n\x0e\n\x06\x06\0\x02\xb0\x01\x03\x12\
    \x04\xdb\x172E\n\x10\n\x06\x06\0\x02\xb0\x01\x04\x12\x06\xdc\x17\x04\xdf\
    \x17\x06\n\x14\n\n\x06\0\x02\xb0\x01\x04\xb0\xca\xbc\"\x12\x06\xdc\x17\
    \x04\xdf\x17\x06\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xe0\x17\x047\
    \n\x11\n\t\x06\0\x02\xb0\x01\x04\xc3\xf3\x04\x12\x04\xe0\x17\x047\n\x0e\
    \n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xe1\x17\x04?\n\x12\n\n\x06\0\x02\
    \xb0\x01\x04\xc2\xf3\x04\0\x12\x04\xe1\x17\x04?\n\x0e\n\x06\x06\0\x02\
    \xb0\x01\x04\x12\x04\xe2\x17\x04B\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xe2\x17\x04B\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\
    \x04\xe3\x17\x04B\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xe3\x17\x04B\n:\n\x05\x06\0\x02\xb1\x01\x12\x06\xe7\x17\x02\xf7\x17\
    \x03\x1a)\x20Delete\x20multiple\x20modules\x20in\x20one\x20request.\n\n\
    \x0e\n\x06\x06\0\x02\xb1\x01\x01\x12\x04\xe7\x17\x06\x13\n\x0e\n\x06\x06\
    \0\x02\xb1\x01\x02\x12\x04\xe7\x17\x15)\n\x0e\n\x06\x06\0\x02\xb1\x01\
    \x03\x12\x04\xe7\x174T\n\x10\n\x06\x06\0\x02\xb1\x01\x04\x12\x06\xe8\x17\
    \x04\xeb\x17\x06\n\x14\n\n\x06\0\x02\xb1\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xe8\x17\x04\xeb\x17\x06\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xec\
    \x17\x047\n\x11\n\t\x06\0\x02\xb1\x01\x04\xc3\xf3\x04\x12\x04\xec\x17\
    \x047\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xed\x17\x04?\n\x12\n\n\
    \x06\0\x02\xb1\x01\x04\xc2\xf3\x04\0\x12\x04\xed\x17\x04?\n\x0e\n\x06\
    \x06\0\x02\xb1\x01\x04\x12\x04\xee\x17\x04B\n\x12\n\n\x06\0\x02\xb1\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xee\x17\x04B\n\x0e\n\x06\x06\0\x02\xb1\x01\
    \x04\x12\x04\xef\x17\x04E\n\x12\n\n\x06\0\x02\xb1\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xef\x17\x04E\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xf0\
    \x17\x04B\n\x12\n\n\x06\0\x02\xb1\x01\x04\xc2\xf3\x04\x03\x12\x04\xf0\
    \x17\x04B\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xf1\x17\x04R\n5\n\n\
    \x06\0\x02\xb1\x01\x04\xc2\xf3\x04\x04\x12\x04\xf1\x17\x04R\"!\x20Needed\
    \x20to\x20cascade\x20delete\x20to\x20IMV\n\n\x0e\n\x06\x06\0\x02\xb1\x01\
    \x04\x12\x04\xf2\x17\x04R\n\x12\n\n\x06\0\x02\xb1\x01\x04\xc2\xf3\x04\
    \x05\x12\x04\xf2\x17\x04R\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xf3\
    \x17\x04U\n\x12\n\n\x06\0\x02\xb1\x01\x04\xc2\xf3\x04\x06\x12\x04\xf3\
    \x17\x04U\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xf4\x17\x04B\n\x12\n\
    \n\x06\0\x02\xb1\x01\x04\xc2\xf3\x04\x07\x12\x04\xf4\x17\x04B\n\x0e\n\
    \x06\x06\0\x02\xb1\x01\x04\x12\x04\xf5\x17\x04?\n\x12\n\n\x06\0\x02\xb1\
    \x01\x04\xc2\xf3\x04\x08\x12\x04\xf5\x17\x04?\n\x0e\n\x06\x06\0\x02\xb1\
    \x01\x04\x12\x04\xf6\x17\x04?\n\x12\n\n\x06\0\x02\xb1\x01\x04\xc2\xf3\
    \x04\t\x12\x04\xf6\x17\x04?\n>\n\x05\x06\0\x02\xb2\x01\x12\x06\xfa\x17\
    \x02\x81\x18\x03\x1a-\x20Get\x20a\x20specific\x20module\x20version\x20fo\
    r\x20a\x20module.\n\n\x0e\n\x06\x06\0\x02\xb2\x01\x01\x12\x04\xfa\x17\
    \x06\x16\n\x0e\n\x06\x06\0\x02\xb2\x01\x02\x12\x04\xfa\x17\x18/\n\x0e\n\
    \x06\x06\0\x02\xb2\x01\x03\x12\x04\xfa\x17:U\n\x10\n\x06\x06\0\x02\xb2\
    \x01\x04\x12\x06\xfb\x17\x04\xfd\x17\x06\n\x14\n\n\x06\0\x02\xb2\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xfb\x17\x04\xfd\x17\x06\n\x0e\n\x06\x06\0\x02\xb2\
    \x01\x04\x12\x04\xfe\x17\x047\n\x11\n\t\x06\0\x02\xb2\x01\x04\xc3\xf3\
    \x04\x12\x04\xfe\x17\x047\n\x0e\n\x06\x06\0\x02\xb2\x01\x04\x12\x04\xff\
    \x17\x04?\n\x12\n\n\x06\0\x02\xb2\x01\x04\xc2\xf3\x04\0\x12\x04\xff\x17\
    \x04?\n\x0e\n\x06\x06\0\x02\xb2\x01\x04\x12\x04\x80\x18\x04B\n\x12\n\n\
    \x06\0\x02\xb2\x01\x04\xc2\xf3\x04\x01\x12\x04\x80\x18\x04B\nD\n\x05\x06\
    \0\x02\xb3\x01\x12\x06\x84\x18\x02\x8b\x18\x03\x1a3\x20List\x20all\x20th\
    e\x20modules\x20versions\x20for\x20a\x20given\x20module.\n\n\x0e\n\x06\
    \x06\0\x02\xb3\x01\x01\x12\x04\x84\x18\x06\x18\n\x0e\n\x06\x06\0\x02\xb3\
    \x01\x02\x12\x04\x84\x18\x1a3\n\x0e\n\x06\x06\0\x02\xb3\x01\x03\x12\x04\
    \x84\x18>X\n\x10\n\x06\x06\0\x02\xb3\x01\x04\x12\x06\x85\x18\x04\x87\x18\
    \x06\n\x14\n\n\x06\0\x02\xb3\x01\x04\xb0\xca\xbc\"\x12\x06\x85\x18\x04\
    \x87\x18\x06\n\x0e\n\x06\x06\0\x02\xb3\x01\x04\x12\x04\x88\x18\x047\n\
    \x11\n\t\x06\0\x02\xb3\x01\x04\xc3\xf3\x04\x12\x04\x88\x18\x047\n\x0e\n\
    \x06\x06\0\x02\xb3\x01\x04\x12\x04\x89\x18\x04?\n\x12\n\n\x06\0\x02\xb3\
    \x01\x04\xc2\xf3\x04\0\x12\x04\x89\x18\x04?\n\x0e\n\x06\x06\0\x02\xb3\
    \x01\x04\x12\x04\x8a\x18\x04B\n\x12\n\n\x06\0\x02\xb3\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\x8a\x18\x04B\nQ\n\x05\x06\0\x02\xb4\x01\x12\x06\x8e\x18\
    \x02\x97\x18\x03\x1a@\x20Create\x20a\x20new\x20module\x20version\x20to\
    \x20trigger\x20training\x20of\x20the\x20module.\n\n\x0e\n\x06\x06\0\x02\
    \xb4\x01\x01\x12\x04\x8e\x18\x06\x18\n\x0e\n\x06\x06\0\x02\xb4\x01\x02\
    \x12\x04\x8e\x18\x1a3\n\x0e\n\x06\x06\0\x02\xb4\x01\x03\x12\x04\x8e\x18>\
    X\n\x10\n\x06\x06\0\x02\xb4\x01\x04\x12\x06\x8f\x18\x04\x92\x18\x06\n\
    \x14\n\n\x06\0\x02\xb4\x01\x04\xb0\xca\xbc\"\x12\x06\x8f\x18\x04\x92\x18\
    \x06\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x93\x18\x047\n\x11\n\t\
    \x06\0\x02\xb4\x01\x04\xc3\xf3\x04\x12\x04\x93\x18\x047\n\x0e\n\x06\x06\
    \0\x02\xb4\x01\x04\x12\x04\x94\x18\x04?\n\x12\n\n\x06\0\x02\xb4\x01\x04\
    \xc2\xf3\x04\0\x12\x04\x94\x18\x04?\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\
    \x12\x04\x95\x18\x04B\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\x95\x18\x04B\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x96\x18\
    \x04B\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x02\x12\x04\x96\x18\
    \x04B\n4\n\x05\x06\0\x02\xb5\x01\x12\x06\x9a\x18\x02\xaa\x18\x03\x1a#\
    \x20Delete\x20a\x20multiple\x20module\x20version.\n\n\x0e\n\x06\x06\0\
    \x02\xb5\x01\x01\x12\x04\x9a\x18\x06\x1a\n\x0e\n\x06\x06\0\x02\xb5\x01\
    \x02\x12\x04\x9a\x18\x1c7\n\x0e\n\x06\x06\0\x02\xb5\x01\x03\x12\x04\x9a\
    \x18Bb\n\x10\n\x06\x06\0\x02\xb5\x01\x04\x12\x06\x9b\x18\x04\x9e\x18\x06\
    \n\x14\n\n\x06\0\x02\xb5\x01\x04\xb0\xca\xbc\"\x12\x06\x9b\x18\x04\x9e\
    \x18\x06\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\x9f\x18\x047\n\x11\n\
    \t\x06\0\x02\xb5\x01\x04\xc3\xf3\x04\x12\x04\x9f\x18\x047\n\x0e\n\x06\
    \x06\0\x02\xb5\x01\x04\x12\x04\xa0\x18\x04?\n\x12\n\n\x06\0\x02\xb5\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xa0\x18\x04?\n\x0e\n\x06\x06\0\x02\xb5\x01\
    \x04\x12\x04\xa1\x18\x04B\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xa1\x18\x04B\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\xa2\
    \x18\x04E\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x02\x12\x04\xa2\
    \x18\x04E\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\xa3\x18\x04B\n\x12\n\
    \n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x03\x12\x04\xa3\x18\x04B\n\x0e\n\
    \x06\x06\0\x02\xb5\x01\x04\x12\x04\xa4\x18\x04R\n5\n\n\x06\0\x02\xb5\x01\
    \x04\xc2\xf3\x04\x04\x12\x04\xa4\x18\x04R\"!\x20Needed\x20to\x20cascade\
    \x20delete\x20to\x20IMV\n\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\xa5\
    \x18\x04R\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x05\x12\x04\xa5\
    \x18\x04R\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\xa6\x18\x04U\n\x12\n\
    \n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x06\x12\x04\xa6\x18\x04U\n\x0e\n\
    \x06\x06\0\x02\xb5\x01\x04\x12\x04\xa7\x18\x04B\n\x12\n\n\x06\0\x02\xb5\
    \x01\x04\xc2\xf3\x04\x07\x12\x04\xa7\x18\x04B\n\x0e\n\x06\x06\0\x02\xb5\
    \x01\x04\x12\x04\xa8\x18\x04?\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\
    \x04\x08\x12\x04\xa8\x18\x04?\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\
    \xa9\x18\x04?\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\t\x12\x04\xa9\
    \x18\x04?\n?\n\x05\x06\0\x02\xb6\x01\x12\x06\xad\x18\x02\xb5\x18\x03\x1a\
    .\x20Get\x20usage\x20count\x20for\x20specific\x20module\x20version.\n\n\
    \x0e\n\x06\x06\0\x02\xb6\x01\x01\x12\x04\xad\x18\x06\x20\n\x0e\n\x06\x06\
    \0\x02\xb6\x01\x02\x12\x04\xad\x18\"C\n\x0e\n\x06\x06\0\x02\xb6\x01\x03\
    \x12\x04\xad\x18Ns\n\x10\n\x06\x06\0\x02\xb6\x01\x04\x12\x06\xae\x18\x04\
    \xb0\x18\x06\n\x14\n\n\x06\0\x02\xb6\x01\x04\xb0\xca\xbc\"\x12\x06\xae\
    \x18\x04\xb0\x18\x06\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xb1\x18\
    \x047\n\x11\n\t\x06\0\x02\xb6\x01\x04\xc3\xf3\x04\x12\x04\xb1\x18\x047\n\
    \x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xb2\x18\x04?\n\x12\n\n\x06\0\
    \x02\xb6\x01\x04\xc2\xf3\x04\0\x12\x04\xb2\x18\x04?\n\x0e\n\x06\x06\0\
    \x02\xb6\x01\x04\x12\x04\xb3\x18\x04B\n\x12\n\n\x06\0\x02\xb6\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\xb3\x18\x04B\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\
    \x12\x04\xb4\x18\x04R\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x02\
    \x12\x04\xb4\x18\x04R\n=\n\x05\x06\0\x02\xb7\x01\x12\x06\xb8\x18\x02\xc1\
    \x18\x03\x1a,\x20Get\x20installed\x20modules\x20vesrions\x20for\x20an\
    \x20app.\n\n\x0e\n\x06\x06\0\x02\xb7\x01\x01\x12\x04\xb8\x18\x06\x1f\n\
    \x0e\n\x06\x06\0\x02\xb7\x01\x02\x12\x04\xb8\x18!A\n\x0e\n\x06\x06\0\x02\
    \xb7\x01\x03\x12\x04\xb8\x18Lp\n\x10\n\x06\x06\0\x02\xb7\x01\x04\x12\x06\
    \xb9\x18\x04\xbb\x18\x06\n\x14\n\n\x06\0\x02\xb7\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xb9\x18\x04\xbb\x18\x06\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\
    \x04\xbc\x18\x047\n\x11\n\t\x06\0\x02\xb7\x01\x04\xc3\xf3\x04\x12\x04\
    \xbc\x18\x047\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xbd\x18\x04?\n\
    \x12\n\n\x06\0\x02\xb7\x01\x04\xc2\xf3\x04\0\x12\x04\xbd\x18\x04?\n\x0e\
    \n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xbe\x18\x04R\n\x12\n\n\x06\0\x02\
    \xb7\x01\x04\xc2\xf3\x04\x01\x12\x04\xbe\x18\x04R\n\x0e\n\x06\x06\0\x02\
    \xb7\x01\x04\x12\x04\xbf\x18\x04B\n\x12\n\n\x06\0\x02\xb7\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xbf\x18\x04B\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\
    \x04\xc0\x18\x04?\n\x12\n\n\x06\0\x02\xb7\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xc0\x18\x04?\n>\n\x05\x06\0\x02\xb8\x01\x12\x06\xc4\x18\x02\xcd\x18\
    \x03\x1a-\x20List\x20installed\x20modules\x20vesrions\x20for\x20an\x20ap\
    p.\n\n\x0e\n\x06\x06\0\x02\xb8\x01\x01\x12\x04\xc4\x18\x06!\n\x0e\n\x06\
    \x06\0\x02\xb8\x01\x02\x12\x04\xc4\x18#E\n\x0e\n\x06\x06\0\x02\xb8\x01\
    \x03\x12\x04\xc4\x18Ps\n\x10\n\x06\x06\0\x02\xb8\x01\x04\x12\x06\xc5\x18\
    \x04\xc7\x18\x06\n\x14\n\n\x06\0\x02\xb8\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xc5\x18\x04\xc7\x18\x06\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xc8\
    \x18\x047\n\x11\n\t\x06\0\x02\xb8\x01\x04\xc3\xf3\x04\x12\x04\xc8\x18\
    \x047\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xc9\x18\x04?\n\x12\n\n\
    \x06\0\x02\xb8\x01\x04\xc2\xf3\x04\0\x12\x04\xc9\x18\x04?\n\x0e\n\x06\
    \x06\0\x02\xb8\x01\x04\x12\x04\xca\x18\x04R\n\x12\n\n\x06\0\x02\xb8\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xca\x18\x04R\n\x0e\n\x06\x06\0\x02\xb8\x01\
    \x04\x12\x04\xcb\x18\x04B\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xcb\x18\x04B\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xcc\
    \x18\x04?\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\x03\x12\x04\xcc\
    \x18\x04?\ns\n\x05\x06\0\x02\xb9\x01\x12\x06\xd0\x18\x02\xda\x18\x03\x1a\
    b\x20Install\x20a\x20new\x20module\x20version\x20which\x20will\x20deploy\
    \x20the\x20specific\x20ModuleVersion\x20to\x20the\x20app\x20in\x20the\
    \x20url.\n\n\x0e\n\x06\x06\0\x02\xb9\x01\x01\x12\x04\xd0\x18\x06!\n\x0e\
    \n\x06\x06\0\x02\xb9\x01\x02\x12\x04\xd0\x18#E\n\x0e\n\x06\x06\0\x02\xb9\
    \x01\x03\x12\x04\xd0\x18Ps\n\x10\n\x06\x06\0\x02\xb9\x01\x04\x12\x06\xd1\
    \x18\x04\xd4\x18\x06\n\x14\n\n\x06\0\x02\xb9\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xd1\x18\x04\xd4\x18\x06\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\
    \xd5\x18\x047\n\x11\n\t\x06\0\x02\xb9\x01\x04\xc3\xf3\x04\x12\x04\xd5\
    \x18\x047\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\xd6\x18\x04R\n\x12\n\
    \n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\0\x12\x04\xd6\x18\x04R\n\x0e\n\x06\
    \x06\0\x02\xb9\x01\x04\x12\x04\xd7\x18\x04R\n\x12\n\n\x06\0\x02\xb9\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xd7\x18\x04R\n\x0e\n\x06\x06\0\x02\xb9\x01\
    \x04\x12\x04\xd8\x18\x04B\n\x12\n\n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xd8\x18\x04B\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\xd9\
    \x18\x04?\n3\n\n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\x03\x12\x04\xd9\x18\
    \x04?\"\x1f\x20since\x20adding\x20Keys\x20needs\x20that.\n\n\xca\x01\n\
    \x05\x06\0\x02\xba\x01\x12\x06\xdf\x18\x02\xed\x18\x03\x1a\xb8\x01\x20Un\
    install\x20an\x20installed\x20module\x20version\x20which\x20will\x20depl\
    oy\x20the\x20specific\x20ModuleVersion\x20to\x20the\x20app\n\x20in\x20th\
    e\x20url.\n\x20This\x20cleaned\x20up\x20any\x20associated\x20caller\x20k\
    eys\x20so\x20needs\x20the\x20Keys_Delete\x20scope.\n\n\x0e\n\x06\x06\0\
    \x02\xba\x01\x01\x12\x04\xdf\x18\x06#\n\x0e\n\x06\x06\0\x02\xba\x01\x02\
    \x12\x04\xdf\x18%I\n\x0e\n\x06\x06\0\x02\xba\x01\x03\x12\x04\xdf\x18Tt\n\
    \x10\n\x06\x06\0\x02\xba\x01\x04\x12\x06\xe0\x18\x04\xe3\x18\x06\n\x14\n\
    \n\x06\0\x02\xba\x01\x04\xb0\xca\xbc\"\x12\x06\xe0\x18\x04\xe3\x18\x06\n\
    \x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xe4\x18\x047\n\x11\n\t\x06\0\
    \x02\xba\x01\x04\xc3\xf3\x04\x12\x04\xe4\x18\x047\n\x0e\n\x06\x06\0\x02\
    \xba\x01\x04\x12\x04\xe5\x18\x04?\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xe5\x18\x04?\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\
    \x04\xe6\x18\x04B\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xe6\x18\x04B\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xe7\x18\x04R\
    \n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x02\x12\x04\xe7\x18\x04R\n\
    \x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xe8\x18\x04R\n\x12\n\n\x06\0\
    \x02\xba\x01\x04\xc2\xf3\x04\x03\x12\x04\xe8\x18\x04R\n\x0e\n\x06\x06\0\
    \x02\xba\x01\x04\x12\x04\xe9\x18\x04U\n\x12\n\n\x06\0\x02\xba\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xe9\x18\x04U\n\x0e\n\x06\x06\0\x02\xba\x01\x04\
    \x12\x04\xea\x18\x04B\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xea\x18\x04B\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xeb\x18\
    \x04?\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x06\x12\x04\xeb\x18\
    \x04?\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xec\x18\x04?\n\x12\n\n\
    \x06\0\x02\xba\x01\x04\xc2\xf3\x04\x07\x12\x04\xec\x18\x04?\n\xc0\x01\n\
    \x05\x06\0\x02\xbb\x01\x12\x06\xf1\x18\x02\xfd\x18\x03\x1a\xae\x01\x20As\
    sign\x20a\x20key\x20that\x20the\x20caller\x20owns\x20to\x20be\x20used\
    \x20when\x20accessing\x20this\x20installed\x20module\x20version\n\x20If\
    \x20this\x20endpoint\x20is\x20called\x20with\x20a\x20different\x20key\
    \x20then\x20it\x20overwrites\x20what\x20is\x20there.\n\n\x0e\n\x06\x06\0\
    \x02\xbb\x01\x01\x12\x04\xf1\x18\x06$\n\x0e\n\x06\x06\0\x02\xbb\x01\x02\
    \x12\x04\xf1\x18&K\n\x0e\n\x06\x06\0\x02\xbb\x01\x03\x12\x04\xf1\x18Vg\n\
    \x10\n\x06\x06\0\x02\xbb\x01\x04\x12\x06\xf2\x18\x04\xf5\x18\x06\n\x14\n\
    \n\x06\0\x02\xbb\x01\x04\xb0\xca\xbc\"\x12\x06\xf2\x18\x04\xf5\x18\x06\n\
    \x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xf6\x18\x047\n\x11\n\t\x06\0\
    \x02\xbb\x01\x04\xc3\xf3\x04\x12\x04\xf6\x18\x047\n\x0e\n\x06\x06\0\x02\
    \xbb\x01\x04\x12\x04\xf7\x18\x04R\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xf7\x18\x04R\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\
    \x04\xf8\x18\x04R\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xf8\x18\x04R\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xf9\x18\x04B\
    \n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x02\x12\x04\xf9\x18\x04B\n\
    \x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xfa\x18\x04?\n3\n\n\x06\0\x02\
    \xbb\x01\x04\xc2\xf3\x04\x03\x12\x04\xfa\x18\x04?\"\x1f\x20since\x20addi\
    ng\x20Keys\x20needs\x20that.\n\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\
    \xfb\x18\x04?\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x04\x12\x04\
    \xfb\x18\x04?\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xfc\x18\x04?\n\
    \x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x05\x12\x04\xfc\x18\x04?\n\
    \x83\x02\n\x05\x06\0\x02\xbc\x01\x12\x06\x82\x19\x02\x92\x19\x03\x1a\xf1\
    \x01\x20Perform\x20bulk\x20operations\x20on\x20a\x20list\x20of\x20inputs\
    \x20based\x20on\x20input\x20source.\n\x20Operation\x20include\x20add,\
    \x20update,\x20delete\x20of\x20concepts,\x20metadata\x20and\x20geo\x20da\
    ta.\n\x20This\x20is\x20an\x20Asynchronous\x20process.\x20Use\x20ListBulk\
    Operations\x20or\x20GetBulkOperation\x20to\x20check\x20the\x20status.\n\
    \n\x0e\n\x06\x06\0\x02\xbc\x01\x01\x12\x04\x82\x19\x06\x18\n\x0e\n\x06\
    \x06\0\x02\xbc\x01\x02\x12\x04\x82\x19\x1a3\n\x0e\n\x06\x06\0\x02\xbc\
    \x01\x03\x12\x04\x82\x19>Y\n\x10\n\x06\x06\0\x02\xbc\x01\x04\x12\x06\x83\
    \x19\x04\x8a\x19\x06\n\x14\n\n\x06\0\x02\xbc\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x83\x19\x04\x8a\x19\x06\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\
    \x8b\x19\x047\n\x11\n\t\x06\0\x02\xbc\x01\x04\xc3\xf3\x04\x12\x04\x8b\
    \x19\x047\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\x8c\x19\x04?\n\x12\n\
    \n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\0\x12\x04\x8c\x19\x04?\n\x0e\n\x06\
    \x06\0\x02\xbc\x01\x04\x12\x04\x8d\x19\x04H\n\x12\n\n\x06\0\x02\xbc\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x8d\x19\x04H\n\x0e\n\x06\x06\0\x02\xbc\x01\
    \x04\x12\x04\x8e\x19\x04H\n\x12\n\n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\x8e\x19\x04H\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\x8f\
    \x19\x04F\n\x12\n\n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\x03\x12\x04\x8f\
    \x19\x04F\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\x90\x19\x04F\n\x12\n\
    \n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\x04\x12\x04\x90\x19\x04F\n\x0e\n\
    \x06\x06\0\x02\xbc\x01\x04\x12\x04\x91\x19\x04I\n\x12\n\n\x06\0\x02\xbc\
    \x01\x04\xc2\xf3\x04\x05\x12\x04\x91\x19\x04I\n/\n\x05\x06\0\x02\xbd\x01\
    \x12\x06\x95\x19\x02\x9f\x19\x03\x1a\x1e\x20List\x20all\x20the\x20bulk\
    \x20operations\n\n\x0e\n\x06\x06\0\x02\xbd\x01\x01\x12\x04\x95\x19\x06\
    \x18\n\x0e\n\x06\x06\0\x02\xbd\x01\x02\x12\x04\x95\x19\x1a3\n\x0e\n\x06\
    \x06\0\x02\xbd\x01\x03\x12\x04\x95\x19>Y\n\x10\n\x06\x06\0\x02\xbd\x01\
    \x04\x12\x06\x96\x19\x04\x9b\x19\x06\n\x14\n\n\x06\0\x02\xbd\x01\x04\xb0\
    \xca\xbc\"\x12\x06\x96\x19\x04\x9b\x19\x06\n\x0e\n\x06\x06\0\x02\xbd\x01\
    \x04\x12\x04\x9c\x19\x047\n\x11\n\t\x06\0\x02\xbd\x01\x04\xc3\xf3\x04\
    \x12\x04\x9c\x19\x047\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\x9d\x19\
    \x04?\n\x12\n\n\x06\0\x02\xbd\x01\x04\xc2\xf3\x04\0\x12\x04\x9d\x19\x04?\
    \n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\x9e\x19\x04H\n\x12\n\n\x06\0\
    \x02\xbd\x01\x04\xc2\xf3\x04\x01\x12\x04\x9e\x19\x04H\n7\n\x05\x06\0\x02\
    \xbe\x01\x12\x06\xa2\x19\x02\xac\x19\x03\x1a&\x20Get\x20the\x20bulk\x20o\
    peration\x20details\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\xbe\x01\x01\x12\
    \x04\xa2\x19\x06\x16\n\x0e\n\x06\x06\0\x02\xbe\x01\x02\x12\x04\xa2\x19\
    \x18/\n\x0e\n\x06\x06\0\x02\xbe\x01\x03\x12\x04\xa2\x19:V\n\x10\n\x06\
    \x06\0\x02\xbe\x01\x04\x12\x06\xa3\x19\x04\xa8\x19\x06\n\x14\n\n\x06\0\
    \x02\xbe\x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x19\x04\xa8\x19\x06\n\x0e\n\
    \x06\x06\0\x02\xbe\x01\x04\x12\x04\xa9\x19\x047\n\x11\n\t\x06\0\x02\xbe\
    \x01\x04\xc3\xf3\x04\x12\x04\xa9\x19\x047\n\x0e\n\x06\x06\0\x02\xbe\x01\
    \x04\x12\x04\xaa\x19\x04?\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xaa\x19\x04?\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\xab\x19\
    \x04H\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x01\x12\x04\xab\x19\
    \x04H\n5\n\x05\x06\0\x02\xbf\x01\x12\x06\xaf\x19\x02\xbc\x19\x03\x1a$\
    \x20Cancel\x20one\x20or\x20more\x20bulk\x20operations\n\n\x0e\n\x06\x06\
    \0\x02\xbf\x01\x01\x12\x04\xaf\x19\x06\x1a\n\x0e\n\x06\x06\0\x02\xbf\x01\
    \x02\x12\x04\xaf\x19\x1c6\n\x0e\n\x06\x06\0\x02\xbf\x01\x03\x12\x04\xaf\
    \x19A\\\n\x10\n\x06\x06\0\x02\xbf\x01\x04\x12\x06\xb0\x19\x04\xb7\x19\
    \x06\n\x14\n\n\x06\0\x02\xbf\x01\x04\xb0\xca\xbc\"\x12\x06\xb0\x19\x04\
    \xb7\x19\x06\n\x0e\n\x06\x06\0\x02\xbf\x01\x04\x12\x04\xb8\x19\x047\n\
    \x11\n\t\x06\0\x02\xbf\x01\x04\xc3\xf3\x04\x12\x04\xb8\x19\x047\n\x0e\n\
    \x06\x06\0\x02\xbf\x01\x04\x12\x04\xb9\x19\x04?\n\x12\n\n\x06\0\x02\xbf\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xb9\x19\x04?\n\x0e\n\x06\x06\0\x02\xbf\
    \x01\x04\x12\x04\xba\x19\x04H\n\x12\n\n\x06\0\x02\xbf\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xba\x19\x04H\n\x0e\n\x06\x06\0\x02\xbf\x01\x04\x12\x04\
    \xbb\x19\x04H\n\x12\n\n\x06\0\x02\xbf\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xbb\x19\x04H\n@\n\x05\x06\0\x02\xc0\x01\x12\x06\xbf\x19\x02\xd0\x19\x03\
    \x1a/\x20delete\x20one\x20or\x20more\x20terminated\x20bulk\x20operations\
    \n\n\x0e\n\x06\x06\0\x02\xc0\x01\x01\x12\x04\xbf\x19\x06\x1a\n\x0e\n\x06\
    \x06\0\x02\xc0\x01\x02\x12\x04\xbf\x19\x1c6\n\x0e\n\x06\x06\0\x02\xc0\
    \x01\x03\x12\x04\xbf\x19Aa\n\x10\n\x06\x06\0\x02\xc0\x01\x04\x12\x06\xc0\
    \x19\x04\xc7\x19\x06\n\x14\n\n\x06\0\x02\xc0\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xc0\x19\x04\xc7\x19\x06\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\
    \xc8\x19\x047\n\x11\n\t\x06\0\x02\xc0\x01\x04\xc3\xf3\x04\x12\x04\xc8\
    \x19\x047\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xc9\x19\x04?\n\x12\n\
    \n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\0\x12\x04\xc9\x19\x04?\n\x0e\n\x06\
    \x06\0\x02\xc0\x01\x04\x12\x04\xca\x19\x04F\n\x12\n\n\x06\0\x02\xc0\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xca\x19\x04F\n\x0e\n\x06\x06\0\x02\xc0\x01\
    \x04\x12\x04\xcb\x19\x04F\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xcb\x19\x04F\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xcc\
    \x19\x04I\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x03\x12\x04\xcc\
    \x19\x04I\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xcd\x19\x04H\n\x12\n\
    \n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x04\x12\x04\xcd\x19\x04H\n\x0e\n\
    \x06\x06\0\x02\xc0\x01\x04\x12\x04\xce\x19\x04H\n\x12\n\n\x06\0\x02\xc0\
    \x01\x04\xc2\xf3\x04\x05\x12\x04\xce\x19\x04H\n\x0e\n\x06\x06\0\x02\xc0\
    \x01\x04\x12\x04\xcf\x19\x04K\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\
    \x04\x06\x12\x04\xcf\x19\x04K\nR\n\x05\x06\0\x02\xc1\x01\x12\x06\xd3\x19\
    \x02\xe1\x19\x03\x1aA\x20List\x20next\x20non-labeled\x20and\x20unassigne\
    d\x20inputs\x20from\x20task's\x20dataset\n\n\x0e\n\x06\x06\0\x02\xc1\x01\
    \x01\x12\x04\xd3\x19\x06\x1d\n\x0e\n\x06\x06\0\x02\xc1\x01\x02\x12\x04\
    \xd3\x19\x1f=\n\x0e\n\x06\x06\0\x02\xc1\x01\x03\x12\x04\xd3\x19HZ\n\x10\
    \n\x06\x06\0\x02\xc1\x01\x04\x12\x06\xd4\x19\x04\xd9\x19\x06\n\x14\n\n\
    \x06\0\x02\xc1\x01\x04\xb0\xca\xbc\"\x12\x06\xd4\x19\x04\xd9\x19\x06\n\
    \x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xda\x19\x047\n\x11\n\t\x06\0\
    \x02\xc1\x01\x04\xc3\xf3\x04\x12\x04\xda\x19\x047\n\x0e\n\x06\x06\0\x02\
    \xc1\x01\x04\x12\x04\xdb\x19\x04?\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xdb\x19\x04?\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\
    \x04\xdc\x19\x04F\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xdc\x19\x04F\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xdd\x19\x04C\
    \n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x02\x12\x04\xdd\x19\x04C\n\
    \x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xde\x19\x04A\n\x12\n\n\x06\0\
    \x02\xc1\x01\x04\xc2\xf3\x04\x03\x12\x04\xde\x19\x04A\n\x0e\n\x06\x06\0\
    \x02\xc1\x01\x04\x12\x04\xdf\x19\x04@\n\x12\n\n\x06\0\x02\xc1\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xdf\x19\x04@\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\
    \x12\x04\xe0\x19\x04C\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xe0\x19\x04C\n\x93\x01\n\x05\x06\0\x02\xc2\x01\x12\x06\xe4\x19\
    \x02\xf1\x19\x03\x1a\x81\x01\x20PutTaskAssignments\x20evaluates\x20all\
    \x20the\x20annotations\x20by\x20labeler\x20(authenticated\x20user)\x20fo\
    r\x20given\x20task\x20(task_id)\x20and\x20input\x20(input_id).\n\n\x0e\n\
    \x06\x06\0\x02\xc2\x01\x01\x12\x04\xe4\x19\x06\x18\n\x0e\n\x06\x06\0\x02\
    \xc2\x01\x02\x12\x04\xe4\x19\x1a3\n\x0e\n\x06\x06\0\x02\xc2\x01\x03\x12\
    \x04\xe4\x19>^\n\x10\n\x06\x06\0\x02\xc2\x01\x04\x12\x06\xe5\x19\x04\xe8\
    \x19\x06\n\x14\n\n\x06\0\x02\xc2\x01\x04\xb0\xca\xbc\"\x12\x06\xe5\x19\
    \x04\xe8\x19\x06\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\xe9\x19\x047\
    \n\x11\n\t\x06\0\x02\xc2\x01\x04\xc3\xf3\x04\x12\x04\xe9\x19\x047\n\x0e\
    \n\x06\x06\0\x02\xc2\x01\x04\x12\x04\xea\x19\x04?\n\x12\n\n\x06\0\x02\
    \xc2\x01\x04\xc2\xf3\x04\0\x12\x04\xea\x19\x04?\n\x0e\n\x06\x06\0\x02\
    \xc2\x01\x04\x12\x04\xeb\x19\x04F\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xeb\x19\x04F\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\
    \x04\xec\x19\x04F\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xec\x19\x04F\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\xed\x19\x04C\
    \n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x03\x12\x04\xed\x19\x04C\n\
    \x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\xee\x19\x04A\n\x12\n\n\x06\0\
    \x02\xc2\x01\x04\xc2\xf3\x04\x04\x12\x04\xee\x19\x04A\n\x0e\n\x06\x06\0\
    \x02\xc2\x01\x04\x12\x04\xef\x19\x04@\n\x12\n\n\x06\0\x02\xc2\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\xef\x19\x04@\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\
    \x12\x04\xf0\x19\x04C\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\xf0\x19\x04C\n/\n\x05\x06\0\x02\xc3\x01\x12\x06\xf6\x19\x02\x80\
    \x1a\x03\x1a\x1e\x20List\x20all\x20the\x20inputs\x20add\x20jobs\n\n\x0e\
    \n\x06\x06\0\x02\xc3\x01\x01\x12\x04\xf6\x19\x06\x17\n\x0e\n\x06\x06\0\
    \x02\xc3\x01\x02\x12\x04\xf6\x19\x191\n\x0e\n\x06\x06\0\x02\xc3\x01\x03\
    \x12\x04\xf6\x19<U\n\x10\n\x06\x06\0\x02\xc3\x01\x04\x12\x06\xf7\x19\x04\
    \xfc\x19\x06\n\x14\n\n\x06\0\x02\xc3\x01\x04\xb0\xca\xbc\"\x12\x06\xf7\
    \x19\x04\xfc\x19\x06\n\x0e\n\x06\x06\0\x02\xc3\x01\x04\x12\x04\xfd\x19\
    \x047\n\x11\n\t\x06\0\x02\xc3\x01\x04\xc3\xf3\x04\x12\x04\xfd\x19\x047\n\
    \x0e\n\x06\x06\0\x02\xc3\x01\x04\x12\x04\xfe\x19\x04?\n\x12\n\n\x06\0\
    \x02\xc3\x01\x04\xc2\xf3\x04\0\x12\x04\xfe\x19\x04?\n\x0e\n\x06\x06\0\
    \x02\xc3\x01\x04\x12\x04\xff\x19\x04A\n\x12\n\n\x06\0\x02\xc3\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\xff\x19\x04A\n6\n\x05\x06\0\x02\xc4\x01\x12\x06\
    \x83\x1a\x02\x8d\x1a\x03\x1a%\x20Get\x20the\x20input\x20add\x20job\x20de\
    tails\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\xc4\x01\x01\x12\x04\x83\x1a\
    \x06\x15\n\x0e\n\x06\x06\0\x02\xc4\x01\x02\x12\x04\x83\x1a\x17-\n\x0e\n\
    \x06\x06\0\x02\xc4\x01\x03\x12\x04\x83\x1a8R\n\x10\n\x06\x06\0\x02\xc4\
    \x01\x04\x12\x06\x84\x1a\x04\x89\x1a\x06\n\x14\n\n\x06\0\x02\xc4\x01\x04\
    \xb0\xca\xbc\"\x12\x06\x84\x1a\x04\x89\x1a\x06\n\x0e\n\x06\x06\0\x02\xc4\
    \x01\x04\x12\x04\x8a\x1a\x047\n\x11\n\t\x06\0\x02\xc4\x01\x04\xc3\xf3\
    \x04\x12\x04\x8a\x1a\x047\n\x0e\n\x06\x06\0\x02\xc4\x01\x04\x12\x04\x8b\
    \x1a\x04?\n\x12\n\n\x06\0\x02\xc4\x01\x04\xc2\xf3\x04\0\x12\x04\x8b\x1a\
    \x04?\n\x0e\n\x06\x06\0\x02\xc4\x01\x04\x12\x04\x8c\x1a\x04A\n\x12\n\n\
    \x06\0\x02\xc4\x01\x04\xc2\xf3\x04\x01\x12\x04\x8c\x1a\x04A\n1\n\x05\x06\
    \0\x02\xc5\x01\x12\x06\x90\x1a\x02\x9d\x1a\x03\x1a\x20\x20cancel\x20the\
    \x20input\x20add\x20job\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\xc5\x01\x01\
    \x12\x04\x90\x1a\x06\x18\n\x0e\n\x06\x06\0\x02\xc5\x01\x02\x12\x04\x90\
    \x1a\x1a3\n\x0e\n\x06\x06\0\x02\xc5\x01\x03\x12\x04\x90\x1a>X\n\x10\n\
    \x06\x06\0\x02\xc5\x01\x04\x12\x06\x91\x1a\x04\x98\x1a\x06\n\x14\n\n\x06\
    \0\x02\xc5\x01\x04\xb0\xca\xbc\"\x12\x06\x91\x1a\x04\x98\x1a\x06\n\x0e\n\
    \x06\x06\0\x02\xc5\x01\x04\x12\x04\x99\x1a\x047\n\x11\n\t\x06\0\x02\xc5\
    \x01\x04\xc3\xf3\x04\x12\x04\x99\x1a\x047\n\x0e\n\x06\x06\0\x02\xc5\x01\
    \x04\x12\x04\x9a\x1a\x04?\n\x12\n\n\x06\0\x02\xc5\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x9a\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc5\x01\x04\x12\x04\x9b\x1a\
    \x04A\n\x12\n\n\x06\0\x02\xc5\x01\x04\xc2\xf3\x04\x01\x12\x04\x9b\x1a\
    \x04A\n\x0e\n\x06\x06\0\x02\xc5\x01\x04\x12\x04\x9c\x1a\x04A\n\x12\n\n\
    \x06\0\x02\xc5\x01\x04\xc2\xf3\x04\x02\x12\x04\x9c\x1a\x04A\n\x0f\n\x05\
    \x06\0\x02\xc6\x01\x12\x06\x9f\x1a\x02\xac\x1a\x03\n\x0e\n\x06\x06\0\x02\
    \xc6\x01\x01\x12\x04\x9f\x1a\x06\x11\n\x0e\n\x06\x06\0\x02\xc6\x01\x02\
    \x12\x04\x9f\x1a\x13%\n\x0e\n\x06\x06\0\x02\xc6\x01\x03\x12\x04\x9f\x1a0\
    C\n\x10\n\x06\x06\0\x02\xc6\x01\x04\x12\x06\xa0\x1a\x04\xa7\x1a\x06\n\
    \x14\n\n\x06\0\x02\xc6\x01\x04\xb0\xca\xbc\"\x12\x06\xa0\x1a\x04\xa7\x1a\
    \x06\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\xa8\x1a\x047\n\x11\n\t\
    \x06\0\x02\xc6\x01\x04\xc3\xf3\x04\x12\x04\xa8\x1a\x047\n\x0e\n\x06\x06\
    \0\x02\xc6\x01\x04\x12\x04\xa9\x1a\x04?\n\x12\n\n\x06\0\x02\xc6\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xa9\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\
    \x12\x04\xaa\x1a\x04B\n\x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xaa\x1a\x04B\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\xab\x1a\
    \x04B\n\x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\x02\x12\x04\xab\x1a\
    \x04B\n\x8e\x01\n\x05\x06\0\x02\xc7\x01\x12\x06\xb0\x1a\x02\xbc\x1a\x03\
    \x1a}\x20Upload\x20a\x20part\x20of\x20a\x20multipart\x20upload.\n\x20Beh\
    aviour\x20on\x20completion\x20depends\x20on\x20the\x20endpoint\x20that\
    \x20was\x20used\x20to\x20initiate\x20the\x20upload.\n\n\x0e\n\x06\x06\0\
    \x02\xc7\x01\x01\x12\x04\xb0\x1a\x06\x1b\n\x0e\n\x06\x06\0\x02\xc7\x01\
    \x02\x12\x04\xb0\x1a\x1d9\n\x0e\n\x06\x06\0\x02\xc7\x01\x03\x12\x04\xb0\
    \x1aDX\n\x10\n\x06\x06\0\x02\xc7\x01\x04\x12\x06\xb1\x1a\x04\xb7\x1a\x06\
    \n\x14\n\n\x06\0\x02\xc7\x01\x04\xb0\xca\xbc\"\x12\x06\xb1\x1a\x04\xb7\
    \x1a\x06\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xb8\x1a\x047\n\x11\n\
    \t\x06\0\x02\xc7\x01\x04\xc3\xf3\x04\x12\x04\xb8\x1a\x047\n\x0e\n\x06\
    \x06\0\x02\xc7\x01\x04\x12\x04\xb9\x1a\x04?\n\x12\n\n\x06\0\x02\xc7\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xb9\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc7\x01\
    \x04\x12\x04\xba\x1a\x04B\n\x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xba\x1a\x04B\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xbb\
    \x1a\x04B\n\x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\x02\x12\x04\xbb\
    \x1a\x04B\n\x0f\n\x05\x06\0\x02\xc8\x01\x12\x06\xbe\x1a\x02\xc8\x1a\x03\
    \n\x0e\n\x06\x06\0\x02\xc8\x01\x01\x12\x04\xbe\x1a\x06\x0f\n\x0e\n\x06\
    \x06\0\x02\xc8\x01\x02\x12\x04\xbe\x1a\x11!\n\x0e\n\x06\x06\0\x02\xc8\
    \x01\x03\x12\x04\xbe\x1a,@\n\x10\n\x06\x06\0\x02\xc8\x01\x04\x12\x06\xbf\
    \x1a\x04\xc4\x1a\x06\n\x14\n\n\x06\0\x02\xc8\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xbf\x1a\x04\xc4\x1a\x06\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\x04\
    \xc5\x1a\x047\n\x11\n\t\x06\0\x02\xc8\x01\x04\xc3\xf3\x04\x12\x04\xc5\
    \x1a\x047\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\x04\xc6\x1a\x04?\n\x12\n\
    \n\x06\0\x02\xc8\x01\x04\xc2\xf3\x04\0\x12\x04\xc6\x1a\x04?\n\x0e\n\x06\
    \x06\0\x02\xc8\x01\x04\x12\x04\xc7\x1a\x04B\n\x12\n\n\x06\0\x02\xc8\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xc7\x1a\x04B\n\x0f\n\x05\x06\0\x02\xc9\x01\
    \x12\x06\xca\x1a\x02\xd4\x1a\x03\n\x0e\n\x06\x06\0\x02\xc9\x01\x01\x12\
    \x04\xca\x1a\x06\x11\n\x0e\n\x06\x06\0\x02\xc9\x01\x02\x12\x04\xca\x1a\
    \x13%\n\x0e\n\x06\x06\0\x02\xc9\x01\x03\x12\x04\xca\x1a0C\n\x10\n\x06\
    \x06\0\x02\xc9\x01\x04\x12\x06\xcb\x1a\x04\xd0\x1a\x06\n\x14\n\n\x06\0\
    \x02\xc9\x01\x04\xb0\xca\xbc\"\x12\x06\xcb\x1a\x04\xd0\x1a\x06\n\x0e\n\
    \x06\x06\0\x02\xc9\x01\x04\x12\x04\xd1\x1a\x047\n\x11\n\t\x06\0\x02\xc9\
    \x01\x04\xc3\xf3\x04\x12\x04\xd1\x1a\x047\n\x0e\n\x06\x06\0\x02\xc9\x01\
    \x04\x12\x04\xd2\x1a\x04?\n\x12\n\n\x06\0\x02\xc9\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xd2\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc9\x01\x04\x12\x04\xd3\x1a\
    \x04B\n\x12\n\n\x06\0\x02\xc9\x01\x04\xc2\xf3\x04\x01\x12\x04\xd3\x1a\
    \x04B\n\x0f\n\x05\x06\0\x02\xca\x01\x12\x06\xd6\x1a\x02\xe4\x1a\x03\n\
    \x0e\n\x06\x06\0\x02\xca\x01\x01\x12\x04\xd6\x1a\x06\x13\n\x0e\n\x06\x06\
    \0\x02\xca\x01\x02\x12\x04\xd6\x1a\x15)\n\x0e\n\x06\x06\0\x02\xca\x01\
    \x03\x12\x04\xd6\x1a4T\n\x10\n\x06\x06\0\x02\xca\x01\x04\x12\x06\xd7\x1a\
    \x04\xde\x1a\x06\n\x14\n\n\x06\0\x02\xca\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xd7\x1a\x04\xde\x1a\x06\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xdf\
    \x1a\x047\n\x11\n\t\x06\0\x02\xca\x01\x04\xc3\xf3\x04\x12\x04\xdf\x1a\
    \x047\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xe0\x1a\x04?\n\x12\n\n\
    \x06\0\x02\xca\x01\x04\xc2\xf3\x04\0\x12\x04\xe0\x1a\x04?\n\x0e\n\x06\
    \x06\0\x02\xca\x01\x04\x12\x04\xe1\x1a\x04B\n\x12\n\n\x06\0\x02\xca\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xe1\x1a\x04B\n\x0e\n\x06\x06\0\x02\xca\x01\
    \x04\x12\x04\xe2\x1a\x04B\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xe2\x1a\x04B\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xe3\
    \x1a\x04E\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\x03\x12\x04\xe3\
    \x1a\x04E\n\xaf\x06\n\x05\x06\0\x02\xcb\x01\x12\x06\xf3\x1a\x02\x86\x1b\
    \x03\x1a\x9d\x06\x20Initiates\x20retrieval\x20of\x20inputs\x20from\x20cl\
    oud\x20storage\x20from\x20a\x20user\x20provided\x20data\x20source.\n\x20\
    Will\x20create\x20and\x20return\x20an\x20inputs-add-job\x20for\x20tracki\
    ng\x20progress.\n\x20Archives\x20will\x20be\x20extracted\x20and\x20their\
    \x20contents\x20will\x20be\x20processed\x20as\x20inputs.\n\n\x20The\x20c\
    loud\x20URL\x20will\x20be\x20treated\x20as\x20a\x20filter\x20prefix.\x20\
    For\x20example\x20s3:/bucket/images_folder/abc\x20will\x20process\n\x20f\
    iles\x20in\x20the\x20images_folder\x20beginning\x20with\x20abc\x20or\x20\
    in\x20a\x20subfolder\x20beginning\x20with\x20abc.\n\x20For\x20example:\n\
    \x20bucket/images_folder/abcImage.png\n\x20bucket/images_folder/abc-1/Da\
    ta.zip\n\n\x20If\x20given\x20URL\x20is\x20for\x20a\x20private\x20bucket\
    \x20or\x20file,\x20then\x20credentials\x20should\x20be\x20provided\x20to\
    \x20access\x20the\x20bucket.\n\x20Credentials\x20should\x20include\x20ri\
    ghts\x20to\x20list\x20the\x20objects\x20in\x20the\x20bucket,\x20except\
    \x20when\x20pointed\x20directly\x20at\x20a\x20file\x20archive,\n\x20in\
    \x20which\x20case\x20it\x20only\x20requires\x20rights\x20to\x20access\
    \x20that\x20particular\x20file.\n\n\x0e\n\x06\x06\0\x02\xcb\x01\x01\x12\
    \x04\xf3\x1a\x06\x1b\n\x0e\n\x06\x06\0\x02\xcb\x01\x02\x12\x04\xf3\x1a\
    \x1d9\n\x0e\n\x06\x06\0\x02\xcb\x01\x03\x12\x04\xf3\x1aD]\n\x10\n\x06\
    \x06\0\x02\xcb\x01\x04\x12\x06\xf4\x1a\x04\xfb\x1a\x06\n\x14\n\n\x06\0\
    \x02\xcb\x01\x04\xb0\xca\xbc\"\x12\x06\xf4\x1a\x04\xfb\x1a\x06\n\x0e\n\
    \x06\x06\0\x02\xcb\x01\x04\x12\x04\xfc\x1a\x047\n\x11\n\t\x06\0\x02\xcb\
    \x01\x04\xc3\xf3\x04\x12\x04\xfc\x1a\x047\n\x0e\n\x06\x06\0\x02\xcb\x01\
    \x04\x12\x04\xfd\x1a\x04?\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xfd\x1a\x04?\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\xfe\x1a\
    \x04F\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\x01\x12\x04\xfe\x1a\
    \x04F\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\xff\x1a\x04F\n\x12\n\n\
    \x06\0\x02\xcb\x01\x04\xc2\xf3\x04\x02\x12\x04\xff\x1a\x04F\n\x0e\n\x06\
    \x06\0\x02\xcb\x01\x04\x12\x04\x80\x1b\x04C\n\x12\n\n\x06\0\x02\xcb\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\x80\x1b\x04C\n\x0e\n\x06\x06\0\x02\xcb\x01\
    \x04\x12\x04\x81\x1b\x04A\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\
    \x04\x12\x04\x81\x1b\x04A\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\x82\
    \x1b\x04A\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\x05\x12\x04\x82\
    \x1b\x04A\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\x83\x1b\x04A\n\x12\n\
    \n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\x06\x12\x04\x83\x1b\x04A\n\x0e\n\
    \x06\x06\0\x02\xcb\x01\x04\x12\x04\x84\x1b\x04>\n\x12\n\n\x06\0\x02\xcb\
    \x01\x04\xc2\xf3\x04\x07\x12\x04\x84\x1b\x04>\n\x0e\n\x06\x06\0\x02\xcb\
    \x01\x04\x12\x04\x85\x1b\x04D\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\
    \x04\x08\x12\x04\x85\x1b\x04D\n=\n\x05\x06\0\x02\xcc\x01\x12\x06\x89\x1b\
    \x02\x93\x1b\x03\x1a,\x20Get\x20the\x20input\x20extraction\x20job\x20det\
    ails\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\xcc\x01\x01\x12\x04\x89\x1b\x06\
    \x1c\n\x0e\n\x06\x06\0\x02\xcc\x01\x02\x12\x04\x89\x1b\x1e;\n\x0e\n\x06\
    \x06\0\x02\xcc\x01\x03\x12\x04\x89\x1bFg\n\x10\n\x06\x06\0\x02\xcc\x01\
    \x04\x12\x06\x8a\x1b\x04\x8f\x1b\x06\n\x14\n\n\x06\0\x02\xcc\x01\x04\xb0\
    \xca\xbc\"\x12\x06\x8a\x1b\x04\x8f\x1b\x06\n\x0e\n\x06\x06\0\x02\xcc\x01\
    \x04\x12\x04\x90\x1b\x047\n\x11\n\t\x06\0\x02\xcc\x01\x04\xc3\xf3\x04\
    \x12\x04\x90\x1b\x047\n\x0e\n\x06\x06\0\x02\xcc\x01\x04\x12\x04\x91\x1b\
    \x04?\n\x12\n\n\x06\0\x02\xcc\x01\x04\xc2\xf3\x04\0\x12\x04\x91\x1b\x04?\
    \n\x0e\n\x06\x06\0\x02\xcc\x01\x04\x12\x04\x92\x1b\x04A\n\x12\n\n\x06\0\
    \x02\xcc\x01\x04\xc2\xf3\x04\x01\x12\x04\x92\x1b\x04A\n5\n\x05\x06\0\x02\
    \xcd\x01\x12\x06\x96\x1b\x02\xa0\x1b\x03\x1a$\x20List\x20all\x20the\x20i\
    nput\x20extraction\x20jobs\n\n\x0e\n\x06\x06\0\x02\xcd\x01\x01\x12\x04\
    \x96\x1b\x06\x1e\n\x0e\n\x06\x06\0\x02\xcd\x01\x02\x12\x04\x96\x1b\x20?\
    \n\x0e\n\x06\x06\0\x02\xcd\x01\x03\x12\x04\x96\x1bJj\n\x10\n\x06\x06\0\
    \x02\xcd\x01\x04\x12\x06\x97\x1b\x04\x9c\x1b\x06\n\x14\n\n\x06\0\x02\xcd\
    \x01\x04\xb0\xca\xbc\"\x12\x06\x97\x1b\x04\x9c\x1b\x06\n\x0e\n\x06\x06\0\
    \x02\xcd\x01\x04\x12\x04\x9d\x1b\x047\n\x11\n\t\x06\0\x02\xcd\x01\x04\
    \xc3\xf3\x04\x12\x04\x9d\x1b\x047\n\x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\
    \x04\x9e\x1b\x04?\n\x12\n\n\x06\0\x02\xcd\x01\x04\xc2\xf3\x04\0\x12\x04\
    \x9e\x1b\x04?\n\x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\x04\x9f\x1b\x04A\n\
    \x12\n\n\x06\0\x02\xcd\x01\x04\xc2\xf3\x04\x01\x12\x04\x9f\x1b\x04A\n\
    \x0f\n\x05\x06\0\x02\xce\x01\x12\x06\xa2\x1b\x02\xaf\x1b\x03\n\x0e\n\x06\
    \x06\0\x02\xce\x01\x01\x12\x04\xa2\x1b\x06\x20\n\x0e\n\x06\x06\0\x02\xce\
    \x01\x02\x12\x04\xa2\x1b\"C\n\x0e\n\x06\x06\0\x02\xce\x01\x03\x12\x04\
    \xa2\x1bNn\n\x10\n\x06\x06\0\x02\xce\x01\x04\x12\x06\xa3\x1b\x04\xaa\x1b\
    \x06\n\x14\n\n\x06\0\x02\xce\x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x1b\x04\
    \xaa\x1b\x06\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xab\x1b\x047\n\
    \x11\n\t\x06\0\x02\xce\x01\x04\xc3\xf3\x04\x12\x04\xab\x1b\x047\n\x0e\n\
    \x06\x06\0\x02\xce\x01\x04\x12\x04\xac\x1b\x04?\n\x12\n\n\x06\0\x02\xce\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xac\x1b\x04?\n\x0e\n\x06\x06\0\x02\xce\
    \x01\x04\x12\x04\xad\x1b\x04A\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xad\x1b\x04A\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\
    \xae\x1b\x04A\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xae\x1b\x04A\n\xe8\x02\n\x05\x06\0\x02\xcf\x01\x12\x06\xb6\x1b\x02\xcb\
    \x1b\x03\x1a\xd6\x02\x20Start\x20uploading\x20a\x20file\x20archive\x20co\
    ntaining\x20inputs.\n\x20Will\x20create\x20and\x20return\x20an\x20inputs\
    -add-job\x20for\x20tracking\x20progress.\n\n\x20Associated\x20inputs-add\
    -job\x20contains\x20an\x20upload\x20id\x20which\x20should\x20be\x20compl\
    eted\x20through\x20`PutUploadContentParts`\x20endpoint.\n\x20Completing\
    \x20the\x20upload\x20will\x20automatically\x20begin\x20unpacking\x20the\
    \x20archive\x20and\x20uploading\x20the\x20contents\x20as\x20inputs.\n\n\
    \x0e\n\x06\x06\0\x02\xcf\x01\x01\x12\x04\xb6\x1b\x06\x17\n\x0e\n\x06\x06\
    \0\x02\xcf\x01\x02\x12\x04\xb6\x1b\x191\n\x0e\n\x06\x06\0\x02\xcf\x01\
    \x03\x12\x04\xb6\x1b<U\n\x10\n\x06\x06\0\x02\xcf\x01\x04\x12\x06\xb7\x1b\
    \x04\xbe\x1b\x06\n\x14\n\n\x06\0\x02\xcf\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xb7\x1b\x04\xbe\x1b\x06\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xbf\
    \x1b\x047\n\x11\n\t\x06\0\x02\xcf\x01\x04\xc3\xf3\x04\x12\x04\xbf\x1b\
    \x047\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xc0\x1b\x04?\n\x12\n\n\
    \x06\0\x02\xcf\x01\x04\xc2\xf3\x04\0\x12\x04\xc0\x1b\x04?\n\x0e\n\x06\
    \x06\0\x02\xcf\x01\x04\x12\x04\xc1\x1b\x04F\n\x12\n\n\x06\0\x02\xcf\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xc1\x1b\x04F\n\x0e\n\x06\x06\0\x02\xcf\x01\
    \x04\x12\x04\xc2\x1b\x04F\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xc2\x1b\x04F\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xc3\
    \x1b\x04C\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\x03\x12\x04\xc3\
    \x1b\x04C\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xc4\x1b\x04A\n\x12\n\
    \n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\x04\x12\x04\xc4\x1b\x04A\n\x0e\n\
    \x06\x06\0\x02\xcf\x01\x04\x12\x04\xc5\x1b\x04A\n\x12\n\n\x06\0\x02\xcf\
    \x01\x04\xc2\xf3\x04\x05\x12\x04\xc5\x1b\x04A\n\x0e\n\x06\x06\0\x02\xcf\
    \x01\x04\x12\x04\xc6\x1b\x04A\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\
    \x04\x06\x12\x04\xc6\x1b\x04A\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\
    \xc7\x1b\x04>\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\x07\x12\x04\
    \xc7\x1b\x04>\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xc8\x1b\x04D\n\
    \x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\x08\x12\x04\xc8\x1b\x04D\n\
    \x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xc9\x1b\x04B\n\x12\n\n\x06\0\
    \x02\xcf\x01\x04\xc2\xf3\x04\t\x12\x04\xc9\x1b\x04B\n\x0e\n\x06\x06\0\
    \x02\xcf\x01\x04\x12\x04\xca\x1b\x04B\n\x12\n\n\x06\0\x02\xcf\x01\x04\
    \xc2\xf3\x04\n\x12\x04\xca\x1b\x04B\n5\n\x05\x06\0\x02\xd0\x01\x12\x06\
    \xd0\x1b\x02\xd7\x1b\x03\x1a$\x20Get\x20a\x20specific\x20runner\x20from\
    \x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xd0\x01\x01\x12\x04\xd0\x1b\x06\
    \x0f\n\x0e\n\x06\x06\0\x02\xd0\x01\x02\x12\x04\xd0\x1b\x11!\n\x0e\n\x06\
    \x06\0\x02\xd0\x01\x03\x12\x04\xd0\x1b,@\n\x10\n\x06\x06\0\x02\xd0\x01\
    \x04\x12\x06\xd1\x1b\x04\xd3\x1b\x06\n\x14\n\n\x06\0\x02\xd0\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xd1\x1b\x04\xd3\x1b\x06\n\x0e\n\x06\x06\0\x02\xd0\x01\
    \x04\x12\x04\xd4\x1b\x047\n\x11\n\t\x06\0\x02\xd0\x01\x04\xc3\xf3\x04\
    \x12\x04\xd4\x1b\x047\n\x0e\n\x06\x06\0\x02\xd0\x01\x04\x12\x04\xd5\x1b\
    \x04?\n\x12\n\n\x06\0\x02\xd0\x01\x04\xc2\xf3\x04\0\x12\x04\xd5\x1b\x04?\
    \n\x0e\n\x06\x06\0\x02\xd0\x01\x04\x12\x04\xd6\x1b\x04B\n\x12\n\n\x06\0\
    \x02\xd0\x01\x04\xc2\xf3\x04\x01\x12\x04\xd6\x1b\x04B\nH\n\x05\x06\0\x02\
    \xd1\x01\x12\x06\xda\x1b\x02\xe1\x1b\x03\x1a7\x20List\x20all\x20the\x20r\
    unners\x20in\x20community,\x20by\x20user\x20or\x20by\x20app.\n\n\x0e\n\
    \x06\x06\0\x02\xd1\x01\x01\x12\x04\xda\x1b\x06\x11\n\x0e\n\x06\x06\0\x02\
    \xd1\x01\x02\x12\x04\xda\x1b\x13%\n\x0e\n\x06\x06\0\x02\xd1\x01\x03\x12\
    \x04\xda\x1b0C\n\x10\n\x06\x06\0\x02\xd1\x01\x04\x12\x06\xdb\x1b\x04\xdd\
    \x1b\x06\n\x14\n\n\x06\0\x02\xd1\x01\x04\xb0\xca\xbc\"\x12\x06\xdb\x1b\
    \x04\xdd\x1b\x06\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\xde\x1b\x047\
    \n\x11\n\t\x06\0\x02\xd1\x01\x04\xc3\xf3\x04\x12\x04\xde\x1b\x047\n\x0e\
    \n\x06\x06\0\x02\xd1\x01\x04\x12\x04\xdf\x1b\x04?\n\x12\n\n\x06\0\x02\
    \xd1\x01\x04\xc2\xf3\x04\0\x12\x04\xdf\x1b\x04?\n\x0e\n\x06\x06\0\x02\
    \xd1\x01\x04\x12\x04\xe0\x1b\x04B\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xe0\x1b\x04B\n+\n\x05\x06\0\x02\xd2\x01\x12\x06\xe4\
    \x1b\x02\xed\x1b\x03\x1a\x1a\x20Add\x20a\x20runners\x20to\x20an\x20app.\
    \n\n\x0e\n\x06\x06\0\x02\xd2\x01\x01\x12\x04\xe4\x1b\x06\x11\n\x0e\n\x06\
    \x06\0\x02\xd2\x01\x02\x12\x04\xe4\x1b\x13%\n\x0e\n\x06\x06\0\x02\xd2\
    \x01\x03\x12\x04\xe4\x1b0C\n\x10\n\x06\x06\0\x02\xd2\x01\x04\x12\x06\xe5\
    \x1b\x04\xe8\x1b\x06\n\x14\n\n\x06\0\x02\xd2\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xe5\x1b\x04\xe8\x1b\x06\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\x12\x04\
    \xe9\x1b\x047\n\x11\n\t\x06\0\x02\xd2\x01\x04\xc3\xf3\x04\x12\x04\xe9\
    \x1b\x047\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\x12\x04\xea\x1b\x04?\n\x12\n\
    \n\x06\0\x02\xd2\x01\x04\xc2\xf3\x04\0\x12\x04\xea\x1b\x04?\n\x0e\n\x06\
    \x06\0\x02\xd2\x01\x04\x12\x04\xeb\x1b\x04B\n\x12\n\n\x06\0\x02\xd2\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xeb\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd2\x01\
    \x04\x12\x04\xec\x1b\x04B\n\x12\n\n\x06\0\x02\xd2\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xec\x1b\x04B\n:\n\x05\x06\0\x02\xd3\x01\x12\x06\xf0\x1b\x02\
    \xfa\x1b\x03\x1a)\x20Delete\x20multiple\x20runners\x20in\x20one\x20reque\
    st.\n\n\x0e\n\x06\x06\0\x02\xd3\x01\x01\x12\x04\xf0\x1b\x06\x13\n\x0e\n\
    \x06\x06\0\x02\xd3\x01\x02\x12\x04\xf0\x1b\x15)\n\x0e\n\x06\x06\0\x02\
    \xd3\x01\x03\x12\x04\xf0\x1b4T\n\x10\n\x06\x06\0\x02\xd3\x01\x04\x12\x06\
    \xf1\x1b\x04\xf4\x1b\x06\n\x14\n\n\x06\0\x02\xd3\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xf1\x1b\x04\xf4\x1b\x06\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\
    \x04\xf5\x1b\x047\n\x11\n\t\x06\0\x02\xd3\x01\x04\xc3\xf3\x04\x12\x04\
    \xf5\x1b\x047\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\x04\xf6\x1b\x04?\n\
    \x12\n\n\x06\0\x02\xd3\x01\x04\xc2\xf3\x04\0\x12\x04\xf6\x1b\x04?\n\x0e\
    \n\x06\x06\0\x02\xd3\x01\x04\x12\x04\xf7\x1b\x04B\n\x12\n\n\x06\0\x02\
    \xd3\x01\x04\xc2\xf3\x04\x01\x12\x04\xf7\x1b\x04B\n\x0e\n\x06\x06\0\x02\
    \xd3\x01\x04\x12\x04\xf8\x1b\x04B\n\x12\n\n\x06\0\x02\xd3\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xf8\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\
    \x04\xf9\x1b\x04E\n\x12\n\n\x06\0\x02\xd3\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xf9\x1b\x04E\n?\n\x05\x06\0\x02\xd4\x01\x12\x06\xfd\x1b\x02\x85\x1c\
    \x03\x1a.\x20List\x20items\x20for\x20the\x20remote\x20runner\x20to\x20wo\
    rk\x20on.\n\n\x0e\n\x06\x06\0\x02\xd4\x01\x01\x12\x04\xfd\x1b\x06\x15\n\
    \x0e\n\x06\x06\0\x02\xd4\x01\x02\x12\x04\xfd\x1b\x17-\n\x0e\n\x06\x06\0\
    \x02\xd4\x01\x03\x12\x04\xfd\x1b8O\n\x10\n\x06\x06\0\x02\xd4\x01\x04\x12\
    \x06\xfe\x1b\x04\x80\x1c\x06\n\x14\n\n\x06\0\x02\xd4\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xfe\x1b\x04\x80\x1c\x06\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\
    \x04\x81\x1c\x047\n\x11\n\t\x06\0\x02\xd4\x01\x04\xc3\xf3\x04\x12\x04\
    \x81\x1c\x047\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\x04\x82\x1c\x04?\n\
    \x12\n\n\x06\0\x02\xd4\x01\x04\xc2\xf3\x04\0\x12\x04\x82\x1c\x04?\n\x0e\
    \n\x06\x06\0\x02\xd4\x01\x04\x12\x04\x83\x1c\x04B\n\x12\n\n\x06\0\x02\
    \xd4\x01\x04\xc2\xf3\x04\x01\x12\x04\x83\x1c\x04B\n\x0e\n\x06\x06\0\x02\
    \xd4\x01\x04\x12\x04\x84\x1c\x04F\n\x12\n\n\x06\0\x02\xd4\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\x84\x1c\x04F\n8\n\x05\x06\0\x02\xd5\x01\x12\x06\x88\
    \x1c\x02\x92\x1c\x03\x1a'\x20Post\x20back\x20outputs\x20from\x20remote\
    \x20runners\n\n\x0e\n\x06\x06\0\x02\xd5\x01\x01\x12\x04\x88\x1c\x06\x1b\
    \n\x0e\n\x06\x06\0\x02\xd5\x01\x02\x12\x04\x88\x1c\x1d9\n\x0e\n\x06\x06\
    \0\x02\xd5\x01\x03\x12\x04\x88\x1cDa\n\x10\n\x06\x06\0\x02\xd5\x01\x04\
    \x12\x06\x89\x1c\x04\x8c\x1c\x06\n\x14\n\n\x06\0\x02\xd5\x01\x04\xb0\xca\
    \xbc\"\x12\x06\x89\x1c\x04\x8c\x1c\x06\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\
    \x12\x04\x8d\x1c\x047\n\x11\n\t\x06\0\x02\xd5\x01\x04\xc3\xf3\x04\x12\
    \x04\x8d\x1c\x047\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\x8e\x1c\x04?\
    \n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\0\x12\x04\x8e\x1c\x04?\n\
    \x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\x8f\x1c\x04B\n\x12\n\n\x06\0\
    \x02\xd5\x01\x04\xc2\xf3\x04\x01\x12\x04\x8f\x1c\x04B\n\x0e\n\x06\x06\0\
    \x02\xd5\x01\x04\x12\x04\x90\x1c\x04F\n\x12\n\n\x06\0\x02\xd5\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\x90\x1c\x04F\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\
    \x12\x04\x91\x1c\x04F\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\x91\x1c\x04F\n\x0f\n\x05\x06\0\x02\xd6\x01\x12\x06\x93\x1c\x02\
    \x9f\x1c\x03\n\x0e\n\x06\x06\0\x02\xd6\x01\x01\x12\x04\x93\x1c\x06+\n\
    \x0e\n\x06\x06\0\x02\xd6\x01\x02\x12\x04\x93\x1c-Y\n\x0f\n\x06\x06\0\x02\
    \xd6\x01\x03\x12\x05\x93\x1cd\x85\x01\n\x10\n\x06\x06\0\x02\xd6\x01\x04\
    \x12\x06\x94\x1c\x04\x9b\x1c\x06\n\x14\n\n\x06\0\x02\xd6\x01\x04\xb0\xca\
    \xbc\"\x12\x06\x94\x1c\x04\x9b\x1c\x06\n\x0e\n\x06\x06\0\x02\xd6\x01\x04\
    \x12\x04\x9c\x1c\x047\n\x11\n\t\x06\0\x02\xd6\x01\x04\xc3\xf3\x04\x12\
    \x04\x9c\x1c\x047\n\x0e\n\x06\x06\0\x02\xd6\x01\x04\x12\x04\x9d\x1c\x04?\
    \n\x12\n\n\x06\0\x02\xd6\x01\x04\xc2\xf3\x04\0\x12\x04\x9d\x1c\x04?\n\
    \x0e\n\x06\x06\0\x02\xd6\x01\x04\x12\x04\x9e\x1c\x04A\n\x12\n\n\x06\0\
    \x02\xd6\x01\x04\xc2\xf3\x04\x01\x12\x04\x9e\x1c\x04A\n-\n\x02\x04\0\x12\
    \x06\xa7\x1c\0\xac\x1c\x01\x1a\x1f\x20Split\x20the\x20results\x20into\
    \x20pages.\n\n\x0b\n\x03\x04\0\x01\x12\x04\xa7\x1c\x08\x12\n}\n\x04\x04\
    \0\x02\0\x12\x04\xa9\x1c\x02\x12\x1ao\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\x20Defaults\x20to\x201.\n\n\r\n\
    \x05\x04\0\x02\0\x05\x12\x04\xa9\x1c\x02\x08\n\r\n\x05\x04\0\x02\0\x01\
    \x12\x04\xa9\x1c\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xa9\x1c\x10\x11\n\
    t\n\x04\x04\0\x02\x01\x12\x04\xab\x1c\x02\x16\x1af\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\x20to\x20128.\n\n\r\n\
    \x05\x04\0\x02\x01\x05\x12\x04\xab\x1c\x02\x08\n\r\n\x05\x04\0\x02\x01\
    \x01\x12\x04\xab\x1c\t\x11\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xab\x1c\
    \x14\x15\n$\n\x02\x04\x01\x12\x06\xaf\x1c\0\xb3\x1c\x01\x1a\x16\x20GetAn\
    notationRequest\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xaf\x1c\x08\x1c\n\x0c\
    \n\x04\x04\x01\x02\0\x12\x04\xb0\x1c\x02,\n\r\n\x05\x04\x01\x02\0\x06\
    \x12\x04\xb0\x1c\x02\x1b\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xb0\x1c\x1c\
    '\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xb0\x1c*+\n\x0c\n\x04\x04\x01\x02\
    \x01\x12\x04\xb1\x1c\x02\x1b\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xb1\
    \x1c\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xb1\x1c\t\x16\n\r\n\
    \x05\x04\x01\x02\x01\x03\x12\x04\xb1\x1c\x19\x1a\n\x0c\n\x04\x04\x01\x02\
    \x02\x12\x04\xb2\x1c\x02\x16\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xb2\
    \x1c\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xb2\x1c\t\x11\n\r\n\
    \x05\x04\x01\x02\x02\x03\x12\x04\xb2\x1c\x14\x15\n&\n\x02\x04\x02\x12\
    \x06\xb6\x1c\0\xe8\x1c\x01\x1a\x18\x20ListAnnotationsRequest\n\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\xb6\x1c\x08\x1e\n\x0b\n\x03\x04\x02\t\x12\x04\
    \xb7\x1c\x02\r\n\x0c\n\x04\x04\x02\t\0\x12\x04\xb7\x1c\x0b\x0c\n\r\n\x05\
    \x04\x02\t\0\x01\x12\x04\xb7\x1c\x0b\x0c\n\r\n\x05\x04\x02\t\0\x02\x12\
    \x04\xb7\x1c\x0b\x0c\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xb9\x1c\x02,\n\r\
    \n\x05\x04\x02\x02\0\x06\x12\x04\xb9\x1c\x02\x1b\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\xb9\x1c\x1c'\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xb9\x1c*+\
    \n.\n\x04\x04\x02\x02\x01\x12\x04\xbc\x1c\x02\x1a\x1a\x20\x20List\x20ann\
    otations\x20for\x20these\x20IDs\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\
    \xbc\x1c\x02\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xbc\x1c\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x01\x01\x12\x04\xbc\x1c\x12\x15\n\r\n\x05\x04\x02\x02\
    \x01\x03\x12\x04\xbc\x1c\x18\x19\n\xd5\x02\n\x04\x04\x02\x02\x02\x12\x04\
    \xc3\x1c\x02\x20\x1a\xc6\x02\x20List\x20annotations\x20for\x20these\x20I\
    nput\x20IDs\n\x20Note\x20that\x20'ids'\x20are\x20optional\x20but\x20if\
    \x20the\x20are\x20provided\x20the\x20number\x20and\x20order\x20in\n\x20'\
    ids'\x20and\x20'input_ids'\x20should\x20match\n\x20If\x20you\x20do\x20no\
    t\x20specify\x20'ids'\x20all\x20the\x20annotations\x20for\x20'input_ids'\
    \x20are\x20returned\n\x20If\x20a\x20you\x20do\x20not\x20specify\x20both\
    \x20'input_ids'\x20and\x20'ids'\x20all\x20the\x20annotations\x20in\x20th\
    e\x20app\x20are\x20returned\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\xc3\
    \x1c\x02\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\xc3\x1c\x0b\x11\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\xc3\x1c\x12\x1b\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\xc3\x1c\x1e\x1f\n\xe6\x03\n\x04\x04\x02\x02\x03\x12\x04\
    \xcb\x1c\x02\x1f\x1a\xd7\x03\x20Only\x20return\x20the\x20annotations\x20\
    that\x20has\x20one\x20of\x20these\x20user\x20IDs,\x20effectively\x20oper\
    ating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20th\
    e\x20results.\n\x20If\x20model_version_ids\x20are\x20also\x20provided\
    \x20these\x20user_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20si\
    nce\n\x20annotations\x20are\x20either\x20provided\x20by\x20users\x20or\
    \x20model\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\x20any\
    \n\x20provided\x20user\x20or\x20model\x20version\x20annotations\x20in\
    \x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20If\x20no\
    \x20user_ids\x20are\x20provided\x20then\x20annotations\x20from\x20all\
    \x20users\x20are\x20returned.\n\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\
    \xcb\x1c\x02\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xcb\x1c\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x03\x01\x12\x04\xcb\x1c\x12\x1a\n\r\n\x05\x04\x02\x02\
    \x03\x03\x12\x04\xcb\x1c\x1d\x1e\n\x82\x04\n\x04\x04\x02\x02\x04\x12\x04\
    \xd3\x1c\x02)\x1a\xf3\x03\x20Only\x20return\x20the\x20annotations\x20tha\
    t\x20has\x20one\x20of\x20these\x20model\x20version\x20IDs,\x20effectivel\
    y\x20operating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20d\
    own\x20the\x20results.\n\x20If\x20user_ids\x20are\x20also\x20provided\
    \x20these\x20model_versions_ids\x20are\x20OR'd\x20with\x20them\x20as\x20\
    well\x20since\n\x20annotations\x20are\x20either\x20provided\x20by\x20use\
    rs\x20or\x20model\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\
    \x20any\n\x20provided\x20user\x20or\x20model\x20version\x20annotations\
    \x20in\x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20If\
    \x20no\x20model_version_ids\x20are\x20provided\x20then\x20annotations\
    \x20from\x20all\x20model\x20versions\x20are\x20returned.\n\n\r\n\x05\x04\
    \x02\x02\x04\x04\x12\x04\xd3\x1c\x02\n\n\r\n\x05\x04\x02\x02\x04\x05\x12\
    \x04\xd3\x1c\x0b\x11\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xd3\x1c\x12#\
    \n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xd3\x1c&(\n\x8b\x01\n\x04\x04\x02\
    \x02\x05\x12\x04\xd7\x1c\x023\x1a}\x20Set\x20status\x20to\x20filter\x20b\
    y\x20a\x20list\x20of\x20statuses\n\x20If\x20not\x20statuses\x20are\x20pr\
    ovided\x20then\x20annotations\x20with\x20any\x20status\x20will\x20be\x20\
    returned.\n\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04\xd7\x1c\x02\n\n\r\n\
    \x05\x04\x02\x02\x05\x06\x12\x04\xd7\x1c\x0b%\n\r\n\x05\x04\x02\x02\x05\
    \x01\x12\x04\xd7\x1c&.\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xd7\x1c12\n\
    \x80\x01\n\x04\x04\x02\x02\x06\x12\x04\xdb\x1c\x02\x20\x1ar\x20Set\x20th\
    is\x20flag\x20to\x20list\x20both\x20trusted\x20and\x20not\x20trusted\x20\
    annotations\n\x20by\x20default\x20it's\x20listing\x20only\x20trusted\x20\
    annotations\n\n\r\n\x05\x04\x02\x02\x06\x05\x12\x04\xdb\x1c\x02\x06\n\r\
    \n\x05\x04\x02\x02\x06\x01\x12\x04\xdb\x1c\x07\x1b\n\r\n\x05\x04\x02\x02\
    \x06\x03\x12\x04\xdb\x1c\x1e\x1f\n_\n\x04\x04\x02\x02\x07\x12\x04\xde\
    \x1c\x02\x20\x1aQ\x20Set\x20this\x20flag\x20to\x20return\x20the\x20model\
    \x20output\x20for\x20model\x20annotations\x20in\x20the\x20response.\n\n\
    \r\n\x05\x04\x02\x02\x07\x05\x12\x04\xde\x1c\x02\x06\n\r\n\x05\x04\x02\
    \x02\x07\x01\x12\x04\xde\x1c\x07\x1a\n\r\n\x05\x04\x02\x02\x07\x03\x12\
    \x04\xde\x1c\x1d\x1f\n~\n\x04\x04\x02\x02\x08\x12\x04\xe2\x1c\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x02\x02\x08\x05\x12\x04\xe2\
    \x1c\x02\x08\n\r\n\x05\x04\x02\x02\x08\x01\x12\x04\xe2\x1c\t\r\n\r\n\x05\
    \x04\x02\x02\x08\x03\x12\x04\xe2\x1c\x10\x11\nu\n\x04\x04\x02\x02\t\x12\
    \x04\xe5\x1c\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20nu\
    mber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x02\x02\t\x05\x12\
    \x04\xe5\x1c\x02\x08\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\xe5\x1c\t\x11\n\
    \r\n\x05\x04\x02\x02\t\x03\x12\x04\xe5\x1c\x14\x15\n5\n\x04\x04\x02\x02\
    \n\x12\x04\xe7\x1c\x02\x16\x1a'\x20Flag\x20to\x20filter\x20annotations\
    \x20by\x20task_id\n\n\r\n\x05\x04\x02\x02\n\x05\x12\x04\xe7\x1c\x02\x08\
    \n\r\n\x05\x04\x02\x02\n\x01\x12\x04\xe7\x1c\t\x10\n\r\n\x05\x04\x02\x02\
    \n\x03\x12\x04\xe7\x1c\x13\x15\n&\n\x02\x04\x03\x12\x06\xeb\x1c\0\xf0\
    \x1c\x01\x1a\x18\x20PostAnnotationsRequest\n\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\xeb\x1c\x08\x1e\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xed\x1c\x02,\n\r\
    \n\x05\x04\x03\x02\0\x06\x12\x04\xed\x1c\x02\x1b\n\r\n\x05\x04\x03\x02\0\
    \x01\x12\x04\xed\x1c\x1c'\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xed\x1c*+\
    \n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xef\x1c\x02&\n\r\n\x05\x04\x03\x02\
    \x01\x04\x12\x04\xef\x1c\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xef\
    \x1c\x0b\x15\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xef\x1c\x16!\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\xef\x1c$%\n'\n\x02\x04\x04\x12\x06\xf3\
    \x1c\0\x80\x1d\x01\x1a\x19\x20PatchAnnotationsRequest\n\n\x0b\n\x03\x04\
    \x04\x01\x12\x04\xf3\x1c\x08\x1f\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xf4\
    \x1c\x02,\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xf4\x1c\x02\x1b\n\r\n\x05\
    \x04\x04\x02\0\x01\x12\x04\xf4\x1c\x1c'\n\r\n\x05\x04\x04\x02\0\x03\x12\
    \x04\xf4\x1c*+\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\xf6\x1c\x02&\n\r\n\
    \x05\x04\x04\x02\x01\x04\x12\x04\xf6\x1c\x02\n\n\r\n\x05\x04\x04\x02\x01\
    \x06\x12\x04\xf6\x1c\x0b\x15\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xf6\
    \x1c\x16!\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xf6\x1c$%\n~\n\x04\x04\
    \x04\x02\x02\x12\x04\xfa\x1c\x02\x14\x1ap\x20The\x20action\x20to\x20perf\
    orm\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'me\
    rge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\r\n\x05\
    \x04\x04\x02\x02\x05\x12\x04\xfa\x1c\x02\x08\n\r\n\x05\x04\x04\x02\x02\
    \x01\x12\x04\xfa\x1c\t\x0f\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xfa\x1c\
    \x12\x13\n\xee\x01\n\x04\x04\x04\x02\x03\x12\x04\xff\x1c\x02\x20\x1a\xdf\
    \x01\x20If\x20the\x20request\x20is\x20a\x20\"remove\"\x20action\x20and\
    \x20the\x20annotation\x20is\x20left\x20with\x20empty\x20data,\n\x20then\
    \x20setting\x20delete_if_empty_data\x20to\x20true\x20will\x20delete\x20t\
    he\x20annotation,\n\x20if\x20possible\x20(for\x20example,\x20will\x20not\
    \x20delete\x20an\x20input-level\x20annotation).\n\n\r\n\x05\x04\x04\x02\
    \x03\x05\x12\x04\xff\x1c\x02\x06\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\
    \xff\x1c\x07\x1b\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xff\x1c\x1e\x1f\n\
    -\n\x02\x04\x05\x12\x06\x83\x1d\0\x91\x1d\x01\x1a\x1f\x20PatchAnnotation\
    sStatusRequest\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x83\x1d\x08%\n\x0c\n\
    \x04\x04\x05\x02\0\x12\x04\x84\x1d\x02,\n\r\n\x05\x04\x05\x02\0\x06\x12\
    \x04\x84\x1d\x02\x1b\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x84\x1d\x1c'\n\
    \r\n\x05\x04\x05\x02\0\x03\x12\x04\x84\x1d*+\n\"\n\x04\x04\x05\x02\x01\
    \x12\x04\x86\x1d\x02\x1f\x1a\x14\x20Filter\x20by\x20user\x20IDs\n\n\r\n\
    \x05\x04\x05\x02\x01\x04\x12\x04\x86\x1d\x02\n\n\r\n\x05\x04\x05\x02\x01\
    \x05\x12\x04\x86\x1d\x0b\x11\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x86\
    \x1d\x12\x1a\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x86\x1d\x1d\x1e\n!\n\
    \x04\x04\x05\x02\x02\x12\x04\x88\x1d\x02\x15\x1a\x13\x20Filter\x20by\x20\
    task\x20ID\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x88\x1d\x02\x08\n\r\n\
    \x05\x04\x05\x02\x02\x01\x12\x04\x88\x1d\t\x10\n\r\n\x05\x04\x05\x02\x02\
    \x03\x12\x04\x88\x1d\x13\x14\n&\n\x04\x04\x05\x02\x03\x12\x04\x8a\x1d\
    \x02;\x1a\x18\x20Filter\x20by\x20Status\x20codes\n\n\r\n\x05\x04\x05\x02\
    \x03\x04\x12\x04\x8a\x1d\x02\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\x8a\
    \x1d\x0b)\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x8a\x1d*6\n\r\n\x05\x04\
    \x05\x02\x03\x03\x12\x04\x8a\x1d9:\n(\n\x04\x04\x05\x02\x04\x12\x04\x8d\
    \x1d\x02\x14\x1a\x1a\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\
    \x05\x02\x04\x05\x12\x04\x8d\x1d\x02\x08\n\r\n\x05\x04\x05\x02\x04\x01\
    \x12\x04\x8d\x1d\t\x0f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\x8d\x1d\x12\
    \x13\n:\n\x04\x04\x05\x02\x05\x12\x04\x90\x1d\x021\x1a,\x20Update\x20fil\
    tered\x20annotations\x20to\x20this\x20status\n\n\r\n\x05\x04\x05\x02\x05\
    \x06\x12\x04\x90\x1d\x02\x20\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\x90\
    \x1d!,\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\x90\x1d/0\n.\n\x02\x04\x06\
    \x12\x06\x94\x1d\0\x98\x1d\x01\x1a\x20\x20PatchAnnotationsStatusResponse\
    \n\n\x0b\n\x03\x04\x06\x01\x12\x04\x94\x1d\x08&\n\x0c\n\x04\x04\x06\x02\
    \0\x12\x04\x95\x1d\x02(\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\x95\x1d\x02\
    \x1c\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x95\x1d\x1d#\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\x95\x1d&'\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x96\x1d\
    \x02\x1f\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x96\x1d\x02\n\n\r\n\x05\
    \x04\x06\x02\x01\x05\x12\x04\x96\x1d\x0b\x11\n\r\n\x05\x04\x06\x02\x01\
    \x01\x12\x04\x96\x1d\x12\x1a\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x96\
    \x1d\x1d\x1e\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\x97\x1d\x02\x1b\n\r\n\
    \x05\x04\x06\x02\x02\x05\x12\x04\x97\x1d\x02\x08\n\r\n\x05\x04\x06\x02\
    \x02\x01\x12\x04\x97\x1d\t\x16\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x97\
    \x1d\x19\x1a\n'\n\x02\x04\x07\x12\x06\x9b\x1d\0\xa1\x1d\x01\x1a\x19\x20D\
    eleteAnnotationRequest\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x9b\x1d\x08\x1f\
    \n\x0c\n\x04\x04\x07\x02\0\x12\x04\x9c\x1d\x02,\n\r\n\x05\x04\x07\x02\0\
    \x06\x12\x04\x9c\x1d\x02\x1b\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x9c\x1d\
    \x1c'\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x9c\x1d*+\n\x0c\n\x04\x04\x07\
    \x02\x01\x12\x04\x9e\x1d\x02\x16\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\
    \x9e\x1d\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x9e\x1d\t\x11\n\r\
    \n\x05\x04\x07\x02\x01\x03\x12\x04\x9e\x1d\x14\x15\n\x0c\n\x04\x04\x07\
    \x02\x02\x12\x04\xa0\x1d\x02\x1b\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\
    \xa0\x1d\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xa0\x1d\t\x16\n\r\
    \n\x05\x04\x07\x02\x02\x03\x12\x04\xa0\x1d\x19\x1a\nD\n\x02\x04\x08\x12\
    \x06\xa4\x1d\0\xb1\x1d\x01\x1a6\x20Request\x20to\x20delete\x20several\
    \x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04\x08\x01\
    \x12\x04\xa4\x1d\x08\x20\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xa5\x1d\x02,\
    \n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xa5\x1d\x02\x1b\n\r\n\x05\x04\x08\
    \x02\0\x01\x12\x04\xa5\x1d\x1c'\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa5\
    \x1d*+\n+\n\x04\x04\x08\x02\x01\x12\x04\xa8\x1d\x02\x1a\x1a\x1d\x20Delet\
    e\x20annotations\x20with\x20IDs\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\
    \xa8\x1d\x02\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xa8\x1d\x0b\x11\n\r\
    \n\x05\x04\x08\x02\x01\x01\x12\x04\xa8\x1d\x12\x15\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xa8\x1d\x18\x19\n\xf0\x02\n\x04\x04\x08\x02\x02\x12\x04\
    \xb0\x1d\x02\x20\x1a\xe1\x02\x20Delete\x20annotations\x20for\x20these\
    \x20Input\x20IDs\n\x20Note\x20that\x20'ids'\x20are\x20optional\x20but\
    \x20if\x20the\x20are\x20provided\x20the\x20number\x20and\x20order\x20in\
    \n\x20'ids'\x20and\x20'input_ids'\x20should\x20match\n\x20If\x20you\x20d\
    o\x20not\x20specifiy\x20'ids'\x20all\x20the\x20annotations\x20for\x20'in\
    put_ids'\x20are\x20deleted\n\x20However\x20you\x20need\x20to\x20specify\
    \x20at\x20least\x20one\x20value\x20for\x20'input_ids'\n\x20i.e.\x20this\
    \x20API\x20does\x20not\x20support\x20deleting\x20all\x20annotations\n\n\
    \r\n\x05\x04\x08\x02\x02\x04\x12\x04\xb0\x1d\x02\n\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\xb0\x1d\x0b\x11\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\
    \xb0\x1d\x12\x1b\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xb0\x1d\x1e\x1f\n\
    (\n\x02\x04\t\x12\x06\xb4\x1d\0\xb7\x1d\x01\x1a\x1a\x20SingleAnnotationR\
    esponse\n\n\x0b\n\x03\x04\t\x01\x12\x04\xb4\x1d\x08\x20\n\x0c\n\x04\x04\
    \t\x02\0\x12\x04\xb5\x1d\x02(\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xb5\x1d\
    \x02\x1c\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xb5\x1d\x1d#\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\xb5\x1d&'\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xb6\x1d\
    \x02\x1c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xb6\x1d\x02\x0c\n\r\n\x05\
    \x04\t\x02\x01\x01\x12\x04\xb6\x1d\r\x17\n\r\n\x05\x04\t\x02\x01\x03\x12\
    \x04\xb6\x1d\x1a\x1b\n'\n\x02\x04\n\x12\x06\xba\x1d\0\xbe\x1d\x01\x1a\
    \x19\x20MultiAnnotationResponse\n\n\x0b\n\x03\x04\n\x01\x12\x04\xba\x1d\
    \x08\x1f\n\x0c\n\x04\x04\n\x02\0\x12\x04\xbb\x1d\x02(\n\r\n\x05\x04\n\
    \x02\0\x06\x12\x04\xbb\x1d\x02\x1c\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xbb\
    \x1d\x1d#\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xbb\x1d&'\n\x0c\n\x04\x04\n\
    \x02\x01\x12\x04\xbd\x1d\x02U\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xbd\
    \x1d\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xbd\x1d\x0b\x15\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\xbd\x1d\x16!\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xbd\x1d$%\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\xbd\x1d&T\n\x10\n\x08\
    \x04\n\x02\x01\x08\xd0\x86\x03\x12\x04\xbd\x1d'S\n,\n\x02\x04\x0b\x12\
    \x06\xc1\x1d\0\xd1\x1d\x01\x1a\x1e\x20ListAnnotationWorkersRequest\n\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\xc1\x1d\x08$\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\xc2\x1d\x02,\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xc2\x1d\x02\
    \x1b\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xc2\x1d\x1c'\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\xc2\x1d*+\n~\n\x04\x04\x0b\x02\x01\x12\x04\xc6\x1d\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x0b\x02\x01\x05\
    \x12\x04\xc6\x1d\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xc6\x1d\t\
    \r\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xc6\x1d\x10\x11\nu\n\x04\x04\
    \x0b\x02\x02\x12\x04\xc9\x1d\x02\x16\x1ag\x20(optional\x20URL\x20paramet\
    er)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x0b\
    \x02\x02\x05\x12\x04\xc9\x1d\x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\
    \x04\xc9\x1d\t\x11\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xc9\x1d\x14\x15\
    \n\x83\x01\n\x04\x04\x0b\x02\x03\x12\x04\xcd\x1d\x02(\x1au\x20(optional\
    \x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\
    \x20included\x20in\x20the\x20response.\n\x20Currently\x20supported:\x20a\
    ll,\x20names\n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xcd\x1d\x02\n\n\r\n\
    \x05\x04\x0b\x02\x03\x05\x12\x04\xcd\x1d\x0b\x11\n\r\n\x05\x04\x0b\x02\
    \x03\x01\x12\x04\xcd\x1d\x12#\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xcd\
    \x1d&'\na\n\x04\x04\x0b\x02\x04\x12\x04\xd0\x1d\x02\x18\x1aS\x20(optiona\
    l\x20URL\x20parameter)\x20Only\x20list\x20workers\x20that\x20have\x20cre\
    ated\x20trusted\x20annotations.\n\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\
    \xd0\x1d\x02\x06\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xd0\x1d\x07\x13\n\
    \r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xd0\x1d\x16\x17\n#\n\x02\x04\x0c\
    \x12\x06\xd4\x1d\0\xd8\x1d\x01\x1a\x15\x20MultiWorkerResponse\n\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\xd4\x1d\x08\x1b\n\x0c\n\x04\x04\x0c\x02\0\x12\
    \x04\xd5\x1d\x02(\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xd5\x1d\x02\x1c\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\xd5\x1d\x1d#\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xd5\x1d&'\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xd7\x1d\x02M\
    \n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xd7\x1d\x02\n\n\r\n\x05\x04\x0c\
    \x02\x01\x06\x12\x04\xd7\x1d\x0b\x11\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xd7\x1d\x12\x19\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xd7\x1d\x1c\
    \x1d\n\r\n\x05\x04\x0c\x02\x01\x08\x12\x04\xd7\x1d\x1eL\n\x10\n\x08\x04\
    \x0c\x02\x01\x08\xd0\x86\x03\x12\x04\xd7\x1d\x1fK\n\x1d\n\x02\x04\r\x12\
    \x06\xdb\x1d\0\xdf\x1d\x01\x1a\x0f\x20GetAppRequest\n\n\x0b\n\x03\x04\r\
    \x01\x12\x04\xdb\x1d\x08\x15\n\x0c\n\x04\x04\r\x02\0\x12\x04\xdc\x1d\x02\
    ,\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xdc\x1d\x02\x1b\n\r\n\x05\x04\r\x02\
    \0\x01\x12\x04\xdc\x1d\x1c'\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xdc\x1d*+\
    \n\x82\x01\n\x04\x04\r\x02\x01\x12\x04\xde\x1d\x02(\x1at\x20(optional\
    \x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\
    \x20included\x20in\x20the\x20response.\x20Currently\x20supported:\x20all\
    ,\x20stars\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xde\x1d\x02\n\n\r\n\x05\
    \x04\r\x02\x01\x05\x12\x04\xde\x1d\x0b\x11\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\xde\x1d\x12#\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xde\x1d&'\n\
    \x1f\n\x02\x04\x0e\x12\x06\xe2\x1d\0\x9d\x1e\x01\x1a\x11\x20ListAppsRequ\
    est\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xe2\x1d\x08\x17\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xe3\x1d\x02,\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xe3\
    \x1d\x02\x1b\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xe3\x1d\x1c'\n\r\n\x05\
    \x04\x0e\x02\0\x03\x12\x04\xe3\x1d*+\n~\n\x04\x04\x0e\x02\x01\x12\x04\
    \xe6\x1d\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x0e\x02\
    \x01\x05\x12\x04\xe6\x1d\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \xe6\x1d\t\r\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xe6\x1d\x10\x11\nu\n\
    \x04\x04\x0e\x02\x02\x12\x04\xe9\x1d\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04\x0e\x02\x02\x05\x12\x04\xe9\x1d\x02\x08\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xe9\x1d\t\x11\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xe9\
    \x1d\x14\x15\n\x82\x01\n\x04\x04\x0e\x02\x03\x12\x04\xec\x1d\x02)\x1at\
    \x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\
    \x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20suppo\
    rted:\x20all,\x20stars\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xec\x1d\
    \x02\n\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xec\x1d\x0b\x11\n\r\n\x05\
    \x04\x0e\x02\x03\x01\x12\x04\xec\x1d\x12#\n\r\n\x05\x04\x0e\x02\x03\x03\
    \x12\x04\xec\x1d&(\no\n\x04\x04\x0e\x02\x04\x12\x04\xf0\x1d\x02\x1a\x1aa\
    \x20Sorting\x20options:\n\x20Whether\x20to\x20sort\x20in\x20ascending\
    \x20order.\x20If\x20false,\x20will\x20order\x20in\x20descending\x20order\
    .\n\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xf0\x1d\x02\x06\n\r\n\x05\x04\
    \x0e\x02\x04\x01\x12\x04\xf0\x1d\x07\x15\n\r\n\x05\x04\x0e\x02\x04\x03\
    \x12\x04\xf0\x1d\x18\x19\n\x0e\n\x04\x04\x0e\x08\0\x12\x06\xf1\x1d\x02\
    \xfb\x1d\x03\n\r\n\x05\x04\x0e\x08\0\x01\x12\x04\xf1\x1d\x08\x0f\n,\n\
    \x04\x04\x0e\x02\x05\x12\x04\xf3\x1d\x04\x1a\x1a\x1e\x20Whether\x20to\
    \x20order\x20by\x20the\x20name\n\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\
    \xf3\x1d\x04\x08\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xf3\x1d\t\x15\n\r\
    \n\x05\x04\x0e\x02\x05\x03\x12\x04\xf3\x1d\x18\x19\n\x80\x01\n\x04\x04\
    \x0e\x02\x06\x12\x04\xf6\x1d\x04!\x1ar\x20Whether\x20to\x20order\x20by\
    \x20the\x20modified_at\x20time.\n\x20If\x20none\x20of\x20the\x20sort\x20\
    options\x20is\x20set\x20to\x20true,\x20will\x20sort\x20by\x20modified_at\
    .\n\n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\xf6\x1d\x04\x08\n\r\n\x05\x04\
    \x0e\x02\x06\x01\x12\x04\xf6\x1d\t\x1c\n\r\n\x05\x04\x0e\x02\x06\x03\x12\
    \x04\xf6\x1d\x1f\x20\n8\n\x04\x04\x0e\x02\x07\x12\x04\xf8\x1d\x04!\x1a*\
    \x20Whether\x20to\x20order\x20by\x20the\x20created_at\x20time.\n\n\r\n\
    \x05\x04\x0e\x02\x07\x05\x12\x04\xf8\x1d\x04\x08\n\r\n\x05\x04\x0e\x02\
    \x07\x01\x12\x04\xf8\x1d\t\x1b\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xf8\
    \x1d\x1e\x20\nF\n\x04\x04\x0e\x02\x08\x12\x04\xfa\x1d\x04!\x1a8\x20Wheth\
    er\x20to\x20order\x20by\x20the\x20number\x20of\x20users\x20stared\x20the\
    \x20app\n\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xfa\x1d\x04\x08\n\r\n\
    \x05\x04\x0e\x02\x08\x01\x12\x04\xfa\x1d\t\x1b\n\r\n\x05\x04\x0e\x02\x08\
    \x03\x12\x04\xfa\x1d\x1e\x20\nf\n\x04\x04\x0e\x02\t\x12\x04\xff\x1d\x02\
    \x19\x1aX\x20Filtering\x20options:\n\x20If\x20true,\x20we\x20only\x20ret\
    urn\x20apps\x20that\x20are\x20handpicked\x20by\x20clarifai\x20staff\n\n\
    \r\n\x05\x04\x0e\x02\t\x05\x12\x04\xff\x1d\x02\x06\n\r\n\x05\x04\x0e\x02\
    \t\x01\x12\x04\xff\x1d\x07\x14\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\xff\
    \x1d\x17\x18\nT\n\x04\x04\x0e\x02\n\x12\x04\x81\x1e\x02\x19\x1aF\x20If\
    \x20true,\x20we\x20only\x20return\x20apps\x20that\x20are\x20starred\x20b\
    y\x20the\x20requesting\x20user\n\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\x81\
    \x1e\x02\x06\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\x81\x1e\x07\x13\n\r\n\
    \x05\x04\x0e\x02\n\x03\x12\x04\x81\x1e\x16\x18\n\\\n\x04\x04\x0e\x02\x0b\
    \x12\x04\x83\x1e\x02\x1a\x1aN\x20If\x20true,\x20we\x20only\x20return\x20\
    apps\x20that\x20are\x20marked\x20as\x20a\x20template\x20by\x20the\x20app\
    \x20owner.\n\n\r\n\x05\x04\x0e\x02\x0b\x05\x12\x04\x83\x1e\x02\x06\n\r\n\
    \x05\x04\x0e\x02\x0b\x01\x12\x04\x83\x1e\x07\x14\n\r\n\x05\x04\x0e\x02\
    \x0b\x03\x12\x04\x83\x1e\x17\x19\n\xba\x04\n\x04\x04\x0e\x02\x0c\x12\x04\
    \x93\x1e\x02\x15\x1a\xab\x04\x20Searching\x20options:\n\x20Specify\x20a\
    \x20search\x20parameter\x20in\x20order\x20to\x20perform\x20keyword\x20se\
    arch\x20on\x20the\n\x20following\x20fields\x20of\x20the\x20application:\
    \n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20name\n\x20\x20\x20-\x20descripti\
    on\n\x20\x20\x20-\x20notes\n\x20\x20\x20-\x20user_id\x20(unless\x20user_\
    app_id.user_id\x20is\x20already\x20set)\n\n\x20Keywords\x20are\x20both\
    \x20normalized\x20for\x20search\x20(so\x20searching\x20for\x20\"satisfy\
    \"\x20matches\x20\"satisfied\")\n\x20and\x20used\x20for\x20partial\x20pr\
    efix-matching\x20(so\x20searching\x20for\x20\"clari\"\x20matches\x20\"cl\
    arifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\x20of\x20fields\x20search\
    ed\x20and\x20the\x20exact\x20keyword\x20matching\n\x20rules\x20are\x20su\
    bject\x20to\x20change\x20and\x20not\x20guaranteed\x20to\x20be\x20backwar\
    ds-compatible.\n\n\r\n\x05\x04\x0e\x02\x0c\x05\x12\x04\x93\x1e\x02\x08\n\
    \r\n\x05\x04\x0e\x02\x0c\x01\x12\x04\x93\x1e\t\x0f\n\r\n\x05\x04\x0e\x02\
    \x0c\x03\x12\x04\x93\x1e\x12\x14\n\x9d\x01\n\x04\x04\x0e\x02\r\x12\x04\
    \x96\x1e\x02'\x1a\x8e\x01\x20Query\x20various\x20text\x20fields\x20(id,\
    \x20name,\x20description,\x20and\x20notes)\x20that\x20can\x20contain\x20\
    the\x20words\x20in\x20the\x20query\x20string\n\x20Deprecated:\x20use\x20\
    search\x20instead.\n\n\r\n\x05\x04\x0e\x02\r\x05\x12\x04\x96\x1e\x02\x08\
    \n\r\n\x05\x04\x0e\x02\r\x01\x12\x04\x96\x1e\t\x0e\n\r\n\x05\x04\x0e\x02\
    \r\x03\x12\x04\x96\x1e\x11\x12\n\r\n\x05\x04\x0e\x02\r\x08\x12\x04\x96\
    \x1e\x13&\n\x0e\n\x06\x04\x0e\x02\r\x08\x03\x12\x04\x96\x1e\x14%\n\xaa\
    \x01\n\x04\x04\x0e\x02\x0e\x12\x04\x99\x1e\x02&\x1a\x9b\x01\x20Filter\
    \x20by\x20the\x20id,\x20name\x20and\x20notes\x20of\x20the\x20app.\x20Thi\
    s\x20supports\x20wilcard\x20queries\x20like\x20\"gen*\"\x20to\x20match\
    \x20\"general\"\x20as\x20an\x20example.\n\x20Deprecated:\x20use\x20searc\
    h\x20instead.\n\n\r\n\x05\x04\x0e\x02\x0e\x05\x12\x04\x99\x1e\x02\x08\n\
    \r\n\x05\x04\x0e\x02\x0e\x01\x12\x04\x99\x1e\t\r\n\r\n\x05\x04\x0e\x02\
    \x0e\x03\x12\x04\x99\x1e\x10\x11\n\r\n\x05\x04\x0e\x02\x0e\x08\x12\x04\
    \x99\x1e\x12%\n\x0e\n\x06\x04\x0e\x02\x0e\x08\x03\x12\x04\x99\x1e\x13$\n\
    \xa6\x01\n\x04\x04\x0e\x02\x0f\x12\x04\x9c\x1e\x02%\x1a\x97\x01\x20Filte\
    r\x20by\x20the\x20user-unique-id\x20of\x20the\x20app.\x20This\x20support\
    s\x20wilcard\x20queries\x20like\x20\"gen*\"\x20to\x20match\x20\"general\
    \"\x20as\x20an\x20example.\n\x20Deprecated:\x20use\x20search\x20instead.\
    \n\n\r\n\x05\x04\x0e\x02\x0f\x05\x12\x04\x9c\x1e\x02\x08\n\r\n\x05\x04\
    \x0e\x02\x0f\x01\x12\x04\x9c\x1e\t\x0b\n\r\n\x05\x04\x0e\x02\x0f\x03\x12\
    \x04\x9c\x1e\x0e\x10\n\r\n\x05\x04\x0e\x02\x0f\x08\x12\x04\x9c\x1e\x11$\
    \n\x0e\n\x06\x04\x0e\x02\x0f\x08\x03\x12\x04\x9c\x1e\x12#\n\x1f\n\x02\
    \x04\x0f\x12\x06\xa0\x1e\0\xa3\x1e\x01\x1a\x11\x20PostAppsRequest\n\n\
    \x0b\n\x03\x04\x0f\x01\x12\x04\xa0\x1e\x08\x17\n\x0c\n\x04\x04\x0f\x02\0\
    \x12\x04\xa1\x1e\x02,\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xa1\x1e\x02\
    \x1b\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xa1\x1e\x1c'\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xa1\x1e*+\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xa2\x1e\
    \x02\x18\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xa2\x1e\x02\n\n\r\n\x05\
    \x04\x0f\x02\x01\x06\x12\x04\xa2\x1e\x0b\x0e\n\r\n\x05\x04\x0f\x02\x01\
    \x01\x12\x04\xa2\x1e\x0f\x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa2\
    \x1e\x16\x17\n\x20\n\x02\x04\x10\x12\x06\xa6\x1e\0\xa8\x1e\x01\x1a\x12\
    \x20DeleteAppRequest\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xa6\x1e\x08\x18\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xa7\x1e\x02,\n\r\n\x05\x04\x10\x02\0\
    \x06\x12\x04\xa7\x1e\x02\x1b\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa7\x1e\
    \x1c'\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa7\x1e*+\n\x20\n\x02\x04\x11\
    \x12\x06\xab\x1e\0\xbb\x1e\x01\x1a\x12\x20PatchAppsRequest\n\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xab\x1e\x08\x18\n\x0c\n\x04\x04\x11\x02\0\x12\x04\
    \xac\x1e\x02,\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xac\x1e\x02\x1b\n\r\n\
    \x05\x04\x11\x02\0\x01\x12\x04\xac\x1e\x1c'\n\r\n\x05\x04\x11\x02\0\x03\
    \x12\x04\xac\x1e*+\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xad\x1e\x02\x18\n\
    \r\n\x05\x04\x11\x02\x01\x04\x12\x04\xad\x1e\x02\n\n\r\n\x05\x04\x11\x02\
    \x01\x06\x12\x04\xad\x1e\x0b\x0e\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xad\x1e\x0f\x13\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xad\x1e\x16\x17\n\
    \x93\x02\n\x04\x04\x11\x02\x02\x12\x04\xb4\x1e\x02\x14\x1a\x84\x02\x20Th\
    e\x20action\x20to\x20perform\x20on\x20the\x20patched\x20App\x20objects\
    \x20except\x20App.Metadata\n\x20Supported\x20values:\x20'overwrite'\x20a\
    nd\x20'remove'.\n\n\x20Note\x20that\x20'remove'\x20can\x20only\x20be\x20\
    used\x20to\x20remove\x20the\x20app\x20image\x20by\x20setting\n\x20'image\
    .url'\x20in\x20the\x20request\x20to\x20the\x20current\x20value\x20return\
    ed\x20for\x20that\x20app.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xb4\
    \x1e\x02\x08\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xb4\x1e\t\x0f\n\r\n\
    \x05\x04\x11\x02\x02\x03\x12\x04\xb4\x1e\x12\x13\nA\n\x04\x04\x11\x02\
    \x03\x12\x04\xb7\x1e\x02/\x1a3\x20The\x20action\x20to\x20perform\x20on\
    \x20the\x20patched\x20App.Metadata\n\n\r\n\x05\x04\x11\x02\x03\x06\x12\
    \x04\xb7\x1e\x02\x1a\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xb7\x1e\x1b*\
    \n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xb7\x1e-.\na\n\x04\x04\x11\x02\
    \x04\x12\x04\xba\x1e\x02\x13\x1aS\x20If\x20set,\x20the\x20app\x20will\
    \x20be\x20automatically\x20reindexed\x20upon\x20change\x20of\x20its\x20b\
    ase\x20workflow.\n\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xba\x1e\x02\x06\
    \n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xba\x1e\x07\x0e\n\r\n\x05\x04\x11\
    \x02\x04\x03\x12\x04\xba\x1e\x11\x12\n\x1f\n\x02\x04\x12\x12\x06\xbe\x1e\
    \0\xce\x1e\x01\x1a\x11\x20PatchAppRequest\n\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xbe\x1e\x08\x17\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xbf\x1e\x02,\n\r\
    \n\x05\x04\x12\x02\0\x06\x12\x04\xbf\x1e\x02\x1b\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xbf\x1e\x1c'\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xbf\x1e*+\
    \n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xc0\x1e\x02\x0e\n\r\n\x05\x04\x12\
    \x02\x01\x06\x12\x04\xc0\x1e\x02\x05\n\r\n\x05\x04\x12\x02\x01\x01\x12\
    \x04\xc0\x1e\x06\t\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xc0\x1e\x0c\r\n\
    \x91\x02\n\x04\x04\x12\x02\x02\x12\x04\xc7\x1e\x02\x14\x1a\x82\x02\x20Th\
    e\x20action\x20to\x20perform\x20on\x20the\x20patched\x20App\x20object\
    \x20except\x20App.Metadata\n\x20Supported\x20values:\x20'overwrite'\x20a\
    nd\x20'remove'.\n\n\x20Note\x20that\x20'remove'\x20can\x20only\x20be\x20\
    used\x20to\x20remove\x20the\x20app\x20image\x20by\x20setting\n\x20'image\
    .url'\x20in\x20the\x20request\x20to\x20the\x20current\x20value\x20return\
    ed\x20for\x20the\x20app.\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xc7\x1e\
    \x02\x08\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xc7\x1e\t\x0f\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xc7\x1e\x12\x13\nA\n\x04\x04\x12\x02\x03\
    \x12\x04\xca\x1e\x02/\x1a3\x20The\x20action\x20to\x20perform\x20on\x20th\
    e\x20patched\x20App.Metadata\n\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xca\
    \x1e\x02\x1a\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xca\x1e\x1b*\n\r\n\
    \x05\x04\x12\x02\x03\x03\x12\x04\xca\x1e-.\na\n\x04\x04\x12\x02\x04\x12\
    \x04\xcd\x1e\x02\x13\x1aS\x20If\x20set,\x20the\x20app\x20will\x20be\x20a\
    utomatically\x20reindexed\x20upon\x20change\x20of\x20its\x20base\x20work\
    flow.\n\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xcd\x1e\x02\x06\n\r\n\x05\
    \x04\x12\x02\x04\x01\x12\x04\xcd\x1e\x07\x0e\n\r\n\x05\x04\x12\x02\x04\
    \x03\x12\x04\xcd\x1e\x11\x12\n#\n\x02\x04\x13\x12\x06\xd2\x1e\0\xdb\x1e\
    \x01\x1a\x15\x20PatchAppsIdsRequest\n\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \xd2\x1e\x08\x1b\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xd3\x1e\x02,\n\r\n\
    \x05\x04\x13\x02\0\x06\x12\x04\xd3\x1e\x02\x1b\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xd3\x1e\x1c'\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xd3\x1e*+\
    \n(\n\x04\x04\x13\x02\x01\x12\x04\xd6\x1e\x02\"\x1a\x1a\x20Array\x20cont\
    aining\x201\x20entry\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xd6\x1e\x02\
    \n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xd6\x1e\x0b\x19\n\r\n\x05\x04\
    \x13\x02\x01\x01\x12\x04\xd6\x1e\x1a\x1d\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\xd6\x1e\x20!\n[\n\x04\x04\x13\x02\x02\x12\x04\xda\x1e\x02\x14\
    \x1aM\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objec\
    ts\n\x20Only\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\x13\x02\
    \x02\x05\x12\x04\xda\x1e\x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \xda\x1e\t\x0f\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xda\x1e\x12\x13\n7\
    \n\x02\x04\x14\x12\x06\xde\x1e\0\xe5\x1e\x01\x1a)\x20Search\x20over\x20t\
    he\x20available\x20applications.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xde\
    \x1e\x08\x1f\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xdf\x1e\x02,\n\r\n\x05\
    \x04\x14\x02\0\x06\x12\x04\xdf\x1e\x02\x1b\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\xdf\x1e\x1c'\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xdf\x1e*+\n(\n\
    \x04\x04\x14\x02\x01\x12\x04\xe1\x1e\x02\x19\x1a\x1a\x20The\x20body\x20o\
    f\x20the\x20request.\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xe1\x1e\x02\
    \n\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xe1\x1e\x0b\x14\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xe1\x1e\x17\x18\n]\n\x04\x04\x14\x02\x02\x12\
    \x04\xe4\x1e\x02\x1c\x1aO\x20Pagination\x20parameters\x20here\x20since\
    \x20there\x20are\x20no\x20url\x20args\x20in\x20this\n\x20POST\x20request\
    .\n\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xe4\x1e\x02\x0c\n\r\n\x05\x04\
    \x14\x02\x02\x01\x12\x04\xe4\x1e\r\x17\n\r\n\x05\x04\x14\x02\x02\x03\x12\
    \x04\xe4\x1e\x1a\x1b\n!\n\x02\x04\x15\x12\x06\xe8\x1e\0\xeb\x1e\x01\x1a\
    \x13\x20SingleAppResponse\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xe8\x1e\x08\
    \x19\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xe9\x1e\x02(\n\r\n\x05\x04\x15\
    \x02\0\x06\x12\x04\xe9\x1e\x02\x1c\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \xe9\x1e\x1d#\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xe9\x1e&'\n\x0c\n\x04\
    \x04\x15\x02\x01\x12\x04\xea\x1e\x02\x0e\n\r\n\x05\x04\x15\x02\x01\x06\
    \x12\x04\xea\x1e\x02\x05\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xea\x1e\
    \x06\t\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xea\x1e\x0c\r\n\x20\n\x02\
    \x04\x16\x12\x06\xee\x1e\0\xf1\x1e\x01\x1a\x12\x20MultiAppResponse\n\n\
    \x0b\n\x03\x04\x16\x01\x12\x04\xee\x1e\x08\x18\n\x0c\n\x04\x04\x16\x02\0\
    \x12\x04\xef\x1e\x02(\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xef\x1e\x02\
    \x1c\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xef\x1e\x1d#\n\r\n\x05\x04\x16\
    \x02\0\x03\x12\x04\xef\x1e&'\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xf0\x1e\
    \x02G\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xf0\x1e\x02\n\n\r\n\x05\x04\
    \x16\x02\x01\x06\x12\x04\xf0\x1e\x0b\x0e\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\xf0\x1e\x0f\x13\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xf0\x1e\
    \x16\x17\n\r\n\x05\x04\x16\x02\x01\x08\x12\x04\xf0\x1e\x18F\n\x10\n\x08\
    \x04\x16\x02\x01\x08\xd0\x86\x03\x12\x04\xf0\x1e\x19E\n(\n\x02\x04\x17\
    \x12\x06\xf4\x1e\0\xff\x1e\x01\x1a\x1a\x20ListCollaboratorsRequest\n\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\xf4\x1e\x08\x20\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\xf5\x1e\x02,\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xf5\x1e\x02\
    \x1b\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xf5\x1e\x1c'\n\r\n\x05\x04\x17\
    \x02\0\x03\x12\x04\xf5\x1e*+\n\x88\x01\n\x04\x04\x17\x02\x01\x12\x04\xf8\
    \x1e\x02\"\x1az\x20Set\x20this\x20flag\x20to\x20list\x20both\x20deleted\
    \x20and\x20not\x20deleted\x20collaborators\n\x20by\x20default\x20it's\
    \x20listing\x20only\x20not\x20deleted\x20collaborators\n\n\r\n\x05\x04\
    \x17\x02\x01\x05\x12\x04\xf8\x1e\x02\x06\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\xf8\x1e\x07\x1d\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xf8\x1e\
    \x20!\n~\n\x04\x04\x17\x02\x02\x12\x04\xfb\x1e\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xfb\x1e\x02\x08\n\r\
    \n\x05\x04\x17\x02\x02\x01\x12\x04\xfb\x1e\t\r\n\r\n\x05\x04\x17\x02\x02\
    \x03\x12\x04\xfb\x1e\x10\x11\nu\n\x04\x04\x17\x02\x03\x12\x04\xfe\x1e\
    \x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xfe\
    \x1e\x02\x08\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xfe\x1e\t\x11\n\r\n\
    \x05\x04\x17\x02\x03\x03\x12\x04\xfe\x1e\x14\x15\n(\n\x02\x04\x18\x12\
    \x06\x82\x1f\0\x85\x1f\x01\x1a\x1a\x20PostCollaboratorsRequest\n\n\x0b\n\
    \x03\x04\x18\x01\x12\x04\x82\x1f\x08\x20\n\x0c\n\x04\x04\x18\x02\0\x12\
    \x04\x83\x1f\x02,\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x83\x1f\x02\x1b\n\
    \r\n\x05\x04\x18\x02\0\x01\x12\x04\x83\x1f\x1c'\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\x83\x1f*+\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x84\x1f\x02*\
    \n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\x84\x1f\x02\n\n\r\n\x05\x04\x18\
    \x02\x01\x06\x12\x04\x84\x1f\x0b\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\
    \x04\x84\x1f\x18%\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x84\x1f()\n)\n\
    \x02\x04\x19\x12\x06\x88\x1f\0\x8f\x1f\x01\x1a\x1b\x20PatchCollaborators\
    Request\n\n\x0b\n\x03\x04\x19\x01\x12\x04\x88\x1f\x08!\n\x0c\n\x04\x04\
    \x19\x02\0\x12\x04\x89\x1f\x02,\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\x89\
    \x1f\x02\x1b\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x89\x1f\x1c'\n\r\n\x05\
    \x04\x19\x02\0\x03\x12\x04\x89\x1f*+\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\
    \x8a\x1f\x02*\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\x8a\x1f\x02\n\n\r\n\
    \x05\x04\x19\x02\x01\x06\x12\x04\x8a\x1f\x0b\x17\n\r\n\x05\x04\x19\x02\
    \x01\x01\x12\x04\x8a\x1f\x18%\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\x8a\
    \x1f()\nj\n\x04\x04\x19\x02\x02\x12\x04\x8e\x1f\x02\x14\x1a\\\x20The\x20\
    action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20n\
    ow\x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\
    \x19\x02\x02\x05\x12\x04\x8e\x1f\x02\x08\n\r\n\x05\x04\x19\x02\x02\x01\
    \x12\x04\x8e\x1f\t\x0f\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\x8e\x1f\x12\
    \x13\n*\n\x02\x04\x1a\x12\x06\x92\x1f\0\x96\x1f\x01\x1a\x1c\x20DeleteCol\
    laboratorsRequest\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\x92\x1f\x08\"\n\x0c\
    \n\x04\x04\x1a\x02\0\x12\x04\x93\x1f\x02,\n\r\n\x05\x04\x1a\x02\0\x06\
    \x12\x04\x93\x1f\x02\x1b\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x93\x1f\x1c\
    '\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x93\x1f*+\n\x0c\n\x04\x04\x1a\x02\
    \x01\x12\x04\x94\x1f\x02'\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\x94\x1f\
    \x02\n\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\x94\x1f\x0b\x11\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\x94\x1f\x12\"\n\r\n\x05\x04\x1a\x02\x01\x03\
    \x12\x04\x94\x1f%&\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\x95\x1f\x02\"\n\r\
    \n\x05\x04\x1a\x02\x02\x04\x12\x04\x95\x1f\x02\n\n\r\n\x05\x04\x1a\x02\
    \x02\x05\x12\x04\x95\x1f\x0b\x11\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\
    \x95\x1f\x12\x1d\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\x95\x1f\x20!\n*\n\
    \x02\x04\x1b\x12\x06\x99\x1f\0\xa6\x1f\x01\x1a\x1c\x20MultiCollaborators\
    Response\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\x99\x1f\x08\"\n\x0c\n\x04\x04\
    \x1b\x02\0\x12\x04\x9a\x1f\x02(\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\x9a\
    \x1f\x02\x1c\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x9a\x1f\x1d#\n\r\n\x05\
    \x04\x1b\x02\0\x03\x12\x04\x9a\x1f&'\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\
    \x9b\x1f\x02Y\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\x9b\x1f\x02\n\n\r\n\
    \x05\x04\x1b\x02\x01\x06\x12\x04\x9b\x1f\x0b\x17\n\r\n\x05\x04\x1b\x02\
    \x01\x01\x12\x04\x9b\x1f\x18%\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\x9b\
    \x1f()\n\r\n\x05\x04\x1b\x02\x01\x08\x12\x04\x9b\x1f*X\n\x10\n\x08\x04\
    \x1b\x02\x01\x08\xd0\x86\x03\x12\x04\x9b\x1f+W\n\xe3\x02\n\x04\x04\x1b\
    \x02\x02\x12\x04\xa5\x1f\x02\x15\x1a\xd4\x02\x20The\x20owner\x20of\x20th\
    e\x20application.\n\n\x20When\x20listing\x20users\x20that\x20have\x20acc\
    ess\x20to\x20the\x20application,\x20i.e.\x20collaborators,\n\x20it\x20is\
    \x20often\x20relevant\x20to\x20also\x20include\x20the\x20application\x20\
    owner,\x20so\x20return\n\x20their\x20information\x20here\x20for\x20conve\
    nience.\n\n\x20Note:\x20app_owner\x20is\x20only\x20returned\x20by\x20Lis\
    tCollaborators\x20and\x20only\x20if\x20the\n\x20owner\x20is\x20a\x20regu\
    lar\x20user,\x20not\x20an\x20organization.\n\n\r\n\x05\x04\x1b\x02\x02\
    \x06\x12\x04\xa5\x1f\x02\x06\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xa5\
    \x1f\x07\x10\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xa5\x1f\x13\x14\n)\n\
    \x02\x04\x1c\x12\x06\xa9\x1f\0\xb5\x1f\x01\x1a\x1b\x20ListCollaborations\
    Request\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xa9\x1f\x08!\n\x0c\n\x04\x04\
    \x1c\x02\0\x12\x04\xaa\x1f\x02,\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xaa\
    \x1f\x02\x1b\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xaa\x1f\x1c'\n\r\n\x05\
    \x04\x1c\x02\0\x03\x12\x04\xaa\x1f*+\n~\n\x04\x04\x1c\x02\x01\x12\x04\
    \xad\x1f\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x1c\x02\
    \x01\x05\x12\x04\xad\x1f\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\
    \xad\x1f\t\r\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xad\x1f\x10\x11\nu\n\
    \x04\x04\x1c\x02\x02\x12\x04\xb0\x1f\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04\x1c\x02\x02\x05\x12\x04\xb0\x1f\x02\x08\n\r\n\x05\x04\x1c\x02\
    \x02\x01\x12\x04\xb0\x1f\t\x11\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xb0\
    \x1f\x14\x15\n\x82\x01\n\x04\x04\x1c\x02\x03\x12\x04\xb4\x1f\x02\x19\x1a\
    t\x20Filtering\x20options:\n\x20If\x20true,\x20we\x20only\x20return\x20c\
    ollaborations\x20on\x20apps\x20that\x20are\x20marked\x20as\x20a\x20templ\
    ate\x20by\x20the\x20app\x20owner.\n\n\r\n\x05\x04\x1c\x02\x03\x05\x12\
    \x04\xb4\x1f\x02\x06\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xb4\x1f\x07\
    \x14\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xb4\x1f\x17\x18\n+\n\x02\x04\
    \x1d\x12\x06\xb8\x1f\0\xbb\x1f\x01\x1a\x1d\x20MultiCollaborationsRespons\
    e\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xb8\x1f\x08#\n\x0c\n\x04\x04\x1d\x02\
    \0\x12\x04\xb9\x1f\x02(\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xb9\x1f\x02\
    \x1c\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xb9\x1f\x1d#\n\r\n\x05\x04\x1d\
    \x02\0\x03\x12\x04\xb9\x1f&'\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xba\x1f\
    \x02[\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xba\x1f\x02\n\n\r\n\x05\x04\
    \x1d\x02\x01\x06\x12\x04\xba\x1f\x0b\x18\n\r\n\x05\x04\x1d\x02\x01\x01\
    \x12\x04\xba\x1f\x19'\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xba\x1f*+\n\
    \r\n\x05\x04\x1d\x02\x01\x08\x12\x04\xba\x1f,Z\n\x10\n\x08\x04\x1d\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xba\x1f-Y\n$\n\x02\x04\x1e\x12\x06\xe3\x1f\
    \0\xe5\x1f\x01\x1a\x16\x20GetStatusCodeRequest\n\n\x0b\n\x03\x04\x1e\x01\
    \x12\x04\xe3\x1f\x08\x1c\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xe4\x1f\x02\
    \x1c\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xe4\x1f\x02\x08\n\r\n\x05\x04\
    \x1e\x02\0\x01\x12\x04\xe4\x1f\t\x17\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xe4\x1f\x1a\x1b\n&\n\x02\x04\x1f\x12\x06\xe8\x1f\0\xe9\x1f\x01\x1a\x18\
    \x20ListStatusCodesRequest\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xe8\x1f\x08\
    \x1e\n(\n\x02\x04\x20\x12\x06\xec\x1f\0\xef\x1f\x01\x1a\x1a\x20SingleSta\
    tusCodeResponse\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xec\x1f\x08\x20\n'\n\
    \x04\x04\x20\x02\0\x12\x04\xee\x1f\x02(\x1a\x19\x20Status\x20of\x20this\
    \x20request.\n\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\xee\x1f\x02\x1c\n\r\n\
    \x05\x04\x20\x02\0\x01\x12\x04\xee\x1f\x1d#\n\r\n\x05\x04\x20\x02\0\x03\
    \x12\x04\xee\x1f&'\n'\n\x02\x04!\x12\x06\xf2\x1f\0\xf5\x1f\x01\x1a\x19\
    \x20MultiStatusCodeResponse\n\n\x0b\n\x03\x04!\x01\x12\x04\xf2\x1f\x08\
    \x1f\n\x0c\n\x04\x04!\x02\0\x12\x04\xf3\x1f\x02(\n\r\n\x05\x04!\x02\0\
    \x06\x12\x04\xf3\x1f\x02\x1c\n\r\n\x05\x04!\x02\0\x01\x12\x04\xf3\x1f\
    \x1d#\n\r\n\x05\x04!\x02\0\x03\x12\x04\xf3\x1f&'\n\x0c\n\x04\x04!\x02\
    \x01\x12\x04\xf4\x1f\x023\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xf4\x1f\x02\
    \n\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xf4\x1f\x0b%\n\r\n\x05\x04!\x02\
    \x01\x01\x12\x04\xf4\x1f&.\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xf4\x1f12\
    \n!\n\x02\x04\"\x12\x06\xf8\x1f\0\xfc\x1f\x01\x1a\x13\x20GetConceptReque\
    st\n\n\x0b\n\x03\x04\"\x01\x12\x04\xf8\x1f\x08\x19\n\x0c\n\x04\x04\"\x02\
    \0\x12\x04\xf9\x1f\x02,\n\r\n\x05\x04\"\x02\0\x06\x12\x04\xf9\x1f\x02\
    \x1b\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xf9\x1f\x1c'\n\r\n\x05\x04\"\x02\
    \0\x03\x12\x04\xf9\x1f*+\n!\n\x04\x04\"\x02\x01\x12\x04\xfb\x1f\x02\x18\
    \x1a\x13\x20The\x20concept's\x20id.\n\n\r\n\x05\x04\"\x02\x01\x05\x12\
    \x04\xfb\x1f\x02\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xfb\x1f\t\x13\n\
    \r\n\x05\x04\"\x02\x01\x03\x12\x04\xfb\x1f\x16\x17\n#\n\x02\x04#\x12\x06\
    \xff\x1f\0\x89\x20\x01\x1a\x15\x20ListConceptsRequest\n\n\x0b\n\x03\x04#\
    \x01\x12\x04\xff\x1f\x08\x1b\n\x0c\n\x04\x04#\x02\0\x12\x04\x80\x20\x02,\
    \n\r\n\x05\x04#\x02\0\x06\x12\x04\x80\x20\x02\x1b\n\r\n\x05\x04#\x02\0\
    \x01\x12\x04\x80\x20\x1c'\n\r\n\x05\x04#\x02\0\x03\x12\x04\x80\x20*+\n~\
    \n\x04\x04#\x02\x01\x12\x04\x83\x20\x02\x12\x1ap\x20(optional\x20URL\x20\
    parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\
    \x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\
    \n\n\r\n\x05\x04#\x02\x01\x05\x12\x04\x83\x20\x02\x08\n\r\n\x05\x04#\x02\
    \x01\x01\x12\x04\x83\x20\t\r\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x83\x20\
    \x10\x11\nu\n\x04\x04#\x02\x02\x12\x04\x86\x20\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\r\n\x05\x04#\x02\x02\x05\x12\x04\x86\x20\x02\x08\n\r\n\x05\x04#\x02\
    \x02\x01\x12\x04\x86\x20\t\x11\n\r\n\x05\x04#\x02\x02\x03\x12\x04\x86\
    \x20\x14\x15\n)\n\x04\x04#\x02\x03\x12\x04\x88\x20\x02\x10\x1a\x1b\x20Fu\
    zzy\x20match\x20on\x20concept\x20ID\n\n\r\n\x05\x04#\x02\x03\x05\x12\x04\
    \x88\x20\x02\x08\n\r\n\x05\x04#\x02\x03\x01\x12\x04\x88\x20\t\x0b\n\r\n\
    \x05\x04#\x02\x03\x03\x12\x04\x88\x20\x0e\x0f\n(\n\x02\x04$\x12\x06\x8c\
    \x20\0\xa5\x20\x01\x1a\x1a\x20ListModelConceptsRequest\n\n\x0b\n\x03\x04\
    $\x01\x12\x04\x8c\x20\x08\x20\n\x0c\n\x04\x04$\x02\0\x12\x04\x8d\x20\x02\
    ,\n\r\n\x05\x04$\x02\0\x06\x12\x04\x8d\x20\x02\x1b\n\r\n\x05\x04$\x02\0\
    \x01\x12\x04\x8d\x20\x1c'\n\r\n\x05\x04$\x02\0\x03\x12\x04\x8d\x20*+\n\
    \x18\n\x04\x04$\x02\x01\x12\x04\x8f\x20\x02\x16\x1a\n\x20Model\x20id\n\n\
    \r\n\x05\x04$\x02\x01\x05\x12\x04\x8f\x20\x02\x08\n\r\n\x05\x04$\x02\x01\
    \x01\x12\x04\x8f\x20\t\x11\n\r\n\x05\x04$\x02\x01\x03\x12\x04\x8f\x20\
    \x14\x15\nY\n\x04\x04$\x02\x02\x12\x04\x91\x20\x02\x18\x1aK\x20Model\x20\
    version\x20Id.\x20Optional,\x20if\x20not\x20provided\x20latest\x20model\
    \x20version\x20is\x20used.\n\n\r\n\x05\x04$\x02\x02\x05\x12\x04\x91\x20\
    \x02\x08\n\r\n\x05\x04$\x02\x02\x01\x12\x04\x91\x20\t\x13\n\r\n\x05\x04$\
    \x02\x02\x03\x12\x04\x91\x20\x16\x17\n~\n\x04\x04$\x02\x03\x12\x04\x95\
    \x20\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20nu\
    mber.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20in\
    to\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04$\x02\x03\x05\x12\
    \x04\x95\x20\x02\x08\n\r\n\x05\x04$\x02\x03\x01\x12\x04\x95\x20\t\r\n\r\
    \n\x05\x04$\x02\x03\x03\x12\x04\x95\x20\x10\x11\nu\n\x04\x04$\x02\x04\
    \x12\x04\x98\x20\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04$\x02\x04\x05\
    \x12\x04\x98\x20\x02\x08\n\r\n\x05\x04$\x02\x04\x01\x12\x04\x98\x20\t\
    \x11\n\r\n\x05\x04$\x02\x04\x03\x12\x04\x98\x20\x14\x15\n\x90\x03\n\x04\
    \x04$\x02\x05\x12\x04\xa4\x20\x02\x14\x1a\x81\x03\x20Searching\x20option\
    s:\n\x20Specify\x20a\x20search\x20parameter\x20in\x20order\x20to\x20perf\
    orm\x20keyword\x20search\x20on\x20the\n\x20following\x20fields\x20of\x20\
    the\x20concept:\n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20name\n\n\x20Keywo\
    rds\x20are\x20used\x20for\x20partial\x20prefix-matching\x20(so\x20search\
    ing\x20for\x20\"larif\"\x20matches\x20\"clarifai\").\n\n\x20NOTE:\x20Bot\
    h\x20the\x20list\x20of\x20fields\x20searched\x20and\x20the\x20exact\x20k\
    eyword\x20matching\n\x20rules\x20are\x20subject\x20to\x20change\x20and\
    \x20not\x20guaranteed\x20to\x20be\x20backwards-compatible.\n\n\r\n\x05\
    \x04$\x02\x05\x05\x12\x04\xa4\x20\x02\x08\n\r\n\x05\x04$\x02\x05\x01\x12\
    \x04\xa4\x20\t\x0f\n\r\n\x05\x04$\x02\x05\x03\x12\x04\xa4\x20\x12\x13\n+\
    \n\x02\x04%\x12\x06\xa8\x20\0\xb4\x20\x01\x1a\x1d\x20PostConceptsSearche\
    sRequest\n\n\x0b\n\x03\x04%\x01\x12\x04\xa8\x20\x08#\n6\n\x04\x04%\x02\0\
    \x12\x04\xaa\x20\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20of\
    \x20the\x20request.\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\xaa\x20\x02\x1b\n\
    \r\n\x05\x04%\x02\0\x01\x12\x04\xaa\x20\x1c'\n\r\n\x05\x04%\x02\0\x03\
    \x12\x04\xaa\x20*+\n(\n\x04\x04%\x02\x01\x12\x04\xac\x20\x02!\x1a\x1a\
    \x20The\x20body\x20of\x20the\x20request.\n\n\r\n\x05\x04%\x02\x01\x06\
    \x12\x04\xac\x20\x02\x0e\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xac\x20\x0f\
    \x1c\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xac\x20\x1f\x20\nY\n\x04\x04%\
    \x02\x02\x12\x04\xaf\x20\x02)\x1aK\x20Request\x20additional\x20info\x20t\
    o\x20be\x20retrieved\x20for\x20each\x20concept\x20in\x20the\x20response.\
    \n\n\r\n\x05\x04%\x02\x02\x06\x12\x04\xaf\x20\x02\x19\n\r\n\x05\x04%\x02\
    \x02\x01\x12\x04\xaf\x20\x1a$\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xaf\x20\
    '(\n]\n\x04\x04%\x02\x03\x12\x04\xb3\x20\x02\x1c\x1aO\x20Pagination\x20p\
    arameters\x20here\x20since\x20there\x20are\x20no\x20url\x20args\x20in\
    \x20this\n\x20POST\x20request.\n\n\r\n\x05\x04%\x02\x03\x06\x12\x04\xb3\
    \x20\x02\x0c\n\r\n\x05\x04%\x02\x03\x01\x12\x04\xb3\x20\r\x17\n\r\n\x05\
    \x04%\x02\x03\x03\x12\x04\xb3\x20\x1a\x1b\n\x0c\n\x02\x04&\x12\x06\xb6\
    \x20\0\xbf\x20\x01\n\x0b\n\x03\x04&\x01\x12\x04\xb6\x20\x08\x1f\n\xd8\
    \x01\n\x04\x04&\x02\0\x12\x04\xbe\x20\x02\x1b\x1a\xc9\x01\x20Determine\
    \x20if\x20the\x20concept\x20is\x20searchable\x20by\x20rank\x20using\x20t\
    his\x20model.\n\x20Currently,\x20only\x20embedder\x20models\x20are\x20su\
    pported.\n\x20##########\x20Supported\x20fields\x20##########\n\x20-\x20\
    app_id\n\x20-\x20id\n\x20-\x20model_version.id\n\x20-\x20user_id\n\n\r\n\
    \x05\x04&\x02\0\x06\x12\x04\xbe\x20\x02\x07\n\r\n\x05\x04&\x02\0\x01\x12\
    \x04\xbe\x20\x08\x16\n\r\n\x05\x04&\x02\0\x03\x12\x04\xbe\x20\x19\x1a\n#\
    \n\x02\x04'\x12\x06\xc2\x20\0\xc6\x20\x01\x1a\x15\x20PostConceptsRequest\
    \n\n\x0b\n\x03\x04'\x01\x12\x04\xc2\x20\x08\x1b\n\x0c\n\x04\x04'\x02\0\
    \x12\x04\xc3\x20\x02,\n\r\n\x05\x04'\x02\0\x06\x12\x04\xc3\x20\x02\x1b\n\
    \r\n\x05\x04'\x02\0\x01\x12\x04\xc3\x20\x1c'\n\r\n\x05\x04'\x02\0\x03\
    \x12\x04\xc3\x20*+\n$\n\x04\x04'\x02\x01\x12\x04\xc5\x20\x02\x20\x1a\x16\
    \x20The\x20concepts\x20to\x20add.\n\n\r\n\x05\x04'\x02\x01\x04\x12\x04\
    \xc5\x20\x02\n\n\r\n\x05\x04'\x02\x01\x06\x12\x04\xc5\x20\x0b\x12\n\r\n\
    \x05\x04'\x02\x01\x01\x12\x04\xc5\x20\x13\x1b\n\r\n\x05\x04'\x02\x01\x03\
    \x12\x04\xc5\x20\x1e\x1f\n$\n\x02\x04(\x12\x06\xc9\x20\0\xd1\x20\x01\x1a\
    \x16\x20PatchConceptsRequest\n\n\x0b\n\x03\x04(\x01\x12\x04\xc9\x20\x08\
    \x1c\n\x0c\n\x04\x04(\x02\0\x12\x04\xca\x20\x02,\n\r\n\x05\x04(\x02\0\
    \x06\x12\x04\xca\x20\x02\x1b\n\r\n\x05\x04(\x02\0\x01\x12\x04\xca\x20\
    \x1c'\n\r\n\x05\x04(\x02\0\x03\x12\x04\xca\x20*+\n&\n\x04\x04(\x02\x01\
    \x12\x04\xcc\x20\x02\x20\x1a\x18\x20The\x20concepts\x20to\x20patch.\n\n\
    \r\n\x05\x04(\x02\x01\x04\x12\x04\xcc\x20\x02\n\n\r\n\x05\x04(\x02\x01\
    \x06\x12\x04\xcc\x20\x0b\x12\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xcc\x20\
    \x13\x1b\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xcc\x20\x1e\x1f\ni\n\x04\x04\
    (\x02\x02\x12\x04\xd0\x20\x02\x14\x1a[\x20The\x20action\x20to\x20perform\
    \x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20ony\x20action\x20\
    'overwrite'\x20is\x20supported\n\n\r\n\x05\x04(\x02\x02\x05\x12\x04\xd0\
    \x20\x02\x08\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xd0\x20\t\x0f\n\r\n\x05\
    \x04(\x02\x02\x03\x12\x04\xd0\x20\x12\x13\n'\n\x02\x04)\x12\x06\xd4\x20\
    \0\xdc\x20\x01\x1a\x19\x20GetConceptCountsRequest\n\n\x0b\n\x03\x04)\x01\
    \x12\x04\xd4\x20\x08\x1f\n\x0c\n\x04\x04)\x02\0\x12\x04\xd5\x20\x02,\n\r\
    \n\x05\x04)\x02\0\x06\x12\x04\xd5\x20\x02\x1b\n\r\n\x05\x04)\x02\0\x01\
    \x12\x04\xd5\x20\x1c'\n\r\n\x05\x04)\x02\0\x03\x12\x04\xd5\x20*+\n~\n\
    \x04\x04)\x02\x01\x12\x04\xd8\x20\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04)\x02\x01\x05\x12\x04\xd8\x20\x02\x08\n\r\n\x05\x04)\x02\x01\
    \x01\x12\x04\xd8\x20\t\r\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xd8\x20\x10\
    \x11\nu\n\x04\x04)\x02\x02\x12\x04\xdb\x20\x02\x16\x1ag\x20(optional\x20\
    URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20b\
    e\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\
    \n\x05\x04)\x02\x02\x05\x12\x04\xdb\x20\x02\x08\n\r\n\x05\x04)\x02\x02\
    \x01\x12\x04\xdb\x20\t\x11\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xdb\x20\
    \x14\x15\n%\n\x02\x04*\x12\x06\xdf\x20\0\xe4\x20\x01\x1a\x17\x20SingleCo\
    nceptResponse\n\n\x0b\n\x03\x04*\x01\x12\x04\xdf\x20\x08\x1d\n$\n\x04\
    \x04*\x02\0\x12\x04\xe1\x20\x02(\x1a\x16\x20The\x20response\x20status.\n\
    \n\r\n\x05\x04*\x02\0\x06\x12\x04\xe1\x20\x02\x1c\n\r\n\x05\x04*\x02\0\
    \x01\x12\x04\xe1\x20\x1d#\n\r\n\x05\x04*\x02\0\x03\x12\x04\xe1\x20&'\n%\
    \n\x04\x04*\x02\x01\x12\x04\xe3\x20\x02\x16\x1a\x17\x20The\x20returned\
    \x20concept.\n\n\r\n\x05\x04*\x02\x01\x06\x12\x04\xe3\x20\x02\t\n\r\n\
    \x05\x04*\x02\x01\x01\x12\x04\xe3\x20\n\x11\n\r\n\x05\x04*\x02\x01\x03\
    \x12\x04\xe3\x20\x14\x15\n$\n\x02\x04+\x12\x06\xe7\x20\0\xec\x20\x01\x1a\
    \x16\x20MultiConceptResponse\n\n\x0b\n\x03\x04+\x01\x12\x04\xe7\x20\x08\
    \x1c\n$\n\x04\x04+\x02\0\x12\x04\xe9\x20\x02(\x1a\x16\x20The\x20response\
    \x20status.\n\n\r\n\x05\x04+\x02\0\x06\x12\x04\xe9\x20\x02\x1c\n\r\n\x05\
    \x04+\x02\0\x01\x12\x04\xe9\x20\x1d#\n\r\n\x05\x04+\x02\0\x03\x12\x04\
    \xe9\x20&'\n&\n\x04\x04+\x02\x01\x12\x04\xeb\x20\x02O\x1a\x18\x20The\x20\
    returned\x20concepts.\n\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xeb\x20\x02\n\
    \n\r\n\x05\x04+\x02\x01\x06\x12\x04\xeb\x20\x0b\x12\n\r\n\x05\x04+\x02\
    \x01\x01\x12\x04\xeb\x20\x13\x1b\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xeb\
    \x20\x1e\x1f\n\r\n\x05\x04+\x02\x01\x08\x12\x04\xeb\x20\x20N\n\x10\n\x08\
    \x04+\x02\x01\x08\xd0\x86\x03\x12\x04\xeb\x20!M\n)\n\x02\x04,\x12\x06\
    \xef\x20\0\xf4\x20\x01\x1a\x1b\x20MultiConceptCountResponse\n\n\x0b\n\
    \x03\x04,\x01\x12\x04\xef\x20\x08!\n$\n\x04\x04,\x02\0\x12\x04\xf1\x20\
    \x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x04,\x02\0\x06\
    \x12\x04\xf1\x20\x02\x1c\n\r\n\x05\x04,\x02\0\x01\x12\x04\xf1\x20\x1d#\n\
    \r\n\x05\x04,\x02\0\x03\x12\x04\xf1\x20&'\n,\n\x04\x04,\x02\x01\x12\x04\
    \xf3\x20\x02Z\x1a\x1e\x20The\x20returned\x20concept\x20counts.\n\n\r\n\
    \x05\x04,\x02\x01\x04\x12\x04\xf3\x20\x02\n\n\r\n\x05\x04,\x02\x01\x06\
    \x12\x04\xf3\x20\x0b\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xf3\x20\x18&\
    \n\r\n\x05\x04,\x02\x01\x03\x12\x04\xf3\x20)*\n\r\n\x05\x04,\x02\x01\x08\
    \x12\x04\xf3\x20+Y\n\x10\n\x08\x04,\x02\x01\x08\xd0\x86\x03\x12\x04\xf3\
    \x20,X\n`\n\x02\x04-\x12\x06\xf7\x20\0\x9f!\x01\x1aR\x20GET\x20all\x20re\
    lations\x20such\x20that\x20the\x20concept_id\x20refers\x20to\x20the\x20s\
    ubject\x20of\x20the\x20relation\n\n\x0b\n\x03\x04-\x01\x12\x04\xf7\x20\
    \x08#\n3\n\x04\x04-\x02\0\x12\x04\xf9\x20\x02,\x1a%\x20The\x20user_id\
    \x20and\x20app_id\x20information.\n\n\r\n\x05\x04-\x02\0\x06\x12\x04\xf9\
    \x20\x02\x1b\n\r\n\x05\x04-\x02\0\x01\x12\x04\xf9\x20\x1c'\n\r\n\x05\x04\
    -\x02\0\x03\x12\x04\xf9\x20*+\n\xb9\x07\n\x04\x04-\x02\x01\x12\x04\x89!\
    \x02\x18\x1a\xaa\x07\x20The\x20subject\x20concept\x20id\x20in\x20your\
    \x20app\x20to\x20get\x20all\x20the\x20relationships\x20for.\n\x20Leave\
    \x20as\x20an\x20empty\x20string\x20(GET\x20/concepts/relations)\x20to\
    \x20list\x20ALL\x20the\x20relations\x20in\x20the\x20app.\n\n\x20When\x20\
    listing\x20all\x20the\x20relations\x20it\x20will\x20only\x20return\x20on\
    e\x20direction\x20of\x20the\x20relationship\n\x20with\x20the\x20predicat\
    e\x20acting\x20on\x20the\x20subject\x20and\x20not\x20the\x20inverse\x20l\
    ike\x20is\x20done\x20when\x20providing\x20a\n\x20concept_id\x20so\x20tha\
    t\x20we\x20can\x20return\x20a\x20reliable\x20page\x20size\x20always.\n\n\
    \x20When\x20providing\x20a\x20concept_id,\x20if\x20a\x20hyponym\x20is\
    \x20present\x20in\x20the\x20DB\x20such\x20as:\n\x20'honey'\x20(subject),\
    \x20'hyponym'\x20(predicate\x20for\x20\"is\x20a\x20kind\x20of\"),\x20'fo\
    od'\x20(object)\n\x20then\x20you\x20can\x20list\x20the\x20concept\x20rel\
    ations\x20for\x20'honey'\x20and\x20get\x20hyponym\x20predicate\x20with\
    \x20'food'\n\x20object.\n\x20But\x20you\x20can\x20also\x20list\x20the\
    \x20concept\x20relations\x20for\x20'food'\x20and\x20it\x20will\x20return\
    \x20the\x20same\x20hyponym\n\x20relationship\x20with\x20'honey'\x20as\
    \x20object\x20and\x20'hypernym'\x20as\x20predicate.\n\x20Synonyms\x20by\
    \x20nature\x20are\x20symmetrical\x20relationships\x20so\x20either\x20sid\
    e\x20can\x20be\x20the\x20concept_id\x20(subject)\n\x20when\x20listing\
    \x20the\x20relations.\n\n\r\n\x05\x04-\x02\x01\x05\x12\x04\x89!\x02\x08\
    \n\r\n\x05\x04-\x02\x01\x01\x12\x04\x89!\t\x13\n\r\n\x05\x04-\x02\x01\
    \x03\x12\x04\x89!\x16\x17\n\xed\x02\n\x04\x04-\x02\x02\x12\x04\x94!\x02\
    \x17\x1a\xde\x02\x20If\x20predicate\x20is\x20provided\x20then\x20only\
    \x20list\x20relations\x20with\x20that\x20predicate.\n\n\x20Note\x20that\
    \x20if\x20no\x20subject\x20is\x20set\x20in\x20concept_id\x20and\x20predi\
    cate\x20is\x20set\x20to\n\x20'hypernym',\x20then\x20it\x20will\x20return\
    \x20any\x20stored\x20hyponyms\x20as\x20hypernyms\x20with\n\x20just\x20th\
    e\x20subject\x20and\x20object\x20swapped\x20since\x20they\x20are\x20reve\
    rsed\x20relations.\n\n\x20Valid\x20predicates\x20are:\n\x20-\x20'hyperny\
    m'\n\x20-\x20'hyponym'\n\x20-\x20'synonym'\n\n\r\n\x05\x04-\x02\x02\x05\
    \x12\x04\x94!\x02\x08\n\r\n\x05\x04-\x02\x02\x01\x12\x04\x94!\t\x12\n\r\
    \n\x05\x04-\x02\x02\x03\x12\x04\x94!\x15\x16\n\x8b\x02\n\x04\x04-\x02\
    \x03\x12\x04\x98!\x02\x20\x1a\xfc\x01\x20If\x20knowledge_graph_id\x20is\
    \x20provided\x20then\x20just\x20list\x20relations\x20from\x20that\x20kno\
    wledge\x20graph.\n\x20If\x20not\x20provided\x20then\x20list\x20relations\
    \x20from\x20all\x20knowledge\x20graphs\x20including\x20the\x20global\x20\
    one\x20for\x20this\n\x20app\x20one\x20(ie.\x20knowledge_graph\x20\"\")\
    \x20and\x20any\x20specific\x20ones\x20in\x20the\x20app.\n\n\r\n\x05\x04-\
    \x02\x03\x05\x12\x04\x98!\x02\x08\n\r\n\x05\x04-\x02\x03\x01\x12\x04\x98\
    !\t\x1b\n\r\n\x05\x04-\x02\x03\x03\x12\x04\x98!\x1e\x1f\n~\n\x04\x04-\
    \x02\x04\x12\x04\x9b!\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20\
    The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    -\x02\x04\x05\x12\x04\x9b!\x02\x08\n\r\n\x05\x04-\x02\x04\x01\x12\x04\
    \x9b!\t\r\n\r\n\x05\x04-\x02\x04\x03\x12\x04\x9b!\x10\x11\nu\n\x04\x04-\
    \x02\x05\x12\x04\x9e!\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04-\x02\x05\
    \x05\x12\x04\x9e!\x02\x08\n\r\n\x05\x04-\x02\x05\x01\x12\x04\x9e!\t\x11\
    \n\r\n\x05\x04-\x02\x05\x03\x12\x04\x9e!\x14\x15\n*\n\x02\x04.\x12\x06\
    \xa2!\0\xa9!\x01\x1a\x1c\x20POST\x20new\x20concept\x20relations\n\n\x0b\
    \n\x03\x04.\x01\x12\x04\xa2!\x08#\n3\n\x04\x04.\x02\0\x12\x04\xa4!\x02,\
    \x1a%\x20The\x20user_id\x20and\x20app_id\x20information.\n\n\r\n\x05\x04\
    .\x02\0\x06\x12\x04\xa4!\x02\x1b\n\r\n\x05\x04.\x02\0\x01\x12\x04\xa4!\
    \x1c'\n\r\n\x05\x04.\x02\0\x03\x12\x04\xa4!*+\nI\n\x04\x04.\x02\x01\x12\
    \x04\xa6!\x02\x18\x1a;\x20The\x20subject\x20concept\x20id\x20you're\x20g\
    oing\x20to\x20add\x20relations\x20for.\n\n\r\n\x05\x04.\x02\x01\x05\x12\
    \x04\xa6!\x02\x08\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xa6!\t\x13\n\r\n\
    \x05\x04.\x02\x01\x03\x12\x04\xa6!\x16\x17\n6\n\x04\x04.\x02\x02\x12\x04\
    \xa8!\x021\x1a(\x20The\x20relationships\x20you're\x20going\x20to\x20add.\
    \n\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xa8!\x02\n\n\r\n\x05\x04.\x02\x02\
    \x06\x12\x04\xa8!\x0b\x1a\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xa8!\x1b,\n\
    \r\n\x05\x04.\x02\x02\x03\x12\x04\xa8!/0\n(\n\x02\x04/\x12\x06\xac!\0\
    \xb3!\x01\x1a\x1a\x20DELETE\x20concept\x20relations\n\n\x0b\n\x03\x04/\
    \x01\x12\x04\xac!\x08%\n3\n\x04\x04/\x02\0\x12\x04\xae!\x02,\x1a%\x20The\
    \x20user_id\x20and\x20app_id\x20information.\n\n\r\n\x05\x04/\x02\0\x06\
    \x12\x04\xae!\x02\x1b\n\r\n\x05\x04/\x02\0\x01\x12\x04\xae!\x1c'\n\r\n\
    \x05\x04/\x02\0\x03\x12\x04\xae!*+\n7\n\x04\x04/\x02\x01\x12\x04\xb0!\
    \x02\x18\x1a)\x20The\x20concept\x20to\x20delete\x20relationship\x20for.\
    \n\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xb0!\x02\x08\n\r\n\x05\x04/\x02\
    \x01\x01\x12\x04\xb0!\t\x13\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xb0!\x16\
    \x17\n7\n\x04\x04/\x02\x02\x12\x04\xb2!\x02\x1a\x1a)\x20The\x20concept\
    \x20relationship\x20ids\x20to\x20delete.\n\n\r\n\x05\x04/\x02\x02\x04\
    \x12\x04\xb2!\x02\n\n\r\n\x05\x04/\x02\x02\x05\x12\x04\xb2!\x0b\x11\n\r\
    \n\x05\x04/\x02\x02\x01\x12\x04\xb2!\x12\x15\n\r\n\x05\x04/\x02\x02\x03\
    \x12\x04\xb2!\x18\x19\n(\n\x02\x040\x12\x06\xb6!\0\xb9!\x01\x1a\x1a\x20G\
    ET\x20all\x20knowledge\x20graphs\n\n\x0b\n\x03\x040\x01\x12\x04\xb6!\x08\
    \"\n3\n\x04\x040\x02\0\x12\x04\xb8!\x02,\x1a%\x20The\x20user_id\x20and\
    \x20app_id\x20information.\n\n\r\n\x05\x040\x02\0\x06\x12\x04\xb8!\x02\
    \x1b\n\r\n\x05\x040\x02\0\x01\x12\x04\xb8!\x1c'\n\r\n\x05\x040\x02\0\x03\
    \x12\x04\xb8!*+\n)\n\x02\x041\x12\x06\xbc!\0\xc0!\x01\x1a\x1b\x20POST\
    \x20new\x20knowledge\x20graphs\n\n\x0b\n\x03\x041\x01\x12\x04\xbc!\x08\"\
    \n3\n\x04\x041\x02\0\x12\x04\xbe!\x02,\x1a%\x20The\x20user_id\x20and\x20\
    app_id\x20information.\n\n\r\n\x05\x041\x02\0\x06\x12\x04\xbe!\x02\x1b\n\
    \r\n\x05\x041\x02\0\x01\x12\x04\xbe!\x1c'\n\r\n\x05\x041\x02\0\x03\x12\
    \x04\xbe!*+\n\x0c\n\x04\x041\x02\x01\x12\x04\xbf!\x02/\n\r\n\x05\x041\
    \x02\x01\x04\x12\x04\xbf!\x02\n\n\r\n\x05\x041\x02\x01\x06\x12\x04\xbf!\
    \x0b\x19\n\r\n\x05\x041\x02\x01\x01\x12\x04\xbf!\x1a*\n\r\n\x05\x041\x02\
    \x01\x03\x12\x04\xbf!-.\n*\n\x02\x042\x12\x06\xc5!\0\xca!\x01\x1a\x1c\
    \x20Start\x20concept\x20mapping\x20jobs\n\n\x0b\n\x03\x042\x01\x12\x04\
    \xc5!\x08%\n3\n\x04\x042\x02\0\x12\x04\xc7!\x02,\x1a%\x20The\x20user_id\
    \x20and\x20app_id\x20information.\n\n\r\n\x05\x042\x02\0\x06\x12\x04\xc7\
    !\x02\x1b\n\r\n\x05\x042\x02\0\x01\x12\x04\xc7!\x1c'\n\r\n\x05\x042\x02\
    \0\x03\x12\x04\xc7!*+\n?\n\x04\x042\x02\x01\x12\x04\xc9!\x026\x1a1\x20Th\
    e\x20concept\x20mapping\x20jobs\x20that\x20are\x20being\x20started\n\n\r\
    \n\x05\x042\x02\x01\x04\x12\x04\xc9!\x02\n\n\r\n\x05\x042\x02\x01\x06\
    \x12\x04\xc9!\x0b\x1c\n\r\n\x05\x042\x02\x01\x01\x12\x04\xc9!\x1d1\n\r\n\
    \x05\x042\x02\x01\x03\x12\x04\xc9!45\n,\n\x02\x043\x12\x06\xce!\0\xd3!\
    \x01\x1a\x1e\x20MultiConceptRelationResponse\n\n\x0b\n\x03\x043\x01\x12\
    \x04\xce!\x08$\n$\n\x04\x043\x02\0\x12\x04\xd0!\x02(\x1a\x16\x20The\x20r\
    esponse\x20status.\n\n\r\n\x05\x043\x02\0\x06\x12\x04\xd0!\x02\x1c\n\r\n\
    \x05\x043\x02\0\x01\x12\x04\xd0!\x1d#\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \xd0!&'\n/\n\x04\x043\x02\x01\x12\x04\xd2!\x02`\x1a!\x20The\x20returned\
    \x20concept\x20relations.\n\n\r\n\x05\x043\x02\x01\x04\x12\x04\xd2!\x02\
    \n\n\r\n\x05\x043\x02\x01\x06\x12\x04\xd2!\x0b\x1a\n\r\n\x05\x043\x02\
    \x01\x01\x12\x04\xd2!\x1b,\n\r\n\x05\x043\x02\x01\x03\x12\x04\xd2!/0\n\r\
    \n\x05\x043\x02\x01\x08\x12\x04\xd2!1_\n\x10\n\x08\x043\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xd2!2^\n+\n\x02\x044\x12\x06\xd7!\0\xdc!\x01\x1a\x1d\
    \x20MultiKnowledgeGraphResponse\n\n\x0b\n\x03\x044\x01\x12\x04\xd7!\x08#\
    \n$\n\x04\x044\x02\0\x12\x04\xd9!\x02(\x1a\x16\x20The\x20response\x20sta\
    tus.\n\n\r\n\x05\x044\x02\0\x06\x12\x04\xd9!\x02\x1c\n\r\n\x05\x044\x02\
    \0\x01\x12\x04\xd9!\x1d#\n\r\n\x05\x044\x02\0\x03\x12\x04\xd9!&'\n.\n\
    \x04\x044\x02\x01\x12\x04\xdb!\x02^\x1a\x20\x20The\x20returned\x20knowle\
    dge\x20graphs.\n\n\r\n\x05\x044\x02\x01\x04\x12\x04\xdb!\x02\n\n\r\n\x05\
    \x044\x02\x01\x06\x12\x04\xdb!\x0b\x19\n\r\n\x05\x044\x02\x01\x01\x12\
    \x04\xdb!\x1a*\n\r\n\x05\x044\x02\x01\x03\x12\x04\xdb!-.\n\r\n\x05\x044\
    \x02\x01\x08\x12\x04\xdb!/]\n\x10\n\x08\x044\x02\x01\x08\xd0\x86\x03\x12\
    \x04\xdb!0\\\n.\n\x02\x045\x12\x06\xe2!\0\xe7!\x01\x1a\x20\x20MultiConce\
    ptMappingJobResponse\n\n\x0b\n\x03\x045\x01\x12\x04\xe2!\x08&\n$\n\x04\
    \x045\x02\0\x12\x04\xe4!\x02(\x1a\x16\x20The\x20response\x20status.\n\n\
    \r\n\x05\x045\x02\0\x06\x12\x04\xe4!\x02\x1c\n\r\n\x05\x045\x02\0\x01\
    \x12\x04\xe4!\x1d#\n\r\n\x05\x045\x02\0\x03\x12\x04\xe4!&'\n=\n\x04\x045\
    \x02\x01\x12\x04\xe6!\x02\x1a\x1a/\x20The\x20ids\x20of\x20the\x20concept\
    \x20mapping\x20jobs\x20underway.\n\n\r\n\x05\x045\x02\x01\x04\x12\x04\
    \xe6!\x02\n\n\r\n\x05\x045\x02\x01\x05\x12\x04\xe6!\x0b\x11\n\r\n\x05\
    \x045\x02\x01\x01\x12\x04\xe6!\x12\x15\n\r\n\x05\x045\x02\x01\x03\x12\
    \x04\xe6!\x18\x19\nB\n\x02\x046\x12\x06\xea!\0\xef!\x01\x1a4\x20GET\x20s\
    ingle\x20concept\x20language\x20for\x20the\x20given\x20concept.\n\n\x0b\
    \n\x03\x046\x01\x12\x04\xea!\x08!\n\x0c\n\x04\x046\x02\0\x12\x04\xeb!\
    \x02,\n\r\n\x05\x046\x02\0\x06\x12\x04\xeb!\x02\x1b\n\r\n\x05\x046\x02\0\
    \x01\x12\x04\xeb!\x1c'\n\r\n\x05\x046\x02\0\x03\x12\x04\xeb!*+\n\x0c\n\
    \x04\x046\x02\x01\x12\x04\xec!\x02\x18\n\r\n\x05\x046\x02\x01\x05\x12\
    \x04\xec!\x02\x08\n\r\n\x05\x046\x02\x01\x01\x12\x04\xec!\t\x13\n\r\n\
    \x05\x046\x02\x01\x03\x12\x04\xec!\x16\x17\n0\n\x04\x046\x02\x02\x12\x04\
    \xee!\x02\x16\x1a\"\x20This\x20is\x20the\x20language\x20identifier.\n\n\
    \r\n\x05\x046\x02\x02\x05\x12\x04\xee!\x02\x08\n\r\n\x05\x046\x02\x02\
    \x01\x12\x04\xee!\t\x11\n\r\n\x05\x046\x02\x02\x03\x12\x04\xee!\x14\x15\
    \nF\n\x02\x047\x12\x06\xf2!\0\xfb!\x01\x1a8\x20List\x20multiple\x20conce\
    pt\x20languages\x20for\x20the\x20given\x20concept.\n\n\x0b\n\x03\x047\
    \x01\x12\x04\xf2!\x08#\n\x0c\n\x04\x047\x02\0\x12\x04\xf3!\x02,\n\r\n\
    \x05\x047\x02\0\x06\x12\x04\xf3!\x02\x1b\n\r\n\x05\x047\x02\0\x01\x12\
    \x04\xf3!\x1c'\n\r\n\x05\x047\x02\0\x03\x12\x04\xf3!*+\n\x0c\n\x04\x047\
    \x02\x01\x12\x04\xf4!\x02\x18\n\r\n\x05\x047\x02\x01\x05\x12\x04\xf4!\
    \x02\x08\n\r\n\x05\x047\x02\x01\x01\x12\x04\xf4!\t\x13\n\r\n\x05\x047\
    \x02\x01\x03\x12\x04\xf4!\x16\x17\n~\n\x04\x047\x02\x02\x12\x04\xf7!\x02\
    \x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\
    \x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x047\x02\x02\x05\x12\
    \x04\xf7!\x02\x08\n\r\n\x05\x047\x02\x02\x01\x12\x04\xf7!\t\r\n\r\n\x05\
    \x047\x02\x02\x03\x12\x04\xf7!\x10\x11\nu\n\x04\x047\x02\x03\x12\x04\xfa\
    !\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x047\x02\x03\x05\x12\x04\xfa!\
    \x02\x08\n\r\n\x05\x047\x02\x03\x01\x12\x04\xfa!\t\x11\n\r\n\x05\x047\
    \x02\x03\x03\x12\x04\xfa!\x14\x15\nG\n\x02\x048\x12\x06\xfe!\0\x84\"\x01\
    \x1a9\x20PATCH\x20multiple\x20concept\x20languages\x20for\x20the\x20give\
    n\x20concept.\n\n\x0b\n\x03\x048\x01\x12\x04\xfe!\x08$\n\x0c\n\x04\x048\
    \x02\0\x12\x04\xff!\x02,\n\r\n\x05\x048\x02\0\x06\x12\x04\xff!\x02\x1b\n\
    \r\n\x05\x048\x02\0\x01\x12\x04\xff!\x1c'\n\r\n\x05\x048\x02\0\x03\x12\
    \x04\xff!*+\n\x0c\n\x04\x048\x02\x01\x12\x04\x80\"\x02\x18\n\r\n\x05\x04\
    8\x02\x01\x05\x12\x04\x80\"\x02\x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\
    \x80\"\t\x13\n\r\n\x05\x048\x02\x01\x03\x12\x04\x80\"\x16\x17\n\x0c\n\
    \x04\x048\x02\x02\x12\x04\x81\"\x021\n\r\n\x05\x048\x02\x02\x04\x12\x04\
    \x81\"\x02\n\n\r\n\x05\x048\x02\x02\x06\x12\x04\x81\"\x0b\x1a\n\r\n\x05\
    \x048\x02\x02\x01\x12\x04\x81\"\x1b,\n\r\n\x05\x048\x02\x02\x03\x12\x04\
    \x81\"/0\nD\n\x04\x048\x02\x03\x12\x04\x83\"\x02\x14\x1a6\x20The\x20acti\
    on\x20to\x20perform\x20with\x20the\x20objects\x20in\x20the\x20PATCH.\n\n\
    \r\n\x05\x048\x02\x03\x05\x12\x04\x83\"\x02\x08\n\r\n\x05\x048\x02\x03\
    \x01\x12\x04\x83\"\t\x0f\n\r\n\x05\x048\x02\x03\x03\x12\x04\x83\"\x12\
    \x13\n\xb9\x04\n\x02\x049\x12\x06\x9a\"\0\x9e\"\x01\x1a8\x20POST\x20mult\
    iple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\n2\xeb\
    \x01\x20//\x20DELETE\x20multiple\x20concept\x20languages\x20for\x20the\
    \x20given\x20concept.\n\x20message\x20DeleteConceptLanguageRequest\x20{\
    \n\x20\x20\x20clarifai.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\
    \x20\x20string\x20concept_id\x20=\x202;\n\x20\x20\x20//\x20The\x20langua\
    ge\x20code\x20to\x20delete.\n\x20\x20\x20string\x20language\x20=\x203;\n\
    \x20}\n2\x82\x02\x20//\x20DELETE\x20multiple\x20concept\x20languages\x20\
    for\x20the\x20given\x20concept.\n\x20message\x20DeleteConceptLanguagesRe\
    quest\x20{\n\x20\x20\x20clarifai.api.UserAppIDSet\x20user_app_id\x20=\
    \x201;\n\x20\x20\x20string\x20concept_id\x20=\x202;\n\x20\x20\x20//\x20T\
    he\x20language\x20code(s)\x20to\x20delete.\n\x20\x20\x20string\x20ids\
    \x20=\x203;\n\x20\x20\x20bool\x20delete_all\x20=\x204;\n\x20}\n\n\x0b\n\
    \x03\x049\x01\x12\x04\x9a\"\x08#\n\x0c\n\x04\x049\x02\0\x12\x04\x9b\"\
    \x02,\n\r\n\x05\x049\x02\0\x06\x12\x04\x9b\"\x02\x1b\n\r\n\x05\x049\x02\
    \0\x01\x12\x04\x9b\"\x1c'\n\r\n\x05\x049\x02\0\x03\x12\x04\x9b\"*+\n\x0c\
    \n\x04\x049\x02\x01\x12\x04\x9c\"\x02\x18\n\r\n\x05\x049\x02\x01\x05\x12\
    \x04\x9c\"\x02\x08\n\r\n\x05\x049\x02\x01\x01\x12\x04\x9c\"\t\x13\n\r\n\
    \x05\x049\x02\x01\x03\x12\x04\x9c\"\x16\x17\n\x0c\n\x04\x049\x02\x02\x12\
    \x04\x9d\"\x021\n\r\n\x05\x049\x02\x02\x04\x12\x04\x9d\"\x02\n\n\r\n\x05\
    \x049\x02\x02\x06\x12\x04\x9d\"\x0b\x1a\n\r\n\x05\x049\x02\x02\x01\x12\
    \x04\x9d\"\x1b,\n\r\n\x05\x049\x02\x02\x03\x12\x04\x9d\"/0\n-\n\x02\x04:\
    \x12\x06\xa1\"\0\xa4\"\x01\x1a\x1f\x20SingleConceptLanguageResponse\n\n\
    \x0b\n\x03\x04:\x01\x12\x04\xa1\"\x08%\n\x0c\n\x04\x04:\x02\0\x12\x04\
    \xa2\"\x02(\n\r\n\x05\x04:\x02\0\x06\x12\x04\xa2\"\x02\x1c\n\r\n\x05\x04\
    :\x02\0\x01\x12\x04\xa2\"\x1d#\n\r\n\x05\x04:\x02\0\x03\x12\x04\xa2\"&'\
    \n\x0c\n\x04\x04:\x02\x01\x12\x04\xa3\"\x02'\n\r\n\x05\x04:\x02\x01\x06\
    \x12\x04\xa3\"\x02\x11\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xa3\"\x12\"\n\
    \r\n\x05\x04:\x02\x01\x03\x12\x04\xa3\"%&\n,\n\x02\x04;\x12\x06\xa7\"\0\
    \xaa\"\x01\x1a\x1e\x20MultiConceptLanguageResponse\n\n\x0b\n\x03\x04;\
    \x01\x12\x04\xa7\"\x08$\n\x0c\n\x04\x04;\x02\0\x12\x04\xa8\"\x02(\n\r\n\
    \x05\x04;\x02\0\x06\x12\x04\xa8\"\x02\x1c\n\r\n\x05\x04;\x02\0\x01\x12\
    \x04\xa8\"\x1d#\n\r\n\x05\x04;\x02\0\x03\x12\x04\xa8\"&'\n\x0c\n\x04\x04\
    ;\x02\x01\x12\x04\xa9\"\x02`\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xa9\"\
    \x02\n\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xa9\"\x0b\x1a\n\r\n\x05\x04;\
    \x02\x01\x01\x12\x04\xa9\"\x1b,\n\r\n\x05\x04;\x02\x01\x03\x12\x04\xa9\"\
    /0\n\r\n\x05\x04;\x02\x01\x08\x12\x04\xa9\"1_\n\x10\n\x08\x04;\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xa9\"2^\n\x1f\n\x02\x04<\x12\x06\xb2\"\0\xb5\"\
    \x01\x1a\x11\x20GetInputRequest\n\n\x0b\n\x03\x04<\x01\x12\x04\xb2\"\x08\
    \x17\n\x0c\n\x04\x04<\x02\0\x12\x04\xb3\"\x02,\n\r\n\x05\x04<\x02\0\x06\
    \x12\x04\xb3\"\x02\x1b\n\r\n\x05\x04<\x02\0\x01\x12\x04\xb3\"\x1c'\n\r\n\
    \x05\x04<\x02\0\x03\x12\x04\xb3\"*+\n\x0c\n\x04\x04<\x02\x01\x12\x04\xb4\
    \"\x02\x16\n\r\n\x05\x04<\x02\x01\x05\x12\x04\xb4\"\x02\x08\n\r\n\x05\
    \x04<\x02\x01\x01\x12\x04\xb4\"\t\x11\n\r\n\x05\x04<\x02\x01\x03\x12\x04\
    \xb4\"\x14\x15\n\x0c\n\x02\x04=\x12\x06\xb6\"\0\xb9\"\x01\n\x0b\n\x03\
    \x04=\x01\x12\x04\xb6\"\x08\x1f\n\x0c\n\x04\x04=\x02\0\x12\x04\xb7\"\x02\
    ,\n\r\n\x05\x04=\x02\0\x06\x12\x04\xb7\"\x02\x1b\n\r\n\x05\x04=\x02\0\
    \x01\x12\x04\xb7\"\x1c'\n\r\n\x05\x04=\x02\0\x03\x12\x04\xb7\"*+\n\x0c\n\
    \x04\x04=\x02\x01\x12\x04\xb8\"\x02\x16\n\r\n\x05\x04=\x02\x01\x05\x12\
    \x04\xb8\"\x02\x08\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xb8\"\t\x11\n\r\n\
    \x05\x04=\x02\x01\x03\x12\x04\xb8\"\x14\x15\n&\n\x02\x04>\x12\x06\xbc\"\
    \0\xc1\"\x01\x1a\x18\x20GetInputSamplesRequest\n\n\x0b\n\x03\x04>\x01\
    \x12\x04\xbc\"\x08\x1e\n\x0c\n\x04\x04>\x02\0\x12\x04\xbd\"\x02,\n\r\n\
    \x05\x04>\x02\0\x06\x12\x04\xbd\"\x02\x1b\n\r\n\x05\x04>\x02\0\x01\x12\
    \x04\xbd\"\x1c'\n\r\n\x05\x04>\x02\0\x03\x12\x04\xbd\"*+\n\x0c\n\x04\x04\
    >\x02\x01\x12\x04\xbe\"\x02\x15\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xbe\"\
    \x02\x08\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xbe\"\t\x10\n\r\n\x05\x04>\
    \x02\x01\x03\x12\x04\xbe\"\x13\x14\nN\n\x04\x04>\x02\x02\x12\x04\xc0\"\
    \x02\x1f\x1a@\x20URL\x20param.\x20If\x20zero\x20ids\x20provided,\x20retu\
    rns\x20for\x20all\x20task\x20labelers\n\n\r\n\x05\x04>\x02\x02\x04\x12\
    \x04\xc0\"\x02\n\n\r\n\x05\x04>\x02\x02\x05\x12\x04\xc0\"\x0b\x11\n\r\n\
    \x05\x04>\x02\x02\x01\x12\x04\xc0\"\x12\x1a\n\r\n\x05\x04>\x02\x02\x03\
    \x12\x04\xc0\"\x1d\x1e\n!\n\x02\x04?\x12\x06\xc4\"\0\xd1\"\x01\x1a\x13\
    \x20ListInputsRequest\n\n\x0b\n\x03\x04?\x01\x12\x04\xc4\"\x08\x19\n\x0c\
    \n\x04\x04?\x02\0\x12\x04\xc5\"\x02,\n\r\n\x05\x04?\x02\0\x06\x12\x04\
    \xc5\"\x02\x1b\n\r\n\x05\x04?\x02\0\x01\x12\x04\xc5\"\x1c'\n\r\n\x05\x04\
    ?\x02\0\x03\x12\x04\xc5\"*+\n~\n\x04\x04?\x02\x01\x12\x04\xc8\"\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xc8\"\
    \x02\x08\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xc8\"\t\r\n\r\n\x05\x04?\x02\
    \x01\x03\x12\x04\xc8\"\x10\x11\nu\n\x04\x04?\x02\x02\x12\x04\xcb\"\x02\
    \x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20re\
    sults\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defau\
    lts\n\x20to\x20128.\n\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xcb\"\x02\x08\n\
    \r\n\x05\x04?\x02\x02\x01\x12\x04\xcb\"\t\x11\n\r\n\x05\x04?\x02\x02\x03\
    \x12\x04\xcb\"\x14\x15\n.\n\x04\x04?\x02\x03\x12\x04\xce\"\x02(\x1a\x20\
    \x20Set\x20status\x20to\x20filter\x20by\x20status\n\n\r\n\x05\x04?\x02\
    \x03\x06\x12\x04\xce\"\x02\x1c\n\r\n\x05\x04?\x02\x03\x01\x12\x04\xce\"\
    \x1d#\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xce\"&'\n\x0c\n\x04\x04?\x02\
    \x04\x12\x04\xd0\"\x02\x1a\n\r\n\x05\x04?\x02\x04\x04\x12\x04\xd0\"\x02\
    \n\n\r\n\x05\x04?\x02\x04\x05\x12\x04\xd0\"\x0b\x11\n\r\n\x05\x04?\x02\
    \x04\x01\x12\x04\xd0\"\x12\x15\n\r\n\x05\x04?\x02\x04\x03\x12\x04\xd0\"\
    \x18\x19\n#\n\x02\x04@\x12\x06\xd4\"\0\xdf\"\x01\x1a\x15\x20StreamInputs\
    Request\n\n\x0b\n\x03\x04@\x01\x12\x04\xd4\"\x08\x1b\n\x0c\n\x04\x04@\
    \x02\0\x12\x04\xd5\"\x02,\n\r\n\x05\x04@\x02\0\x06\x12\x04\xd5\"\x02\x1b\
    \n\r\n\x05\x04@\x02\0\x01\x12\x04\xd5\"\x1c'\n\r\n\x05\x04@\x02\0\x03\
    \x12\x04\xd5\"*+\nt\n\x04\x04@\x02\x01\x12\x04\xd8\"\x02\x16\x1af\x20(op\
    tional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x2020.\n\n\r\n\x05\x04@\x02\x01\x05\x12\x04\xd8\"\x02\x08\n\r\n\x05\x04\
    @\x02\x01\x01\x12\x04\xd8\"\t\x11\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xd8\
    \"\x14\x15\n\x0c\n\x04\x04@\x02\x02\x12\x04\xd9\"\x02\x15\n\r\n\x05\x04@\
    \x02\x02\x05\x12\x04\xd9\"\x02\x08\n\r\n\x05\x04@\x02\x02\x01\x12\x04\
    \xd9\"\t\x10\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xd9\"\x13\x14\n\x8a\x01\
    \n\x04\x04@\x02\x03\x12\x04\xdd\"\x02\x17\x1a|\x20By\x20default,\x20the\
    \x20endpoint\x20return\x20inputs\x20by\x20the\x20time\x20when\x20it\x20i\
    s\x20added.\n\x20If\x20this\x20is\x20set\x20to\x20true,\x20we\x20will\
    \x20return\x20inputs\x20by\x20id.\n\n\r\n\x05\x04@\x02\x03\x05\x12\x04\
    \xdd\"\x02\x06\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xdd\"\x07\x12\n\r\n\
    \x05\x04@\x02\x03\x03\x12\x04\xdd\"\x15\x16\n\x0c\n\x04\x04@\x02\x04\x12\
    \x04\xde\"\x02\x16\n\r\n\x05\x04@\x02\x04\x05\x12\x04\xde\"\x02\x06\n\r\
    \n\x05\x04@\x02\x04\x01\x12\x04\xde\"\x07\x11\n\r\n\x05\x04@\x02\x04\x03\
    \x12\x04\xde\"\x14\x15\n!\n\x02\x04A\x12\x06\xe2\"\0\xf4\"\x01\x1a\x13\
    \x20PostInputsRequest\n\n\x0b\n\x03\x04A\x01\x12\x04\xe2\"\x08\x19\n\x0c\
    \n\x04\x04A\x02\0\x12\x04\xe3\"\x02,\n\r\n\x05\x04A\x02\0\x06\x12\x04\
    \xe3\"\x02\x1b\n\r\n\x05\x04A\x02\0\x01\x12\x04\xe3\"\x1c'\n\r\n\x05\x04\
    A\x02\0\x03\x12\x04\xe3\"*+\nt\n\x04\x04A\x02\x01\x12\x04\xea\"\x02\x1c\
    \x1af\x20List\x20of\x20inputs\x20to\x20post.\n\x20For\x20each\x20input,\
    \x20the\x20following\x20fields\x20are\x20used:\n\x20*\x20id\n\x20*\x20da\
    ta\n\x20*\x20dataset_ids\n\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xea\"\x02\
    \n\n\r\n\x05\x04A\x02\x01\x06\x12\x04\xea\"\x0b\x10\n\r\n\x05\x04A\x02\
    \x01\x01\x12\x04\xea\"\x11\x17\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xea\"\
    \x1a\x1b\n\xc9\x02\n\x04\x04A\x02\x02\x12\x04\xf0\"\x02\x1f\x1a\xba\x02\
    \x20Collect\x20statistics\x20about\x20created\x20inputs\x20in\x20job\x20\
    with\x20given\x20ID.\n\x20*\x20If\x20job\x20ID\x20is\x20empty,\x20then\
    \x20job\x20is\x20not\x20created.\n\x20*\x20If\x20job\x20ID\x20is\x20non-\
    empty\x20and\x20doesn't\x20already\x20exist,\x20then\x20a\x20new\x20job\
    \x20will\x20be\x20created\x20with\x20given\x20ID.\n\x20*\x20If\x20job\
    \x20ID\x20does\x20already\x20exist,\x20then\x20new\x20inputs\x20statisti\
    cs\x20are\x20merged\x20with\x20previous\x20inputs\x20statistics.\n\n\r\n\
    \x05\x04A\x02\x02\x05\x12\x04\xf0\"\x02\x08\n\r\n\x05\x04A\x02\x02\x01\
    \x12\x04\xf0\"\t\x1a\n\r\n\x05\x04A\x02\x02\x03\x12\x04\xf0\"\x1d\x1e\n1\
    \n\x04\x04A\x02\x03\x12\x04\xf3\"\x02=\x1a#\x20How\x20to\x20handle\x20in\
    put\x20ID\x20conflicts.\n\n\r\n\x05\x04A\x02\x03\x06\x12\x04\xf3\"\x02\
    \x1b\n\r\n\x05\x04A\x02\x03\x01\x12\x04\xf3\"\x1c8\n\r\n\x05\x04A\x02\
    \x03\x03\x12\x04\xf3\";<\n\"\n\x02\x04B\x12\x06\xfb\"\0\x87#\x01\x1a\x14\
    \x20PatchInputsRequest\n\n\x0b\n\x03\x04B\x01\x12\x04\xfb\"\x08\x1a\n\
    \x0c\n\x04\x04B\x02\0\x12\x04\xfc\"\x02,\n\r\n\x05\x04B\x02\0\x06\x12\
    \x04\xfc\"\x02\x1b\n\r\n\x05\x04B\x02\0\x01\x12\x04\xfc\"\x1c'\n\r\n\x05\
    \x04B\x02\0\x03\x12\x04\xfc\"*+\n\x89\x01\n\x04\x04B\x02\x01\x12\x04\x82\
    #\x02\x1c\x1a{\x20List\x20of\x20inputs\x20to\x20patch.\n\x20Inputs\x20ar\
    e\x20identified\x20by\x20id\x20field.\n\x20For\x20each\x20input,\x20the\
    \x20following\x20fields\x20are\x20patchable:\n\x20*\x20data\n\n\r\n\x05\
    \x04B\x02\x01\x04\x12\x04\x82#\x02\n\n\r\n\x05\x04B\x02\x01\x06\x12\x04\
    \x82#\x0b\x10\n\r\n\x05\x04B\x02\x01\x01\x12\x04\x82#\x11\x17\n\r\n\x05\
    \x04B\x02\x01\x03\x12\x04\x82#\x1a\x1b\n~\n\x04\x04B\x02\x02\x12\x04\x86\
    #\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\
    \x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20an\
    d\x20'remove'\x20are\x20supported\n\n\r\n\x05\x04B\x02\x02\x05\x12\x04\
    \x86#\x02\x08\n\r\n\x05\x04B\x02\x02\x01\x12\x04\x86#\t\x0f\n\r\n\x05\
    \x04B\x02\x02\x03\x12\x04\x86#\x12\x13\n\"\n\x02\x04C\x12\x06\x8a#\0\x8d\
    #\x01\x1a\x14\x20DeleteInputRequest\n\n\x0b\n\x03\x04C\x01\x12\x04\x8a#\
    \x08\x1a\n\x0c\n\x04\x04C\x02\0\x12\x04\x8b#\x02,\n\r\n\x05\x04C\x02\0\
    \x06\x12\x04\x8b#\x02\x1b\n\r\n\x05\x04C\x02\0\x01\x12\x04\x8b#\x1c'\n\r\
    \n\x05\x04C\x02\0\x03\x12\x04\x8b#*+\n\x0c\n\x04\x04C\x02\x01\x12\x04\
    \x8c#\x02\x16\n\r\n\x05\x04C\x02\x01\x05\x12\x04\x8c#\x02\x08\n\r\n\x05\
    \x04C\x02\x01\x01\x12\x04\x8c#\t\x11\n\r\n\x05\x04C\x02\x01\x03\x12\x04\
    \x8c#\x14\x15\nD\n\x02\x04D\x12\x06\x90#\0\x95#\x01\x1a6\x20Request\x20t\
    o\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\
    \x0b\n\x03\x04D\x01\x12\x04\x90#\x08\x1b\n\x0b\n\x03\x04D\t\x12\x04\x91#\
    \x02\r\n\x0c\n\x04\x04D\t\0\x12\x04\x91#\x0b\x0c\n\r\n\x05\x04D\t\0\x01\
    \x12\x04\x91#\x0b\x0c\n\r\n\x05\x04D\t\0\x02\x12\x04\x91#\x0b\x0c\n\x0c\
    \n\x04\x04D\x02\0\x12\x04\x93#\x02,\n\r\n\x05\x04D\x02\0\x06\x12\x04\x93\
    #\x02\x1b\n\r\n\x05\x04D\x02\0\x01\x12\x04\x93#\x1c'\n\r\n\x05\x04D\x02\
    \0\x03\x12\x04\x93#*+\n\x0c\n\x04\x04D\x02\x01\x12\x04\x94#\x02\x1a\n\r\
    \n\x05\x04D\x02\x01\x04\x12\x04\x94#\x02\n\n\r\n\x05\x04D\x02\x01\x05\
    \x12\x04\x94#\x0b\x11\n\r\n\x05\x04D\x02\x01\x01\x12\x04\x94#\x12\x15\n\
    \r\n\x05\x04D\x02\x01\x03\x12\x04\x94#\x18\x19\n#\n\x02\x04E\x12\x06\x98\
    #\0\x9b#\x01\x1a\x15\x20SingleInputResponse\n\n\x0b\n\x03\x04E\x01\x12\
    \x04\x98#\x08\x1b\n\x0c\n\x04\x04E\x02\0\x12\x04\x99#\x02(\n\r\n\x05\x04\
    E\x02\0\x06\x12\x04\x99#\x02\x1c\n\r\n\x05\x04E\x02\0\x01\x12\x04\x99#\
    \x1d#\n\r\n\x05\x04E\x02\0\x03\x12\x04\x99#&'\n\x0c\n\x04\x04E\x02\x01\
    \x12\x04\x9a#\x02\x12\n\r\n\x05\x04E\x02\x01\x06\x12\x04\x9a#\x02\x07\n\
    \r\n\x05\x04E\x02\x01\x01\x12\x04\x9a#\x08\r\n\r\n\x05\x04E\x02\x01\x03\
    \x12\x04\x9a#\x10\x11\n\x0c\n\x02\x04F\x12\x06\x9d#\0\xa4#\x01\n\x0b\n\
    \x03\x04F\x01\x12\x04\x9d#\x08\x20\n\x0c\n\x04\x04F\x02\0\x12\x04\x9e#\
    \x02(\n\r\n\x05\x04F\x02\0\x06\x12\x04\x9e#\x02\x1c\n\r\n\x05\x04F\x02\0\
    \x01\x12\x04\x9e#\x1d#\n\r\n\x05\x04F\x02\0\x03\x12\x04\x9e#&'\n\x95\x01\
    \n\x04\x04F\x02\x01\x12\x04\xa3#\x02\x1a\x1a\x86\x01\x20MPEG-dash\x20man\
    ifest\x20as\x20data-URI,\x20base64-encoded\n\x20Can\x20be\x20empty\x20if\
    \x20status\x20is\x20FAILED\n\x20Can\x20be\x20fallback\x20manifest\x20if\
    \x20status\x20is\x20MIXED_STATUS\n\n\r\n\x05\x04F\x02\x01\x05\x12\x04\
    \xa3#\x02\x08\n\r\n\x05\x04F\x02\x01\x01\x12\x04\xa3#\t\x15\n\r\n\x05\
    \x04F\x02\x01\x03\x12\x04\xa3#\x18\x19\n\"\n\x02\x04G\x12\x06\xa7#\0\xad\
    #\x01\x1a\x14\x20MultiInputResponse\n\n\x0b\n\x03\x04G\x01\x12\x04\xa7#\
    \x08\x1a\n\x0c\n\x04\x04G\x02\0\x12\x04\xa9#\x02(\n\r\n\x05\x04G\x02\0\
    \x06\x12\x04\xa9#\x02\x1c\n\r\n\x05\x04G\x02\0\x01\x12\x04\xa9#\x1d#\n\r\
    \n\x05\x04G\x02\0\x03\x12\x04\xa9#&'\n\x0c\n\x04\x04G\x02\x01\x12\x04\
    \xaa#\x02K\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xaa#\x02\n\n\r\n\x05\x04G\
    \x02\x01\x06\x12\x04\xaa#\x0b\x10\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xaa\
    #\x11\x17\n\r\n\x05\x04G\x02\x01\x03\x12\x04\xaa#\x1a\x1b\n\r\n\x05\x04G\
    \x02\x01\x08\x12\x04\xaa#\x1cJ\n\x10\n\x08\x04G\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xaa#\x1dI\n\x0c\n\x04\x04G\x02\x02\x12\x04\xac#\x02\"\n\r\n\x05\
    \x04G\x02\x02\x06\x12\x04\xac#\x02\x0e\n\r\n\x05\x04G\x02\x02\x01\x12\
    \x04\xac#\x0f\x1d\n\r\n\x05\x04G\x02\x02\x03\x12\x04\xac#\x20!\n,\n\x02\
    \x04H\x12\x06\xb0#\0\xb4#\x01\x1a\x1e\x20MultiInputAnnotationResponse\n\
    \n\x0b\n\x03\x04H\x01\x12\x04\xb0#\x08$\n\x0c\n\x04\x04H\x02\0\x12\x04\
    \xb2#\x02(\n\r\n\x05\x04H\x02\0\x06\x12\x04\xb2#\x02\x1c\n\r\n\x05\x04H\
    \x02\0\x01\x12\x04\xb2#\x1d#\n\r\n\x05\x04H\x02\0\x03\x12\x04\xb2#&'\n\
    \x0c\n\x04\x04H\x02\x01\x12\x04\xb3#\x02G\n\r\n\x05\x04H\x02\x01\x04\x12\
    \x04\xb3#\x02\n\n\r\n\x05\x04H\x02\x01\x06\x12\x04\xb3#\x0b\x0e\n\r\n\
    \x05\x04H\x02\x01\x01\x12\x04\xb3#\x0f\x13\n\r\n\x05\x04H\x02\x01\x03\
    \x12\x04\xb3#\x16\x17\n\r\n\x05\x04H\x02\x01\x08\x12\x04\xb3#\x18F\n\x10\
    \n\x08\x04H\x02\x01\x08\xd0\x86\x03\x12\x04\xb3#\x19E\n(\n\x02\x04I\x12\
    \x06\xb7#\0\xbb#\x01\x1a\x1a\x20SingleInputCountResponse\n\n\x0b\n\x03\
    \x04I\x01\x12\x04\xb7#\x08\x20\n\x0c\n\x04\x04I\x02\0\x12\x04\xb8#\x02(\
    \n\r\n\x05\x04I\x02\0\x06\x12\x04\xb8#\x02\x1c\n\r\n\x05\x04I\x02\0\x01\
    \x12\x04\xb8#\x1d#\n\r\n\x05\x04I\x02\0\x03\x12\x04\xb8#&'\n\x0c\n\x04\
    \x04I\x02\x01\x12\x04\xba#\x02\x18\n\r\n\x05\x04I\x02\x01\x06\x12\x04\
    \xba#\x02\x0c\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xba#\r\x13\n\r\n\x05\
    \x04I\x02\x01\x03\x12\x04\xba#\x16\x17\n$\n\x02\x04J\x12\x06\xbe#\0\xc0#\
    \x01\x1a\x16\x20GetInputCountRequest\n\n\x0b\n\x03\x04J\x01\x12\x04\xbe#\
    \x08\x1c\n\x0c\n\x04\x04J\x02\0\x12\x04\xbf#\x02,\n\r\n\x05\x04J\x02\0\
    \x06\x12\x04\xbf#\x02\x1b\n\r\n\x05\x04J\x02\0\x01\x12\x04\xbf#\x1c'\n\r\
    \n\x05\x04J\x02\0\x03\x12\x04\xbf#*+\n#\n\x02\x04K\x12\x06\xc3#\0\xf2#\
    \x01\x1a\x15\x20ListDatasetsRequest\n\n\x0b\n\x03\x04K\x01\x12\x04\xc3#\
    \x08\x1b\n\x0c\n\x04\x04K\x02\0\x12\x04\xc4#\x02,\n\r\n\x05\x04K\x02\0\
    \x06\x12\x04\xc4#\x02\x1b\n\r\n\x05\x04K\x02\0\x01\x12\x04\xc4#\x1c'\n\r\
    \n\x05\x04K\x02\0\x03\x12\x04\xc4#*+\n~\n\x04\x04K\x02\x01\x12\x04\xc7#\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04K\x02\x01\x05\x12\
    \x04\xc7#\x02\x08\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xc7#\t\r\n\r\n\x05\
    \x04K\x02\x01\x03\x12\x04\xc7#\x10\x11\nu\n\x04\x04K\x02\x02\x12\x04\xca\
    #\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04K\x02\x02\x05\x12\x04\xca#\
    \x02\x08\n\r\n\x05\x04K\x02\x02\x01\x12\x04\xca#\t\x11\n\r\n\x05\x04K\
    \x02\x02\x03\x12\x04\xca#\x14\x15\n\x0c\n\x04\x04K\x02\x03\x12\x04\xcc#\
    \x02(\n\r\n\x05\x04K\x02\x03\x04\x12\x04\xcc#\x02\n\n\r\n\x05\x04K\x02\
    \x03\x05\x12\x04\xcc#\x0b\x11\n\r\n\x05\x04K\x02\x03\x01\x12\x04\xcc#\
    \x12#\n\r\n\x05\x04K\x02\x03\x03\x12\x04\xcc#&'\no\n\x04\x04K\x02\x04\
    \x12\x04\xd0#\x02\x1a\x1aa\x20Sorting\x20options:\n\x20Whether\x20to\x20\
    sort\x20in\x20ascending\x20order.\x20If\x20false,\x20will\x20order\x20in\
    \x20descending\x20order.\n\n\r\n\x05\x04K\x02\x04\x05\x12\x04\xd0#\x02\
    \x06\n\r\n\x05\x04K\x02\x04\x01\x12\x04\xd0#\x07\x15\n\r\n\x05\x04K\x02\
    \x04\x03\x12\x04\xd0#\x18\x19\n\x0e\n\x04\x04K\x08\0\x12\x06\xd1#\x02\
    \xda#\x03\n\r\n\x05\x04K\x08\0\x01\x12\x04\xd1#\x08\x0f\n8\n\x04\x04K\
    \x02\x05\x12\x04\xd3#\x04\x20\x1a*\x20Whether\x20to\x20order\x20by\x20th\
    e\x20created_at\x20time.\n\n\r\n\x05\x04K\x02\x05\x05\x12\x04\xd3#\x04\
    \x08\n\r\n\x05\x04K\x02\x05\x01\x12\x04\xd3#\t\x1b\n\r\n\x05\x04K\x02\
    \x05\x03\x12\x04\xd3#\x1e\x1f\nF\n\x04\x04K\x02\x06\x12\x04\xd5#\x04\x20\
    \x1a8\x20Whether\x20to\x20order\x20by\x20the\x20number\x20of\x20users\
    \x20stared\x20the\x20app\n\n\r\n\x05\x04K\x02\x06\x05\x12\x04\xd5#\x04\
    \x08\n\r\n\x05\x04K\x02\x06\x01\x12\x04\xd5#\t\x1b\n\r\n\x05\x04K\x02\
    \x06\x03\x12\x04\xd5#\x1e\x1f\nP\n\x04\x04K\x02\x07\x12\x04\xd7#\x04!\
    \x1aB\x20If\x20neither\x20sort\x20option\x20is\x20set\x20to\x20true,\x20\
    will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04K\x02\x07\x05\x12\x04\
    \xd7#\x04\x08\n\r\n\x05\x04K\x02\x07\x01\x12\x04\xd7#\t\x1c\n\r\n\x05\
    \x04K\x02\x07\x03\x12\x04\xd7#\x1f\x20\n3\n\x04\x04K\x02\x08\x12\x04\xd9\
    #\x04\x19\x1a%\x20Whether\x20to\x20order\x20by\x20the\x20external\x20id\
    \n\n\r\n\x05\x04K\x02\x08\x05\x12\x04\xd9#\x04\x08\n\r\n\x05\x04K\x02\
    \x08\x01\x12\x04\xd9#\t\x13\n\r\n\x05\x04K\x02\x08\x03\x12\x04\xd9#\x16\
    \x18\n\"\n\x04\x04K\x02\t\x12\x04\xdd#\x02\x18\x1a\x14\x20Filtering\x20o\
    ptions:\n\n\r\n\x05\x04K\x02\t\x05\x12\x04\xdd#\x02\x06\n\r\n\x05\x04K\
    \x02\t\x01\x12\x04\xdd#\x07\x13\n\r\n\x05\x04K\x02\t\x03\x12\x04\xdd#\
    \x16\x17\n~\n\x04\x04K\x02\n\x12\x04\xdf#\x02\x15\x1ap\x20Filter\x20data\
    sets\x20by\x20bookmark.\x20If\x20set,\x20only\x20return\x20bookmarked\
    \x20datasets.\x20Otherwise\x20none\x20bookmarked\x20datasets\x20only.\n\
    \n\r\n\x05\x04K\x02\n\x05\x12\x04\xdf#\x02\x06\n\r\n\x05\x04K\x02\n\x01\
    \x12\x04\xdf#\x07\x0f\n\r\n\x05\x04K\x02\n\x03\x12\x04\xdf#\x12\x14\n\
    \xac\x04\n\x04\x04K\x02\x0b\x12\x04\xee#\x02\x15\x1a\x9d\x04\x20Searchin\
    g\x20options:\n\x20Specify\x20a\x20search\x20parameter\x20in\x20order\
    \x20to\x20perform\x20keyword\x20search\x20on\x20the\n\x20following\x20fi\
    elds\x20of\x20the\x20dataset:\n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20des\
    cription\n\x20\x20\x20-\x20notes\n\x20\x20\x20-\x20user_id\x20(unless\
    \x20user_app_id.user_id\x20is\x20already\x20set)\n\n\x20Keywords\x20are\
    \x20both\x20normalized\x20for\x20search\x20(so\x20searching\x20for\x20\"\
    satisfy\"\x20matches\x20\"satisfied\")\n\x20and\x20used\x20for\x20partia\
    l\x20prefix-matching\x20(so\x20searching\x20for\x20\"clari\"\x20matches\
    \x20\"clarifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\x20of\x20fields\
    \x20searched\x20and\x20the\x20exact\x20keyword\x20matching\n\x20rules\
    \x20are\x20subject\x20to\x20change\x20and\x20not\x20guaranteed\x20to\x20\
    be\x20backwards-compatible.\n\n\r\n\x05\x04K\x02\x0b\x05\x12\x04\xee#\
    \x02\x08\n\r\n\x05\x04K\x02\x0b\x01\x12\x04\xee#\t\x0f\n\r\n\x05\x04K\
    \x02\x0b\x03\x12\x04\xee#\x12\x14\nK\n\x04\x04K\x02\x0c\x12\x04\xf1#\x02\
    %\x1a=\x20Fuzzy\x20filter\x20on\x20dataset\x20ID\n\x20Deprecated:\x20use\
    \x20search\x20instead.\n\n\r\n\x05\x04K\x02\x0c\x05\x12\x04\xf1#\x02\x08\
    \n\r\n\x05\x04K\x02\x0c\x01\x12\x04\xf1#\t\x0b\n\r\n\x05\x04K\x02\x0c\
    \x03\x12\x04\xf1#\x0e\x10\n\r\n\x05\x04K\x02\x0c\x08\x12\x04\xf1#\x11$\n\
    \x0e\n\x06\x04K\x02\x0c\x08\x03\x12\x04\xf1#\x12#\n!\n\x02\x04L\x12\x06\
    \xf5#\0\xfb#\x01\x1a\x13\x20GetDatasetRequest\n\n\x0b\n\x03\x04L\x01\x12\
    \x04\xf5#\x08\x19\n\x0c\n\x04\x04L\x02\0\x12\x04\xf6#\x02,\n\r\n\x05\x04\
    L\x02\0\x06\x12\x04\xf6#\x02\x1b\n\r\n\x05\x04L\x02\0\x01\x12\x04\xf6#\
    \x1c'\n\r\n\x05\x04L\x02\0\x03\x12\x04\xf6#*+\n'\n\x04\x04L\x02\x01\x12\
    \x04\xf9#\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\
    \x05\x04L\x02\x01\x05\x12\x04\xf9#\x02\x08\n\r\n\x05\x04L\x02\x01\x01\
    \x12\x04\xf9#\t\x13\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xf9#\x16\x17\n\
    \x0c\n\x04\x04L\x02\x02\x12\x04\xfa#\x02(\n\r\n\x05\x04L\x02\x02\x04\x12\
    \x04\xfa#\x02\n\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xfa#\x0b\x11\n\r\n\
    \x05\x04L\x02\x02\x01\x12\x04\xfa#\x12#\n\r\n\x05\x04L\x02\x02\x03\x12\
    \x04\xfa#&'\n4\n\x02\x04M\x12\x06\xfe#\0\x83$\x01\x1a&\x20Request\x20to\
    \x20add\x20one\x20or\x20more\x20datasets.\n\n\x0b\n\x03\x04M\x01\x12\x04\
    \xfe#\x08\x1b\n\x0c\n\x04\x04M\x02\0\x12\x04\xff#\x02,\n\r\n\x05\x04M\
    \x02\0\x06\x12\x04\xff#\x02\x1b\n\r\n\x05\x04M\x02\0\x01\x12\x04\xff#\
    \x1c'\n\r\n\x05\x04M\x02\0\x03\x12\x04\xff#*+\n@\n\x04\x04M\x02\x01\x12\
    \x04\x82$\x02\x20\x1a2\x20List\x20of\x20datasets\x20that\x20are\x20reque\
    sted\x20to\x20be\x20added.\n\n\r\n\x05\x04M\x02\x01\x04\x12\x04\x82$\x02\
    \n\n\r\n\x05\x04M\x02\x01\x06\x12\x04\x82$\x0b\x12\n\r\n\x05\x04M\x02\
    \x01\x01\x12\x04\x82$\x13\x1b\n\r\n\x05\x04M\x02\x01\x03\x12\x04\x82$\
    \x1e\x1f\n2\n\x02\x04N\x12\x06\x86$\0\x92$\x01\x1a$\x20Request\x20to\x20\
    patch\x20several\x20datasets.\n\n\x0b\n\x03\x04N\x01\x12\x04\x86$\x08\
    \x1c\n\x0c\n\x04\x04N\x02\0\x12\x04\x87$\x02,\n\r\n\x05\x04N\x02\0\x06\
    \x12\x04\x87$\x02\x1b\n\r\n\x05\x04N\x02\0\x01\x12\x04\x87$\x1c'\n\r\n\
    \x05\x04N\x02\0\x03\x12\x04\x87$*+\nB\n\x04\x04N\x02\x01\x12\x04\x8a$\
    \x02\x20\x1a4\x20List\x20of\x20datasets\x20that\x20are\x20requested\x20t\
    o\x20be\x20updated.\n\n\r\n\x05\x04N\x02\x01\x04\x12\x04\x8a$\x02\n\n\r\
    \n\x05\x04N\x02\x01\x06\x12\x04\x8a$\x0b\x12\n\r\n\x05\x04N\x02\x01\x01\
    \x12\x04\x8a$\x13\x1b\n\r\n\x05\x04N\x02\x01\x03\x12\x04\x8a$\x1e\x1f\n\
    \x8d\x02\n\x04\x04N\x02\x02\x12\x04\x91$\x02\x14\x1a\xfe\x01\x20The\x20a\
    ction\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20Supported\
    \x20values:\x20'overwrite',\x20'merge',\x20and\x20'remove'.\n\n\x20Note\
    \x20that\x20'remove'\x20can\x20only\x20be\x20used\x20to\x20remove\x20the\
    \x20dataset\x20image\x20by\x20setting\n\x20'image.url'\x20in\x20the\x20r\
    equest\x20to\x20the\x20current\x20value\x20returned\x20for\x20that\x20da\
    taset.\n\n\r\n\x05\x04N\x02\x02\x05\x12\x04\x91$\x02\x08\n\r\n\x05\x04N\
    \x02\x02\x01\x12\x04\x91$\t\x0f\n\r\n\x05\x04N\x02\x02\x03\x12\x04\x91$\
    \x12\x13\nB\n\x02\x04O\x12\x06\x95$\0\x98$\x01\x1a4\x20Request\x20to\x20\
    delete\x20several\x20datasets\x20by\x20list\x20of\x20ids.\n\n\x0b\n\x03\
    \x04O\x01\x12\x04\x95$\x08\x1d\n\x0c\n\x04\x04O\x02\0\x12\x04\x96$\x02,\
    \n\r\n\x05\x04O\x02\0\x06\x12\x04\x96$\x02\x1b\n\r\n\x05\x04O\x02\0\x01\
    \x12\x04\x96$\x1c'\n\r\n\x05\x04O\x02\0\x03\x12\x04\x96$*+\n\x0c\n\x04\
    \x04O\x02\x01\x12\x04\x97$\x02\"\n\r\n\x05\x04O\x02\x01\x04\x12\x04\x97$\
    \x02\n\n\r\n\x05\x04O\x02\x01\x05\x12\x04\x97$\x0b\x11\n\r\n\x05\x04O\
    \x02\x01\x01\x12\x04\x97$\x12\x1d\n\r\n\x05\x04O\x02\x01\x03\x12\x04\x97\
    $\x20!\n$\n\x02\x04P\x12\x06\x9b$\0\x9e$\x01\x1a\x16\x20MultiDatasetResp\
    onse\n\n\x0b\n\x03\x04P\x01\x12\x04\x9b$\x08\x1c\n\x0c\n\x04\x04P\x02\0\
    \x12\x04\x9c$\x02(\n\r\n\x05\x04P\x02\0\x06\x12\x04\x9c$\x02\x1c\n\r\n\
    \x05\x04P\x02\0\x01\x12\x04\x9c$\x1d#\n\r\n\x05\x04P\x02\0\x03\x12\x04\
    \x9c$&'\n\x0c\n\x04\x04P\x02\x01\x12\x04\x9d$\x02O\n\r\n\x05\x04P\x02\
    \x01\x04\x12\x04\x9d$\x02\n\n\r\n\x05\x04P\x02\x01\x06\x12\x04\x9d$\x0b\
    \x12\n\r\n\x05\x04P\x02\x01\x01\x12\x04\x9d$\x13\x1b\n\r\n\x05\x04P\x02\
    \x01\x03\x12\x04\x9d$\x1e\x1f\n\r\n\x05\x04P\x02\x01\x08\x12\x04\x9d$\
    \x20N\n\x10\n\x08\x04P\x02\x01\x08\xd0\x86\x03\x12\x04\x9d$!M\n%\n\x02\
    \x04Q\x12\x06\xa1$\0\xa4$\x01\x1a\x17\x20SingleDatasetResponse\n\n\x0b\n\
    \x03\x04Q\x01\x12\x04\xa1$\x08\x1d\n\x0c\n\x04\x04Q\x02\0\x12\x04\xa2$\
    \x02(\n\r\n\x05\x04Q\x02\0\x06\x12\x04\xa2$\x02\x1c\n\r\n\x05\x04Q\x02\0\
    \x01\x12\x04\xa2$\x1d#\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xa2$&'\n\x0c\n\
    \x04\x04Q\x02\x01\x12\x04\xa3$\x02\x16\n\r\n\x05\x04Q\x02\x01\x06\x12\
    \x04\xa3$\x02\t\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\xa3$\n\x11\n\r\n\x05\
    \x04Q\x02\x01\x03\x12\x04\xa3$\x14\x15\n(\n\x02\x04R\x12\x06\xa7$\0\xb1$\
    \x01\x1a\x1a\x20ListDatasetInputsRequest\n\n\x0b\n\x03\x04R\x01\x12\x04\
    \xa7$\x08\x20\n\x0c\n\x04\x04R\x02\0\x12\x04\xa8$\x02,\n\r\n\x05\x04R\
    \x02\0\x06\x12\x04\xa8$\x02\x1b\n\r\n\x05\x04R\x02\0\x01\x12\x04\xa8$\
    \x1c'\n\r\n\x05\x04R\x02\0\x03\x12\x04\xa8$*+\n'\n\x04\x04R\x02\x01\x12\
    \x04\xaa$\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\
    \x05\x04R\x02\x01\x05\x12\x04\xaa$\x02\x08\n\r\n\x05\x04R\x02\x01\x01\
    \x12\x04\xaa$\t\x13\n\r\n\x05\x04R\x02\x01\x03\x12\x04\xaa$\x16\x17\n~\n\
    \x04\x04R\x02\x02\x12\x04\xad$\x02\x12\x1ap\x20(optional\x20URL\x20param\
    eter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spl\
    it\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\
    \n\x05\x04R\x02\x02\x05\x12\x04\xad$\x02\x08\n\r\n\x05\x04R\x02\x02\x01\
    \x12\x04\xad$\t\r\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xad$\x10\x11\nu\n\
    \x04\x04R\x02\x03\x12\x04\xb0$\x02\x16\x1ag\x20(optional\x20URL\x20param\
    eter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contain\
    ed\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04R\
    \x02\x03\x05\x12\x04\xb0$\x02\x08\n\r\n\x05\x04R\x02\x03\x01\x12\x04\xb0\
    $\t\x11\n\r\n\x05\x04R\x02\x03\x03\x12\x04\xb0$\x14\x15\n&\n\x02\x04S\
    \x12\x06\xb4$\0\xbc$\x01\x1a\x18\x20GetDatasetInputRequest\n\n\x0b\n\x03\
    \x04S\x01\x12\x04\xb4$\x08\x1e\n\x0c\n\x04\x04S\x02\0\x12\x04\xb5$\x02,\
    \n\r\n\x05\x04S\x02\0\x06\x12\x04\xb5$\x02\x1b\n\r\n\x05\x04S\x02\0\x01\
    \x12\x04\xb5$\x1c'\n\r\n\x05\x04S\x02\0\x03\x12\x04\xb5$*+\n'\n\x04\x04S\
    \x02\x01\x12\x04\xb8$\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id\
    .\n\n\r\n\x05\x04S\x02\x01\x05\x12\x04\xb8$\x02\x08\n\r\n\x05\x04S\x02\
    \x01\x01\x12\x04\xb8$\t\x13\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xb8$\x16\
    \x17\n-\n\x04\x04S\x02\x02\x12\x04\xbb$\x02\x16\x1a\x1f\x20Identify\x20d\
    ataset\x20input\x20by\x20id.\n\n\r\n\x05\x04S\x02\x02\x05\x12\x04\xbb$\
    \x02\x08\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xbb$\t\x11\n\r\n\x05\x04S\
    \x02\x02\x03\x12\x04\xbb$\x14\x15\n4\n\x02\x04T\x12\x06\xbf$\0\xcb$\x01\
    \x1a&\x20Request\x20to\x20add\x20one\x20or\x20more\x20datasets.\n\n\x0b\
    \n\x03\x04T\x01\x12\x04\xbf$\x08\x20\n\x0c\n\x04\x04T\x02\0\x12\x04\xc0$\
    \x02,\n\r\n\x05\x04T\x02\0\x06\x12\x04\xc0$\x02\x1b\n\r\n\x05\x04T\x02\0\
    \x01\x12\x04\xc0$\x1c'\n\r\n\x05\x04T\x02\0\x03\x12\x04\xc0$*+\n'\n\x04\
    \x04T\x02\x01\x12\x04\xc3$\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\
    \x20id.\n\n\r\n\x05\x04T\x02\x01\x05\x12\x04\xc3$\x02\x08\n\r\n\x05\x04T\
    \x02\x01\x01\x12\x04\xc3$\t\x13\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xc3$\
    \x16\x17\n\x96\x01\n\x04\x04T\x02\x02\x12\x04\xc7$\x02+\x1a\x87\x01\x20L\
    ist\x20of\x20inputs\x20that\x20are\x20requested\x20to\x20be\x20added\x20\
    to\x20this\x20dataset.\n\x20Identify\x20each\x20input\x20by\x20id\x20fie\
    ld.\x20All\x20other\x20inputs\x20fields\x20are\x20ignored.\n\n\r\n\x05\
    \x04T\x02\x02\x04\x12\x04\xc7$\x02\n\n\r\n\x05\x04T\x02\x02\x06\x12\x04\
    \xc7$\x0b\x17\n\r\n\x05\x04T\x02\x02\x01\x12\x04\xc7$\x18&\n\r\n\x05\x04\
    T\x02\x02\x03\x12\x04\xc7$)*\nC\n\x04\x04T\x02\x03\x12\x04\xca$\x02\x14\
    \x1a5\x20Query\x20to\x20search\x20inputs\x20to\x20be\x20added\x20to\x20t\
    his\x20dataset.\n\n\r\n\x05\x04T\x02\x03\x06\x12\x04\xca$\x02\x08\n\r\n\
    \x05\x04T\x02\x03\x01\x12\x04\xca$\t\x0f\n\r\n\x05\x04T\x02\x03\x03\x12\
    \x04\xca$\x12\x13\nH\n\x02\x04U\x12\x06\xce$\0\xd6$\x01\x1a:\x20Request\
    \x20to\x20delete\x20several\x20dataset\x20inputs\x20by\x20list\x20of\x20\
    ids.\n\n\x0b\n\x03\x04U\x01\x12\x04\xce$\x08\"\n\x0c\n\x04\x04U\x02\0\
    \x12\x04\xcf$\x02,\n\r\n\x05\x04U\x02\0\x06\x12\x04\xcf$\x02\x1b\n\r\n\
    \x05\x04U\x02\0\x01\x12\x04\xcf$\x1c'\n\r\n\x05\x04U\x02\0\x03\x12\x04\
    \xcf$*+\n'\n\x04\x04U\x02\x01\x12\x04\xd2$\x02\x18\x1a\x19\x20Identify\
    \x20dataset\x20by\x20id.\n\n\r\n\x05\x04U\x02\x01\x05\x12\x04\xd2$\x02\
    \x08\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xd2$\t\x13\n\r\n\x05\x04U\x02\
    \x01\x03\x12\x04\xd2$\x16\x17\n<\n\x04\x04U\x02\x02\x12\x04\xd5$\x02\x20\
    \x1a.\x20Specify\x20which\x20inputs\x20to\x20delete\x20from\x20dataset.\
    \n\n\r\n\x05\x04U\x02\x02\x04\x12\x04\xd5$\x02\n\n\r\n\x05\x04U\x02\x02\
    \x05\x12\x04\xd5$\x0b\x11\n\r\n\x05\x04U\x02\x02\x01\x12\x04\xd5$\x12\
    \x1b\n\r\n\x05\x04U\x02\x02\x03\x12\x04\xd5$\x1e\x1f\n)\n\x02\x04V\x12\
    \x06\xd9$\0\xde$\x01\x1a\x1b\x20MultiDatasetInputResponse\n\n\x0b\n\x03\
    \x04V\x01\x12\x04\xd9$\x08!\n\x0b\n\x03\x04V\t\x12\x04\xda$\x02\r\n\x0c\
    \n\x04\x04V\t\0\x12\x04\xda$\x0b\x0c\n\r\n\x05\x04V\t\0\x01\x12\x04\xda$\
    \x0b\x0c\n\r\n\x05\x04V\t\0\x02\x12\x04\xda$\x0b\x0c\n\x0c\n\x04\x04V\
    \x02\0\x12\x04\xdb$\x02(\n\r\n\x05\x04V\x02\0\x06\x12\x04\xdb$\x02\x1c\n\
    \r\n\x05\x04V\x02\0\x01\x12\x04\xdb$\x1d#\n\r\n\x05\x04V\x02\0\x03\x12\
    \x04\xdb$&'\n\x0c\n\x04\x04V\x02\x01\x12\x04\xdc$\x02Z\n\r\n\x05\x04V\
    \x02\x01\x04\x12\x04\xdc$\x02\n\n\r\n\x05\x04V\x02\x01\x06\x12\x04\xdc$\
    \x0b\x17\n\r\n\x05\x04V\x02\x01\x01\x12\x04\xdc$\x18&\n\r\n\x05\x04V\x02\
    \x01\x03\x12\x04\xdc$)*\n\r\n\x05\x04V\x02\x01\x08\x12\x04\xdc$+Y\n\x10\
    \n\x08\x04V\x02\x01\x08\xd0\x86\x03\x12\x04\xdc$,X\n\x0c\n\x04\x04V\x02\
    \x02\x12\x04\xdd$\x02#\n\r\n\x05\x04V\x02\x02\x06\x12\x04\xdd$\x02\x0f\n\
    \r\n\x05\x04V\x02\x02\x01\x12\x04\xdd$\x10\x1e\n\r\n\x05\x04V\x02\x02\
    \x03\x12\x04\xdd$!\"\n*\n\x02\x04W\x12\x06\xe1$\0\xe4$\x01\x1a\x1c\x20Si\
    ngleDatasetInputResponse\n\n\x0b\n\x03\x04W\x01\x12\x04\xe1$\x08\"\n\x0c\
    \n\x04\x04W\x02\0\x12\x04\xe2$\x02(\n\r\n\x05\x04W\x02\0\x06\x12\x04\xe2\
    $\x02\x1c\n\r\n\x05\x04W\x02\0\x01\x12\x04\xe2$\x1d#\n\r\n\x05\x04W\x02\
    \0\x03\x12\x04\xe2$&'\n\x0c\n\x04\x04W\x02\x01\x12\x04\xe3$\x02!\n\r\n\
    \x05\x04W\x02\x01\x06\x12\x04\xe3$\x02\x0e\n\r\n\x05\x04W\x02\x01\x01\
    \x12\x04\xe3$\x0f\x1c\n\r\n\x05\x04W\x02\x01\x03\x12\x04\xe3$\x1f\x20\n*\
    \n\x02\x04X\x12\x06\xe7$\0\xf4$\x01\x1a\x1c\x20ListDatasetVersionsReques\
    t\n\n\x0b\n\x03\x04X\x01\x12\x04\xe7$\x08\"\n\x0c\n\x04\x04X\x02\0\x12\
    \x04\xe8$\x02,\n\r\n\x05\x04X\x02\0\x06\x12\x04\xe8$\x02\x1b\n\r\n\x05\
    \x04X\x02\0\x01\x12\x04\xe8$\x1c'\n\r\n\x05\x04X\x02\0\x03\x12\x04\xe8$*\
    +\n'\n\x04\x04X\x02\x01\x12\x04\xeb$\x02\x18\x1a\x19\x20Identify\x20data\
    set\x20by\x20id.\n\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xeb$\x02\x08\n\r\n\
    \x05\x04X\x02\x01\x01\x12\x04\xeb$\t\x13\n\r\n\x05\x04X\x02\x01\x03\x12\
    \x04\xeb$\x16\x17\n~\n\x04\x04X\x02\x02\x12\x04\xef$\x02\x12\x1ap\x20(op\
    tional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20i\
    s\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defau\
    lts\x20to\x201.\n\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xef$\x02\x08\n\r\n\
    \x05\x04X\x02\x02\x01\x12\x04\xef$\t\r\n\r\n\x05\x04X\x02\x02\x03\x12\
    \x04\xef$\x10\x11\nu\n\x04\x04X\x02\x03\x12\x04\xf3$\x02\x16\x1ag\x20(op\
    tional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x04X\x02\x03\x05\x12\x04\xf3$\x02\x08\n\r\n\x05\x04\
    X\x02\x03\x01\x12\x04\xf3$\t\x11\n\r\n\x05\x04X\x02\x03\x03\x12\x04\xf3$\
    \x14\x15\n(\n\x02\x04Y\x12\x06\xf7$\0\xff$\x01\x1a\x1a\x20GetDatasetVers\
    ionRequest\n\n\x0b\n\x03\x04Y\x01\x12\x04\xf7$\x08\x20\n\x0c\n\x04\x04Y\
    \x02\0\x12\x04\xf8$\x02,\n\r\n\x05\x04Y\x02\0\x06\x12\x04\xf8$\x02\x1b\n\
    \r\n\x05\x04Y\x02\0\x01\x12\x04\xf8$\x1c'\n\r\n\x05\x04Y\x02\0\x03\x12\
    \x04\xf8$*+\n'\n\x04\x04Y\x02\x01\x12\x04\xfb$\x02\x18\x1a\x19\x20Identi\
    fy\x20dataset\x20by\x20id.\n\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\xfb$\x02\
    \x08\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xfb$\t\x13\n\r\n\x05\x04Y\x02\
    \x01\x03\x12\x04\xfb$\x16\x17\n/\n\x04\x04Y\x02\x02\x12\x04\xfe$\x02\x20\
    \x1a!\x20Identify\x20dataset\x20version\x20by\x20id.\n\n\r\n\x05\x04Y\
    \x02\x02\x05\x12\x04\xfe$\x02\x08\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\xfe\
    $\t\x1b\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\xfe$\x1e\x1f\n6\n\x02\x04Z\
    \x12\x06\x82%\0\x9a%\x01\x1a(\x20ListDatasetVersionMetricsGroupsRequest\
    \n\n\x0b\n\x03\x04Z\x01\x12\x04\x82%\x08.\n\x0c\n\x04\x04Z\x02\0\x12\x04\
    \x83%\x02,\n\r\n\x05\x04Z\x02\0\x06\x12\x04\x83%\x02\x1b\n\r\n\x05\x04Z\
    \x02\0\x01\x12\x04\x83%\x1c'\n\r\n\x05\x04Z\x02\0\x03\x12\x04\x83%*+\n'\
    \n\x04\x04Z\x02\x01\x12\x04\x86%\x02\x18\x1a\x19\x20Identify\x20dataset\
    \x20by\x20id.\n\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\x86%\x02\x08\n\r\n\
    \x05\x04Z\x02\x01\x01\x12\x04\x86%\t\x13\n\r\n\x05\x04Z\x02\x01\x03\x12\
    \x04\x86%\x16\x17\n/\n\x04\x04Z\x02\x02\x12\x04\x89%\x02\x20\x1a!\x20Ide\
    ntify\x20dataset\x20version\x20by\x20id.\n\n\r\n\x05\x04Z\x02\x02\x05\
    \x12\x04\x89%\x02\x08\n\r\n\x05\x04Z\x02\x02\x01\x12\x04\x89%\t\x1b\n\r\
    \n\x05\x04Z\x02\x02\x03\x12\x04\x89%\x1e\x1f\n~\n\x04\x04Z\x02\x03\x12\
    \x04\x8d%\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04Z\x02\x03\
    \x05\x12\x04\x8d%\x02\x08\n\r\n\x05\x04Z\x02\x03\x01\x12\x04\x8d%\t\r\n\
    \r\n\x05\x04Z\x02\x03\x03\x12\x04\x8d%\x10\x11\nu\n\x04\x04Z\x02\x04\x12\
    \x04\x90%\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numbe\
    r\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20p\
    age.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04Z\x02\x04\x05\x12\x04\
    \x90%\x02\x08\n\r\n\x05\x04Z\x02\x04\x01\x12\x04\x90%\t\x11\n\r\n\x05\
    \x04Z\x02\x04\x03\x12\x04\x90%\x14\x15\nh\n\x04\x04Z\x02\x05\x12\x04\x93\
    %\x02#\x1aZ\x20Filter\x20by\x20parent\x20path.\x20Multiple\x20parent\x20\
    paths\x20are\x20OR-ed.\x20Empty\x20list\x20results\x20in\x20no\x20filter\
    .\n\n\r\n\x05\x04Z\x02\x05\x04\x12\x04\x93%\x02\n\n\r\n\x05\x04Z\x02\x05\
    \x05\x12\x04\x93%\x0b\x11\n\r\n\x05\x04Z\x02\x05\x01\x12\x04\x93%\x12\
    \x1e\n\r\n\x05\x04Z\x02\x05\x03\x12\x04\x93%!\"\na\n\x04\x04Z\x02\x06\
    \x12\x04\x96%\x024\x1aS\x20Filter\x20by\x20parent\x20type.\x20Multiple\
    \x20types\x20are\x20OR-ed.\x20Empty\x20list\x20results\x20in\x20no\x20fi\
    lter.\n\n\r\n\x05\x04Z\x02\x06\x04\x12\x04\x96%\x02\n\n\r\n\x05\x04Z\x02\
    \x06\x06\x12\x04\x96%\x0b)\n\r\n\x05\x04Z\x02\x06\x01\x12\x04\x96%*/\n\r\
    \n\x05\x04Z\x02\x06\x03\x12\x04\x96%23\n\\\n\x04\x04Z\x02\x07\x12\x04\
    \x99%\x02,\x1aN\x20Filter\x20by\x20value.\x20Multiple\x20values\x20are\
    \x20OR-ed.\x20Empty\x20list\x20results\x20in\x20no\x20filter.\n\n\r\n\
    \x05\x04Z\x02\x07\x04\x12\x04\x99%\x02\n\n\r\n\x05\x04Z\x02\x07\x06\x12\
    \x04\x99%\x0b\x20\n\r\n\x05\x04Z\x02\x07\x01\x12\x04\x99%!'\n\r\n\x05\
    \x04Z\x02\x07\x03\x12\x04\x99%*+\n<\n\x02\x04[\x12\x06\x9d%\0\xa5%\x01\
    \x1a.\x20Request\x20to\x20add\x20one\x20or\x20more\x20dataset\x20version\
    s.\n\n\x0b\n\x03\x04[\x01\x12\x04\x9d%\x08\"\n\x0c\n\x04\x04[\x02\0\x12\
    \x04\x9e%\x02,\n\r\n\x05\x04[\x02\0\x06\x12\x04\x9e%\x02\x1b\n\r\n\x05\
    \x04[\x02\0\x01\x12\x04\x9e%\x1c'\n\r\n\x05\x04[\x02\0\x03\x12\x04\x9e%*\
    +\n'\n\x04\x04[\x02\x01\x12\x04\xa1%\x02\x18\x1a\x19\x20Identify\x20data\
    set\x20by\x20id.\n\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xa1%\x02\x08\n\r\n\
    \x05\x04[\x02\x01\x01\x12\x04\xa1%\t\x13\n\r\n\x05\x04[\x02\x01\x03\x12\
    \x04\xa1%\x16\x17\nH\n\x04\x04[\x02\x02\x12\x04\xa4%\x02/\x1a:\x20List\
    \x20of\x20dataset\x20versions\x20that\x20are\x20requested\x20to\x20be\
    \x20added.\n\n\r\n\x05\x04[\x02\x02\x04\x12\x04\xa4%\x02\n\n\r\n\x05\x04\
    [\x02\x02\x06\x12\x04\xa4%\x0b\x19\n\r\n\x05\x04[\x02\x02\x01\x12\x04\
    \xa4%\x1a*\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xa4%-.\n:\n\x02\x04\\\x12\
    \x06\xa8%\0\xb4%\x01\x1a,\x20Request\x20to\x20patch\x20several\x20datase\
    t\x20versions.\n\n\x0b\n\x03\x04\\\x01\x12\x04\xa8%\x08#\n\x0c\n\x04\x04\
    \\\x02\0\x12\x04\xa9%\x02,\n\r\n\x05\x04\\\x02\0\x06\x12\x04\xa9%\x02\
    \x1b\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xa9%\x1c'\n\r\n\x05\x04\\\x02\0\
    \x03\x12\x04\xa9%*+\n'\n\x04\x04\\\x02\x01\x12\x04\xac%\x02\x18\x1a\x19\
    \x20Identify\x20dataset\x20by\x20id.\n\n\r\n\x05\x04\\\x02\x01\x05\x12\
    \x04\xac%\x02\x08\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xac%\t\x13\n\r\n\
    \x05\x04\\\x02\x01\x03\x12\x04\xac%\x16\x17\nJ\n\x04\x04\\\x02\x02\x12\
    \x04\xaf%\x02/\x1a<\x20List\x20of\x20dataset\x20versions\x20that\x20are\
    \x20requested\x20to\x20be\x20updated.\n\n\r\n\x05\x04\\\x02\x02\x04\x12\
    \x04\xaf%\x02\n\n\r\n\x05\x04\\\x02\x02\x06\x12\x04\xaf%\x0b\x19\n\r\n\
    \x05\x04\\\x02\x02\x01\x12\x04\xaf%\x1a*\n\r\n\x05\x04\\\x02\x02\x03\x12\
    \x04\xaf%-.\nk\n\x04\x04\\\x02\x03\x12\x04\xb3%\x02\x14\x1a]\x20The\x20a\
    ction\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20no\
    w,\x20only\x20'overwrite'\x20action\x20is\x20supported\n\n\r\n\x05\x04\\\
    \x02\x03\x05\x12\x04\xb3%\x02\x08\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\
    \xb3%\t\x0f\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\xb3%\x12\x13\nJ\n\x02\
    \x04]\x12\x06\xb7%\0\xbe%\x01\x1a<\x20Request\x20to\x20delete\x20several\
    \x20dataset\x20versions\x20by\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04]\
    \x01\x12\x04\xb7%\x08$\n\x0c\n\x04\x04]\x02\0\x12\x04\xb8%\x02,\n\r\n\
    \x05\x04]\x02\0\x06\x12\x04\xb8%\x02\x1b\n\r\n\x05\x04]\x02\0\x01\x12\
    \x04\xb8%\x1c'\n\r\n\x05\x04]\x02\0\x03\x12\x04\xb8%*+\n'\n\x04\x04]\x02\
    \x01\x12\x04\xbb%\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\
    \n\r\n\x05\x04]\x02\x01\x05\x12\x04\xbb%\x02\x08\n\r\n\x05\x04]\x02\x01\
    \x01\x12\x04\xbb%\t\x13\n\r\n\x05\x04]\x02\x01\x03\x12\x04\xbb%\x16\x17\
    \n\x0c\n\x04\x04]\x02\x02\x12\x04\xbd%\x02*\n\r\n\x05\x04]\x02\x02\x04\
    \x12\x04\xbd%\x02\n\n\r\n\x05\x04]\x02\x02\x05\x12\x04\xbd%\x0b\x11\n\r\
    \n\x05\x04]\x02\x02\x01\x12\x04\xbd%\x12%\n\r\n\x05\x04]\x02\x02\x03\x12\
    \x04\xbd%()\n?\n\x02\x04^\x12\x06\xc1%\0\xcd%\x01\x1a1\x20Request\x20to\
    \x20create\x20exports\x20of\x20a\x20dataset\x20version.\n\n\x0b\n\x03\
    \x04^\x01\x12\x04\xc1%\x08'\n\x0c\n\x04\x04^\x02\0\x12\x04\xc2%\x02,\n\r\
    \n\x05\x04^\x02\0\x06\x12\x04\xc2%\x02\x1b\n\r\n\x05\x04^\x02\0\x01\x12\
    \x04\xc2%\x1c'\n\r\n\x05\x04^\x02\0\x03\x12\x04\xc2%*+\n'\n\x04\x04^\x02\
    \x01\x12\x04\xc5%\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\
    \n\r\n\x05\x04^\x02\x01\x05\x12\x04\xc5%\x02\x08\n\r\n\x05\x04^\x02\x01\
    \x01\x12\x04\xc5%\t\x13\n\r\n\x05\x04^\x02\x01\x03\x12\x04\xc5%\x16\x17\
    \n/\n\x04\x04^\x02\x02\x12\x04\xc8%\x02\x20\x1a!\x20Identify\x20dataset\
    \x20version\x20by\x20id.\n\n\r\n\x05\x04^\x02\x02\x05\x12\x04\xc8%\x02\
    \x08\n\r\n\x05\x04^\x02\x02\x01\x12\x04\xc8%\t\x1b\n\r\n\x05\x04^\x02\
    \x02\x03\x12\x04\xc8%\x1e\x1f\n\x86\x01\n\x04\x04^\x02\x03\x12\x04\xcc%\
    \x02,\x1ax\x20exports\x20is\x20the\x20list\x20of\x20requested\x20dataset\
    \x20version\x20exports.\n\x20Only\x20setting\x20the\x20'format'\x20field\
    \x20of\x20the\x20export\x20is\x20supported.\n\n\r\n\x05\x04^\x02\x03\x04\
    \x12\x04\xcc%\x02\n\n\r\n\x05\x04^\x02\x03\x06\x12\x04\xcc%\x0b\x1f\n\r\
    \n\x05\x04^\x02\x03\x01\x12\x04\xcc%\x20'\n\r\n\x05\x04^\x02\x03\x03\x12\
    \x04\xcc%*+\n\x0c\n\x02\x04_\x12\x06\xcf%\0\xd2%\x01\n\x0b\n\x03\x04_\
    \x01\x12\x04\xcf%\x08#\n\x0c\n\x04\x04_\x02\0\x12\x04\xd0%\x02(\n\r\n\
    \x05\x04_\x02\0\x06\x12\x04\xd0%\x02\x1c\n\r\n\x05\x04_\x02\0\x01\x12\
    \x04\xd0%\x1d#\n\r\n\x05\x04_\x02\0\x03\x12\x04\xd0%&'\n\x0c\n\x04\x04_\
    \x02\x01\x12\x04\xd1%\x02^\n\r\n\x05\x04_\x02\x01\x04\x12\x04\xd1%\x02\n\
    \n\r\n\x05\x04_\x02\x01\x06\x12\x04\xd1%\x0b\x19\n\r\n\x05\x04_\x02\x01\
    \x01\x12\x04\xd1%\x1a*\n\r\n\x05\x04_\x02\x01\x03\x12\x04\xd1%-.\n\r\n\
    \x05\x04_\x02\x01\x08\x12\x04\xd1%/]\n\x10\n\x08\x04_\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xd1%0\\\n\x0c\n\x02\x04`\x12\x06\xd4%\0\xd7%\x01\n\x0b\
    \n\x03\x04`\x01\x12\x04\xd4%\x08)\n\x0c\n\x04\x04`\x02\0\x12\x04\xd5%\
    \x02(\n\r\n\x05\x04`\x02\0\x06\x12\x04\xd5%\x02\x1c\n\r\n\x05\x04`\x02\0\
    \x01\x12\x04\xd5%\x1d#\n\r\n\x05\x04`\x02\0\x03\x12\x04\xd5%&'\n\x0c\n\
    \x04\x04`\x02\x01\x12\x04\xd6%\x02[\n\r\n\x05\x04`\x02\x01\x04\x12\x04\
    \xd6%\x02\n\n\r\n\x05\x04`\x02\x01\x06\x12\x04\xd6%\x0b\x1f\n\r\n\x05\
    \x04`\x02\x01\x01\x12\x04\xd6%\x20'\n\r\n\x05\x04`\x02\x01\x03\x12\x04\
    \xd6%*+\n\r\n\x05\x04`\x02\x01\x08\x12\x04\xd6%,Z\n\x10\n\x08\x04`\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xd6%-Y\n\x0c\n\x02\x04a\x12\x06\xd9%\0\xdc%\
    \x01\n\x0b\n\x03\x04a\x01\x12\x04\xd9%\x08/\n\x0c\n\x04\x04a\x02\0\x12\
    \x04\xda%\x02(\n\r\n\x05\x04a\x02\0\x06\x12\x04\xda%\x02\x1c\n\r\n\x05\
    \x04a\x02\0\x01\x12\x04\xda%\x1d#\n\r\n\x05\x04a\x02\0\x03\x12\x04\xda%&\
    '\n\x0c\n\x04\x04a\x02\x01\x12\x04\xdb%\x02x\n\r\n\x05\x04a\x02\x01\x04\
    \x12\x04\xdb%\x02\n\n\r\n\x05\x04a\x02\x01\x06\x12\x04\xdb%\x0b%\n\r\n\
    \x05\x04a\x02\x01\x01\x12\x04\xdb%&D\n\r\n\x05\x04a\x02\x01\x03\x12\x04\
    \xdb%GH\n\r\n\x05\x04a\x02\x01\x08\x12\x04\xdb%Iw\n\x10\n\x08\x04a\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xdb%Jv\n\x0c\n\x02\x04b\x12\x06\xde%\0\xe1%\
    \x01\n\x0b\n\x03\x04b\x01\x12\x04\xde%\x08$\n\x0c\n\x04\x04b\x02\0\x12\
    \x04\xdf%\x02(\n\r\n\x05\x04b\x02\0\x06\x12\x04\xdf%\x02\x1c\n\r\n\x05\
    \x04b\x02\0\x01\x12\x04\xdf%\x1d#\n\r\n\x05\x04b\x02\0\x03\x12\x04\xdf%&\
    '\n\x0c\n\x04\x04b\x02\x01\x12\x04\xe0%\x02%\n\r\n\x05\x04b\x02\x01\x06\
    \x12\x04\xe0%\x02\x10\n\r\n\x05\x04b\x02\x01\x01\x12\x04\xe0%\x11\x20\n\
    \r\n\x05\x04b\x02\x01\x03\x12\x04\xe0%#$\n\xcb\x01\n\x02\x04c\x12\x06\
    \xe7%\0\xef%\x01\x1a\xbc\x01////////////////////////////////////////////\
    //////\n\x20Model\x20prediction\x20related\x20stuff\x20needs\x20inputs\
    \x20and\x20produces\x20outputs.\n///////////////////////////////////////\
    ///////////\n\x20Model\x20prediction.\n\n\x0b\n\x03\x04c\x01\x12\x04\xe7\
    %\x08\x1f\n\x0c\n\x04\x04c\x02\0\x12\x04\xe8%\x02,\n\r\n\x05\x04c\x02\0\
    \x06\x12\x04\xe8%\x02\x1b\n\r\n\x05\x04c\x02\0\x01\x12\x04\xe8%\x1c'\n\r\
    \n\x05\x04c\x02\0\x03\x12\x04\xe8%*+\n\x0c\n\x04\x04c\x02\x01\x12\x04\
    \xe9%\x02\x16\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xe9%\x02\x08\n\r\n\x05\
    \x04c\x02\x01\x01\x12\x04\xe9%\t\x11\n\r\n\x05\x04c\x02\x01\x03\x12\x04\
    \xe9%\x14\x15\n\x0c\n\x04\x04c\x02\x02\x12\x04\xea%\x02\x18\n\r\n\x05\
    \x04c\x02\x02\x05\x12\x04\xea%\x02\x08\n\r\n\x05\x04c\x02\x02\x01\x12\
    \x04\xea%\t\x13\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xea%\x16\x17\n\x0c\n\
    \x04\x04c\x02\x03\x12\x04\xeb%\x02\x1c\n\r\n\x05\x04c\x02\x03\x04\x12\
    \x04\xeb%\x02\n\n\r\n\x05\x04c\x02\x03\x06\x12\x04\xeb%\x0b\x10\n\r\n\
    \x05\x04c\x02\x03\x01\x12\x04\xeb%\x11\x17\n\r\n\x05\x04c\x02\x03\x03\
    \x12\x04\xeb%\x1a\x1b\n\x88\x01\n\x04\x04c\x02\x04\x12\x04\xee%\x02\x12\
    \x1az\x20This\x20allows\x20you\x20to\x20specify\x20config\x20options\x20\
    for\x20the\x20model\x20such\x20as\n\x20the\x20language\x20which\x20appea\
    r's\x20in\x20the\x20model's\x20output_info.\n\n\r\n\x05\x04c\x02\x04\x06\
    \x12\x04\xee%\x02\x07\n\r\n\x05\x04c\x02\x04\x01\x12\x04\xee%\x08\r\n\r\
    \n\x05\x04c\x02\x04\x03\x12\x04\xee%\x10\x11\nF\n\x02\x04d\x12\x06\xf2%\
    \0\xfc%\x01\x1a8\x20Listing\x20the\x20inputs\x20that\x20went\x20into\x20\
    training\x20this\x20model.\n\n\x0b\n\x03\x04d\x01\x12\x04\xf2%\x08\x1e\n\
    \x0c\n\x04\x04d\x02\0\x12\x04\xf3%\x02,\n\r\n\x05\x04d\x02\0\x06\x12\x04\
    \xf3%\x02\x1b\n\r\n\x05\x04d\x02\0\x01\x12\x04\xf3%\x1c'\n\r\n\x05\x04d\
    \x02\0\x03\x12\x04\xf3%*+\n\x0c\n\x04\x04d\x02\x01\x12\x04\xf4%\x02\x16\
    \n\r\n\x05\x04d\x02\x01\x05\x12\x04\xf4%\x02\x08\n\r\n\x05\x04d\x02\x01\
    \x01\x12\x04\xf4%\t\x11\n\r\n\x05\x04d\x02\x01\x03\x12\x04\xf4%\x14\x15\
    \n\x0c\n\x04\x04d\x02\x02\x12\x04\xf5%\x02\x18\n\r\n\x05\x04d\x02\x02\
    \x05\x12\x04\xf5%\x02\x08\n\r\n\x05\x04d\x02\x02\x01\x12\x04\xf5%\t\x13\
    \n\r\n\x05\x04d\x02\x02\x03\x12\x04\xf5%\x16\x17\n~\n\x04\x04d\x02\x03\
    \x12\x04\xf8%\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20p\
    age\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resu\
    lts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04d\x02\
    \x03\x05\x12\x04\xf8%\x02\x08\n\r\n\x05\x04d\x02\x03\x01\x12\x04\xf8%\t\
    \r\n\r\n\x05\x04d\x02\x03\x03\x12\x04\xf8%\x10\x11\nu\n\x04\x04d\x02\x04\
    \x12\x04\xfb%\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04d\x02\x04\x05\x12\
    \x04\xfb%\x02\x08\n\r\n\x05\x04d\x02\x04\x01\x12\x04\xfb%\t\x11\n\r\n\
    \x05\x04d\x02\x04\x03\x12\x04\xfb%\x14\x15\n\x1d\n\x02\x04e\x12\x06\xff%\
    \0\x82&\x01\x1a\x0f\x20GetKeyRequest\n\n\x0b\n\x03\x04e\x01\x12\x04\xff%\
    \x08\x15\n\x0c\n\x04\x04e\x02\0\x12\x04\x80&\x02,\n\r\n\x05\x04e\x02\0\
    \x06\x12\x04\x80&\x02\x1b\n\r\n\x05\x04e\x02\0\x01\x12\x04\x80&\x1c'\n\r\
    \n\x05\x04e\x02\0\x03\x12\x04\x80&*+\n\x0c\n\x04\x04e\x02\x01\x12\x04\
    \x81&\x02\x14\n\r\n\x05\x04e\x02\x01\x05\x12\x04\x81&\x02\x08\n\r\n\x05\
    \x04e\x02\x01\x01\x12\x04\x81&\t\x0f\n\r\n\x05\x04e\x02\x01\x03\x12\x04\
    \x81&\x12\x13\n\x1f\n\x02\x04f\x12\x06\x85&\0\x90&\x01\x1a\x11\x20ListKe\
    ysRequest\n\n\x0b\n\x03\x04f\x01\x12\x04\x85&\x08\x17\n\x0c\n\x04\x04f\
    \x02\0\x12\x04\x86&\x02,\n\r\n\x05\x04f\x02\0\x06\x12\x04\x86&\x02\x1b\n\
    \r\n\x05\x04f\x02\0\x01\x12\x04\x86&\x1c'\n\r\n\x05\x04f\x02\0\x03\x12\
    \x04\x86&*+\n~\n\x04\x04f\x02\x01\x12\x04\x89&\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\r\n\x05\x04f\x02\x01\x05\x12\x04\x89&\x02\x08\n\r\n\x05\
    \x04f\x02\x01\x01\x12\x04\x89&\t\r\n\r\n\x05\x04f\x02\x01\x03\x12\x04\
    \x89&\x10\x11\nu\n\x04\x04f\x02\x02\x12\x04\x8c&\x02\x16\x1ag\x20(option\
    al\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20wil\
    l\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\
    \n\n\r\n\x05\x04f\x02\x02\x05\x12\x04\x8c&\x02\x08\n\r\n\x05\x04f\x02\
    \x02\x01\x12\x04\x8c&\t\x11\n\r\n\x05\x04f\x02\x02\x03\x12\x04\x8c&\x14\
    \x15\n\x0c\n\x04\x04f\x02\x03\x12\x04\x8d&\x02\x17\n\r\n\x05\x04f\x02\
    \x03\x05\x12\x04\x8d&\x02\x06\n\r\n\x05\x04f\x02\x03\x01\x12\x04\x8d&\
    \x07\x12\n\r\n\x05\x04f\x02\x03\x03\x12\x04\x8d&\x15\x16\n\x0c\n\x04\x04\
    f\x02\x04\x12\x04\x8e&\x02\x1d\n\r\n\x05\x04f\x02\x04\x04\x12\x04\x8e&\
    \x02\n\n\r\n\x05\x04f\x02\x04\x05\x12\x04\x8e&\x0b\x11\n\r\n\x05\x04f\
    \x02\x04\x01\x12\x04\x8e&\x12\x18\n\r\n\x05\x04f\x02\x04\x03\x12\x04\x8e\
    &\x1b\x1c\n\x0c\n\x04\x04f\x02\x05\x12\x04\x8f&\x02\x20\n\r\n\x05\x04f\
    \x02\x05\x04\x12\x04\x8f&\x02\n\n\r\n\x05\x04f\x02\x05\x05\x12\x04\x8f&\
    \x0b\x11\n\r\n\x05\x04f\x02\x05\x01\x12\x04\x8f&\x12\x1b\n\r\n\x05\x04f\
    \x02\x05\x03\x12\x04\x8f&\x1e\x1f\n\"\n\x02\x04g\x12\x06\x93&\0\x9b&\x01\
    \x1a\x14\x20ListAppKeysRequest\n\n\x0b\n\x03\x04g\x01\x12\x04\x93&\x08\
    \x1a\n\x0c\n\x04\x04g\x02\0\x12\x04\x94&\x02,\n\r\n\x05\x04g\x02\0\x06\
    \x12\x04\x94&\x02\x1b\n\r\n\x05\x04g\x02\0\x01\x12\x04\x94&\x1c'\n\r\n\
    \x05\x04g\x02\0\x03\x12\x04\x94&*+\n~\n\x04\x04g\x02\x01\x12\x04\x97&\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04g\x02\x01\x05\x12\
    \x04\x97&\x02\x08\n\r\n\x05\x04g\x02\x01\x01\x12\x04\x97&\t\r\n\r\n\x05\
    \x04g\x02\x01\x03\x12\x04\x97&\x10\x11\nu\n\x04\x04g\x02\x02\x12\x04\x9a\
    &\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04g\x02\x02\x05\x12\x04\x9a&\
    \x02\x08\n\r\n\x05\x04g\x02\x02\x01\x12\x04\x9a&\t\x11\n\r\n\x05\x04g\
    \x02\x02\x03\x12\x04\x9a&\x14\x15\n\x1f\n\x02\x04h\x12\x06\x9e&\0\xa1&\
    \x01\x1a\x11\x20PostKeysRequest\n\n\x0b\n\x03\x04h\x01\x12\x04\x9e&\x08\
    \x17\n\x0c\n\x04\x04h\x02\0\x12\x04\x9f&\x02,\n\r\n\x05\x04h\x02\0\x06\
    \x12\x04\x9f&\x02\x1b\n\r\n\x05\x04h\x02\0\x01\x12\x04\x9f&\x1c'\n\r\n\
    \x05\x04h\x02\0\x03\x12\x04\x9f&*+\n\x0c\n\x04\x04h\x02\x01\x12\x04\xa0&\
    \x02\x18\n\r\n\x05\x04h\x02\x01\x04\x12\x04\xa0&\x02\n\n\r\n\x05\x04h\
    \x02\x01\x06\x12\x04\xa0&\x0b\x0e\n\r\n\x05\x04h\x02\x01\x01\x12\x04\xa0\
    &\x0f\x13\n\r\n\x05\x04h\x02\x01\x03\x12\x04\xa0&\x16\x17\n\x20\n\x02\
    \x04i\x12\x06\xa4&\0\xa7&\x01\x1a\x12\x20DeleteKeyRequest\n\n\x0b\n\x03\
    \x04i\x01\x12\x04\xa4&\x08\x18\n\x0c\n\x04\x04i\x02\0\x12\x04\xa5&\x02,\
    \n\r\n\x05\x04i\x02\0\x06\x12\x04\xa5&\x02\x1b\n\r\n\x05\x04i\x02\0\x01\
    \x12\x04\xa5&\x1c'\n\r\n\x05\x04i\x02\0\x03\x12\x04\xa5&*+\n\x0c\n\x04\
    \x04i\x02\x01\x12\x04\xa6&\x02\x14\n\r\n\x05\x04i\x02\x01\x05\x12\x04\
    \xa6&\x02\x08\n\r\n\x05\x04i\x02\x01\x01\x12\x04\xa6&\t\x0f\n\r\n\x05\
    \x04i\x02\x01\x03\x12\x04\xa6&\x12\x13\n\x20\n\x02\x04j\x12\x06\xaa&\0\
    \xb1&\x01\x1a\x12\x20PatchKeysRequest\n\n\x0b\n\x03\x04j\x01\x12\x04\xaa\
    &\x08\x18\n\x0c\n\x04\x04j\x02\0\x12\x04\xab&\x02,\n\r\n\x05\x04j\x02\0\
    \x06\x12\x04\xab&\x02\x1b\n\r\n\x05\x04j\x02\0\x01\x12\x04\xab&\x1c'\n\r\
    \n\x05\x04j\x02\0\x03\x12\x04\xab&*+\n\x0c\n\x04\x04j\x02\x01\x12\x04\
    \xac&\x02\x18\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xac&\x02\n\n\r\n\x05\
    \x04j\x02\x01\x06\x12\x04\xac&\x0b\x0e\n\r\n\x05\x04j\x02\x01\x01\x12\
    \x04\xac&\x0f\x13\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xac&\x16\x17\nj\n\
    \x04\x04j\x02\x02\x12\x04\xb0&\x02\x14\x1a\\\x20The\x20action\x20to\x20p\
    erform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20only\x20act\
    ion\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04j\x02\x02\x05\x12\
    \x04\xb0&\x02\x08\n\r\n\x05\x04j\x02\x02\x01\x12\x04\xb0&\t\x0f\n\r\n\
    \x05\x04j\x02\x02\x03\x12\x04\xb0&\x12\x13\n!\n\x02\x04k\x12\x06\xb4&\0\
    \xb7&\x01\x1a\x13\x20SingleKeyResponse\n\n\x0b\n\x03\x04k\x01\x12\x04\
    \xb4&\x08\x19\n\x0c\n\x04\x04k\x02\0\x12\x04\xb5&\x02(\n\r\n\x05\x04k\
    \x02\0\x06\x12\x04\xb5&\x02\x1c\n\r\n\x05\x04k\x02\0\x01\x12\x04\xb5&\
    \x1d#\n\r\n\x05\x04k\x02\0\x03\x12\x04\xb5&&'\n\x0c\n\x04\x04k\x02\x01\
    \x12\x04\xb6&\x02\x0e\n\r\n\x05\x04k\x02\x01\x06\x12\x04\xb6&\x02\x05\n\
    \r\n\x05\x04k\x02\x01\x01\x12\x04\xb6&\x06\t\n\r\n\x05\x04k\x02\x01\x03\
    \x12\x04\xb6&\x0c\r\n\x20\n\x02\x04l\x12\x06\xba&\0\xbd&\x01\x1a\x12\x20\
    MultiKeyResponse\n\n\x0b\n\x03\x04l\x01\x12\x04\xba&\x08\x18\n\x0c\n\x04\
    \x04l\x02\0\x12\x04\xbb&\x02(\n\r\n\x05\x04l\x02\0\x06\x12\x04\xbb&\x02\
    \x1c\n\r\n\x05\x04l\x02\0\x01\x12\x04\xbb&\x1d#\n\r\n\x05\x04l\x02\0\x03\
    \x12\x04\xbb&&'\n\x0c\n\x04\x04l\x02\x01\x12\x04\xbc&\x02G\n\r\n\x05\x04\
    l\x02\x01\x04\x12\x04\xbc&\x02\n\n\r\n\x05\x04l\x02\x01\x06\x12\x04\xbc&\
    \x0b\x0e\n\r\n\x05\x04l\x02\x01\x01\x12\x04\xbc&\x0f\x13\n\r\n\x05\x04l\
    \x02\x01\x03\x12\x04\xbc&\x16\x17\n\r\n\x05\x04l\x02\x01\x08\x12\x04\xbc\
    &\x18F\n\x10\n\x08\x04l\x02\x01\x08\xd0\x86\x03\x12\x04\xbc&\x19E\n\x1f\
    \n\x02\x04m\x12\x06\xc8&\0\xd2&\x01\x1a\x11\x20GetModelRequest\n\n\x0b\n\
    \x03\x04m\x01\x12\x04\xc8&\x08\x17\n\x0c\n\x04\x04m\x02\0\x12\x04\xc9&\
    \x02,\n\r\n\x05\x04m\x02\0\x06\x12\x04\xc9&\x02\x1b\n\r\n\x05\x04m\x02\0\
    \x01\x12\x04\xc9&\x1c'\n\r\n\x05\x04m\x02\0\x03\x12\x04\xc9&*+\n\x0c\n\
    \x04\x04m\x02\x01\x12\x04\xca&\x02\x16\n\r\n\x05\x04m\x02\x01\x05\x12\
    \x04\xca&\x02\x08\n\r\n\x05\x04m\x02\x01\x01\x12\x04\xca&\t\x11\n\r\n\
    \x05\x04m\x02\x01\x03\x12\x04\xca&\x14\x15\nw\n\x04\x04m\x02\x02\x12\x04\
    \xcd&\x02\x18\x1ai\x20This\x20is\x20included\x20so\x20that\x20we\x20can\
    \x20re-use\x20this\x20request\x20for\x20multiple\n\x20rpcs\x20with\x20an\
    d\x20without\x20the\x20version_id.\n\n\r\n\x05\x04m\x02\x02\x05\x12\x04\
    \xcd&\x02\x08\n\r\n\x05\x04m\x02\x02\x01\x12\x04\xcd&\t\x13\n\r\n\x05\
    \x04m\x02\x02\x03\x12\x04\xcd&\x16\x17\n\x0c\n\x04\x04m\x02\x03\x12\x04\
    \xce&\x02\x16\n\r\n\x05\x04m\x02\x03\x05\x12\x04\xce&\x02\x08\n\r\n\x05\
    \x04m\x02\x03\x01\x12\x04\xce&\t\x11\n\r\n\x05\x04m\x02\x03\x03\x12\x04\
    \xce&\x14\x15\n\x0c\n\x04\x04m\x02\x04\x12\x04\xcf&\x02\x1a\n\r\n\x05\
    \x04m\x02\x04\x05\x12\x04\xcf&\x02\x06\n\r\n\x05\x04m\x02\x04\x01\x12\
    \x04\xcf&\x07\x15\n\r\n\x05\x04m\x02\x04\x03\x12\x04\xcf&\x18\x19\n\x95\
    \x01\n\x04\x04m\x02\x05\x12\x04\xd1&\x02)\x1a\x86\x01\x20(optional\x20UR\
    L\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\x20inc\
    luded\x20in\x20the\x20response.\x20Currently\x20supported:\x20all,\x20st\
    ars,\x20outputs,\x20presets\n\n\r\n\x05\x04m\x02\x05\x04\x12\x04\xd1&\
    \x02\n\n\r\n\x05\x04m\x02\x05\x05\x12\x04\xd1&\x0b\x11\n\r\n\x05\x04m\
    \x02\x05\x01\x12\x04\xd1&\x12#\n\r\n\x05\x04m\x02\x05\x03\x12\x04\xd1&&(\
    \n!\n\x02\x04n\x12\x06\xd5&\0\xab'\x01\x1a\x13\x20ListModelsRequest\n\n\
    \x0b\n\x03\x04n\x01\x12\x04\xd5&\x08\x19\n\x0b\n\x03\x04n\t\x12\x04\xd6&\
    \x02\r\n\x0c\n\x04\x04n\t\0\x12\x04\xd6&\x0b\x0c\n\r\n\x05\x04n\t\0\x01\
    \x12\x04\xd6&\x0b\x0c\n\r\n\x05\x04n\t\0\x02\x12\x04\xd6&\x0b\x0c\n\x0c\
    \n\x04\x04n\x02\0\x12\x04\xd7&\x02,\n\r\n\x05\x04n\x02\0\x06\x12\x04\xd7\
    &\x02\x1b\n\r\n\x05\x04n\x02\0\x01\x12\x04\xd7&\x1c'\n\r\n\x05\x04n\x02\
    \0\x03\x12\x04\xd7&*+\n~\n\x04\x04n\x02\x01\x12\x04\xda&\x02\x12\x1ap\
    \x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginati\
    on\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xda&\x02\
    \x08\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xda&\t\r\n\r\n\x05\x04n\x02\x01\
    \x03\x12\x04\xda&\x10\x11\nu\n\x04\x04n\x02\x02\x12\x04\xdd&\x02\x16\x1a\
    g\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\
    \x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\
    \x20to\x20128.\n\n\r\n\x05\x04n\x02\x02\x05\x12\x04\xdd&\x02\x08\n\r\n\
    \x05\x04n\x02\x02\x01\x12\x04\xdd&\t\x11\n\r\n\x05\x04n\x02\x02\x03\x12\
    \x04\xdd&\x14\x15\n\x95\x01\n\x04\x04n\x02\x03\x12\x04\xe0&\x02)\x1a\x86\
    \x01\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fi\
    elds\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20s\
    upported:\x20all,\x20stars,\x20outputs,\x20presets\n\n\r\n\x05\x04n\x02\
    \x03\x04\x12\x04\xe0&\x02\n\n\r\n\x05\x04n\x02\x03\x05\x12\x04\xe0&\x0b\
    \x11\n\r\n\x05\x04n\x02\x03\x01\x12\x04\xe0&\x12#\n\r\n\x05\x04n\x02\x03\
    \x03\x12\x04\xe0&&(\no\n\x04\x04n\x02\x04\x12\x04\xe4&\x02\x1b\x1aa\x20S\
    orting\x20options:\n\x20Whether\x20to\x20sort\x20in\x20ascending\x20orde\
    r.\x20If\x20false,\x20will\x20order\x20in\x20descending\x20order.\n\n\r\
    \n\x05\x04n\x02\x04\x05\x12\x04\xe4&\x02\x06\n\r\n\x05\x04n\x02\x04\x01\
    \x12\x04\xe4&\x07\x15\n\r\n\x05\x04n\x02\x04\x03\x12\x04\xe4&\x18\x1a\n\
    \x0e\n\x04\x04n\x08\0\x12\x06\xe5&\x02\xf1&\x03\n\r\n\x05\x04n\x08\0\x01\
    \x12\x04\xe5&\x08\x0f\n,\n\x04\x04n\x02\x05\x12\x04\xe7&\x04\x1b\x1a\x1e\
    \x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\r\n\x05\x04n\x02\x05\
    \x05\x12\x04\xe7&\x04\x08\n\r\n\x05\x04n\x02\x05\x01\x12\x04\xe7&\t\x15\
    \n\r\n\x05\x04n\x02\x05\x03\x12\x04\xe7&\x18\x1a\nA\n\x04\x04n\x02\x06\
    \x12\x04\xe9&\x04!\x1a3\x20Whether\x20to\x20order\x20by\x20the\x20number\
    \x20of\x20training\x20inputs\n\n\r\n\x05\x04n\x02\x06\x05\x12\x04\xe9&\
    \x04\x08\n\r\n\x05\x04n\x02\x06\x01\x12\x04\xe9&\t\x1b\n\r\n\x05\x04n\
    \x02\x06\x03\x12\x04\xe9&\x1e\x20\n\x9d\x01\n\x04\x04n\x02\x07\x12\x04\
    \xec&\x04\"\x1a\x8e\x01\x20Whether\x20to\x20order\x20by\x20the\x20modifi\
    ed_at\x20time\x20of\x20the\x20latest\x20model\x20version.\n\x20If\x20non\
    e\x20of\x20the\x20sort\x20options\x20is\x20set\x20to\x20true,\x20will\
    \x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04n\x02\x07\x05\x12\x04\xec&\
    \x04\x08\n\r\n\x05\x04n\x02\x07\x01\x12\x04\xec&\t\x1c\n\r\n\x05\x04n\
    \x02\x07\x03\x12\x04\xec&\x1f!\n2\n\x04\x04n\x02\x08\x12\x04\xee&\x04!\
    \x1a$\x20Whether\x20to\x20order\x20by\x20the\x20created_at\n\n\r\n\x05\
    \x04n\x02\x08\x05\x12\x04\xee&\x04\x08\n\r\n\x05\x04n\x02\x08\x01\x12\
    \x04\xee&\t\x1b\n\r\n\x05\x04n\x02\x08\x03\x12\x04\xee&\x1e\x20\n2\n\x04\
    \x04n\x02\t\x12\x04\xf0&\x04!\x1a$\x20Whether\x20to\x20order\x20by\x20co\
    unt\x20of\x20stars\n\n\r\n\x05\x04n\x02\t\x05\x12\x04\xf0&\x04\x08\n\r\n\
    \x05\x04n\x02\t\x01\x12\x04\xf0&\t\x1b\n\r\n\x05\x04n\x02\t\x03\x12\x04\
    \xf0&\x1e\x20\n\x8f\x01\n\x04\x04n\x02\n\x12\x04\xf6&\x02\x1b\x1a\x80\
    \x01\x20Filtering\x20options:\n\x20Filter\x20models\x20by\x20the\x20spec\
    ific\x20model_type_id.\x20See\x20ListModelTypes\x20for\x20the\x20list\
    \x20of\x20ModelType.Id's\n\x20supported.\n\n\r\n\x05\x04n\x02\n\x05\x12\
    \x04\xf6&\x02\x08\n\r\n\x05\x04n\x02\n\x01\x12\x04\xf6&\t\x16\n\r\n\x05\
    \x04n\x02\n\x03\x12\x04\xf6&\x19\x1a\n|\n\x04\x04n\x02\x0b\x12\x04\xf8&\
    \x02\x18\x1an\x20If\x20true,\x20we\x20only\x20return\x20models\x20that\
    \x20have\x20the\x20status\x20MODEL_TRAINED,\x20which\x20includes\x20non-\
    trainable\x20model\x20types.\n\n\r\n\x05\x04n\x02\x0b\x05\x12\x04\xf8&\
    \x02\x06\n\r\n\x05\x04n\x02\x0b\x01\x12\x04\xf8&\x07\x13\n\r\n\x05\x04n\
    \x02\x0b\x03\x12\x04\xf8&\x16\x17\n\xb5\x01\n\x04\x04n\x02\x0c\x12\x04\
    \xfb&\x02#\x1a\xa6\x01\x20The\x20list\x20of\x20input\x20fields\x20to\x20\
    the\x20model.\n\x20For\x20example,\x20you\x20can\x20specify\x20'image',\
    \x20which\x20will\x20return\x20models\x20that\x20make\x20inferences\x20o\
    n\x20images\x20like\x20visual-classifier\x20models.\n\n\r\n\x05\x04n\x02\
    \x0c\x04\x12\x04\xfb&\x02\n\n\r\n\x05\x04n\x02\x0c\x05\x12\x04\xfb&\x0b\
    \x11\n\r\n\x05\x04n\x02\x0c\x01\x12\x04\xfb&\x12\x1e\n\r\n\x05\x04n\x02\
    \x0c\x03\x12\x04\xfb&!\"\n\x9e\x01\n\x04\x04n\x02\r\x12\x04\xfe&\x02$\
    \x1a\x8f\x01\x20The\x20list\x20of\x20output\x20fields\x20to\x20the\x20mo\
    del.\n\x20For\x20example,\x20you\x20can\x20specify\x20'regions[...].data\
    .concepts',\x20which\x20will\x20return\x20visual-detector\x20models.\n\n\
    \r\n\x05\x04n\x02\r\x04\x12\x04\xfe&\x02\n\n\r\n\x05\x04n\x02\r\x05\x12\
    \x04\xfe&\x0b\x11\n\r\n\x05\x04n\x02\r\x01\x12\x04\xfe&\x12\x1f\n\r\n\
    \x05\x04n\x02\r\x03\x12\x04\xfe&\"#\n:\n\x04\x04n\x02\x0e\x12\x04\x80'\
    \x02\x16\x1a,\x20Filter\x20by\x20the\x20license\x20of\x20the\x20model\
    \x20version\n\n\r\n\x05\x04n\x02\x0e\x05\x12\x04\x80'\x02\x08\n\r\n\x05\
    \x04n\x02\x0e\x01\x12\x04\x80'\t\x10\n\r\n\x05\x04n\x02\x0e\x03\x12\x04\
    \x80'\x13\x15\nT\n\x04\x04n\x02\x0f\x12\x04\x82'\x02\x1a\x1aF\x20If\x20t\
    rue,\x20we\x20only\x20return\x20models\x20that\x20are\x20handpicked\x20b\
    y\x20clarifai\x20staff\n\n\r\n\x05\x04n\x02\x0f\x05\x12\x04\x82'\x02\x06\
    \n\r\n\x05\x04n\x02\x0f\x01\x12\x04\x82'\x07\x14\n\r\n\x05\x04n\x02\x0f\
    \x03\x12\x04\x82'\x17\x19\nV\n\x04\x04n\x02\x10\x12\x04\x84'\x02\x19\x1a\
    H\x20If\x20true,\x20we\x20only\x20return\x20models\x20that\x20are\x20sta\
    rred\x20by\x20the\x20requesting\x20user\n\n\r\n\x05\x04n\x02\x10\x05\x12\
    \x04\x84'\x02\x06\n\r\n\x05\x04n\x02\x10\x01\x12\x04\x84'\x07\x13\n\r\n\
    \x05\x04n\x02\x10\x03\x12\x04\x84'\x16\x18\n1\n\x04\x04n\x02\x11\x12\x04\
    \x86'\x02\x20\x1a#\x20List\x20of\x20toolkit\x20tags\x20to\x20filter\x20b\
    y\n\n\r\n\x05\x04n\x02\x11\x04\x12\x04\x86'\x02\n\n\r\n\x05\x04n\x02\x11\
    \x05\x12\x04\x86'\x0b\x11\n\r\n\x05\x04n\x02\x11\x01\x12\x04\x86'\x12\
    \x1a\n\r\n\x05\x04n\x02\x11\x03\x12\x04\x86'\x1d\x1f\n2\n\x04\x04n\x02\
    \x12\x12\x04\x88'\x02!\x1a$\x20List\x20of\x20use_case\x20tags\x20to\x20f\
    ilter\x20by\n\n\r\n\x05\x04n\x02\x12\x04\x12\x04\x88'\x02\n\n\r\n\x05\
    \x04n\x02\x12\x05\x12\x04\x88'\x0b\x11\n\r\n\x05\x04n\x02\x12\x01\x12\
    \x04\x88'\x12\x1b\n\r\n\x05\x04n\x02\x12\x03\x12\x04\x88'\x1e\x20\n2\n\
    \x04\x04n\x02\x13\x12\x04\x8a'\x02!\x1a$\x20List\x20of\x20language\x20ta\
    gs\x20to\x20filter\x20by\n\n\r\n\x05\x04n\x02\x13\x04\x12\x04\x8a'\x02\n\
    \n\r\n\x05\x04n\x02\x13\x05\x12\x04\x8a'\x0b\x11\n\r\n\x05\x04n\x02\x13\
    \x01\x12\x04\x8a'\x12\x1b\n\r\n\x05\x04n\x02\x13\x03\x12\x04\x8a'\x1e\
    \x20\n\x96\x02\n\x04\x04n\x02\x14\x12\x04\x8d'\x02!\x1a\x87\x02\x20Old\
    \x20API\x20behavior\x20resulted\x20in\x20returning\x20clarifai\x20main\
    \x20models\x20when\x20calling\x20ListModels\x20while\x20scoped\x20to\x20\
    an\x20app.\x20While\x20we\x20transition\n\x20away\x20from\x20that,\x20we\
    \x20can\x20use\x20this\x20flag\x20to\x20not\x20always\x20fetch\x20clarif\
    ai\x20main\x20models,\x20unless\x20that\x20is\x20the\x20app\x20we\x20are\
    \x20explicitly\x20listing\x20for.\n\n\r\n\x05\x04n\x02\x14\x05\x12\x04\
    \x8d'\x02\x06\n\r\n\x05\x04n\x02\x14\x01\x12\x04\x8d'\x07\x1b\n\r\n\x05\
    \x04n\x02\x14\x03\x12\x04\x8d'\x1e\x20\n\x88\x02\n\x04\x04n\x02\x15\x12\
    \x04\x91'\x02\x15\x1a\xf9\x01\x20Filter\x20models\x20by\x20bookmark.\x20\
    If\x20set,\x20only\x20return\x20bookmarked\x20models.\x20Otherwise\x20no\
    ne\x20bookmarked\x20models\x20only.\n\x20Note:\x20you\x20can\x20not\x20f\
    ilter\x20`trained_only`\x20and\x20bookmark\x20at\x20the\x20same\x20time.\
    \n\x20When\x20filter\x20by\x20bookmark,\x20we\x20will\x20return\x20train\
    ed\x20and\x20untrained\x20models.\n\n\r\n\x05\x04n\x02\x15\x05\x12\x04\
    \x91'\x02\x06\n\r\n\x05\x04n\x02\x15\x01\x12\x04\x91'\x07\x0f\n\r\n\x05\
    \x04n\x02\x15\x03\x12\x04\x91'\x12\x14\n\xb4\x04\n\x04\x04n\x02\x16\x12\
    \x04\xa1'\x02\x15\x1a\xa5\x04\x20Searching\x20options:\n\x20Specify\x20a\
    \x20search\x20parameter\x20in\x20order\x20to\x20perform\x20keyword\x20se\
    arch\x20on\x20the\n\x20following\x20fields\x20of\x20the\x20model:\n\x20\
    \x20\x20-\x20id\n\x20\x20\x20-\x20name\n\x20\x20\x20-\x20description\n\
    \x20\x20\x20-\x20notes\n\x20\x20\x20-\x20user_id\x20(unless\x20user_app_\
    id.user_id\x20is\x20already\x20set)\n\n\x20Keywords\x20are\x20both\x20no\
    rmalized\x20for\x20search\x20(so\x20searching\x20for\x20\"satisfy\"\x20m\
    atches\x20\"satisfied\")\n\x20and\x20used\x20for\x20partial\x20prefix-ma\
    tching\x20(so\x20searching\x20for\x20\"clari\"\x20matches\x20\"clarifai\
    \").\n\n\x20NOTE:\x20Both\x20the\x20list\x20of\x20fields\x20searched\x20\
    and\x20the\x20exact\x20keyword\x20matching\n\x20rules\x20are\x20subject\
    \x20to\x20change\x20and\x20not\x20guaranteed\x20to\x20be\x20backwards-co\
    mpatible.\n\n\r\n\x05\x04n\x02\x16\x05\x12\x04\xa1'\x02\x08\n\r\n\x05\
    \x04n\x02\x16\x01\x12\x04\xa1'\t\x0f\n\r\n\x05\x04n\x02\x16\x03\x12\x04\
    \xa1'\x12\x14\n\xde\x01\n\x04\x04n\x02\x17\x12\x04\xa4'\x02(\x1a\xcf\x01\
    \x20Query\x20name,\x20description\x20and\x20id\x20fields,\x20that\x20can\
    \x20contain\x20the\x20words\x20in\x20the\x20query\x20string.\x20Does\x20\
    NOT\x20support\x20wildcards\x20-\x20full\x20words\x20only.\x20Supports\
    \x20operators\x20\"OR\"\x20and\x20\"-\"\x20as\x20NOT.\n\x20Deprecated:\
    \x20use\x20search\x20instead.\n\n\r\n\x05\x04n\x02\x17\x05\x12\x04\xa4'\
    \x02\x08\n\r\n\x05\x04n\x02\x17\x01\x12\x04\xa4'\t\x0e\n\r\n\x05\x04n\
    \x02\x17\x03\x12\x04\xa4'\x11\x13\n\r\n\x05\x04n\x02\x17\x08\x12\x04\xa4\
    '\x14'\n\x0e\n\x06\x04n\x02\x17\x08\x03\x12\x04\xa4'\x15&\n\xad\x01\n\
    \x04\x04n\x02\x18\x12\x04\xa7'\x02&\x1a\x9e\x01\x20Filter\x20by\x20the\
    \x20description\x20and\x20id\x20of\x20the\x20model.\x20This\x20supports\
    \x20wildcard\x20queries\x20like\x20\"gen*\"\x20to\x20match\x20\"general\
    \"\x20as\x20an\x20example.\n\x20Deprecated:\x20use\x20search\x20instead.\
    \n\n\r\n\x05\x04n\x02\x18\x05\x12\x04\xa7'\x02\x08\n\r\n\x05\x04n\x02\
    \x18\x01\x12\x04\xa7'\t\r\n\r\n\x05\x04n\x02\x18\x03\x12\x04\xa7'\x10\
    \x11\n\r\n\x05\x04n\x02\x18\x08\x12\x04\xa7'\x12%\n\x0e\n\x06\x04n\x02\
    \x18\x08\x03\x12\x04\xa7'\x13$\n\x9c\x01\n\x04\x04n\x02\x19\x12\x04\xaa'\
    \x022\x1a\x8d\x01\x20Extends\x20the\x20name\x20filter\x20to\x20include\
    \x20the\x20user_id\x20of\x20the\x20application\x20owner\x20that\x20the\
    \x20model\x20belongs\x20to.\n\x20Deprecated:\x20use\x20search\x20instead\
    \x20of\x20name.\n\n\r\n\x05\x04n\x02\x19\x05\x12\x04\xaa'\x02\x06\n\r\n\
    \x05\x04n\x02\x19\x01\x12\x04\xaa'\x07\x18\n\r\n\x05\x04n\x02\x19\x03\
    \x12\x04\xaa'\x1b\x1d\n\r\n\x05\x04n\x02\x19\x08\x12\x04\xaa'\x1e1\n\x0e\
    \n\x06\x04n\x02\x19\x08\x03\x12\x04\xaa'\x1f0\n$\n\x02\x04o\x12\x06\xae'\
    \0\xb0'\x01\x1a\x16\x20ResourceCountRequest\n\n\x0b\n\x03\x04o\x01\x12\
    \x04\xae'\x08\x20\n\x0c\n\x04\x04o\x02\0\x12\x04\xaf'\x02,\n\r\n\x05\x04\
    o\x02\0\x06\x12\x04\xaf'\x02\x1b\n\r\n\x05\x04o\x02\0\x01\x12\x04\xaf'\
    \x1c'\n\r\n\x05\x04o\x02\0\x03\x12\x04\xaf'*+\n%\n\x02\x04p\x12\x06\xb3'\
    \0\xba'\x01\x1a\x17\x20ResourceCountResponse\n\n\x0b\n\x03\x04p\x01\x12\
    \x04\xb3'\x08!\n\x0c\n\x04\x04p\x02\0\x12\x04\xb4'\x02(\n\r\n\x05\x04p\
    \x02\0\x06\x12\x04\xb4'\x02\x1c\n\r\n\x05\x04p\x02\0\x01\x12\x04\xb4'\
    \x1d#\n\r\n\x05\x04p\x02\0\x03\x12\x04\xb4'&'\n\x0c\n\x04\x04p\x02\x01\
    \x12\x04\xb5'\x02\x15\n\r\n\x05\x04p\x02\x01\x05\x12\x04\xb5'\x02\x07\n\
    \r\n\x05\x04p\x02\x01\x01\x12\x04\xb5'\x08\x10\n\r\n\x05\x04p\x02\x01\
    \x03\x12\x04\xb5'\x13\x14\n\x0c\n\x04\x04p\x02\x02\x12\x04\xb6'\x02\x13\
    \n\r\n\x05\x04p\x02\x02\x05\x12\x04\xb6'\x02\x07\n\r\n\x05\x04p\x02\x02\
    \x01\x12\x04\xb6'\x08\x0e\n\r\n\x05\x04p\x02\x02\x03\x12\x04\xb6'\x11\
    \x12\n\x0c\n\x04\x04p\x02\x03\x12\x04\xb7'\x02\x16\n\r\n\x05\x04p\x02\
    \x03\x05\x12\x04\xb7'\x02\x07\n\r\n\x05\x04p\x02\x03\x01\x12\x04\xb7'\
    \x08\x11\n\r\n\x05\x04p\x02\x03\x03\x12\x04\xb7'\x14\x15\n\x0c\n\x04\x04\
    p\x02\x04\x12\x04\xb8'\x02\x14\n\r\n\x05\x04p\x02\x04\x05\x12\x04\xb8'\
    \x02\x07\n\r\n\x05\x04p\x02\x04\x01\x12\x04\xb8'\x08\x0f\n\r\n\x05\x04p\
    \x02\x04\x03\x12\x04\xb8'\x12\x13\n\x0c\n\x04\x04p\x02\x05\x12\x04\xb9'\
    \x02\x13\n\r\n\x05\x04p\x02\x05\x05\x12\x04\xb9'\x02\x07\n\r\n\x05\x04p\
    \x02\x05\x01\x12\x04\xb9'\x08\x0e\n\r\n\x05\x04p\x02\x05\x03\x12\x04\xb9\
    '\x11\x12\n\x0c\n\x02\x04q\x12\x06\xbc'\0\xc4'\x01\n\x0b\n\x03\x04q\x01\
    \x12\x04\xbc'\x08!\n\x0c\n\x04\x04q\x02\0\x12\x04\xbd'\x02,\n\r\n\x05\
    \x04q\x02\0\x06\x12\x04\xbd'\x02\x1b\n\r\n\x05\x04q\x02\0\x01\x12\x04\
    \xbd'\x1c'\n\r\n\x05\x04q\x02\0\x03\x12\x04\xbd'*+\n\x0c\n\x04\x04q\x02\
    \x01\x12\x04\xbf'\x02\x16\n\r\n\x05\x04q\x02\x01\x05\x12\x04\xbf'\x02\
    \x08\n\r\n\x05\x04q\x02\x01\x01\x12\x04\xbf'\t\x11\n\r\n\x05\x04q\x02\
    \x01\x03\x12\x04\xbf'\x14\x15\n\x0c\n\x04\x04q\x02\x02\x12\x04\xc1'\x02\
    \x1f\n\r\n\x05\x04q\x02\x02\x04\x12\x04\xc1'\x02\n\n\r\n\x05\x04q\x02\
    \x02\x05\x12\x04\xc1'\x0b\x11\n\r\n\x05\x04q\x02\x02\x01\x12\x04\xc1'\
    \x12\x1a\n\r\n\x05\x04q\x02\x02\x03\x12\x04\xc1'\x1d\x1e\n\"\n\x04\x04q\
    \x02\x03\x12\x04\xc3'\x02\x14\x1a\x14overwrite\x20supported\n\n\r\n\x05\
    \x04q\x02\x03\x05\x12\x04\xc3'\x02\x08\n\r\n\x05\x04q\x02\x03\x01\x12\
    \x04\xc3'\t\x0f\n\r\n\x05\x04q\x02\x03\x03\x12\x04\xc3'\x12\x13\n.\n\x02\
    \x04r\x12\x06\xc7'\0\xcf'\x01\x1a\x20\x20PatchModelCheckConsentsRequest\
    \n\n\x0b\n\x03\x04r\x01\x12\x04\xc7'\x08&\n\x0c\n\x04\x04r\x02\0\x12\x04\
    \xc8'\x02,\n\r\n\x05\x04r\x02\0\x06\x12\x04\xc8'\x02\x1b\n\r\n\x05\x04r\
    \x02\0\x01\x12\x04\xc8'\x1c'\n\r\n\x05\x04r\x02\0\x03\x12\x04\xc8'*+\n\
    \x1c\n\x04\x04r\x02\x01\x12\x04\xca'\x02\x16\x1a\x0e\x20the\x20model\x20\
    id\n\n\r\n\x05\x04r\x02\x01\x05\x12\x04\xca'\x02\x08\n\r\n\x05\x04r\x02\
    \x01\x01\x12\x04\xca'\t\x11\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xca'\x14\
    \x15\n\x1c\n\x04\x04r\x02\x02\x12\x04\xcc'\x02%\x1a\x0e\x20the\x20consen\
    ts\n\n\r\n\x05\x04r\x02\x02\x04\x12\x04\xcc'\x02\n\n\r\n\x05\x04r\x02\
    \x02\x05\x12\x04\xcc'\x0b\x11\n\r\n\x05\x04r\x02\x02\x01\x12\x04\xcc'\
    \x12\x20\n\r\n\x05\x04r\x02\x02\x03\x12\x04\xcc'#$\n\"\n\x04\x04r\x02\
    \x03\x12\x04\xce'\x02\x14\x1a\x14overwrite\x20supported\n\n\r\n\x05\x04r\
    \x02\x03\x05\x12\x04\xce'\x02\x08\n\r\n\x05\x04r\x02\x03\x01\x12\x04\xce\
    '\t\x0f\n\r\n\x05\x04r\x02\x03\x03\x12\x04\xce'\x12\x13\n\x0c\n\x02\x04s\
    \x12\x06\xd1'\0\xd9'\x01\n\x0b\n\x03\x04s\x01\x12\x04\xd1'\x08!\n\x0c\n\
    \x04\x04s\x02\0\x12\x04\xd2'\x02,\n\r\n\x05\x04s\x02\0\x06\x12\x04\xd2'\
    \x02\x1b\n\r\n\x05\x04s\x02\0\x01\x12\x04\xd2'\x1c'\n\r\n\x05\x04s\x02\0\
    \x03\x12\x04\xd2'*+\n\x0c\n\x04\x04s\x02\x01\x12\x04\xd4'\x02\x16\n\r\n\
    \x05\x04s\x02\x01\x05\x12\x04\xd4'\x02\x08\n\r\n\x05\x04s\x02\x01\x01\
    \x12\x04\xd4'\t\x11\n\r\n\x05\x04s\x02\x01\x03\x12\x04\xd4'\x14\x15\n\
    \x0c\n\x04\x04s\x02\x02\x12\x04\xd6'\x02\x1f\n\r\n\x05\x04s\x02\x02\x04\
    \x12\x04\xd6'\x02\n\n\r\n\x05\x04s\x02\x02\x05\x12\x04\xd6'\x0b\x11\n\r\
    \n\x05\x04s\x02\x02\x01\x12\x04\xd6'\x12\x1a\n\r\n\x05\x04s\x02\x02\x03\
    \x12\x04\xd6'\x1d\x1e\n\"\n\x04\x04s\x02\x03\x12\x04\xd8'\x02\x14\x1a\
    \x14overwrite\x20supported\n\n\r\n\x05\x04s\x02\x03\x05\x12\x04\xd8'\x02\
    \x08\n\r\n\x05\x04s\x02\x03\x01\x12\x04\xd8'\t\x0f\n\r\n\x05\x04s\x02\
    \x03\x03\x12\x04\xd8'\x12\x13\n\x0c\n\x02\x04t\x12\x06\xdb'\0\xe3'\x01\n\
    \x0b\n\x03\x04t\x01\x12\x04\xdb'\x08\"\n\x0c\n\x04\x04t\x02\0\x12\x04\
    \xdc'\x02,\n\r\n\x05\x04t\x02\0\x06\x12\x04\xdc'\x02\x1b\n\r\n\x05\x04t\
    \x02\0\x01\x12\x04\xdc'\x1c'\n\r\n\x05\x04t\x02\0\x03\x12\x04\xdc'*+\n\
    \x0c\n\x04\x04t\x02\x01\x12\x04\xde'\x02\x16\n\r\n\x05\x04t\x02\x01\x05\
    \x12\x04\xde'\x02\x08\n\r\n\x05\x04t\x02\x01\x01\x12\x04\xde'\t\x11\n\r\
    \n\x05\x04t\x02\x01\x03\x12\x04\xde'\x14\x15\n\x0c\n\x04\x04t\x02\x02\
    \x12\x04\xe0'\x02\x20\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xe0'\x02\n\n\r\
    \n\x05\x04t\x02\x02\x05\x12\x04\xe0'\x0b\x11\n\r\n\x05\x04t\x02\x02\x01\
    \x12\x04\xe0'\x12\x1b\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xe0'\x1e\x1f\n(\
    \n\x04\x04t\x02\x03\x12\x04\xe2'\x02\x14\x1a\x1a\x20Only\x20overwrite\
    \x20supported\n\n\r\n\x05\x04t\x02\x03\x05\x12\x04\xe2'\x02\x08\n\r\n\
    \x05\x04t\x02\x03\x01\x12\x04\xe2'\t\x0f\n\r\n\x05\x04t\x02\x03\x03\x12\
    \x04\xe2'\x12\x13\n\x0c\n\x02\x04u\x12\x06\xe7'\0\xea'\x01\n\x0b\n\x03\
    \x04u\x01\x12\x04\xe7'\x08!\n\x0c\n\x04\x04u\x02\0\x12\x04\xe8'\x02(\n\r\
    \n\x05\x04u\x02\0\x06\x12\x04\xe8'\x02\x1c\n\r\n\x05\x04u\x02\0\x01\x12\
    \x04\xe8'\x1d#\n\r\n\x05\x04u\x02\0\x03\x12\x04\xe8'&'\n\x0c\n\x04\x04u\
    \x02\x01\x12\x04\xe9'\x02\x1f\n\r\n\x05\x04u\x02\x01\x04\x12\x04\xe9'\
    \x02\n\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xe9'\x0b\x11\n\r\n\x05\x04u\
    \x02\x01\x01\x12\x04\xe9'\x12\x1a\n\r\n\x05\x04u\x02\x01\x03\x12\x04\xe9\
    '\x1d\x1e\n\x0c\n\x02\x04v\x12\x06\xec'\0\xef'\x01\n\x0b\n\x03\x04v\x01\
    \x12\x04\xec'\x08&\n\x0c\n\x04\x04v\x02\0\x12\x04\xed'\x02(\n\r\n\x05\
    \x04v\x02\0\x06\x12\x04\xed'\x02\x1c\n\r\n\x05\x04v\x02\0\x01\x12\x04\
    \xed'\x1d#\n\r\n\x05\x04v\x02\0\x03\x12\x04\xed'&'\n\x0c\n\x04\x04v\x02\
    \x01\x12\x04\xee'\x02%\n\r\n\x05\x04v\x02\x01\x04\x12\x04\xee'\x02\n\n\r\
    \n\x05\x04v\x02\x01\x05\x12\x04\xee'\x0b\x11\n\r\n\x05\x04v\x02\x01\x01\
    \x12\x04\xee'\x12\x20\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xee'#$\n\x0c\n\
    \x02\x04w\x12\x06\xf1'\0\xf4'\x01\n\x0b\n\x03\x04w\x01\x12\x04\xf1'\x08!\
    \n\x0c\n\x04\x04w\x02\0\x12\x04\xf2'\x02(\n\r\n\x05\x04w\x02\0\x06\x12\
    \x04\xf2'\x02\x1c\n\r\n\x05\x04w\x02\0\x01\x12\x04\xf2'\x1d#\n\r\n\x05\
    \x04w\x02\0\x03\x12\x04\xf2'&'\n\x0c\n\x04\x04w\x02\x01\x12\x04\xf3'\x02\
    \x1f\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xf3'\x02\n\n\r\n\x05\x04w\x02\
    \x01\x05\x12\x04\xf3'\x0b\x11\n\r\n\x05\x04w\x02\x01\x01\x12\x04\xf3'\
    \x12\x1a\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xf3'\x1d\x1e\n\x0c\n\x02\x04\
    x\x12\x06\xf6'\0\xf9'\x01\n\x0b\n\x03\x04x\x01\x12\x04\xf6'\x08\"\n\x0c\
    \n\x04\x04x\x02\0\x12\x04\xf7'\x02(\n\r\n\x05\x04x\x02\0\x06\x12\x04\xf7\
    '\x02\x1c\n\r\n\x05\x04x\x02\0\x01\x12\x04\xf7'\x1d#\n\r\n\x05\x04x\x02\
    \0\x03\x12\x04\xf7'&'\n\x0c\n\x04\x04x\x02\x01\x12\x04\xf8'\x02\x20\n\r\
    \n\x05\x04x\x02\x01\x04\x12\x04\xf8'\x02\n\n\r\n\x05\x04x\x02\x01\x05\
    \x12\x04\xf8'\x0b\x11\n\r\n\x05\x04x\x02\x01\x01\x12\x04\xf8'\x12\x1b\n\
    \r\n\x05\x04x\x02\x01\x03\x12\x04\xf8'\x1e\x1f\n!\n\x02\x04y\x12\x06\xfc\
    '\0\x86(\x01\x1a\x13\x20PostModelsRequest\n\n\x0b\n\x03\x04y\x01\x12\x04\
    \xfc'\x08\x19\n\x0c\n\x04\x04y\x02\0\x12\x04\xfd'\x02,\n\r\n\x05\x04y\
    \x02\0\x06\x12\x04\xfd'\x02\x1b\n\r\n\x05\x04y\x02\0\x01\x12\x04\xfd'\
    \x1c'\n\r\n\x05\x04y\x02\0\x03\x12\x04\xfd'*+\n\x91\x02\n\x04\x04y\x02\
    \x01\x12\x04\x83(\x02&\x1a\x82\x02\x20NOTE:\x20inconsistent\x20since\x20\
    \"model\"\x20is\x20not\x20plural,\x20please\x20use\x20\"models\"\x20belo\
    w.\n\x20Previously\x20you\x20could\x20only\x20create\x20one\x20model\x20\
    at\x20a\x20time.\n\x20We\x20still\x20support\x20this\x20but\x20you\x20sh\
    ould\x20pass\x20it\x20as\x20models=[model]\x20so\n\x20that\x20this\x20en\
    dpoint\x20is\x20consistent\x20with\x20the\x20rest\x20of\x20our\x20API.\n\
    \n\r\n\x05\x04y\x02\x01\x06\x12\x04\x83(\x02\x07\n\r\n\x05\x04y\x02\x01\
    \x01\x12\x04\x83(\x08\r\n\r\n\x05\x04y\x02\x01\x03\x12\x04\x83(\x10\x11\
    \n\r\n\x05\x04y\x02\x01\x08\x12\x04\x83(\x12%\n\x0e\n\x06\x04y\x02\x01\
    \x08\x03\x12\x04\x83(\x13$\nU\n\x04\x04y\x02\x02\x12\x04\x85(\x02\x1c\
    \x1aG\x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20m\
    odel\x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\r\n\x05\x04y\x02\
    \x02\x04\x12\x04\x85(\x02\n\n\r\n\x05\x04y\x02\x02\x06\x12\x04\x85(\x0b\
    \x10\n\r\n\x05\x04y\x02\x02\x01\x12\x04\x85(\x11\x17\n\r\n\x05\x04y\x02\
    \x02\x03\x12\x04\x85(\x1a\x1b\n\"\n\x02\x04z\x12\x06\x89(\0\x94(\x01\x1a\
    \x14\x20PatchModelsRequest\n\n\x0b\n\x03\x04z\x01\x12\x04\x89(\x08\x1a\n\
    \x0c\n\x04\x04z\x02\0\x12\x04\x8a(\x02,\n\r\n\x05\x04z\x02\0\x06\x12\x04\
    \x8a(\x02\x1b\n\r\n\x05\x04z\x02\0\x01\x12\x04\x8a(\x1c'\n\r\n\x05\x04z\
    \x02\0\x03\x12\x04\x8a(*+\n\x0c\n\x04\x04z\x02\x01\x12\x04\x8b(\x02\x1c\
    \n\r\n\x05\x04z\x02\x01\x04\x12\x04\x8b(\x02\n\n\r\n\x05\x04z\x02\x01\
    \x06\x12\x04\x8b(\x0b\x10\n\r\n\x05\x04z\x02\x01\x01\x12\x04\x8b(\x11\
    \x17\n\r\n\x05\x04z\x02\x01\x03\x12\x04\x8b(\x1a\x1b\n\xd8\x02\n\x04\x04\
    z\x02\x02\x12\x04\x93(\x02\x14\x1a\xc9\x02\x20The\x20action\x20to\x20per\
    form\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'm\
    erge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\x20Not\
    e\x20that\x20'remove'\x20can\x20be\x20used\x20to\x20remove\x20the\x20mod\
    el\x20image\x20by\x20setting\n\x20'image.url'\x20in\x20the\x20request\
    \x20to\x20the\x20current\x20value\x20returned\x20for\x20that\x20model.\n\
    \x20This\x20cannot\x20be\x20used\x20in\x20a\x20request\x20that\x20is\x20\
    patching\x20other\x20fields\x20as\x20well.\n\n\r\n\x05\x04z\x02\x02\x05\
    \x12\x04\x93(\x02\x08\n\r\n\x05\x04z\x02\x02\x01\x12\x04\x93(\t\x0f\n\r\
    \n\x05\x04z\x02\x02\x03\x12\x04\x93(\x12\x13\n\x0c\n\x02\x04{\x12\x06\
    \x96(\0\x9b(\x01\n\x0b\n\x03\x04{\x01\x12\x04\x96(\x08\x16\n\x15\n\x04\
    \x04{\x02\0\x12\x04\x98(\x02\x10\x1a\x07old\x20id\n\n\r\n\x05\x04{\x02\0\
    \x05\x12\x04\x98(\x02\x08\n\r\n\x05\x04{\x02\0\x01\x12\x04\x98(\t\x0b\n\
    \r\n\x05\x04{\x02\0\x03\x12\x04\x98(\x0e\x0f\n\x15\n\x04\x04{\x02\x01\
    \x12\x04\x9a(\x02\x14\x1a\x07new\x20id\n\n\r\n\x05\x04{\x02\x01\x05\x12\
    \x04\x9a(\x02\x08\n\r\n\x05\x04{\x02\x01\x01\x12\x04\x9a(\t\x0f\n\r\n\
    \x05\x04{\x02\x01\x03\x12\x04\x9a(\x12\x13\n$\n\x02\x04|\x12\x06\x9e(\0\
    \xa7(\x01\x1a\x16\x20PatchModelIdsRequest\n\n\x0b\n\x03\x04|\x01\x12\x04\
    \x9e(\x08\x1c\n\x0c\n\x04\x04|\x02\0\x12\x04\x9f(\x02,\n\r\n\x05\x04|\
    \x02\0\x06\x12\x04\x9f(\x02\x1b\n\r\n\x05\x04|\x02\0\x01\x12\x04\x9f(\
    \x1c'\n\r\n\x05\x04|\x02\0\x03\x12\x04\x9f(*+\n(\n\x04\x04|\x02\x01\x12\
    \x04\xa2(\x02\"\x1a\x1a\x20Array\x20containing\x201\x20entry\n\n\r\n\x05\
    \x04|\x02\x01\x04\x12\x04\xa2(\x02\n\n\r\n\x05\x04|\x02\x01\x06\x12\x04\
    \xa2(\x0b\x19\n\r\n\x05\x04|\x02\x01\x01\x12\x04\xa2(\x1a\x1d\n\r\n\x05\
    \x04|\x02\x01\x03\x12\x04\xa2(\x20!\n[\n\x04\x04|\x02\x02\x12\x04\xa6(\
    \x02\x14\x1aM\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\
    \x20objects\n\x20Only\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04|\
    \x02\x02\x05\x12\x04\xa6(\x02\x08\n\r\n\x05\x04|\x02\x02\x01\x12\x04\xa6\
    (\t\x0f\n\r\n\x05\x04|\x02\x02\x03\x12\x04\xa6(\x12\x13\n\"\n\x02\x04}\
    \x12\x06\xaa(\0\xad(\x01\x1a\x14\x20DeleteModelRequest\n\n\x0b\n\x03\x04\
    }\x01\x12\x04\xaa(\x08\x1a\n\x0c\n\x04\x04}\x02\0\x12\x04\xab(\x02,\n\r\
    \n\x05\x04}\x02\0\x06\x12\x04\xab(\x02\x1b\n\r\n\x05\x04}\x02\0\x01\x12\
    \x04\xab(\x1c'\n\r\n\x05\x04}\x02\0\x03\x12\x04\xab(*+\n\x0c\n\x04\x04}\
    \x02\x01\x12\x04\xac(\x02\x16\n\r\n\x05\x04}\x02\x01\x05\x12\x04\xac(\
    \x02\x08\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xac(\t\x11\n\r\n\x05\x04}\
    \x02\x01\x03\x12\x04\xac(\x14\x15\nD\n\x02\x04~\x12\x06\xb0(\0\xb4(\x01\
    \x1a6\x20Request\x20to\x20delete\x20several\x20things\x20by\x20the\x20li\
    st\x20of\x20ids.\n\n\x0b\n\x03\x04~\x01\x12\x04\xb0(\x08\x1b\n\x0c\n\x04\
    \x04~\x02\0\x12\x04\xb1(\x02,\n\r\n\x05\x04~\x02\0\x06\x12\x04\xb1(\x02\
    \x1b\n\r\n\x05\x04~\x02\0\x01\x12\x04\xb1(\x1c'\n\r\n\x05\x04~\x02\0\x03\
    \x12\x04\xb1(*+\n\x0c\n\x04\x04~\x02\x01\x12\x04\xb2(\x02\x1a\n\r\n\x05\
    \x04~\x02\x01\x04\x12\x04\xb2(\x02\n\n\r\n\x05\x04~\x02\x01\x05\x12\x04\
    \xb2(\x0b\x11\n\r\n\x05\x04~\x02\x01\x01\x12\x04\xb2(\x12\x15\n\r\n\x05\
    \x04~\x02\x01\x03\x12\x04\xb2(\x18\x19\n\x0c\n\x04\x04~\x02\x02\x12\x04\
    \xb3(\x02\x16\n\r\n\x05\x04~\x02\x02\x05\x12\x04\xb3(\x02\x06\n\r\n\x05\
    \x04~\x02\x02\x01\x12\x04\xb3(\x07\x11\n\r\n\x05\x04~\x02\x02\x03\x12\
    \x04\xb3(\x14\x15\n1\n\x02\x04\x7f\x12\x06\xb7(\0\xbf(\x01\x1a#\x20Searc\
    h\x20over\x20the\x20available\x20models.\n\n\x0b\n\x03\x04\x7f\x01\x12\
    \x04\xb7(\x08!\n6\n\x04\x04\x7f\x02\0\x12\x04\xb9(\x02,\x1a(\x20Ids\x20p\
    resent\x20in\x20the\x20url\x20of\x20the\x20request.\n\n\r\n\x05\x04\x7f\
    \x02\0\x06\x12\x04\xb9(\x02\x1b\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xb9(\
    \x1c'\n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\xb9(*+\n(\n\x04\x04\x7f\x02\
    \x01\x12\x04\xbb(\x02\x1d\x1a\x1a\x20The\x20body\x20of\x20the\x20request\
    .\n\n\r\n\x05\x04\x7f\x02\x01\x06\x12\x04\xbb(\x02\x0c\n\r\n\x05\x04\x7f\
    \x02\x01\x01\x12\x04\xbb(\r\x18\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\
    \xbb(\x1b\x1c\n]\n\x04\x04\x7f\x02\x02\x12\x04\xbe(\x02\x1c\x1aO\x20Pagi\
    nation\x20parameters\x20here\x20since\x20there\x20are\x20no\x20url\x20ar\
    gs\x20in\x20this\n\x20POST\x20request.\n\n\r\n\x05\x04\x7f\x02\x02\x06\
    \x12\x04\xbe(\x02\x0c\n\r\n\x05\x04\x7f\x02\x02\x01\x12\x04\xbe(\r\x17\n\
    \r\n\x05\x04\x7f\x02\x02\x03\x12\x04\xbe(\x1a\x1b\n$\n\x03\x04\x80\x01\
    \x12\x06\xc2(\0\xc5(\x01\x1a\x15\x20SingleModelResponse\n\n\x0c\n\x04\
    \x04\x80\x01\x01\x12\x04\xc2(\x08\x1b\n\r\n\x05\x04\x80\x01\x02\0\x12\
    \x04\xc3(\x02(\n\x0e\n\x06\x04\x80\x01\x02\0\x06\x12\x04\xc3(\x02\x1c\n\
    \x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xc3(\x1d#\n\x0e\n\x06\x04\x80\
    \x01\x02\0\x03\x12\x04\xc3(&'\n\r\n\x05\x04\x80\x01\x02\x01\x12\x04\xc4(\
    \x02\x12\n\x0e\n\x06\x04\x80\x01\x02\x01\x06\x12\x04\xc4(\x02\x07\n\x0e\
    \n\x06\x04\x80\x01\x02\x01\x01\x12\x04\xc4(\x08\r\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x03\x12\x04\xc4(\x10\x11\n#\n\x03\x04\x81\x01\x12\x06\xc8(\
    \0\xcb(\x01\x1a\x14\x20MultiModelResponse\n\n\x0c\n\x04\x04\x81\x01\x01\
    \x12\x04\xc8(\x08\x1a\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xc9(\x02(\n\
    \x0e\n\x06\x04\x81\x01\x02\0\x06\x12\x04\xc9(\x02\x1c\n\x0e\n\x06\x04\
    \x81\x01\x02\0\x01\x12\x04\xc9(\x1d#\n\x0e\n\x06\x04\x81\x01\x02\0\x03\
    \x12\x04\xc9(&'\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\xca(\x02K\n\x0e\n\
    \x06\x04\x81\x01\x02\x01\x04\x12\x04\xca(\x02\n\n\x0e\n\x06\x04\x81\x01\
    \x02\x01\x06\x12\x04\xca(\x0b\x10\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\
    \x12\x04\xca(\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\x01\x03\x12\x04\xca(\
    \x1a\x1b\n\x0e\n\x06\x04\x81\x01\x02\x01\x08\x12\x04\xca(\x1cJ\n\x11\n\t\
    \x04\x81\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xca(\x1dI\n*\n\x03\x04\x82\
    \x01\x12\x06\xce(\0\xd5(\x01\x1a\x1b\x20PatchModelVersionsRequest\n\n\
    \x0c\n\x04\x04\x82\x01\x01\x12\x04\xce(\x08!\n\r\n\x05\x04\x82\x01\x02\0\
    \x12\x04\xcf(\x02,\n\x0e\n\x06\x04\x82\x01\x02\0\x06\x12\x04\xcf(\x02\
    \x1b\n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\xcf(\x1c'\n\x0e\n\x06\x04\
    \x82\x01\x02\0\x03\x12\x04\xcf(*+\n\r\n\x05\x04\x82\x01\x02\x01\x12\x04\
    \xd0(\x02\x16\n\x0e\n\x06\x04\x82\x01\x02\x01\x05\x12\x04\xd0(\x02\x08\n\
    \x0e\n\x06\x04\x82\x01\x02\x01\x01\x12\x04\xd0(\t\x11\n\x0e\n\x06\x04\
    \x82\x01\x02\x01\x03\x12\x04\xd0(\x14\x15\n\r\n\x05\x04\x82\x01\x02\x02\
    \x12\x04\xd1(\x02+\n\x0e\n\x06\x04\x82\x01\x02\x02\x04\x12\x04\xd1(\x02\
    \n\n\x0e\n\x06\x04\x82\x01\x02\x02\x06\x12\x04\xd1(\x0b\x17\n\x0e\n\x06\
    \x04\x82\x01\x02\x02\x01\x12\x04\xd1(\x18&\n\x0e\n\x06\x04\x82\x01\x02\
    \x02\x03\x12\x04\xd1()*\n\x7f\n\x05\x04\x82\x01\x02\x03\x12\x04\xd4(\x02\
    \x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20o\
    bjects\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20\
    'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\x82\x01\x02\x03\x05\x12\
    \x04\xd4(\x02\x08\n\x0e\n\x06\x04\x82\x01\x02\x03\x01\x12\x04\xd4(\t\x0f\
    \n\x0e\n\x06\x04\x82\x01\x02\x03\x03\x12\x04\xd4(\x12\x13\n;\n\x03\x04\
    \x83\x01\x12\x06\xd8(\0\xdc(\x01\x1a,\x20request\x20for\x20different\x20\
    endpoints\x20currently.\n\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\xd8(\x08\
    \x1e\n\r\n\x05\x04\x83\x01\x02\0\x12\x04\xd9(\x02,\n\x0e\n\x06\x04\x83\
    \x01\x02\0\x06\x12\x04\xd9(\x02\x1b\n\x0e\n\x06\x04\x83\x01\x02\0\x01\
    \x12\x04\xd9(\x1c'\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xd9(*+\n\r\
    \n\x05\x04\x83\x01\x02\x01\x12\x04\xda(\x02\x16\n\x0e\n\x06\x04\x83\x01\
    \x02\x01\x05\x12\x04\xda(\x02\x08\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\
    \x12\x04\xda(\t\x11\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xda(\x14\
    \x15\n\r\n\x05\x04\x83\x01\x02\x02\x12\x04\xdb(\x02\x18\n\x0e\n\x06\x04\
    \x83\x01\x02\x02\x05\x12\x04\xdb(\x02\x08\n\x0e\n\x06\x04\x83\x01\x02\
    \x02\x01\x12\x04\xdb(\t\x13\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\x12\x04\
    \xdb(\x16\x17\n)\n\x03\x04\x84\x01\x12\x06\xdf(\0\xfd(\x01\x1a\x1a\x20Li\
    stModelVersionsRequest\n\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\xdf(\x08\
    \x20\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\xe0(\x02,\n\x0e\n\x06\x04\x84\
    \x01\x02\0\x06\x12\x04\xe0(\x02\x1b\n\x0e\n\x06\x04\x84\x01\x02\0\x01\
    \x12\x04\xe0(\x1c'\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\xe0(*+\n\r\
    \n\x05\x04\x84\x01\x02\x01\x12\x04\xe1(\x02\x16\n\x0e\n\x06\x04\x84\x01\
    \x02\x01\x05\x12\x04\xe1(\x02\x08\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\
    \x12\x04\xe1(\t\x11\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\xe1(\x14\
    \x15\n\x7f\n\x05\x04\x84\x01\x02\x02\x12\x04\xe4(\x02\x12\x1ap\x20(optio\
    nal\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\x0e\n\x06\x04\x84\x01\x02\x02\x05\x12\x04\xe4(\x02\
    \x08\n\x0e\n\x06\x04\x84\x01\x02\x02\x01\x12\x04\xe4(\t\r\n\x0e\n\x06\
    \x04\x84\x01\x02\x02\x03\x12\x04\xe4(\x10\x11\nv\n\x05\x04\x84\x01\x02\
    \x03\x12\x04\xe7(\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x84\x01\x02\
    \x03\x05\x12\x04\xe7(\x02\x08\n\x0e\n\x06\x04\x84\x01\x02\x03\x01\x12\
    \x04\xe7(\t\x11\n\x0e\n\x06\x04\x84\x01\x02\x03\x03\x12\x04\xe7(\x14\x15\
    \nq\n\x05\x04\x84\x01\x02\x04\x12\x04\xeb(\x02\"\x1ab\x20Filtering\x20op\
    tions:\n\x20To\x20list\x20only\x20the\x20model\x20versions\x20that\x20ha\
    ve\x20these\x20concept\x20ids\x20present\x20in\x20them.\n\n\x0e\n\x06\
    \x04\x84\x01\x02\x04\x04\x12\x04\xeb(\x02\n\n\x0e\n\x06\x04\x84\x01\x02\
    \x04\x05\x12\x04\xeb(\x0b\x11\n\x0e\n\x06\x04\x84\x01\x02\x04\x01\x12\
    \x04\xeb(\x12\x1d\n\x0e\n\x06\x04\x84\x01\x02\x04\x03\x12\x04\xeb(\x20!\
    \nH\n\x05\x04\x84\x01\x02\x05\x12\x04\xed(\x02\x18\x1a9\x20To\x20list\
    \x20only\x20the\x20model\x20versions\x20that\x20have\x20been\x20trained.\
    \n\n\x0e\n\x06\x04\x84\x01\x02\x05\x05\x12\x04\xed(\x02\x06\n\x0e\n\x06\
    \x04\x84\x01\x02\x05\x01\x12\x04\xed(\x07\x13\n\x0e\n\x06\x04\x84\x01\
    \x02\x05\x03\x12\x04\xed(\x16\x17\np\n\x05\x04\x84\x01\x02\x06\x12\x04\
    \xf1(\x02\x1a\x1aa\x20Sorting\x20options:\n\x20Whether\x20to\x20sort\x20\
    in\x20ascending\x20order.\x20If\x20false,\x20will\x20order\x20in\x20desc\
    ending\x20order.\n\n\x0e\n\x06\x04\x84\x01\x02\x06\x05\x12\x04\xf1(\x02\
    \x06\n\x0e\n\x06\x04\x84\x01\x02\x06\x01\x12\x04\xf1(\x07\x15\n\x0e\n\
    \x06\x04\x84\x01\x02\x06\x03\x12\x04\xf1(\x18\x19\n\x0f\n\x05\x04\x84\
    \x01\x08\0\x12\x06\xf2(\x02\xfc(\x03\n\x0e\n\x06\x04\x84\x01\x08\0\x01\
    \x12\x04\xf2(\x08\x0f\n4\n\x05\x04\x84\x01\x02\x07\x12\x04\xf4(\x04!\x1a\
    %\x20Whether\x20to\x20order\x20by\x20the\x20status\x20code\n\n\x0e\n\x06\
    \x04\x84\x01\x02\x07\x05\x12\x04\xf4(\x04\x08\n\x0e\n\x06\x04\x84\x01\
    \x02\x07\x01\x12\x04\xf4(\t\x1c\n\x0e\n\x06\x04\x84\x01\x02\x07\x03\x12\
    \x04\xf4(\x1f\x20\nB\n\x05\x04\x84\x01\x02\x08\x12\x04\xf6(\x04\x20\x1a3\
    \x20Whether\x20to\x20order\x20by\x20the\x20number\x20of\x20training\x20i\
    nputs\n\n\x0e\n\x06\x04\x84\x01\x02\x08\x05\x12\x04\xf6(\x04\x08\n\x0e\n\
    \x06\x04\x84\x01\x02\x08\x01\x12\x04\xf6(\t\x1b\n\x0e\n\x06\x04\x84\x01\
    \x02\x08\x03\x12\x04\xf6(\x1e\x1f\n3\n\x05\x04\x84\x01\x02\t\x12\x04\xf8\
    (\x04\"\x1a$\x20Whether\x20to\x20sort\x20by\x20the\x20description\n\n\
    \x0e\n\x06\x04\x84\x01\x02\t\x05\x12\x04\xf8(\x04\x08\n\x0e\n\x06\x04\
    \x84\x01\x02\t\x01\x12\x04\xf8(\t\x1c\n\x0e\n\x06\x04\x84\x01\x02\t\x03\
    \x12\x04\xf8(\x1f!\ny\n\x05\x04\x84\x01\x02\n\x12\x04\xfb(\x04!\x1aj\x20\
    Whether\x20to\x20order\x20by\x20the\x20created_at\x20time\n\x20If\x20nei\
    ther\x20sort\x20option\x20is\x20set\x20to\x20true,\x20will\x20sort\x20by\
    \x20created_at.\n\n\x0e\n\x06\x04\x84\x01\x02\n\x05\x12\x04\xfb(\x04\x08\
    \n\x0e\n\x06\x04\x84\x01\x02\n\x01\x12\x04\xfb(\t\x1b\n\x0e\n\x06\x04\
    \x84\x01\x02\n\x03\x12\x04\xfb(\x1e\x20\n*\n\x03\x04\x85\x01\x12\x06\x80\
    )\0\x84)\x01\x1a\x1b\x20DeleteModelVersionRequest\n\n\x0c\n\x04\x04\x85\
    \x01\x01\x12\x04\x80)\x08!\n\r\n\x05\x04\x85\x01\x02\0\x12\x04\x81)\x02,\
    \n\x0e\n\x06\x04\x85\x01\x02\0\x06\x12\x04\x81)\x02\x1b\n\x0e\n\x06\x04\
    \x85\x01\x02\0\x01\x12\x04\x81)\x1c'\n\x0e\n\x06\x04\x85\x01\x02\0\x03\
    \x12\x04\x81)*+\n\r\n\x05\x04\x85\x01\x02\x01\x12\x04\x82)\x02\x16\n\x0e\
    \n\x06\x04\x85\x01\x02\x01\x05\x12\x04\x82)\x02\x08\n\x0e\n\x06\x04\x85\
    \x01\x02\x01\x01\x12\x04\x82)\t\x11\n\x0e\n\x06\x04\x85\x01\x02\x01\x03\
    \x12\x04\x82)\x14\x15\n\r\n\x05\x04\x85\x01\x02\x02\x12\x04\x83)\x02\x18\
    \n\x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\x83)\x02\x08\n\x0e\n\x06\
    \x04\x85\x01\x02\x02\x01\x12\x04\x83)\t\x13\n\x0e\n\x06\x04\x85\x01\x02\
    \x02\x03\x12\x04\x83)\x16\x17\n+\n\x03\x04\x86\x01\x12\x06\x87)\0\x8a)\
    \x01\x1a\x1c\x20SingleModelVersionResponse\n\n\x0c\n\x04\x04\x86\x01\x01\
    \x12\x04\x87)\x08\"\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\x88)\x02(\n\x0e\
    \n\x06\x04\x86\x01\x02\0\x06\x12\x04\x88)\x02\x1c\n\x0e\n\x06\x04\x86\
    \x01\x02\0\x01\x12\x04\x88)\x1d#\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\
    \x04\x88)&'\n\r\n\x05\x04\x86\x01\x02\x01\x12\x04\x89)\x02!\n\x0e\n\x06\
    \x04\x86\x01\x02\x01\x06\x12\x04\x89)\x02\x0e\n\x0e\n\x06\x04\x86\x01\
    \x02\x01\x01\x12\x04\x89)\x0f\x1c\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\
    \x12\x04\x89)\x1f\x20\n*\n\x03\x04\x87\x01\x12\x06\x8d)\0\x90)\x01\x1a\
    \x1b\x20MultiModelVersionResponse\n\n\x0c\n\x04\x04\x87\x01\x01\x12\x04\
    \x8d)\x08!\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\x8e)\x02(\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x06\x12\x04\x8e)\x02\x1c\n\x0e\n\x06\x04\x87\x01\x02\0\
    \x01\x12\x04\x8e)\x1d#\n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\x8e)&'\
    \n\r\n\x05\x04\x87\x01\x02\x01\x12\x04\x8f)\x02Z\n\x0e\n\x06\x04\x87\x01\
    \x02\x01\x04\x12\x04\x8f)\x02\n\n\x0e\n\x06\x04\x87\x01\x02\x01\x06\x12\
    \x04\x8f)\x0b\x17\n\x0e\n\x06\x04\x87\x01\x02\x01\x01\x12\x04\x8f)\x18&\
    \n\x0e\n\x06\x04\x87\x01\x02\x01\x03\x12\x04\x8f))*\n\x0e\n\x06\x04\x87\
    \x01\x02\x01\x08\x12\x04\x8f)+Y\n\x11\n\t\x04\x87\x01\x02\x01\x08\xd0\
    \x86\x03\x12\x04\x8f),X\n4\n\x03\x04\x88\x01\x12\x06\x93)\0\xa0)\x01\x1a\
    %\x20Create\x20(train)\x20a\x20new\x20model\x20version.\n\n\x0c\n\x04\
    \x04\x88\x01\x01\x12\x04\x93)\x08\x20\n\x0c\n\x04\x04\x88\x01\t\x12\x04\
    \x94)\x02\x19\n\r\n\x05\x04\x88\x01\t\0\x12\x04\x94)\x0b\x0c\n\x0e\n\x06\
    \x04\x88\x01\t\0\x01\x12\x04\x94)\x0b\x0c\n\x0e\n\x06\x04\x88\x01\t\0\
    \x02\x12\x04\x94)\x0b\x0c\n\r\n\x05\x04\x88\x01\t\x01\x12\x04\x94)\x0e\
    \x0f\n\x0e\n\x06\x04\x88\x01\t\x01\x01\x12\x04\x94)\x0e\x0f\n\x0e\n\x06\
    \x04\x88\x01\t\x01\x02\x12\x04\x94)\x0e\x0f\n\r\n\x05\x04\x88\x01\t\x02\
    \x12\x04\x94)\x11\x12\n\x0e\n\x06\x04\x88\x01\t\x02\x01\x12\x04\x94)\x11\
    \x12\n\x0e\n\x06\x04\x88\x01\t\x02\x02\x12\x04\x94)\x11\x12\n\r\n\x05\
    \x04\x88\x01\t\x03\x12\x04\x94)\x14\x15\n\x0e\n\x06\x04\x88\x01\t\x03\
    \x01\x12\x04\x94)\x14\x15\n\x0e\n\x06\x04\x88\x01\t\x03\x02\x12\x04\x94)\
    \x14\x15\n\r\n\x05\x04\x88\x01\t\x04\x12\x04\x94)\x17\x18\n\x0e\n\x06\
    \x04\x88\x01\t\x04\x01\x12\x04\x94)\x17\x18\n\x0e\n\x06\x04\x88\x01\t\
    \x04\x02\x12\x04\x94)\x17\x18\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\x95)\
    \x02,\n\x0e\n\x06\x04\x88\x01\x02\0\x06\x12\x04\x95)\x02\x1b\n\x0e\n\x06\
    \x04\x88\x01\x02\0\x01\x12\x04\x95)\x1c'\n\x0e\n\x06\x04\x88\x01\x02\0\
    \x03\x12\x04\x95)*+\n\r\n\x05\x04\x88\x01\x02\x01\x12\x04\x96)\x02\x16\n\
    \x0e\n\x06\x04\x88\x01\x02\x01\x05\x12\x04\x96)\x02\x08\n\x0e\n\x06\x04\
    \x88\x01\x02\x01\x01\x12\x04\x96)\t\x11\n\x0e\n\x06\x04\x88\x01\x02\x01\
    \x03\x12\x04\x96)\x14\x15\n\r\n\x05\x04\x88\x01\x02\x02\x12\x04\x98)\x02\
    +\n\x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\x98)\x02\n\n\x0e\n\x06\x04\
    \x88\x01\x02\x02\x06\x12\x04\x98)\x0b\x17\n\x0e\n\x06\x04\x88\x01\x02\
    \x02\x01\x12\x04\x98)\x18&\n\x0e\n\x06\x04\x88\x01\x02\x02\x03\x12\x04\
    \x98))*\n4\n\x05\x04\x88\x01\x02\x03\x12\x04\x9b)\x02\x19\x1a%\x20Descri\
    ption\x20about\x20this\x20training\x20run\n\n\x0e\n\x06\x04\x88\x01\x02\
    \x03\x05\x12\x04\x9b)\x02\x08\n\x0e\n\x06\x04\x88\x01\x02\x03\x01\x12\
    \x04\x9b)\t\x14\n\x0e\n\x06\x04\x88\x01\x02\x03\x03\x12\x04\x9b)\x17\x18\
    \n\xa2\x01\n\x05\x04\x88\x01\x02\x04\x12\x04\x9f)\x02\x1a\x1a\x92\x01\
    \x20When\x20evaluate_after_training\x20set\x20to\x20true,\x20we\x20will\
    \x20do\x20evaluation\x20immediately\x20after\x20training\x20finishes.\n\
    \x20We\x20will\x20merge\x20this\x20with\x20default_eval_info.\n\n\x0e\n\
    \x06\x04\x88\x01\x02\x04\x06\x12\x04\x9f)\x02\n\n\x0e\n\x06\x04\x88\x01\
    \x02\x04\x01\x12\x04\x9f)\x0b\x14\n\x0e\n\x06\x04\x88\x01\x02\x04\x03\
    \x12\x04\x9f)\x17\x19\n\r\n\x03\x04\x89\x01\x12\x06\xa2)\0\xa6)\x01\n\
    \x0c\n\x04\x04\x89\x01\x01\x12\x04\xa2)\x08,\n\r\n\x05\x04\x89\x01\x02\0\
    \x12\x04\xa3)\x02,\n\x0e\n\x06\x04\x89\x01\x02\0\x06\x12\x04\xa3)\x02\
    \x1b\n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\xa3)\x1c'\n\x0e\n\x06\x04\
    \x89\x01\x02\0\x03\x12\x04\xa3)*+\n\r\n\x05\x04\x89\x01\x02\x01\x12\x04\
    \xa4)\x02\x19\n\x0e\n\x06\x04\x89\x01\x02\x01\x05\x12\x04\xa4)\x02\x08\n\
    \x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\xa4)\t\x14\n\x0e\n\x06\x04\
    \x89\x01\x02\x01\x03\x12\x04\xa4)\x17\x18\n\r\n\x05\x04\x89\x01\x02\x02\
    \x12\x04\xa5)\x02<\n\x0e\n\x06\x04\x89\x01\x02\x02\x04\x12\x04\xa5)\x02\
    \n\n\x0e\n\x06\x04\x89\x01\x02\x02\x06\x12\x04\xa5)\x0b*\n\x0e\n\x06\x04\
    \x89\x01\x02\x02\x01\x12\x04\xa5)+7\n\x0e\n\x06\x04\x89\x01\x02\x02\x03\
    \x12\x04\xa5):;\n\r\n\x03\x04\x8a\x01\x12\x06\xaa)\0\xae)\x01\n\x0c\n\
    \x04\x04\x8a\x01\x01\x12\x04\xaa)\x08*\n\r\n\x05\x04\x8a\x01\x02\0\x12\
    \x04\xab)\x02,\n\x0e\n\x06\x04\x8a\x01\x02\0\x06\x12\x04\xab)\x02\x1b\n\
    \x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\xab)\x1c'\n\x0e\n\x06\x04\x8a\
    \x01\x02\0\x03\x12\x04\xab)*+\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xac)\
    \x02\x19\n\x0e\n\x06\x04\x8a\x01\x02\x01\x05\x12\x04\xac)\x02\x08\n\x0e\
    \n\x06\x04\x8a\x01\x02\x01\x01\x12\x04\xac)\t\x14\n\x0e\n\x06\x04\x8a\
    \x01\x02\x01\x03\x12\x04\xac)\x17\x18\n\r\n\x05\x04\x8a\x01\x02\x02\x12\
    \x04\xad)\x02:\n\x0e\n\x06\x04\x8a\x01\x02\x02\x04\x12\x04\xad)\x02\n\n\
    \x0e\n\x06\x04\x8a\x01\x02\x02\x06\x12\x04\xad)\x0b(\n\x0e\n\x06\x04\x8a\
    \x01\x02\x02\x01\x12\x04\xad))5\n\x0e\n\x06\x04\x8a\x01\x02\x02\x03\x12\
    \x04\xad)89\n\r\n\x03\x04\x8b\x01\x12\x06\xb0)\0\xb2)\x01\n\x0c\n\x04\
    \x04\x8b\x01\x01\x12\x04\xb0)\x08%\n\r\n\x05\x04\x8b\x01\x02\0\x12\x04\
    \xb1)\x02\x18\n\x0e\n\x06\x04\x8b\x01\x02\0\x05\x12\x04\xb1)\x02\x08\n\
    \x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\xb1)\t\x13\n\x0e\n\x06\x04\x8b\
    \x01\x02\0\x03\x12\x04\xb1)\x16\x17\n\r\n\x03\x04\x8c\x01\x12\x06\xb4)\0\
    \xb6)\x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xb4)\x08'\n\r\n\x05\x04\
    \x8c\x01\x02\0\x12\x04\xb5)\x02\x18\n\x0e\n\x06\x04\x8c\x01\x02\0\x05\
    \x12\x04\xb5)\x02\x08\n\x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\x04\xb5)\t\
    \x13\n\x0e\n\x06\x04\x8c\x01\x02\0\x03\x12\x04\xb5)\x16\x17\n+\n\x03\x04\
    \x8d\x01\x12\x06\xb9)\0\xbb)\x01\x1a\x1c\x20ModelVersionPublishRequest\n\
    \n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xb9)\x08\"\n\r\n\x05\x04\x8d\x01\
    \x02\0\x12\x04\xba)\x02\x18\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\
    \xba)\x02\x08\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xba)\t\x13\n\x0e\
    \n\x06\x04\x8d\x01\x02\0\x03\x12\x04\xba)\x16\x17\n0\n\x03\x04\x8e\x01\
    \x12\x06\xbe)\0\xc2)\x01\x1a!\x20PostModelVersionsPublishRequest\n\n\x0c\
    \n\x04\x04\x8e\x01\x01\x12\x04\xbe)\x08'\n\r\n\x05\x04\x8e\x01\x02\0\x12\
    \x04\xbf)\x02,\n\x0e\n\x06\x04\x8e\x01\x02\0\x06\x12\x04\xbf)\x02\x1b\n\
    \x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\xbf)\x1c'\n\x0e\n\x06\x04\x8e\
    \x01\x02\0\x03\x12\x04\xbf)*+\n\r\n\x05\x04\x8e\x01\x02\x01\x12\x04\xc0)\
    \x02\x16\n\x0e\n\x06\x04\x8e\x01\x02\x01\x05\x12\x04\xc0)\x02\x08\n\x0e\
    \n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\xc0)\t\x11\n\x0e\n\x06\x04\x8e\
    \x01\x02\x01\x03\x12\x04\xc0)\x14\x15\n\r\n\x05\x04\x8e\x01\x02\x02\x12\
    \x04\xc1)\x027\n\x0e\n\x06\x04\x8e\x01\x02\x02\x04\x12\x04\xc1)\x02\n\n\
    \x0e\n\x06\x04\x8e\x01\x02\x02\x06\x12\x04\xc1)\x0b%\n\x0e\n\x06\x04\x8e\
    \x01\x02\x02\x01\x12\x04\xc1)&2\n\x0e\n\x06\x04\x8e\x01\x02\x02\x03\x12\
    \x04\xc1)56\n-\n\x03\x04\x8f\x01\x12\x06\xc5)\0\xc7)\x01\x1a\x1e\x20Mode\
    lVersionUnpublishRequest\n\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xc5)\x08$\
    \n\r\n\x05\x04\x8f\x01\x02\0\x12\x04\xc6)\x02\x18\n\x0e\n\x06\x04\x8f\
    \x01\x02\0\x05\x12\x04\xc6)\x02\x08\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\
    \x12\x04\xc6)\t\x13\n\x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xc6)\x16\
    \x17\n2\n\x03\x04\x90\x01\x12\x06\xca)\0\xce)\x01\x1a#\x20PostModelVersi\
    onsUnPublishRequest\n\n\x0c\n\x04\x04\x90\x01\x01\x12\x04\xca)\x08)\n\r\
    \n\x05\x04\x90\x01\x02\0\x12\x04\xcb)\x02,\n\x0e\n\x06\x04\x90\x01\x02\0\
    \x06\x12\x04\xcb)\x02\x1b\n\x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\xcb)\
    \x1c'\n\x0e\n\x06\x04\x90\x01\x02\0\x03\x12\x04\xcb)*+\n\r\n\x05\x04\x90\
    \x01\x02\x01\x12\x04\xcc)\x02\x16\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\
    \x12\x04\xcc)\x02\x08\n\x0e\n\x06\x04\x90\x01\x02\x01\x01\x12\x04\xcc)\t\
    \x11\n\x0e\n\x06\x04\x90\x01\x02\x01\x03\x12\x04\xcc)\x14\x15\n\r\n\x05\
    \x04\x90\x01\x02\x02\x12\x04\xcd)\x029\n\x0e\n\x06\x04\x90\x01\x02\x02\
    \x04\x12\x04\xcd)\x02\n\n\x0e\n\x06\x04\x90\x01\x02\x02\x06\x12\x04\xcd)\
    \x0b'\n\x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\xcd)(4\n\x0e\n\x06\x04\
    \x90\x01\x02\x02\x03\x12\x04\xcd)78\n+\n\x03\x04\x91\x01\x12\x06\xd1)\0\
    \xd6)\x01\x1a\x1c\x20Evaluate\x20this\x20model\x20vesion\n\n\x0c\n\x04\
    \x04\x91\x01\x01\x12\x04\xd1)\x08\x1e\n\r\n\x05\x04\x91\x01\x02\0\x12\
    \x04\xd2)\x02,\n\x0e\n\x06\x04\x91\x01\x02\0\x06\x12\x04\xd2)\x02\x1b\n\
    \x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xd2)\x1c'\n\x0e\n\x06\x04\x91\
    \x01\x02\0\x03\x12\x04\xd2)*+\n\xd0\x01\n\x05\x04\x91\x01\x02\x01\x12\
    \x04\xd5)\x02(\x1a\xc0\x01\x20eval_info,\x20id,\x20model,\x20and\x20grou\
    nd_truth_dataset\x20will\x20be\x20used\x20when\x20creating\x20the\x20eva\
    luation\n\x20If\x20no\x20dataset\x20is\x20provided,\x20all\x20app\x20dat\
    a\x20that\x20is\x20annotated\x20with\x20concepts\x20from\x20the\x20model\
    \x20will\x20be\x20used.\n\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\x04\
    \xd5)\x02\n\n\x0e\n\x06\x04\x91\x01\x02\x01\x06\x12\x04\xd5)\x0b\x16\n\
    \x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\xd5)\x17#\n\x0e\n\x06\x04\x91\
    \x01\x02\x01\x03\x12\x04\xd5)&'\n\r\n\x03\x04\x92\x01\x12\x06\xd8)\0\xff\
    )\x01\n\x0c\n\x04\x04\x92\x01\x01\x12\x04\xd8)\x08\x1e\n\r\n\x05\x04\x92\
    \x01\x02\0\x12\x04\xd9)\x02,\n\x0e\n\x06\x04\x92\x01\x02\0\x06\x12\x04\
    \xd9)\x02\x1b\n\x0e\n\x06\x04\x92\x01\x02\0\x01\x12\x04\xd9)\x1c'\n\x0e\
    \n\x06\x04\x92\x01\x02\0\x03\x12\x04\xd9)*+\n\x7f\n\x05\x04\x92\x01\x02\
    \x01\x12\x04\xdc)\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\x92\x01\x02\x01\x05\x12\x04\xdc)\x02\x08\n\x0e\n\x06\x04\x92\x01\
    \x02\x01\x01\x12\x04\xdc)\t\r\n\x0e\n\x06\x04\x92\x01\x02\x01\x03\x12\
    \x04\xdc)\x10\x11\nv\n\x05\x04\x92\x01\x02\x02\x12\x04\xdf)\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\x92\x01\x02\x02\x05\x12\x04\xdf)\x02\x08\n\
    \x0e\n\x06\x04\x92\x01\x02\x02\x01\x12\x04\xdf)\t\x11\n\x0e\n\x06\x04\
    \x92\x01\x02\x02\x03\x12\x04\xdf)\x14\x15\nV\n\x05\x04\x92\x01\x02\x03\
    \x12\x04\xe1)\x02\x1a\x1aG\x20If\x20true,\x20sort\x20in\x20ascending\x20\
    order,\x20otherwise\x20sort\x20in\x20descending\x20order.\n\n\x0e\n\x06\
    \x04\x92\x01\x02\x03\x05\x12\x04\xe1)\x02\x06\n\x0e\n\x06\x04\x92\x01\
    \x02\x03\x01\x12\x04\xe1)\x07\x15\n\x0e\n\x06\x04\x92\x01\x02\x03\x03\
    \x12\x04\xe1)\x18\x19\n\x0f\n\x05\x04\x92\x01\x08\0\x12\x06\xe2)\x02\xf4\
    )\x03\n\x0e\n\x06\x04\x92\x01\x08\0\x01\x12\x04\xe2)\x08\x0f\n3\n\x05\
    \x04\x92\x01\x02\x04\x12\x04\xe4)\x04\x1c\x1a$\x20Whether\x20to\x20order\
    \x20by\x20application\x20id\n\n\x0e\n\x06\x04\x92\x01\x02\x04\x05\x12\
    \x04\xe4)\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\x04\x01\x12\x04\xe4)\t\x17\
    \n\x0e\n\x06\x04\x92\x01\x02\x04\x03\x12\x04\xe4)\x1a\x1b\nJ\n\x05\x04\
    \x92\x01\x02\x05\x12\x04\xe6)\x04\x1d\x1a;\x20Whether\x20to\x20order\x20\
    by\x20eval\x20metric\x20summary.macro_avg_roc_auc\n\n\x0e\n\x06\x04\x92\
    \x01\x02\x05\x05\x12\x04\xe6)\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\x05\
    \x01\x12\x04\xe6)\t\x18\n\x0e\n\x06\x04\x92\x01\x02\x05\x03\x12\x04\xe6)\
    \x1b\x1c\n;\n\x05\x04\x92\x01\x02\x06\x12\x04\xe8)\x04\x18\x1a,\x20Wheth\
    er\x20to\x20order\x20by\x20eval\x20metric\x20summary.f1\n\n\x0e\n\x06\
    \x04\x92\x01\x02\x06\x05\x12\x04\xe8)\x04\x08\n\x0e\n\x06\x04\x92\x01\
    \x02\x06\x01\x12\x04\xe8)\t\x13\n\x0e\n\x06\x04\x92\x01\x02\x06\x03\x12\
    \x04\xe8)\x16\x17\n@\n\x05\x04\x92\x01\x02\x07\x12\x04\xea)\x04\x20\x1a1\
    \x20Whether\x20to\x20order\x20by\x20when\x20the\x20metric\x20was\x20crea\
    ted\n\n\x0e\n\x06\x04\x92\x01\x02\x07\x05\x12\x04\xea)\x04\x08\n\x0e\n\
    \x06\x04\x92\x01\x02\x07\x01\x12\x04\xea)\t\x1b\n\x0e\n\x06\x04\x92\x01\
    \x02\x07\x03\x12\x04\xea)\x1e\x1f\nR\n\x05\x04\x92\x01\x02\x08\x12\x04\
    \xec)\x04(\x1aC\x20Whether\x20to\x20order\x20by\x20eval\x20metric\x20sum\
    mary.mean_avg_precision_iou_50\n\n\x0e\n\x06\x04\x92\x01\x02\x08\x05\x12\
    \x04\xec)\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\x08\x01\x12\x04\xec)\t#\n\
    \x0e\n\x06\x04\x92\x01\x02\x08\x03\x12\x04\xec)&'\nL\n\x05\x04\x92\x01\
    \x02\t\x12\x04\xee)\x04\x20\x1a=\x20Whether\x20to\x20order\x20by\x20eval\
    \x20metric\x20summary.macro_avg_precision\n\n\x0e\n\x06\x04\x92\x01\x02\
    \t\x05\x12\x04\xee)\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\t\x01\x12\x04\
    \xee)\t\x1a\n\x0e\n\x06\x04\x92\x01\x02\t\x03\x12\x04\xee)\x1d\x1f\nI\n\
    \x05\x04\x92\x01\x02\n\x12\x04\xf0)\x04\x1d\x1a:\x20Whether\x20to\x20ord\
    er\x20by\x20eval\x20metric\x20summary.macro_avg_recall\n\n\x0e\n\x06\x04\
    \x92\x01\x02\n\x05\x12\x04\xf0)\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\n\
    \x01\x12\x04\xf0)\t\x17\n\x0e\n\x06\x04\x92\x01\x02\n\x03\x12\x04\xf0)\
    \x1a\x1c\n\r\n\x05\x04\x92\x01\x02\x0b\x12\x04\xf1)\x04\x1f\n\x0e\n\x06\
    \x04\x92\x01\x02\x0b\x05\x12\x04\xf1)\x04\x08\n\x0e\n\x06\x04\x92\x01\
    \x02\x0b\x01\x12\x04\xf1)\t\x19\n\x0e\n\x06\x04\x92\x01\x02\x0b\x03\x12\
    \x04\xf1)\x1c\x1e\n\r\n\x05\x04\x92\x01\x02\x0c\x12\x04\xf2)\x04&\n\x0e\
    \n\x06\x04\x92\x01\x02\x0c\x05\x12\x04\xf2)\x04\x08\n\x0e\n\x06\x04\x92\
    \x01\x02\x0c\x01\x12\x04\xf2)\t\x20\n\x0e\n\x06\x04\x92\x01\x02\x0c\x03\
    \x12\x04\xf2)#%\n\r\n\x05\x04\x92\x01\x02\r\x12\x04\xf3)\x04'\n\x0e\n\
    \x06\x04\x92\x01\x02\r\x05\x12\x04\xf3)\x04\x08\n\x0e\n\x06\x04\x92\x01\
    \x02\r\x01\x12\x04\xf3)\t!\n\x0e\n\x06\x04\x92\x01\x02\r\x03\x12\x04\xf3\
    )$&\n(\n\x05\x04\x92\x01\x02\x0e\x12\x04\xf6)\x02\x1c\x1a\x19\x20Filter\
    \x20on\x20model\x20type\x20id\n\n\x0e\n\x06\x04\x92\x01\x02\x0e\x05\x12\
    \x04\xf6)\x02\x08\n\x0e\n\x06\x04\x92\x01\x02\x0e\x01\x12\x04\xf6)\t\x16\
    \n\x0e\n\x06\x04\x92\x01\x02\x0e\x03\x12\x04\xf6)\x19\x1b\n\\\n\x05\x04\
    \x92\x01\x02\x0f\x12\x04\xf8)\x02(\x1aM\x20Filter\x20on\x20dataset\x20ID\
    \x20of\x20the\x20dataset\x20version\x20specified\x20in\x20the\x20metric\
    \x20version\n\n\x0e\n\x06\x04\x92\x01\x02\x0f\x04\x12\x04\xf8)\x02\n\n\
    \x0e\n\x06\x04\x92\x01\x02\x0f\x05\x12\x04\xf8)\x0b\x11\n\x0e\n\x06\x04\
    \x92\x01\x02\x0f\x01\x12\x04\xf8)\x12\"\n\x0e\n\x06\x04\x92\x01\x02\x0f\
    \x03\x12\x04\xf8)%'\n[\n\x05\x04\x92\x01\x02\x10\x12\x04\xfa)\x02)\x1aL\
    \x20Filter\x20on\x20dataset\x20ID\x20of\x20the\x20dataset\x20version\x20\
    specified\x20by\x20the\x20model\x20version\n\n\x0e\n\x06\x04\x92\x01\x02\
    \x10\x04\x12\x04\xfa)\x02\n\n\x0e\n\x06\x04\x92\x01\x02\x10\x05\x12\x04\
    \xfa)\x0b\x11\n\x0e\n\x06\x04\x92\x01\x02\x10\x01\x12\x04\xfa)\x12#\n\
    \x0e\n\x06\x04\x92\x01\x02\x10\x03\x12\x04\xfa)&(\nT\n\x05\x04\x92\x01\
    \x02\x11\x12\x04\xfc)\x02#\x1aE\x20Filter\x20on\x20concept\x20IDs\x20spe\
    cified\x20in\x20the\x20modele\x20version's\x20output_info\n\n\x0e\n\x06\
    \x04\x92\x01\x02\x11\x04\x12\x04\xfc)\x02\n\n\x0e\n\x06\x04\x92\x01\x02\
    \x11\x05\x12\x04\xfc)\x0b\x11\n\x0e\n\x06\x04\x92\x01\x02\x11\x01\x12\
    \x04\xfc)\x12\x1d\n\x0e\n\x06\x04\x92\x01\x02\x11\x03\x12\x04\xfc)\x20\"\
    \nB\n\x05\x04\x92\x01\x02\x12\x12\x04\xfe)\x02\x20\x1a3\x20Whether\x20to\
    \x20show\x20failed\x20metrics,\x20defaults\x20to\x20false\n\n\x0e\n\x06\
    \x04\x92\x01\x02\x12\x05\x12\x04\xfe)\x02\x06\n\x0e\n\x06\x04\x92\x01\
    \x02\x12\x01\x12\x04\xfe)\x07\x1a\n\x0e\n\x06\x04\x92\x01\x02\x12\x03\
    \x12\x04\xfe)\x1d\x1f\n\r\n\x03\x04\x93\x01\x12\x06\x81*\0\x87*\x01\n\
    \x0c\n\x04\x04\x93\x01\x01\x12\x04\x81*\x08\x1c\n\r\n\x05\x04\x93\x01\
    \x02\0\x12\x04\x82*\x02,\n\x0e\n\x06\x04\x93\x01\x02\0\x06\x12\x04\x82*\
    \x02\x1b\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\x82*\x1c'\n\x0e\n\x06\
    \x04\x93\x01\x02\0\x03\x12\x04\x82**+\n\r\n\x05\x04\x93\x01\x02\x01\x12\
    \x04\x83*\x02\x1b\n\x0e\n\x06\x04\x93\x01\x02\x01\x05\x12\x04\x83*\x02\
    \x08\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\x83*\t\x16\n\x0e\n\x06\
    \x04\x93\x01\x02\x01\x03\x12\x04\x83*\x19\x1a\no\n\x05\x04\x93\x01\x02\
    \x02\x12\x04\x86*\x02\x19\x1a`\x20Any\x20of\x20the\x20fields\x20you\x20w\
    ish\x20to\x20return\x20in\x20the\x20metrics\n\x20By\x20default,\x20only\
    \x20the\x20summary\x20is\x20returned.\n\n\x0e\n\x06\x04\x93\x01\x02\x02\
    \x06\x12\x04\x86*\x02\r\n\x0e\n\x06\x04\x93\x01\x02\x02\x01\x12\x04\x86*\
    \x0e\x14\n\x0e\n\x06\x04\x93\x01\x02\x02\x03\x12\x04\x86*\x17\x18\n+\n\
    \x03\x04\x94\x01\x12\x06\x8c*\0\x92*\x01\x1a\x1c\x20Evaluate\x20this\x20\
    model\x20vesion\n\n\x0c\n\x04\x04\x94\x01\x01\x12\x04\x8c*\x08*\n\r\n\
    \x05\x04\x94\x01\x02\0\x12\x04\x8d*\x02,\n\x0e\n\x06\x04\x94\x01\x02\0\
    \x06\x12\x04\x8d*\x02\x1b\n\x0e\n\x06\x04\x94\x01\x02\0\x01\x12\x04\x8d*\
    \x1c'\n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\x8d**+\n\r\n\x05\x04\x94\
    \x01\x02\x01\x12\x04\x8e*\x02\x16\n\x0e\n\x06\x04\x94\x01\x02\x01\x05\
    \x12\x04\x8e*\x02\x08\n\x0e\n\x06\x04\x94\x01\x02\x01\x01\x12\x04\x8e*\t\
    \x11\n\x0e\n\x06\x04\x94\x01\x02\x01\x03\x12\x04\x8e*\x14\x15\n\r\n\x05\
    \x04\x94\x01\x02\x02\x12\x04\x8f*\x02\x1e\n\x0e\n\x06\x04\x94\x01\x02\
    \x02\x05\x12\x04\x8f*\x02\x08\n\x0e\n\x06\x04\x94\x01\x02\x02\x01\x12\
    \x04\x8f*\t\x19\n\x0e\n\x06\x04\x94\x01\x02\x02\x03\x12\x04\x8f*\x1c\x1d\
    \nJ\n\x05\x04\x94\x01\x02\x03\x12\x04\x91*\x02(\x1a;\x20EvalInfo\x20and\
    \x20ID\x20will\x20be\x20used\x20when\x20creating\x20the\x20evaluation\n\
    \n\x0e\n\x06\x04\x94\x01\x02\x03\x04\x12\x04\x91*\x02\n\n\x0e\n\x06\x04\
    \x94\x01\x02\x03\x06\x12\x04\x91*\x0b\x16\n\x0e\n\x06\x04\x94\x01\x02\
    \x03\x01\x12\x04\x91*\x17#\n\x0e\n\x06\x04\x94\x01\x02\x03\x03\x12\x04\
    \x91*&'\n\r\n\x03\x04\x95\x01\x12\x06\x94*\0\xa0*\x01\n\x0c\n\x04\x04\
    \x95\x01\x01\x12\x04\x94*\x08*\n\r\n\x05\x04\x95\x01\x02\0\x12\x04\x95*\
    \x02,\n\x0e\n\x06\x04\x95\x01\x02\0\x06\x12\x04\x95*\x02\x1b\n\x0e\n\x06\
    \x04\x95\x01\x02\0\x01\x12\x04\x95*\x1c'\n\x0e\n\x06\x04\x95\x01\x02\0\
    \x03\x12\x04\x95**+\n\r\n\x05\x04\x95\x01\x02\x01\x12\x04\x96*\x02\x16\n\
    \x0e\n\x06\x04\x95\x01\x02\x01\x05\x12\x04\x96*\x02\x08\n\x0e\n\x06\x04\
    \x95\x01\x02\x01\x01\x12\x04\x96*\t\x11\n\x0e\n\x06\x04\x95\x01\x02\x01\
    \x03\x12\x04\x96*\x14\x15\n\r\n\x05\x04\x95\x01\x02\x02\x12\x04\x97*\x02\
    \x1e\n\x0e\n\x06\x04\x95\x01\x02\x02\x05\x12\x04\x97*\x02\x08\n\x0e\n\
    \x06\x04\x95\x01\x02\x02\x01\x12\x04\x97*\t\x19\n\x0e\n\x06\x04\x95\x01\
    \x02\x02\x03\x12\x04\x97*\x1c\x1d\n\x7f\n\x05\x04\x95\x01\x02\x03\x12\
    \x04\x9b*\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x95\x01\
    \x02\x03\x05\x12\x04\x9b*\x02\x08\n\x0e\n\x06\x04\x95\x01\x02\x03\x01\
    \x12\x04\x9b*\t\r\n\x0e\n\x06\x04\x95\x01\x02\x03\x03\x12\x04\x9b*\x10\
    \x11\nv\n\x05\x04\x95\x01\x02\x04\x12\x04\x9f*\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\x95\x01\x02\x04\x05\x12\x04\x9f*\x02\x08\n\x0e\n\x06\
    \x04\x95\x01\x02\x04\x01\x12\x04\x9f*\t\x11\n\x0e\n\x06\x04\x95\x01\x02\
    \x04\x03\x12\x04\x9f*\x14\x15\n\r\n\x03\x04\x96\x01\x12\x06\xa2*\0\xab*\
    \x01\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xa2*\x08(\n\r\n\x05\x04\x96\x01\
    \x02\0\x12\x04\xa3*\x02,\n\x0e\n\x06\x04\x96\x01\x02\0\x06\x12\x04\xa3*\
    \x02\x1b\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\xa3*\x1c'\n\x0e\n\x06\
    \x04\x96\x01\x02\0\x03\x12\x04\xa3**+\n\r\n\x05\x04\x96\x01\x02\x01\x12\
    \x04\xa4*\x02\x16\n\x0e\n\x06\x04\x96\x01\x02\x01\x05\x12\x04\xa4*\x02\
    \x08\n\x0e\n\x06\x04\x96\x01\x02\x01\x01\x12\x04\xa4*\t\x11\n\x0e\n\x06\
    \x04\x96\x01\x02\x01\x03\x12\x04\xa4*\x14\x15\n\r\n\x05\x04\x96\x01\x02\
    \x02\x12\x04\xa5*\x02\x1e\n\x0e\n\x06\x04\x96\x01\x02\x02\x05\x12\x04\
    \xa5*\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x02\x01\x12\x04\xa5*\t\x19\n\
    \x0e\n\x06\x04\x96\x01\x02\x02\x03\x12\x04\xa5*\x1c\x1d\n\r\n\x05\x04\
    \x96\x01\x02\x03\x12\x04\xa6*\x02\x1b\n\x0e\n\x06\x04\x96\x01\x02\x03\
    \x05\x12\x04\xa6*\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x03\x01\x12\x04\
    \xa6*\t\x16\n\x0e\n\x06\x04\x96\x01\x02\x03\x03\x12\x04\xa6*\x19\x1a\nx\
    \n\x05\x04\x96\x01\x02\x04\x12\x04\xaa*\x02\x19\x1ai\x20Any\x20of\x20the\
    \x20fields\x20you\x20wish\x20to\x20return\x20from\x20multiclass_metrics\
    \n\x20By\x20default,\x20only\x20the\x20summary\x20is\x20returned.\n\n\
    \x0e\n\x06\x04\x96\x01\x02\x04\x06\x12\x04\xaa*\x02\r\n\x0e\n\x06\x04\
    \x96\x01\x02\x04\x01\x12\x04\xaa*\x0e\x14\n\x0e\n\x06\x04\x96\x01\x02\
    \x04\x03\x12\x04\xaa*\x17\x18\n\r\n\x03\x04\x97\x01\x12\x06\xad*\0\xb0*\
    \x01\n\x0c\n\x04\x04\x97\x01\x01\x12\x04\xad*\x08!\n\r\n\x05\x04\x97\x01\
    \x02\0\x12\x04\xae*\x02(\n\x0e\n\x06\x04\x97\x01\x02\0\x06\x12\x04\xae*\
    \x02\x1c\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\xae*\x1d#\n\x0e\n\x06\
    \x04\x97\x01\x02\0\x03\x12\x04\xae*&'\n\r\n\x05\x04\x97\x01\x02\x01\x12\
    \x04\xaf*\x02\x1f\n\x0e\n\x06\x04\x97\x01\x02\x01\x06\x12\x04\xaf*\x02\r\
    \n\x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\x04\xaf*\x0e\x1a\n\x0e\n\x06\
    \x04\x97\x01\x02\x01\x03\x12\x04\xaf*\x1d\x1e\n\r\n\x03\x04\x98\x01\x12\
    \x06\xb2*\0\xb5*\x01\n\x0c\n\x04\x04\x98\x01\x01\x12\x04\xb2*\x08\x20\n\
    \r\n\x05\x04\x98\x01\x02\0\x12\x04\xb3*\x02(\n\x0e\n\x06\x04\x98\x01\x02\
    \0\x06\x12\x04\xb3*\x02\x1c\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\
    \xb3*\x1d#\n\x0e\n\x06\x04\x98\x01\x02\0\x03\x12\x04\xb3*&'\n\r\n\x05\
    \x04\x98\x01\x02\x01\x12\x04\xb4*\x02(\n\x0e\n\x06\x04\x98\x01\x02\x01\
    \x04\x12\x04\xb4*\x02\n\n\x0e\n\x06\x04\x98\x01\x02\x01\x06\x12\x04\xb4*\
    \x0b\x16\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\x12\x04\xb4*\x17#\n\x0e\n\
    \x06\x04\x98\x01\x02\x01\x03\x12\x04\xb4*&'\n-\n\x03\x04\x99\x01\x12\x06\
    \xb8*\0\xc3*\x01\x1a\x1e\x20Evaluate\x20this\x20model\x20version.\n\n\
    \x0c\n\x04\x04\x99\x01\x01\x12\x04\xb8*\x08&\n\x0c\n\x04\x04\x99\x01\t\
    \x12\x04\xb9*\x02\r\n\r\n\x05\x04\x99\x01\t\0\x12\x04\xb9*\x0b\x0c\n\x0e\
    \n\x06\x04\x99\x01\t\0\x01\x12\x04\xb9*\x0b\x0c\n\x0e\n\x06\x04\x99\x01\
    \t\0\x02\x12\x04\xb9*\x0b\x0c\n\r\n\x05\x04\x99\x01\x02\0\x12\x04\xba*\
    \x02,\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\xba*\x02\x1b\n\x0e\n\x06\
    \x04\x99\x01\x02\0\x01\x12\x04\xba*\x1c'\n\x0e\n\x06\x04\x99\x01\x02\0\
    \x03\x12\x04\xba**+\n\r\n\x05\x04\x99\x01\x02\x01\x12\x04\xbb*\x02\x16\n\
    \x0e\n\x06\x04\x99\x01\x02\x01\x05\x12\x04\xbb*\x02\x08\n\x0e\n\x06\x04\
    \x99\x01\x02\x01\x01\x12\x04\xbb*\t\x11\n\x0e\n\x06\x04\x99\x01\x02\x01\
    \x03\x12\x04\xbb*\x14\x15\n\r\n\x05\x04\x99\x01\x02\x02\x12\x04\xbc*\x02\
    \x18\n\x0e\n\x06\x04\x99\x01\x02\x02\x05\x12\x04\xbc*\x02\x08\n\x0e\n\
    \x06\x04\x99\x01\x02\x02\x01\x12\x04\xbc*\t\x13\n\x0e\n\x06\x04\x99\x01\
    \x02\x02\x03\x12\x04\xbc*\x16\x17\nF\n\x05\x04\x99\x01\x02\x03\x12\x04\
    \xbf*\x02&\x1a7\x20Use\x20this\x20to\x20filter\x20inputs\x20that\x20are\
    \x20used\x20in\x20evaluation\n\n\x0e\n\x06\x04\x99\x01\x02\x03\x06\x12\
    \x04\xbf*\x02\x15\n\x0e\n\x06\x04\x99\x01\x02\x03\x01\x12\x04\xbf*\x16!\
    \n\x0e\n\x06\x04\x99\x01\x02\x03\x03\x12\x04\xbf*$%\nF\n\x05\x04\x99\x01\
    \x02\x04\x12\x04\xc2*\x02\x1a\x1a7\x20evaluation\x20info.\x20Such\x20as\
    \x20dataset\x20used\x20for\x20evaluation.\n\n\x0e\n\x06\x04\x99\x01\x02\
    \x04\x06\x12\x04\xc2*\x02\n\n\x0e\n\x06\x04\x99\x01\x02\x04\x01\x12\x04\
    \xc2*\x0b\x14\n\x0e\n\x06\x04\x99\x01\x02\x04\x03\x12\x04\xc2*\x17\x19\n\
    U\n\x03\x04\x9a\x01\x12\x06\xc7*\0\xcf*\x01\x1aF\x20Get\x20the\x20alread\
    y\x20computed\x20evaluation\x20metrics\x20for\x20this\x20model\n\x20vers\
    ion.\n\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\xc7*\x08%\n\r\n\x05\x04\x9a\
    \x01\x02\0\x12\x04\xc8*\x02,\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\x04\
    \xc8*\x02\x1b\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\xc8*\x1c'\n\x0e\
    \n\x06\x04\x9a\x01\x02\0\x03\x12\x04\xc8**+\n\r\n\x05\x04\x9a\x01\x02\
    \x01\x12\x04\xc9*\x02\x16\n\x0e\n\x06\x04\x9a\x01\x02\x01\x05\x12\x04\
    \xc9*\x02\x08\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\xc9*\t\x11\n\
    \x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\xc9*\x14\x15\n\r\n\x05\x04\
    \x9a\x01\x02\x02\x12\x04\xca*\x02\x18\n\x0e\n\x06\x04\x9a\x01\x02\x02\
    \x05\x12\x04\xca*\x02\x08\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\x04\
    \xca*\t\x13\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\xca*\x16\x17\n|\
    \n\x05\x04\x9a\x01\x02\x03\x12\x04\xce*\x02\x19\x1am\x20Any\x20of\x20the\
    \x20fields\x20you\x20wish\x20to\x20return\x20from\x20multiclass_metrics\
    \n\x20By\x20default,\x20only\x20the\x20summary\x20will\x20be\x20returned\
    \n\n\x0e\n\x06\x04\x9a\x01\x02\x03\x06\x12\x04\xce*\x02\r\n\x0e\n\x06\
    \x04\x9a\x01\x02\x03\x01\x12\x04\xce*\x0e\x14\n\x0e\n\x06\x04\x9a\x01\
    \x02\x03\x03\x12\x04\xce*\x17\x18\n\xeb\x01\n\x03\x04\x9b\x01\x12\x06\
    \xdc*\0\xe1*\x01\x1a\x15\x20GetModelTypeRequest\n2\xc4\x01\x20//\x20Requ\
    est\x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20i\
    ds.\n\x20message\x20DeleteModelVersionsRequest\x20{\n\x20\x20\x20clarifa\
    i.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20repeated\x20st\
    ring\x20ids\x20=\x202;\n\x20\x20\x20bool\x20delete_all\x20=\x203;\n\x20}\
    \n\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\xdc*\x08\x1b\nl\n\x05\x04\x9b\x01\
    \x02\0\x12\x04\xde*\x02,\x1a]\x20use\x20and\x20app\x20combo.\x20Not\x20r\
    eally\x20used\x20for\x20this\x20endpoint\x20at\x20this\x20time\x20so\x20\
    may\x20go\x20away\x20in\x20future.\n\n\x0e\n\x06\x04\x9b\x01\x02\0\x06\
    \x12\x04\xde*\x02\x1b\n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\xde*\x1c\
    '\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\x04\xde**+\n@\n\x05\x04\x9b\x01\
    \x02\x01\x12\x04\xe0*\x02\x1b\x1a1\x20The\x20specific\x20ModelType.Id\
    \x20you\x20want\x20to\x20retrieve.\n\n\x0e\n\x06\x04\x9b\x01\x02\x01\x05\
    \x12\x04\xe0*\x02\x08\n\x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\x04\xe0*\t\
    \x16\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\x12\x04\xe0*\x19\x1a\n&\n\x03\
    \x04\x9c\x01\x12\x06\xe4*\0\xed*\x01\x1a\x17\x20ListModelTypesRequest\n\
    \n\x0c\n\x04\x04\x9c\x01\x01\x12\x04\xe4*\x08\x1d\nl\n\x05\x04\x9c\x01\
    \x02\0\x12\x04\xe6*\x02,\x1a]\x20use\x20and\x20app\x20combo.\x20Not\x20r\
    eally\x20used\x20for\x20this\x20endpoint\x20at\x20this\x20time\x20so\x20\
    may\x20go\x20away\x20in\x20future.\n\n\x0e\n\x06\x04\x9c\x01\x02\0\x06\
    \x12\x04\xe6*\x02\x1b\n\x0e\n\x06\x04\x9c\x01\x02\0\x01\x12\x04\xe6*\x1c\
    '\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\x12\x04\xe6**+\n\x7f\n\x05\x04\x9c\
    \x01\x02\x01\x12\x04\xe9*\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\xe9*\x02\x08\n\x0e\n\x06\x04\x9c\
    \x01\x02\x01\x01\x12\x04\xe9*\t\r\n\x0e\n\x06\x04\x9c\x01\x02\x01\x03\
    \x12\x04\xe9*\x10\x11\nv\n\x05\x04\x9c\x01\x02\x02\x12\x04\xec*\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\x9c\x01\x02\x02\x05\x12\x04\xec*\x02\
    \x08\n\x0e\n\x06\x04\x9c\x01\x02\x02\x01\x12\x04\xec*\t\x11\n\x0e\n\x06\
    \x04\x9c\x01\x02\x02\x03\x12\x04\xec*\x14\x15\n,\n\x03\x04\x9d\x01\x12\
    \x04\xf0*\0(\x1a\x1f\x20ListOpenSourceLicensesRequest\n\n\x0c\n\x04\x04\
    \x9d\x01\x01\x12\x04\xf0*\x08%\n/\n\x03\x04\x9e\x01\x12\x06\xf3*\0\xf6*\
    \x01\x1a\x20\x20ListOpenSourceLicensesResponse\n\n\x0c\n\x04\x04\x9e\x01\
    \x01\x12\x04\xf3*\x08&\n\r\n\x05\x04\x9e\x01\x02\0\x12\x04\xf4*\x02(\n\
    \x0e\n\x06\x04\x9e\x01\x02\0\x06\x12\x04\xf4*\x02\x1c\n\x0e\n\x06\x04\
    \x9e\x01\x02\0\x01\x12\x04\xf4*\x1d#\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\
    \x12\x04\xf4*&'\n\r\n\x05\x04\x9e\x01\x02\x01\x12\x04\xf5*\x02\x1f\n\x0e\
    \n\x06\x04\x9e\x01\x02\x01\x04\x12\x04\xf5*\x02\n\n\x0e\n\x06\x04\x9e\
    \x01\x02\x01\x05\x12\x04\xf5*\x0b\x11\n\x0e\n\x06\x04\x9e\x01\x02\x01\
    \x01\x12\x04\xf5*\x12\x1a\n\x0e\n\x06\x04\x9e\x01\x02\x01\x03\x12\x04\
    \xf5*\x1d\x1e\n(\n\x03\x04\x9f\x01\x12\x06\xf9*\0\xfe*\x01\x1a\x19\x20Si\
    ngleModelTypeResponse\n\n\x0c\n\x04\x04\x9f\x01\x01\x12\x04\xf9*\x08\x1f\
    \n(\n\x05\x04\x9f\x01\x02\0\x12\x04\xfb*\x02(\x1a\x19\x20Status\x20of\
    \x20the\x20response.\n\n\x0e\n\x06\x04\x9f\x01\x02\0\x06\x12\x04\xfb*\
    \x02\x1c\n\x0e\n\x06\x04\x9f\x01\x02\0\x01\x12\x04\xfb*\x1d#\n\x0e\n\x06\
    \x04\x9f\x01\x02\0\x03\x12\x04\xfb*&'\n2\n\x05\x04\x9f\x01\x02\x01\x12\
    \x04\xfd*\x02J\x1a#\x20The\x20retrieved\x20ModelType\x20object.\x20.\n\n\
    \x0e\n\x06\x04\x9f\x01\x02\x01\x06\x12\x04\xfd*\x02\x0b\n\x0e\n\x06\x04\
    \x9f\x01\x02\x01\x01\x12\x04\xfd*\x0c\x16\n\x0e\n\x06\x04\x9f\x01\x02\
    \x01\x03\x12\x04\xfd*\x19\x1a\n\x0e\n\x06\x04\x9f\x01\x02\x01\x08\x12\
    \x04\xfd*\x1bI\n\x11\n\t\x04\x9f\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xfd\
    *\x1cH\n'\n\x03\x04\xa0\x01\x12\x06\x81+\0\x8a+\x01\x1a\x18\x20MultiMode\
    lTypeResponse\n\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\x81+\x08\x1e\n(\n\
    \x05\x04\xa0\x01\x02\0\x12\x04\x83+\x02(\x1a\x19\x20Status\x20of\x20the\
    \x20response.\n\n\x0e\n\x06\x04\xa0\x01\x02\0\x06\x12\x04\x83+\x02\x1c\n\
    \x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\x83+\x1d#\n\x0e\n\x06\x04\xa0\
    \x01\x02\0\x03\x12\x04\x83+&'\n+\n\x05\x04\xa0\x01\x02\x01\x12\x04\x85+\
    \x02T\x1a\x1c\x20List\x20of\x20ModelType\x20objects.\n\n\x0e\n\x06\x04\
    \xa0\x01\x02\x01\x04\x12\x04\x85+\x02\n\n\x0e\n\x06\x04\xa0\x01\x02\x01\
    \x06\x12\x04\x85+\x0b\x14\n\x0e\n\x06\x04\xa0\x01\x02\x01\x01\x12\x04\
    \x85+\x15\x20\n\x0e\n\x06\x04\xa0\x01\x02\x01\x03\x12\x04\x85+#$\n\x0e\n\
    \x06\x04\xa0\x01\x02\x01\x08\x12\x04\x85+%S\n\x11\n\t\x04\xa0\x01\x02\
    \x01\x08\xd0\x86\x03\x12\x04\x85+&R\n(\n\x05\x04\xa0\x01\x02\x02\x12\x04\
    \x87+\x02%\x1a\x19\x20List\x20of\x20model\x20importers\n\n\x0e\n\x06\x04\
    \xa0\x01\x02\x02\x06\x12\x04\x87+\x02\x10\n\x0e\n\x06\x04\xa0\x01\x02\
    \x02\x01\x12\x04\x87+\x11\x20\n\x0e\n\x06\x04\xa0\x01\x02\x02\x03\x12\
    \x04\x87+#$\nD\n\x05\x04\xa0\x01\x02\x03\x12\x04\x89+\x028\x1a5\x20Trito\
    n\x20model\x20envs\x20that\x20can\x20be\x20used\x20for\x20model\x20uploa\
    d\n\n\x0e\n\x06\x04\xa0\x01\x02\x03\x04\x12\x04\x89+\x02\n\n\x0e\n\x06\
    \x04\xa0\x01\x02\x03\x06\x12\x04\x89+\x0b\x1d\n\x0e\n\x06\x04\xa0\x01\
    \x02\x03\x01\x12\x04\x89+\x1e4\n\x0e\n\x06\x04\xa0\x01\x02\x03\x03\x12\
    \x04\x89+67\n3\n\x03\x04\xa1\x01\x12\x06\x8d+\0\x96+\x01\x1a$\x20GetMode\
    lVersionInputExampleRequest\n\n\x0c\n\x04\x04\xa1\x01\x01\x12\x04\x8d+\
    \x08*\nA\n\x05\x04\xa1\x01\x02\0\x12\x04\x8f+\x02,\x1a2\x20authorization\
    \x20field\x20\x20(contains\x20app/user\x20id\x20info)\n\n\x0e\n\x06\x04\
    \xa1\x01\x02\0\x06\x12\x04\x8f+\x02\x1b\n\x0e\n\x06\x04\xa1\x01\x02\0\
    \x01\x12\x04\x8f+\x1c'\n\x0e\n\x06\x04\xa1\x01\x02\0\x03\x12\x04\x8f+*+\
    \n3\n\x05\x04\xa1\x01\x02\x01\x12\x04\x91+\x02\x16\x1a$\x20id\x20of\x20m\
    odel\x20the\x20example\x20belongs\x20to\n\n\x0e\n\x06\x04\xa1\x01\x02\
    \x01\x05\x12\x04\x91+\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x01\x01\x12\
    \x04\x91+\t\x11\n\x0e\n\x06\x04\xa1\x01\x02\x01\x03\x12\x04\x91+\x14\x15\
    \n8\n\x05\x04\xa1\x01\x02\x02\x12\x04\x93+\x02\x1e\x1a)\x20specific\x20v\
    ersion\x20the\x20example\x20belongs\x20to\n\n\x0e\n\x06\x04\xa1\x01\x02\
    \x02\x05\x12\x04\x93+\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x02\x01\x12\
    \x04\x93+\t\x19\n\x0e\n\x06\x04\xa1\x01\x02\x02\x03\x12\x04\x93+\x1c\x1d\
    \n'\n\x05\x04\xa1\x01\x02\x03\x12\x04\x95+\x02\x18\x1a\x18\x20Id\x20of\
    \x20example\x20to\x20fetch\n\n\x0e\n\x06\x04\xa1\x01\x02\x03\x05\x12\x04\
    \x95+\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x03\x01\x12\x04\x95+\t\x13\n\
    \x0e\n\x06\x04\xa1\x01\x02\x03\x03\x12\x04\x95+\x16\x17\n5\n\x03\x04\xa2\
    \x01\x12\x06\x99+\0\xa4+\x01\x1a&\x20ListModelVersionInputExamplesReques\
    t\n\n\x0c\n\x04\x04\xa2\x01\x01\x12\x04\x99+\x08,\nA\n\x05\x04\xa2\x01\
    \x02\0\x12\x04\x9b+\x02,\x1a2\x20authorization\x20field\x20\x20(contains\
    \x20app/user\x20id\x20info)\n\n\x0e\n\x06\x04\xa2\x01\x02\0\x06\x12\x04\
    \x9b+\x02\x1b\n\x0e\n\x06\x04\xa2\x01\x02\0\x01\x12\x04\x9b+\x1c'\n\x0e\
    \n\x06\x04\xa2\x01\x02\0\x03\x12\x04\x9b+*+\n3\n\x05\x04\xa2\x01\x02\x01\
    \x12\x04\x9d+\x02\x16\x1a$\x20id\x20of\x20model\x20the\x20example\x20bel\
    ongs\x20to\n\n\x0e\n\x06\x04\xa2\x01\x02\x01\x05\x12\x04\x9d+\x02\x08\n\
    \x0e\n\x06\x04\xa2\x01\x02\x01\x01\x12\x04\x9d+\t\x11\n\x0e\n\x06\x04\
    \xa2\x01\x02\x01\x03\x12\x04\x9d+\x14\x15\n8\n\x05\x04\xa2\x01\x02\x02\
    \x12\x04\x9f+\x02\x1e\x1a)\x20specific\x20version\x20the\x20example\x20b\
    elongs\x20to\n\n\x0e\n\x06\x04\xa2\x01\x02\x02\x05\x12\x04\x9f+\x02\x08\
    \n\x0e\n\x06\x04\xa2\x01\x02\x02\x01\x12\x04\x9f+\t\x19\n\x0e\n\x06\x04\
    \xa2\x01\x02\x02\x03\x12\x04\x9f+\x1c\x1d\n)\n\x05\x04\xa2\x01\x02\x03\
    \x12\x04\xa1+\x02\x12\x1a\x1a\x20Optional,\x20defaults\x20to\x201.\n\n\
    \x0e\n\x06\x04\xa2\x01\x02\x03\x05\x12\x04\xa1+\x02\x08\n\x0e\n\x06\x04\
    \xa2\x01\x02\x03\x01\x12\x04\xa1+\t\r\n\x0e\n\x06\x04\xa2\x01\x02\x03\
    \x03\x12\x04\xa1+\x10\x11\n?\n\x05\x04\xa2\x01\x02\x04\x12\x04\xa3+\x02\
    \x16\x1a0\x20Optional,\x20defaults\x20to\x20128\x20references\x20per\x20\
    page.\n\n\x0e\n\x06\x04\xa2\x01\x02\x04\x05\x12\x04\xa3+\x02\x08\n\x0e\n\
    \x06\x04\xa2\x01\x02\x04\x01\x12\x04\xa3+\t\x11\n\x0e\n\x06\x04\xa2\x01\
    \x02\x04\x03\x12\x04\xa3+\x14\x15\n7\n\x03\x04\xa3\x01\x12\x06\xa9+\0\
    \xae+\x01\x1a(\x20SingleModelVersionInputExampleResponse\n\n\x0c\n\x04\
    \x04\xa3\x01\x01\x12\x04\xa9+\x08.\n#\n\x05\x04\xa3\x01\x02\0\x12\x04\
    \xab+\x02(\x1a\x14\x20status\x20of\x20response\n\n\x0e\n\x06\x04\xa3\x01\
    \x02\0\x06\x12\x04\xab+\x02\x1c\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\
    \x04\xab+\x1d#\n\x0e\n\x06\x04\xa3\x01\x02\0\x03\x12\x04\xab+&'\n,\n\x05\
    \x04\xa3\x01\x02\x01\x12\x04\xad+\x02;\x1a\x1d\x20model\x20input\x20exam\
    ple\x20message\n\n\x0e\n\x06\x04\xa3\x01\x02\x01\x06\x12\x04\xad+\x02\
    \x1a\n\x0e\n\x06\x04\xa3\x01\x02\x01\x01\x12\x04\xad+\x1b6\n\x0e\n\x06\
    \x04\xa3\x01\x02\x01\x03\x12\x04\xad+9:\n6\n\x03\x04\xa4\x01\x12\x06\xb1\
    +\0\xb6+\x01\x1a'\x20MultiModelVersionInputExampleResponse\n\n\x0c\n\x04\
    \x04\xa4\x01\x01\x12\x04\xb1+\x08-\n#\n\x05\x04\xa4\x01\x02\0\x12\x04\
    \xb3+\x02(\x1a\x14\x20status\x20of\x20response\n\n\x0e\n\x06\x04\xa4\x01\
    \x02\0\x06\x12\x04\xb3+\x02\x1c\n\x0e\n\x06\x04\xa4\x01\x02\0\x01\x12\
    \x04\xb3+\x1d#\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\x04\xb3+&'\n-\n\x05\
    \x04\xa4\x01\x02\x01\x12\x04\xb5+\x02E\x1a\x1e\x20model\x20input\x20exam\
    ple\x20messages\n\n\x0e\n\x06\x04\xa4\x01\x02\x01\x04\x12\x04\xb5+\x02\n\
    \n\x0e\n\x06\x04\xa4\x01\x02\x01\x06\x12\x04\xb5+\x0b#\n\x0e\n\x06\x04\
    \xa4\x01\x02\x01\x01\x12\x04\xb5+$@\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\
    \x12\x04\xb5+CD\n+\n\x03\x04\xa5\x01\x12\x06\xb9+\0\xc1+\x01\x1a\x1c\x20\
    ListModelReferencesRequest\n\n\x0c\n\x04\x04\xa5\x01\x01\x12\x04\xb9+\
    \x08\"\n\r\n\x05\x04\xa5\x01\x02\0\x12\x04\xba+\x02,\n\x0e\n\x06\x04\xa5\
    \x01\x02\0\x06\x12\x04\xba+\x02\x1b\n\x0e\n\x06\x04\xa5\x01\x02\0\x01\
    \x12\x04\xba+\x1c'\n\x0e\n\x06\x04\xa5\x01\x02\0\x03\x12\x04\xba+*+\n\r\
    \n\x05\x04\xa5\x01\x02\x01\x12\x04\xbc+\x02\x16\n\x0e\n\x06\x04\xa5\x01\
    \x02\x01\x05\x12\x04\xbc+\x02\x08\n\x0e\n\x06\x04\xa5\x01\x02\x01\x01\
    \x12\x04\xbc+\t\x11\n\x0e\n\x06\x04\xa5\x01\x02\x01\x03\x12\x04\xbc+\x14\
    \x15\n)\n\x05\x04\xa5\x01\x02\x02\x12\x04\xbe+\x02\x12\x1a\x1a\x20Option\
    al,\x20defaults\x20to\x201.\n\n\x0e\n\x06\x04\xa5\x01\x02\x02\x05\x12\
    \x04\xbe+\x02\x08\n\x0e\n\x06\x04\xa5\x01\x02\x02\x01\x12\x04\xbe+\t\r\n\
    \x0e\n\x06\x04\xa5\x01\x02\x02\x03\x12\x04\xbe+\x10\x11\n?\n\x05\x04\xa5\
    \x01\x02\x03\x12\x04\xc0+\x02\x16\x1a0\x20Optional,\x20defaults\x20to\
    \x20128\x20references\x20per\x20page.\n\n\x0e\n\x06\x04\xa5\x01\x02\x03\
    \x05\x12\x04\xc0+\x02\x08\n\x0e\n\x06\x04\xa5\x01\x02\x03\x01\x12\x04\
    \xc0+\t\x11\n\x0e\n\x06\x04\xa5\x01\x02\x03\x03\x12\x04\xc0+\x14\x15\n,\
    \n\x03\x04\xa6\x01\x12\x06\xc6+\0\xc9+\x01\x1a\x1d\x20MultiModelReferenc\
    eResponse\n\n\x0c\n\x04\x04\xa6\x01\x01\x12\x04\xc6+\x08#\n\r\n\x05\x04\
    \xa6\x01\x02\0\x12\x04\xc7+\x02(\n\x0e\n\x06\x04\xa6\x01\x02\0\x06\x12\
    \x04\xc7+\x02\x1c\n\x0e\n\x06\x04\xa6\x01\x02\0\x01\x12\x04\xc7+\x1d#\n\
    \x0e\n\x06\x04\xa6\x01\x02\0\x03\x12\x04\xc7+&'\n\r\n\x05\x04\xa6\x01\
    \x02\x01\x12\x04\xc8+\x02/\n\x0e\n\x06\x04\xa6\x01\x02\x01\x04\x12\x04\
    \xc8+\x02\n\n\x0e\n\x06\x04\xa6\x01\x02\x01\x06\x12\x04\xc8+\x0b\x19\n\
    \x0e\n\x06\x04\xa6\x01\x02\x01\x01\x12\x04\xc8+\x1a*\n\x0e\n\x06\x04\xa6\
    \x01\x02\x01\x03\x12\x04\xc8+-.\n$\n\x03\x04\xa7\x01\x12\x06\xcc+\0\xcf+\
    \x01\x1a\x15\x20MultiOutputResponse\n\n\x0c\n\x04\x04\xa7\x01\x01\x12\
    \x04\xcc+\x08\x1b\n\r\n\x05\x04\xa7\x01\x02\0\x12\x04\xcd+\x02(\n\x0e\n\
    \x06\x04\xa7\x01\x02\0\x06\x12\x04\xcd+\x02\x1c\n\x0e\n\x06\x04\xa7\x01\
    \x02\0\x01\x12\x04\xcd+\x1d#\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\x12\x04\
    \xcd+&'\n\r\n\x05\x04\xa7\x01\x02\x01\x12\x04\xce+\x02M\n\x0e\n\x06\x04\
    \xa7\x01\x02\x01\x04\x12\x04\xce+\x02\n\n\x0e\n\x06\x04\xa7\x01\x02\x01\
    \x06\x12\x04\xce+\x0b\x11\n\x0e\n\x06\x04\xa7\x01\x02\x01\x01\x12\x04\
    \xce+\x12\x19\n\x0e\n\x06\x04\xa7\x01\x02\x01\x03\x12\x04\xce+\x1c\x1d\n\
    \x0e\n\x06\x04\xa7\x01\x02\x01\x08\x12\x04\xce+\x1eL\n\x11\n\t\x04\xa7\
    \x01\x02\x01\x08\xd0\x86\x03\x12\x04\xce+\x1fK\n\"\n\x03\x04\xa8\x01\x12\
    \x06\xd2+\0\xd9+\x01\x1a\x13\x20ListScopesRequest\n\n\x0c\n\x04\x04\xa8\
    \x01\x01\x12\x04\xd2+\x08\x19\n\xc3\x01\n\x05\x04\xa8\x01\x02\0\x12\x04\
    \xd5+\x02\x16\x1a\xb3\x01\x20If\x20\"personal_access_token\"\x20include\
    \x20scopes\x20and\x20endpoints\x20available\x20to\x20personal\x20access\
    \x20tokens.\n\x20If\x20\"api_key\"\x20include\x20scopes\x20and\x20endpoi\
    nts\x20available\x20to\x20app-specific\x20keys.\x20(default)\n\n\x0e\n\
    \x06\x04\xa8\x01\x02\0\x05\x12\x04\xd5+\x02\x08\n\x0e\n\x06\x04\xa8\x01\
    \x02\0\x01\x12\x04\xd5+\t\x11\n\x0e\n\x06\x04\xa8\x01\x02\0\x03\x12\x04\
    \xd5+\x14\x15\np\n\x05\x04\xa8\x01\x02\x01\x12\x04\xd8+\x02,\x1aa\x20For\
    \x20all\x20user\x20specific\x20information\x20we\x20include\x20user_app_\
    id\x20to\x20get\x20the\x20user_id\x20in\x20a\x20consistent\x20way\n\n\
    \x0e\n\x06\x04\xa8\x01\x02\x01\x06\x12\x04\xd8+\x02\x1b\n\x0e\n\x06\x04\
    \xa8\x01\x02\x01\x01\x12\x04\xd8+\x1c'\n\x0e\n\x06\x04\xa8\x01\x02\x01\
    \x03\x12\x04\xd8+*+\n\x20\n\x03\x04\xa9\x01\x12\x06\xdc+\0\xde+\x01\x1a\
    \x11\x20MyScopesRequest\n\n\x0c\n\x04\x04\xa9\x01\x01\x12\x04\xdc+\x08\
    \x17\n\r\n\x05\x04\xa9\x01\x02\0\x12\x04\xdd+\x02,\n\x0e\n\x06\x04\xa9\
    \x01\x02\0\x06\x12\x04\xdd+\x02\x1b\n\x0e\n\x06\x04\xa9\x01\x02\0\x01\
    \x12\x04\xdd+\x1c'\n\x0e\n\x06\x04\xa9\x01\x02\0\x03\x12\x04\xdd+*+\n$\n\
    \x03\x04\xaa\x01\x12\x06\xe1+\0\xe3+\x01\x1a\x15\x20MyScopesUserRequest\
    \n\n\x0c\n\x04\x04\xaa\x01\x01\x12\x04\xe1+\x08\x1b\n\r\n\x05\x04\xaa\
    \x01\x02\0\x12\x04\xe2+\x02,\n\x0e\n\x06\x04\xaa\x01\x02\0\x06\x12\x04\
    \xe2+\x02\x1b\n\x0e\n\x06\x04\xaa\x01\x02\0\x01\x12\x04\xe2+\x1c'\n\x0e\
    \n\x06\x04\xaa\x01\x02\0\x03\x12\x04\xe2+*+\n$\n\x03\x04\xab\x01\x12\x06\
    \xe6+\0\xe7+\x01\x1a\x15\x20MyScopesRootRequest\n\n\x0c\n\x04\x04\xab\
    \x01\x01\x12\x04\xe6+\x08\x1b\n'\n\x03\x04\xac\x01\x12\x06\xea+\0\xf3+\
    \x01\x1a\x18\x20MultiScopeDepsResponse\n\n\x0c\n\x04\x04\xac\x01\x01\x12\
    \x04\xea+\x08\x1e\n+\n\x05\x04\xac\x01\x02\0\x12\x04\xec+\x02(\x1a\x1c\
    \x20The\x20status\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xac\x01\x02\
    \0\x06\x12\x04\xec+\x02\x1c\n\x0e\n\x06\x04\xac\x01\x02\0\x01\x12\x04\
    \xec+\x1d#\n\x0e\n\x06\x04\xac\x01\x02\0\x03\x12\x04\xec+&'\nM\n\x05\x04\
    \xac\x01\x02\x01\x12\x04\xee+\x02$\x1a>\x20scopes\x20is\x20a\x20list\x20\
    of\x20low-level\x20scopes\x20and\x20their\x20dependencies.\n\n\x0e\n\x06\
    \x04\xac\x01\x02\x01\x04\x12\x04\xee+\x02\n\n\x0e\n\x06\x04\xac\x01\x02\
    \x01\x06\x12\x04\xee+\x0b\x14\n\x0e\n\x06\x04\xac\x01\x02\x01\x01\x12\
    \x04\xee+\x15\x1f\n\x0e\n\x06\x04\xac\x01\x02\x01\x03\x12\x04\xee+\"#\n\
    \xc3\x01\n\x05\x04\xac\x01\x02\x02\x12\x04\xf2+\x02*\x1a\xb3\x01\x20endp\
    oint_scopes\x20is\x20a\x20listof\x20all\x20the\x20publicly\x20available\
    \x20endponts\x20which\x20can\x20be\n\x20used\x20as\x20scopes\x20as\x20we\
    ll.\x20A\x20call\x20to\x20each\x20of\x20those\x20endpoint\x20depends\x20\
    on\x20a\x20subset\n\x20of\x20the\x20above\x20\"scopes\"\n\n\x0e\n\x06\
    \x04\xac\x01\x02\x02\x04\x12\x04\xf2+\x02\n\n\x0e\n\x06\x04\xac\x01\x02\
    \x02\x06\x12\x04\xf2+\x0b\x17\n\x0e\n\x06\x04\xac\x01\x02\x02\x01\x12\
    \x04\xf2+\x18%\n\x0e\n\x06\x04\xac\x01\x02\x02\x03\x12\x04\xf2+()\n#\n\
    \x03\x04\xad\x01\x12\x06\xf6+\0\x80,\x01\x1a\x14\x20MultiScopeResponse\n\
    \n\x0c\n\x04\x04\xad\x01\x01\x12\x04\xf6+\x08\x1a\n+\n\x05\x04\xad\x01\
    \x02\0\x12\x04\xf8+\x02(\x1a\x1c\x20The\x20status\x20of\x20the\x20reques\
    t.\n\n\x0e\n\x06\x04\xad\x01\x02\0\x06\x12\x04\xf8+\x02\x1c\n\x0e\n\x06\
    \x04\xad\x01\x02\0\x01\x12\x04\xf8+\x1d#\n\x0e\n\x06\x04\xad\x01\x02\0\
    \x03\x12\x04\xf8+&'\n@\n\x05\x04\xad\x01\x02\x01\x12\x04\xfa+\x02\x1d\
    \x1a1\x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\x20that\x20your\
    \x20key\x20has.\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\x12\x04\xfa+\x02\n\
    \n\x0e\n\x06\x04\xad\x01\x02\x01\x05\x12\x04\xfa+\x0b\x11\n\x0e\n\x06\
    \x04\xad\x01\x02\x01\x01\x12\x04\xfa+\x12\x18\n\x0e\n\x06\x04\xad\x01\
    \x02\x01\x03\x12\x04\xfa+\x1b\x1c\n4\n\x05\x04\xad\x01\x02\x02\x12\x04\
    \xfc+\x02\x0e\x1a%\x20The\x20app\x20that\x20the\x20key\x20has\x20access\
    \x20to.\n\n\x0e\n\x06\x04\xad\x01\x02\x02\x06\x12\x04\xfc+\x02\x05\n\x0e\
    \n\x06\x04\xad\x01\x02\x02\x01\x12\x04\xfc+\x06\t\n\x0e\n\x06\x04\xad\
    \x01\x02\x02\x03\x12\x04\xfc+\x0c\r\nJ\n\x05\x04\xad\x01\x02\x03\x12\x04\
    \xfe+\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoint\x20permi\
    ssions\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xad\x01\x02\x03\
    \x04\x12\x04\xfe+\x02\n\n\x0e\n\x06\x04\xad\x01\x02\x03\x05\x12\x04\xfe+\
    \x0b\x11\n\x0e\n\x06\x04\xad\x01\x02\x03\x01\x12\x04\xfe+\x12\x1b\n\x0e\
    \n\x06\x04\xad\x01\x02\x03\x03\x12\x04\xfe+\x1e\x1f\n\r\n\x05\x04\xad\
    \x01\x02\x04\x12\x04\xff+\x02\x20\n\x0e\n\x06\x04\xad\x01\x02\x04\x05\
    \x12\x04\xff+\x02\x08\n\x0e\n\x06\x04\xad\x01\x02\x04\x01\x12\x04\xff+\t\
    \x1b\n\x0e\n\x06\x04\xad\x01\x02\x04\x03\x12\x04\xff+\x1e\x1f\n'\n\x03\
    \x04\xae\x01\x12\x06\x83,\0\x8b,\x01\x1a\x18\x20MultiScopeUserResponse\n\
    \n\x0c\n\x04\x04\xae\x01\x01\x12\x04\x83,\x08\x1e\n+\n\x05\x04\xae\x01\
    \x02\0\x12\x04\x85,\x02(\x1a\x1c\x20The\x20status\x20of\x20the\x20reques\
    t.\n\n\x0e\n\x06\x04\xae\x01\x02\0\x06\x12\x04\x85,\x02\x1c\n\x0e\n\x06\
    \x04\xae\x01\x02\0\x01\x12\x04\x85,\x1d#\n\x0e\n\x06\x04\xae\x01\x02\0\
    \x03\x12\x04\x85,&'\n@\n\x05\x04\xae\x01\x02\x01\x12\x04\x87,\x02\x1d\
    \x1a1\x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\x20that\x20your\
    \x20key\x20has.\n\n\x0e\n\x06\x04\xae\x01\x02\x01\x04\x12\x04\x87,\x02\n\
    \n\x0e\n\x06\x04\xae\x01\x02\x01\x05\x12\x04\x87,\x0b\x11\n\x0e\n\x06\
    \x04\xae\x01\x02\x01\x01\x12\x04\x87,\x12\x18\n\x0e\n\x06\x04\xae\x01\
    \x02\x01\x03\x12\x04\x87,\x1b\x1c\nJ\n\x05\x04\xae\x01\x02\x02\x12\x04\
    \x89,\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoint\x20permi\
    ssions\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xae\x01\x02\x02\
    \x04\x12\x04\x89,\x02\n\n\x0e\n\x06\x04\xae\x01\x02\x02\x05\x12\x04\x89,\
    \x0b\x11\n\x0e\n\x06\x04\xae\x01\x02\x02\x01\x12\x04\x89,\x12\x1b\n\x0e\
    \n\x06\x04\xae\x01\x02\x02\x03\x12\x04\x89,\x1e\x1f\n\r\n\x05\x04\xae\
    \x01\x02\x03\x12\x04\x8a,\x02\x20\n\x0e\n\x06\x04\xae\x01\x02\x03\x05\
    \x12\x04\x8a,\x02\x08\n\x0e\n\x06\x04\xae\x01\x02\x03\x01\x12\x04\x8a,\t\
    \x1b\n\x0e\n\x06\x04\xae\x01\x02\x03\x03\x12\x04\x8a,\x1e\x1f\n'\n\x03\
    \x04\xaf\x01\x12\x06\x8e,\0\x96,\x01\x1a\x18\x20MultiScopeRootResponse\n\
    \n\x0c\n\x04\x04\xaf\x01\x01\x12\x04\x8e,\x08\x1e\n+\n\x05\x04\xaf\x01\
    \x02\0\x12\x04\x90,\x02(\x1a\x1c\x20The\x20status\x20of\x20the\x20reques\
    t.\n\n\x0e\n\x06\x04\xaf\x01\x02\0\x06\x12\x04\x90,\x02\x1c\n\x0e\n\x06\
    \x04\xaf\x01\x02\0\x01\x12\x04\x90,\x1d#\n\x0e\n\x06\x04\xaf\x01\x02\0\
    \x03\x12\x04\x90,&'\n@\n\x05\x04\xaf\x01\x02\x01\x12\x04\x92,\x02\x1d\
    \x1a1\x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\x20that\x20your\
    \x20key\x20has.\n\n\x0e\n\x06\x04\xaf\x01\x02\x01\x04\x12\x04\x92,\x02\n\
    \n\x0e\n\x06\x04\xaf\x01\x02\x01\x05\x12\x04\x92,\x0b\x11\n\x0e\n\x06\
    \x04\xaf\x01\x02\x01\x01\x12\x04\x92,\x12\x18\n\x0e\n\x06\x04\xaf\x01\
    \x02\x01\x03\x12\x04\x92,\x1b\x1c\nJ\n\x05\x04\xaf\x01\x02\x02\x12\x04\
    \x94,\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoint\x20permi\
    ssions\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xaf\x01\x02\x02\
    \x04\x12\x04\x94,\x02\n\n\x0e\n\x06\x04\xaf\x01\x02\x02\x05\x12\x04\x94,\
    \x0b\x11\n\x0e\n\x06\x04\xaf\x01\x02\x02\x01\x12\x04\x94,\x12\x1b\n\x0e\
    \n\x06\x04\xaf\x01\x02\x02\x03\x12\x04\x94,\x1e\x1f\n\r\n\x05\x04\xaf\
    \x01\x02\x03\x12\x04\x95,\x02\x20\n\x0e\n\x06\x04\xaf\x01\x02\x03\x05\
    \x12\x04\x95,\x02\x08\n\x0e\n\x06\x04\xaf\x01\x02\x03\x01\x12\x04\x95,\t\
    \x1b\n\x0e\n\x06\x04\xaf\x01\x02\x03\x03\x12\x04\x95,\x1e\x1f\n!\n\x03\
    \x04\xb0\x01\x12\x06\x99,\0\x9c,\x01\x1a\x12\x20GetSearchRequest\n\n\x0c\
    \n\x04\x04\xb0\x01\x01\x12\x04\x99,\x08\x18\n\r\n\x05\x04\xb0\x01\x02\0\
    \x12\x04\x9a,\x02,\n\x0e\n\x06\x04\xb0\x01\x02\0\x06\x12\x04\x9a,\x02\
    \x1b\n\x0e\n\x06\x04\xb0\x01\x02\0\x01\x12\x04\x9a,\x1c'\n\x0e\n\x06\x04\
    \xb0\x01\x02\0\x03\x12\x04\x9a,*+\n\r\n\x05\x04\xb0\x01\x02\x01\x12\x04\
    \x9b,\x02\x10\n\x0e\n\x06\x04\xb0\x01\x02\x01\x05\x12\x04\x9b,\x02\x08\n\
    \x0e\n\x06\x04\xb0\x01\x02\x01\x01\x12\x04\x9b,\t\x0b\n\x0e\n\x06\x04\
    \xb0\x01\x02\x01\x03\x12\x04\x9b,\x0e\x0f\n$\n\x03\x04\xb1\x01\x12\x06\
    \x9f,\0\xa7,\x01\x1a\x15\x20ListSearchesRequest\n\n\x0c\n\x04\x04\xb1\
    \x01\x01\x12\x04\x9f,\x08\x1b\n\r\n\x05\x04\xb1\x01\x02\0\x12\x04\xa0,\
    \x02,\n\x0e\n\x06\x04\xb1\x01\x02\0\x06\x12\x04\xa0,\x02\x1b\n\x0e\n\x06\
    \x04\xb1\x01\x02\0\x01\x12\x04\xa0,\x1c'\n\x0e\n\x06\x04\xb1\x01\x02\0\
    \x03\x12\x04\xa0,*+\n\x7f\n\x05\x04\xb1\x01\x02\x01\x12\x04\xa3,\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xb1\x01\x02\x01\x05\x12\
    \x04\xa3,\x02\x08\n\x0e\n\x06\x04\xb1\x01\x02\x01\x01\x12\x04\xa3,\t\r\n\
    \x0e\n\x06\x04\xb1\x01\x02\x01\x03\x12\x04\xa3,\x10\x11\nv\n\x05\x04\xb1\
    \x01\x02\x02\x12\x04\xa6,\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\
    \x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\
    \xb1\x01\x02\x02\x05\x12\x04\xa6,\x02\x08\n\x0e\n\x06\x04\xb1\x01\x02\
    \x02\x01\x12\x04\xa6,\t\x11\n\x0e\n\x06\x04\xb1\x01\x02\x02\x03\x12\x04\
    \xa6,\x14\x15\n$\n\x03\x04\xb2\x01\x12\x06\xaa,\0\xb8,\x01\x1a\x15\x20Po\
    stSearchesRequest\n\n\x0c\n\x04\x04\xb2\x01\x01\x12\x04\xaa,\x08\x1b\n6\
    \n\x05\x04\xb2\x01\x02\0\x12\x04\xac,\x02,\x1a'\x20The\x20user_id\x20and\
    \x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\xb2\x01\x02\0\x06\
    \x12\x04\xac,\x02\x1b\n\x0e\n\x06\x04\xb2\x01\x02\0\x01\x12\x04\xac,\x1c\
    '\n\x0e\n\x06\x04\xb2\x01\x02\0\x03\x12\x04\xac,*+\nk\n\x05\x04\xb2\x01\
    \x02\x01\x12\x04\xb0,\x02$\x1a\\\x20The\x20query;\x20this\x20specifies\
    \x20how\x20the\x20data\x20to\x20be\x20searched\n\x20this\x20will\x20be\
    \x20replaced\x20by\x20\"Searches\"\n\n\x0e\n\x06\x04\xb2\x01\x02\x01\x06\
    \x12\x04\xb0,\x02\x07\n\x0e\n\x06\x04\xb2\x01\x02\x01\x01\x12\x04\xb0,\
    \x08\r\n\x0e\n\x06\x04\xb2\x01\x02\x01\x03\x12\x04\xb0,\x10\x11\n\x0e\n\
    \x06\x04\xb2\x01\x02\x01\x08\x12\x04\xb0,\x12#\n\x0f\n\x07\x04\xb2\x01\
    \x02\x01\x08\x03\x12\x04\xb0,\x13\"\n\x85\x01\n\x05\x04\xb2\x01\x02\x02\
    \x12\x04\xb4,\x02\x1f\x1av\x20The\x20searched\x20to\x20be\x20executed\
    \x20or\x20saved\n\x20Eventually\x20the\x20request\x20level\x20fields\x20\
    will\x20be\x20deprecated\x20in\x20favor\x20of\x20this\x20object\n\n\x0e\
    \n\x06\x04\xb2\x01\x02\x02\x04\x12\x04\xb4,\x02\n\n\x0e\n\x06\x04\xb2\
    \x01\x02\x02\x06\x12\x04\xb4,\x0b\x11\n\x0e\n\x06\x04\xb2\x01\x02\x02\
    \x01\x12\x04\xb4,\x12\x1a\n\x0e\n\x06\x04\xb2\x01\x02\x02\x03\x12\x04\
    \xb4,\x1d\x1e\nO\n\x05\x04\xb2\x01\x02\x03\x12\x04\xb7,\x02\x1c\x1a@\x20\
    Pagination\x20information\x20to\x20paginate\x20through\x20search\x20resu\
    lt\x20Hits.\n\n\x0e\n\x06\x04\xb2\x01\x02\x03\x06\x12\x04\xb7,\x02\x0c\n\
    \x0e\n\x06\x04\xb2\x01\x02\x03\x01\x12\x04\xb7,\r\x17\n\x0e\n\x06\x04\
    \xb2\x01\x02\x03\x03\x12\x04\xb7,\x1a\x1b\n\r\n\x03\x04\xb3\x01\x12\x06\
    \xba,\0\xc4,\x01\n\x0c\n\x04\x04\xb3\x01\x01\x12\x04\xba,\x08\"\n6\n\x05\
    \x04\xb3\x01\x02\0\x12\x04\xbc,\x02,\x1a'\x20The\x20user_id\x20and\x20ap\
    p_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\xb3\x01\x02\0\x06\x12\x04\
    \xbc,\x02\x1b\n\x0e\n\x06\x04\xb3\x01\x02\0\x01\x12\x04\xbc,\x1c'\n\x0e\
    \n\x06\x04\xb3\x01\x02\0\x03\x12\x04\xbc,*+\n+\n\x05\x04\xb3\x01\x02\x01\
    \x12\x04\xbf,\x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\
    \n\n\x0e\n\x06\x04\xb3\x01\x02\x01\x04\x12\x04\xbf,\x02\n\n\x0e\n\x06\
    \x04\xb3\x01\x02\x01\x06\x12\x04\xbf,\x0b\x11\n\x0e\n\x06\x04\xb3\x01\
    \x02\x01\x01\x12\x04\xbf,\x12\x1a\n\x0e\n\x06\x04\xb3\x01\x02\x01\x03\
    \x12\x04\xbf,\x1d\x1e\nr\n\x05\x04\xb3\x01\x02\x02\x12\x04\xc3,\x02\x14\
    \x1ac\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20Searc\
    h\x20objects\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20s\
    upported\n\n\x0e\n\x06\x04\xb3\x01\x02\x02\x05\x12\x04\xc3,\x02\x08\n\
    \x0e\n\x06\x04\xb3\x01\x02\x02\x01\x12\x04\xc3,\t\x0f\n\x0e\n\x06\x04\
    \xb3\x01\x02\x02\x03\x12\x04\xc3,\x12\x13\n\r\n\x03\x04\xb4\x01\x12\x06\
    \xc6,\0\xd0,\x01\n\x0c\n\x04\x04\xb4\x01\x01\x12\x04\xc6,\x08'\n6\n\x05\
    \x04\xb4\x01\x02\0\x12\x04\xc8,\x02,\x1a'\x20The\x20user_id\x20and\x20ap\
    p_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\xb4\x01\x02\0\x06\x12\x04\
    \xc8,\x02\x1b\n\x0e\n\x06\x04\xb4\x01\x02\0\x01\x12\x04\xc8,\x1c'\n\x0e\
    \n\x06\x04\xb4\x01\x02\0\x03\x12\x04\xc8,*+\n+\n\x05\x04\xb4\x01\x02\x01\
    \x12\x04\xcb,\x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\
    \n\n\x0e\n\x06\x04\xb4\x01\x02\x01\x04\x12\x04\xcb,\x02\n\n\x0e\n\x06\
    \x04\xb4\x01\x02\x01\x06\x12\x04\xcb,\x0b\x11\n\x0e\n\x06\x04\xb4\x01\
    \x02\x01\x01\x12\x04\xcb,\x12\x1a\n\x0e\n\x06\x04\xb4\x01\x02\x01\x03\
    \x12\x04\xcb,\x1d\x1e\nr\n\x05\x04\xb4\x01\x02\x02\x12\x04\xcf,\x02\x14\
    \x1ac\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20Searc\
    h\x20objects\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20s\
    upported\n\n\x0e\n\x06\x04\xb4\x01\x02\x02\x05\x12\x04\xcf,\x02\x08\n\
    \x0e\n\x06\x04\xb4\x01\x02\x02\x01\x12\x04\xcf,\t\x0f\n\x0e\n\x06\x04\
    \xb4\x01\x02\x02\x03\x12\x04\xcf,\x12\x13\n%\n\x03\x04\xb5\x01\x12\x06\
    \xd3,\0\xdd,\x01\x1a\x16\x20PatchSearchesRequest\n\n\x0c\n\x04\x04\xb5\
    \x01\x01\x12\x04\xd3,\x08\x1c\n6\n\x05\x04\xb5\x01\x02\0\x12\x04\xd5,\
    \x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\
    \n\x0e\n\x06\x04\xb5\x01\x02\0\x06\x12\x04\xd5,\x02\x1b\n\x0e\n\x06\x04\
    \xb5\x01\x02\0\x01\x12\x04\xd5,\x1c'\n\x0e\n\x06\x04\xb5\x01\x02\0\x03\
    \x12\x04\xd5,*+\n+\n\x05\x04\xb5\x01\x02\x01\x12\x04\xd8,\x02\x1f\x1a\
    \x1c\x20The\x20searches\x20to\x20be\x20patched\n\n\x0e\n\x06\x04\xb5\x01\
    \x02\x01\x04\x12\x04\xd8,\x02\n\n\x0e\n\x06\x04\xb5\x01\x02\x01\x06\x12\
    \x04\xd8,\x0b\x11\n\x0e\n\x06\x04\xb5\x01\x02\x01\x01\x12\x04\xd8,\x12\
    \x1a\n\x0e\n\x06\x04\xb5\x01\x02\x01\x03\x12\x04\xd8,\x1d\x1e\nr\n\x05\
    \x04\xb5\x01\x02\x02\x12\x04\xdc,\x02\x14\x1ac\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20Search\x20objects\n\x20For\x20now\
    \x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\
    \xb5\x01\x02\x02\x05\x12\x04\xdc,\x02\x08\n\x0e\n\x06\x04\xb5\x01\x02\
    \x02\x01\x12\x04\xdc,\t\x0f\n\x0e\n\x06\x04\xb5\x01\x02\x02\x03\x12\x04\
    \xdc,\x12\x13\n`\n\x03\x04\xb6\x01\x12\x06\xe0,\0\xe8,\x01\x1aQ\x20PostS\
    earchesByIDRequest\x20performs\x20returns\x20results\x20of\x20a\x20saved\
    \x20search\x20given\x20its\x20ID\n\n\x0c\n\x04\x04\xb6\x01\x01\x12\x04\
    \xe0,\x08\x1f\n\r\n\x05\x04\xb6\x01\x02\0\x12\x04\xe1,\x02,\n\x0e\n\x06\
    \x04\xb6\x01\x02\0\x06\x12\x04\xe1,\x02\x1b\n\x0e\n\x06\x04\xb6\x01\x02\
    \0\x01\x12\x04\xe1,\x1c'\n\x0e\n\x06\x04\xb6\x01\x02\0\x03\x12\x04\xe1,*\
    +\n3\n\x05\x04\xb6\x01\x02\x01\x12\x04\xe4,\x02\x10\x1a$\x20ID\x20for\
    \x20saves\x20search\x20to\x20be\x20executed\n\n\x0e\n\x06\x04\xb6\x01\
    \x02\x01\x05\x12\x04\xe4,\x02\x08\n\x0e\n\x06\x04\xb6\x01\x02\x01\x01\
    \x12\x04\xe4,\t\x0b\n\x0e\n\x06\x04\xb6\x01\x02\x01\x03\x12\x04\xe4,\x0e\
    \x0f\nO\n\x05\x04\xb6\x01\x02\x02\x12\x04\xe7,\x02\x1c\x1a@\x20Paginatio\
    n\x20information\x20to\x20paginate\x20through\x20search\x20result\x20Hit\
    s.\n\n\x0e\n\x06\x04\xb6\x01\x02\x02\x06\x12\x04\xe7,\x02\x0c\n\x0e\n\
    \x06\x04\xb6\x01\x02\x02\x01\x12\x04\xe7,\r\x17\n\x0e\n\x06\x04\xb6\x01\
    \x02\x02\x03\x12\x04\xe7,\x1a\x1b\n$\n\x03\x04\xb7\x01\x12\x06\xeb,\0\
    \xee,\x01\x1a\x15\x20DeleteSearchRequest\n\n\x0c\n\x04\x04\xb7\x01\x01\
    \x12\x04\xeb,\x08\x1b\n\r\n\x05\x04\xb7\x01\x02\0\x12\x04\xec,\x02,\n\
    \x0e\n\x06\x04\xb7\x01\x02\0\x06\x12\x04\xec,\x02\x1b\n\x0e\n\x06\x04\
    \xb7\x01\x02\0\x01\x12\x04\xec,\x1c'\n\x0e\n\x06\x04\xb7\x01\x02\0\x03\
    \x12\x04\xec,*+\n\r\n\x05\x04\xb7\x01\x02\x01\x12\x04\xed,\x02\x10\n\x0e\
    \n\x06\x04\xb7\x01\x02\x01\x05\x12\x04\xed,\x02\x08\n\x0e\n\x06\x04\xb7\
    \x01\x02\x01\x01\x12\x04\xed,\t\x0b\n\x0e\n\x06\x04\xb7\x01\x02\x01\x03\
    \x12\x04\xed,\x0e\x0f\n\x87\x01\n\x03\x04\xb8\x01\x12\x06\xf3,\0\xfc,\
    \x01\x1ax\x20Execute\x20a\x20new\x20annotation\x20search\x20and\x20optio\
    nally\x20save\x20it\n\x20annotation\x20search\x20over\x20annotations\x20\
    using\x20rank\x20and\x20filter\x20proto\n\n\x0c\n\x04\x04\xb8\x01\x01\
    \x12\x04\xf3,\x08&\n6\n\x05\x04\xb8\x01\x02\0\x12\x04\xf5,\x02,\x1a'\x20\
    The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\
    \x04\xb8\x01\x02\0\x06\x12\x04\xf5,\x02\x1b\n\x0e\n\x06\x04\xb8\x01\x02\
    \0\x01\x12\x04\xf5,\x1c'\n\x0e\n\x06\x04\xb8\x01\x02\0\x03\x12\x04\xf5,*\
    +\n5\n\x05\x04\xb8\x01\x02\x01\x12\x04\xf8,\x02\x1f\x1a&\x20The\x20searc\
    hed\x20to\x20be\x20executed\x20or\x20saved\n\n\x0e\n\x06\x04\xb8\x01\x02\
    \x01\x04\x12\x04\xf8,\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x01\x06\x12\x04\
    \xf8,\x0b\x11\n\x0e\n\x06\x04\xb8\x01\x02\x01\x01\x12\x04\xf8,\x12\x1a\n\
    \x0e\n\x06\x04\xb8\x01\x02\x01\x03\x12\x04\xf8,\x1d\x1e\nO\n\x05\x04\xb8\
    \x01\x02\x02\x12\x04\xfb,\x02\x1c\x1a@\x20Pagination\x20information\x20t\
    o\x20paginate\x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\
    \xb8\x01\x02\x02\x06\x12\x04\xfb,\x02\x0c\n\x0e\n\x06\x04\xb8\x01\x02\
    \x02\x01\x12\x04\xfb,\r\x17\n\x0e\n\x06\x04\xb8\x01\x02\x02\x03\x12\x04\
    \xfb,\x1a\x1b\n5\n\x03\x04\xb9\x01\x12\x06\xff,\0\x82-\x01\x1a&\x20Delet\
    eAnnotationSearchMetricsRequest\n\n\x0c\n\x04\x04\xb9\x01\x01\x12\x04\
    \xff,\x08,\n\r\n\x05\x04\xb9\x01\x02\0\x12\x04\x80-\x02,\n\x0e\n\x06\x04\
    \xb9\x01\x02\0\x06\x12\x04\x80-\x02\x1b\n\x0e\n\x06\x04\xb9\x01\x02\0\
    \x01\x12\x04\x80-\x1c'\n\x0e\n\x06\x04\xb9\x01\x02\0\x03\x12\x04\x80-*+\
    \n\r\n\x05\x04\xb9\x01\x02\x01\x12\x04\x81-\x02\x10\n\x0e\n\x06\x04\xb9\
    \x01\x02\x01\x05\x12\x04\x81-\x02\x08\n\x0e\n\x06\x04\xb9\x01\x02\x01\
    \x01\x12\x04\x81-\t\x0b\n\x0e\n\x06\x04\xb9\x01\x02\x01\x03\x12\x04\x81-\
    \x0e\x0f\nB\n\x03\x04\xba\x01\x12\x06\x85-\0\x92-\x01\x1a3\x20Execute\
    \x20a\x20new\x20input\x20search\x20and\x20optionally\x20save\x20it\n\n\
    \x0c\n\x04\x04\xba\x01\x01\x12\x04\x85-\x08!\n6\n\x05\x04\xba\x01\x02\0\
    \x12\x04\x87-\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20quer\
    y\x20from.\n\n\x0e\n\x06\x04\xba\x01\x02\0\x06\x12\x04\x87-\x02\x1b\n\
    \x0e\n\x06\x04\xba\x01\x02\0\x01\x12\x04\x87-\x1c'\n\x0e\n\x06\x04\xba\
    \x01\x02\0\x03\x12\x04\x87-*+\n5\n\x05\x04\xba\x01\x02\x01\x12\x04\x8a-\
    \x02\x1f\x1a&\x20The\x20searched\x20to\x20be\x20executed\x20or\x20saved\
    \n\n\x0e\n\x06\x04\xba\x01\x02\x01\x04\x12\x04\x8a-\x02\n\n\x0e\n\x06\
    \x04\xba\x01\x02\x01\x06\x12\x04\x8a-\x0b\x11\n\x0e\n\x06\x04\xba\x01\
    \x02\x01\x01\x12\x04\x8a-\x12\x1a\n\x0e\n\x06\x04\xba\x01\x02\x01\x03\
    \x12\x04\x8a-\x1d\x1e\nO\n\x05\x04\xba\x01\x02\x02\x12\x04\x8d-\x02\x1c\
    \x1a@\x20Pagination\x20information\x20to\x20paginate\x20through\x20searc\
    h\x20result\x20Hits.\n\n\x0e\n\x06\x04\xba\x01\x02\x02\x06\x12\x04\x8d-\
    \x02\x0c\n\x0e\n\x06\x04\xba\x01\x02\x02\x01\x12\x04\x8d-\r\x17\n\x0e\n\
    \x06\x04\xba\x01\x02\x02\x03\x12\x04\x8d-\x1a\x1b\nh\n\x05\x04\xba\x01\
    \x02\x03\x12\x04\x91-\x02\x16\x1aY\x20If\x20only_count\x20is\x20set,\x20\
    then\x20the\x20response\x20will\x20not\x20contain\x20hits,\n\x20but\x20h\
    it_counts\x20instead.\n\n\x0e\n\x06\x04\xba\x01\x02\x03\x05\x12\x04\x91-\
    \x02\x06\n\x0e\n\x06\x04\xba\x01\x02\x03\x01\x12\x04\x91-\x07\x11\n\x0e\
    \n\x06\x04\xba\x01\x02\x03\x03\x12\x04\x91-\x14\x15\nZ\n\x03\x04\xbb\x01\
    \x12\x06\x95-\0\x99-\x01\x1aK\x20SingleSearchResponse\x20returns\x20save\
    d\x20search\x20in\x20response\x20to\x20GetSearchRequest\n\n\x0c\n\x04\
    \x04\xbb\x01\x01\x12\x04\x95-\x08\x1c\n=\n\x05\x04\xbb\x01\x02\0\x12\x04\
    \x97-\x02(\x1a.\x20Status\x20of\x20whether\x20the\x20search\x20was\x20su\
    ccessful.\n\n\x0e\n\x06\x04\xbb\x01\x02\0\x06\x12\x04\x97-\x02\x1c\n\x0e\
    \n\x06\x04\xbb\x01\x02\0\x01\x12\x04\x97-\x1d#\n\x0e\n\x06\x04\xbb\x01\
    \x02\0\x03\x12\x04\x97-&'\n\r\n\x05\x04\xbb\x01\x02\x01\x12\x04\x98-\x02\
    \x14\n\x0e\n\x06\x04\xbb\x01\x02\x01\x06\x12\x04\x98-\x02\x08\n\x0e\n\
    \x06\x04\xbb\x01\x02\x01\x01\x12\x04\x98-\t\x0f\n\x0e\n\x06\x04\xbb\x01\
    \x02\x01\x03\x12\x04\x98-\x12\x13\n$\n\x03\x04\xbc\x01\x12\x06\x9c-\0\
    \xaf-\x01\x1a\x15\x20MultiSearchResponse\n\n\x0c\n\x04\x04\xbc\x01\x01\
    \x12\x04\x9c-\x08\x1b\n=\n\x05\x04\xbc\x01\x02\0\x12\x04\x9e-\x02(\x1a.\
    \x20Status\x20of\x20whether\x20the\x20search\x20was\x20successful.\n\n\
    \x0e\n\x06\x04\xbc\x01\x02\0\x06\x12\x04\x9e-\x02\x1c\n\x0e\n\x06\x04\
    \xbc\x01\x02\0\x01\x12\x04\x9e-\x1d#\n\x0e\n\x06\x04\xbc\x01\x02\0\x03\
    \x12\x04\x9e-&'\n?\n\x05\x04\xbc\x01\x02\x01\x12\x04\xa1-\x02\x10\x1a0\
    \x20A\x20unique\x20id\x20which\x20uniquely\x20identifies\x20a\x20search\
    \n\n\x0e\n\x06\x04\xbc\x01\x02\x01\x05\x12\x04\xa1-\x02\x08\n\x0e\n\x06\
    \x04\xbc\x01\x02\x01\x01\x12\x04\xa1-\t\x0b\n\x0e\n\x06\x04\xbc\x01\x02\
    \x01\x03\x12\x04\xa1-\x0e\x0f\n0\n\x05\x04\xbc\x01\x02\x02\x12\x04\xa4-\
    \x02G\x1a!\x20The\x20list\x20of\x20search\x20result\x20Hits.\n\n\x0e\n\
    \x06\x04\xbc\x01\x02\x02\x04\x12\x04\xa4-\x02\n\n\x0e\n\x06\x04\xbc\x01\
    \x02\x02\x06\x12\x04\xa4-\x0b\x0e\n\x0e\n\x06\x04\xbc\x01\x02\x02\x01\
    \x12\x04\xa4-\x0f\x13\n\x0e\n\x06\x04\xbc\x01\x02\x02\x03\x12\x04\xa4-\
    \x16\x17\n\x0e\n\x06\x04\xbc\x01\x02\x02\x08\x12\x04\xa4-\x18F\n\x11\n\t\
    \x04\xbc\x01\x02\x02\x08\xd0\x86\x03\x12\x04\xa4-\x19E\n<\n\x05\x04\xbc\
    \x01\x02\x03\x12\x04\xa7-\x02\x12\x1a-\x20The\x20original\x20query\x20pr\
    ovided\x20in\x20the\x20request.\n\n\x0e\n\x06\x04\xbc\x01\x02\x03\x06\
    \x12\x04\xa7-\x02\x07\n\x0e\n\x06\x04\xbc\x01\x02\x03\x01\x12\x04\xa7-\
    \x08\r\n\x0e\n\x06\x04\xbc\x01\x02\x03\x03\x12\x04\xa7-\x10\x11\n?\n\x05\
    \x04\xbc\x01\x02\x04\x12\x04\xaa-\x02\x1f\x1a0\x20The\x20original\x20Sea\
    rches\x20provided\x20in\x20the\x20request.\n\n\x0e\n\x06\x04\xbc\x01\x02\
    \x04\x04\x12\x04\xaa-\x02\n\n\x0e\n\x06\x04\xbc\x01\x02\x04\x06\x12\x04\
    \xaa-\x0b\x11\n\x0e\n\x06\x04\xbc\x01\x02\x04\x01\x12\x04\xaa-\x12\x1a\n\
    \x0e\n\x06\x04\xbc\x01\x02\x04\x03\x12\x04\xaa-\x1d\x1e\n\x81\x01\n\x05\
    \x04\xbc\x01\x02\x05\x12\x04\xae-\x02#\x1ar\x20The\x20counts\x20of\x20hi\
    ts\x20for\x20each\x20search,\x20in\x20the\x20same\x20order\x20as\x20sear\
    ches.\n\x20Only\x20returned\x20if\x20the\x20request\x20set\x20only_count\
    .\n\n\x0e\n\x06\x04\xbc\x01\x02\x05\x04\x12\x04\xae-\x02\n\n\x0e\n\x06\
    \x04\xbc\x01\x02\x05\x06\x12\x04\xae-\x0b\x13\n\x0e\n\x06\x04\xbc\x01\
    \x02\x05\x01\x12\x04\xae-\x14\x1e\n\x0e\n\x06\x04\xbc\x01\x02\x05\x03\
    \x12\x04\xae-!\"\n3\n\x03\x04\xbd\x01\x12\x06\xb2-\0\xc4-\x01\x1a$\x20Po\
    stAnnotationSearchMetricsRequest\n\n\x0c\n\x04\x04\xbd\x01\x01\x12\x04\
    \xb2-\x08*\n\r\n\x05\x04\xbd\x01\x02\0\x12\x04\xb3-\x02,\n\x0e\n\x06\x04\
    \xbd\x01\x02\0\x06\x12\x04\xb3-\x02\x1b\n\x0e\n\x06\x04\xbd\x01\x02\0\
    \x01\x12\x04\xb3-\x1c'\n\x0e\n\x06\x04\xbd\x01\x02\0\x03\x12\x04\xb3-*+\
    \nJ\n\x05\x04\xbd\x01\x02\x01\x12\x04\xb6-\x02\x10\x1a;\x20A\x20unique\
    \x20customer\x20facing\x20id\x20to\x20identify\x20this\x20eval\x20reques\
    t\n\n\x0e\n\x06\x04\xbd\x01\x02\x01\x05\x12\x04\xb6-\x02\x08\n\x0e\n\x06\
    \x04\xbd\x01\x02\x01\x01\x12\x04\xb6-\t\x0b\n\x0e\n\x06\x04\xbd\x01\x02\
    \x01\x03\x12\x04\xb6-\x0e\x0f\n;\n\x05\x04\xbd\x01\x02\x02\x12\x04\xb9-\
    \x02'\x1a,\x20The\x20ground\x20truth\x20we\x20are\x20evaluating\x20again\
    st\n\n\x0e\n\x06\x04\xbd\x01\x02\x02\x06\x12\x04\xb9-\x02\x15\n\x0e\n\
    \x06\x04\xbd\x01\x02\x02\x01\x12\x04\xb9-\x16\"\n\x0e\n\x06\x04\xbd\x01\
    \x02\x02\x03\x12\x04\xb9-%&\n*\n\x05\x04\xbd\x01\x02\x03\x12\x04\xbc-\
    \x02)\x1a\x1b\x20The\x20set\x20we\x20are\x20evaluating\n\n\x0e\n\x06\x04\
    \xbd\x01\x02\x03\x06\x12\x04\xbc-\x02\x15\n\x0e\n\x06\x04\xbd\x01\x02\
    \x03\x01\x12\x04\xbc-\x16$\n\x0e\n\x06\x04\xbd\x01\x02\x03\x03\x12\x04\
    \xbc-'(\ny\n\x05\x04\xbd\x01\x02\x04\x12\x04\xc0-\x02\x10\x1aj\x20List\
    \x20of\x20concepts\x20to\x20evaluate\x20are\x20expected\x20to\x20be\x20i\
    n\x20data.concepts\n\x20If\x20nil,\x20then\x20all\x20app\x20concepts\x20\
    are\x20used\n\n\x0e\n\x06\x04\xbd\x01\x02\x04\x06\x12\x04\xc0-\x02\x06\n\
    \x0e\n\x06\x04\xbd\x01\x02\x04\x01\x12\x04\xc0-\x07\x0b\n\x0e\n\x06\x04\
    \xbd\x01\x02\x04\x03\x12\x04\xc0-\x0e\x0f\n.\n\x05\x04\xbd\x01\x02\x05\
    \x12\x04\xc3-\x02%\x1a\x1f\x20The\x20type\x20of\x20evaluation\x20to\x20u\
    se\n\n\x0e\n\x06\x04\xbd\x01\x02\x05\x06\x12\x04\xc3-\x02\x10\n\x0e\n\
    \x06\x04\xbd\x01\x02\x05\x01\x12\x04\xc3-\x11\x20\n\x0e\n\x06\x04\xbd\
    \x01\x02\x05\x03\x12\x04\xc3-#$\n2\n\x03\x04\xbe\x01\x12\x06\xc7-\0\xcc-\
    \x01\x1a#\x20GetAnnotationSearchMetricsRequest\n\n\x0c\n\x04\x04\xbe\x01\
    \x01\x12\x04\xc7-\x08)\n\r\n\x05\x04\xbe\x01\x02\0\x12\x04\xc8-\x02,\n\
    \x0e\n\x06\x04\xbe\x01\x02\0\x06\x12\x04\xc8-\x02\x1b\n\x0e\n\x06\x04\
    \xbe\x01\x02\0\x01\x12\x04\xc8-\x1c'\n\x0e\n\x06\x04\xbe\x01\x02\0\x03\
    \x12\x04\xc8-*+\nH\n\x05\x04\xbe\x01\x02\x01\x12\x04\xcb-\x02\x10\x1a9\
    \x20Unique\x20custom\x20facing\x20id\x20that\x20identifies\x20the\x20eva\
    l\x20to\x20get\n\n\x0e\n\x06\x04\xbe\x01\x02\x01\x05\x12\x04\xcb-\x02\
    \x08\n\x0e\n\x06\x04\xbe\x01\x02\x01\x01\x12\x04\xcb-\t\x0b\n\x0e\n\x06\
    \x04\xbe\x01\x02\x01\x03\x12\x04\xcb-\x0e\x0f\n3\n\x03\x04\xbf\x01\x12\
    \x06\xcf-\0\xd1-\x01\x1a$\x20ListAnnotationSearchMetricsRequest\n\n\x0c\
    \n\x04\x04\xbf\x01\x01\x12\x04\xcf-\x08*\n\r\n\x05\x04\xbf\x01\x02\0\x12\
    \x04\xd0-\x02,\n\x0e\n\x06\x04\xbf\x01\x02\0\x06\x12\x04\xd0-\x02\x1b\n\
    \x0e\n\x06\x04\xbf\x01\x02\0\x01\x12\x04\xd0-\x1c'\n\x0e\n\x06\x04\xbf\
    \x01\x02\0\x03\x12\x04\xd0-*+\n5\n\x03\x04\xc0\x01\x12\x06\xd4-\0\xd8-\
    \x01\x1a&\x20MultiAnnotationSearchMetricsResponse\n\n\x0c\n\x04\x04\xc0\
    \x01\x01\x12\x04\xd4-\x08,\n&\n\x05\x04\xc0\x01\x02\0\x12\x04\xd6-\x02(\
    \x1a\x17\x20Status\x20of\x20the\x20request\n\n\x0e\n\x06\x04\xc0\x01\x02\
    \0\x06\x12\x04\xd6-\x02\x1c\n\x0e\n\x06\x04\xc0\x01\x02\0\x01\x12\x04\
    \xd6-\x1d#\n\x0e\n\x06\x04\xc0\x01\x02\0\x03\x12\x04\xd6-&'\n\r\n\x05\
    \x04\xc0\x01\x02\x01\x12\x04\xd7-\x02A\n\x0e\n\x06\x04\xc0\x01\x02\x01\
    \x04\x12\x04\xd7-\x02\n\n\x0e\n\x06\x04\xc0\x01\x02\x01\x06\x12\x04\xd7-\
    \x0b\"\n\x0e\n\x06\x04\xc0\x01\x02\x01\x01\x12\x04\xd7-#<\n\x0e\n\x06\
    \x04\xc0\x01\x02\x01\x03\x12\x04\xd7-?@\n-\n\x03\x04\xc1\x01\x12\x06\xdb\
    -\0\xe3-\x01\x1a\x1e\x20ListAnnotationFiltersRequest\n\n\x0c\n\x04\x04\
    \xc1\x01\x01\x12\x04\xdb-\x08$\n\r\n\x05\x04\xc1\x01\x02\0\x12\x04\xdc-\
    \x02,\n\x0e\n\x06\x04\xc1\x01\x02\0\x06\x12\x04\xdc-\x02\x1b\n\x0e\n\x06\
    \x04\xc1\x01\x02\0\x01\x12\x04\xdc-\x1c'\n\x0e\n\x06\x04\xc1\x01\x02\0\
    \x03\x12\x04\xdc-*+\n\x7f\n\x05\x04\xc1\x01\x02\x01\x12\x04\xdf-\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xc1\x01\x02\x01\x05\x12\
    \x04\xdf-\x02\x08\n\x0e\n\x06\x04\xc1\x01\x02\x01\x01\x12\x04\xdf-\t\r\n\
    \x0e\n\x06\x04\xc1\x01\x02\x01\x03\x12\x04\xdf-\x10\x11\nv\n\x05\x04\xc1\
    \x01\x02\x02\x12\x04\xe2-\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\
    \x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\
    \xc1\x01\x02\x02\x05\x12\x04\xe2-\x02\x08\n\x0e\n\x06\x04\xc1\x01\x02\
    \x02\x01\x12\x04\xe2-\t\x11\n\x0e\n\x06\x04\xc1\x01\x02\x02\x03\x12\x04\
    \xe2-\x14\x15\n+\n\x03\x04\xc2\x01\x12\x06\xe6-\0\xeb-\x01\x1a\x1c\x20Ge\
    tAnnotationFilterRequest\n\n\x0c\n\x04\x04\xc2\x01\x01\x12\x04\xe6-\x08\
    \"\n\r\n\x05\x04\xc2\x01\x02\0\x12\x04\xe7-\x02,\n\x0e\n\x06\x04\xc2\x01\
    \x02\0\x06\x12\x04\xe7-\x02\x1b\n\x0e\n\x06\x04\xc2\x01\x02\0\x01\x12\
    \x04\xe7-\x1c'\n\x0e\n\x06\x04\xc2\x01\x02\0\x03\x12\x04\xe7-*+\n2\n\x05\
    \x04\xc2\x01\x02\x01\x12\x04\xea-\x02\"\x1a#\x20Identify\x20annotation\
    \x20filter\x20by\x20id.\n\n\x0e\n\x06\x04\xc2\x01\x02\x01\x05\x12\x04\
    \xea-\x02\x08\n\x0e\n\x06\x04\xc2\x01\x02\x01\x01\x12\x04\xea-\t\x1d\n\
    \x0e\n\x06\x04\xc2\x01\x02\x01\x03\x12\x04\xea-\x20!\n?\n\x03\x04\xc3\
    \x01\x12\x06\xee-\0\xf3-\x01\x1a0\x20Request\x20to\x20add\x20one\x20or\
    \x20more\x20annotation\x20filters.\n\n\x0c\n\x04\x04\xc3\x01\x01\x12\x04\
    \xee-\x08$\n\r\n\x05\x04\xc3\x01\x02\0\x12\x04\xef-\x02,\n\x0e\n\x06\x04\
    \xc3\x01\x02\0\x06\x12\x04\xef-\x02\x1b\n\x0e\n\x06\x04\xc3\x01\x02\0\
    \x01\x12\x04\xef-\x1c'\n\x0e\n\x06\x04\xc3\x01\x02\0\x03\x12\x04\xef-*+\
    \nK\n\x05\x04\xc3\x01\x02\x01\x12\x04\xf2-\x023\x1a<\x20List\x20of\x20an\
    notation\x20filters\x20that\x20are\x20requested\x20to\x20be\x20added.\n\
    \n\x0e\n\x06\x04\xc3\x01\x02\x01\x04\x12\x04\xf2-\x02\n\n\x0e\n\x06\x04\
    \xc3\x01\x02\x01\x06\x12\x04\xf2-\x0b\x1b\n\x0e\n\x06\x04\xc3\x01\x02\
    \x01\x01\x12\x04\xf2-\x1c.\n\x0e\n\x06\x04\xc3\x01\x02\x01\x03\x12\x04\
    \xf2-12\n=\n\x03\x04\xc4\x01\x12\x06\xf6-\0\xff-\x01\x1a.\x20Request\x20\
    to\x20patch\x20several\x20annotation\x20filters.\n\n\x0c\n\x04\x04\xc4\
    \x01\x01\x12\x04\xf6-\x08%\n\r\n\x05\x04\xc4\x01\x02\0\x12\x04\xf7-\x02,\
    \n\x0e\n\x06\x04\xc4\x01\x02\0\x06\x12\x04\xf7-\x02\x1b\n\x0e\n\x06\x04\
    \xc4\x01\x02\0\x01\x12\x04\xf7-\x1c'\n\x0e\n\x06\x04\xc4\x01\x02\0\x03\
    \x12\x04\xf7-*+\nM\n\x05\x04\xc4\x01\x02\x01\x12\x04\xfa-\x023\x1a>\x20L\
    ist\x20of\x20annotation\x20filters\x20that\x20are\x20requested\x20to\x20\
    be\x20updated.\n\n\x0e\n\x06\x04\xc4\x01\x02\x01\x04\x12\x04\xfa-\x02\n\
    \n\x0e\n\x06\x04\xc4\x01\x02\x01\x06\x12\x04\xfa-\x0b\x1b\n\x0e\n\x06\
    \x04\xc4\x01\x02\x01\x01\x12\x04\xfa-\x1c.\n\x0e\n\x06\x04\xc4\x01\x02\
    \x01\x03\x12\x04\xfa-12\nl\n\x05\x04\xc4\x01\x02\x02\x12\x04\xfe-\x02\
    \x14\x1a]\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20o\
    bjects\n\x20For\x20now,\x20only\x20'overwrite'\x20action\x20is\x20suppor\
    ted\n\n\x0e\n\x06\x04\xc4\x01\x02\x02\x05\x12\x04\xfe-\x02\x08\n\x0e\n\
    \x06\x04\xc4\x01\x02\x02\x01\x12\x04\xfe-\t\x0f\n\x0e\n\x06\x04\xc4\x01\
    \x02\x02\x03\x12\x04\xfe-\x12\x13\nM\n\x03\x04\xc5\x01\x12\x06\x82.\0\
    \x87.\x01\x1a>\x20Request\x20to\x20delete\x20several\x20annotation\x20fi\
    lters\x20by\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xc5\x01\x01\x12\x04\
    \x82.\x08&\n\r\n\x05\x04\xc5\x01\x02\0\x12\x04\x83.\x02,\n\x0e\n\x06\x04\
    \xc5\x01\x02\0\x06\x12\x04\x83.\x02\x1b\n\x0e\n\x06\x04\xc5\x01\x02\0\
    \x01\x12\x04\x83.\x1c'\n\x0e\n\x06\x04\xc5\x01\x02\0\x03\x12\x04\x83.*+\
    \n1\n\x05\x04\xc5\x01\x02\x01\x12\x04\x86.\x02,\x1a\"\x20Specify\x20whic\
    h\x20filters\x20to\x20delete.\n\n\x0e\n\x06\x04\xc5\x01\x02\x01\x04\x12\
    \x04\x86.\x02\n\n\x0e\n\x06\x04\xc5\x01\x02\x01\x05\x12\x04\x86.\x0b\x11\
    \n\x0e\n\x06\x04\xc5\x01\x02\x01\x01\x12\x04\x86.\x12'\n\x0e\n\x06\x04\
    \xc5\x01\x02\x01\x03\x12\x04\x86.*+\n.\n\x03\x04\xc6\x01\x12\x06\x8a.\0\
    \x8e.\x01\x1a\x1f\x20MultiAnnotationFilterResponse\n\n\x0c\n\x04\x04\xc6\
    \x01\x01\x12\x04\x8a.\x08%\n\r\n\x05\x04\xc6\x01\x02\0\x12\x04\x8b.\x02(\
    \n\x0e\n\x06\x04\xc6\x01\x02\0\x06\x12\x04\x8b.\x02\x1c\n\x0e\n\x06\x04\
    \xc6\x01\x02\0\x01\x12\x04\x8b.\x1d#\n\x0e\n\x06\x04\xc6\x01\x02\0\x03\
    \x12\x04\x8b.&'\n\r\n\x05\x04\xc6\x01\x02\x01\x12\x04\x8d.\x02b\n\x0e\n\
    \x06\x04\xc6\x01\x02\x01\x04\x12\x04\x8d.\x02\n\n\x0e\n\x06\x04\xc6\x01\
    \x02\x01\x06\x12\x04\x8d.\x0b\x1b\n\x0e\n\x06\x04\xc6\x01\x02\x01\x01\
    \x12\x04\x8d.\x1c.\n\x0e\n\x06\x04\xc6\x01\x02\x01\x03\x12\x04\x8d.12\n\
    \x0e\n\x06\x04\xc6\x01\x02\x01\x08\x12\x04\x8d.3a\n\x11\n\t\x04\xc6\x01\
    \x02\x01\x08\xd0\x86\x03\x12\x04\x8d.4`\n/\n\x03\x04\xc7\x01\x12\x06\x91\
    .\0\x95.\x01\x1a\x20\x20SingleAnnotationFilterResponse\n\n\x0c\n\x04\x04\
    \xc7\x01\x01\x12\x04\x91.\x08&\n\r\n\x05\x04\xc7\x01\x02\0\x12\x04\x92.\
    \x02(\n\x0e\n\x06\x04\xc7\x01\x02\0\x06\x12\x04\x92.\x02\x1c\n\x0e\n\x06\
    \x04\xc7\x01\x02\0\x01\x12\x04\x92.\x1d#\n\x0e\n\x06\x04\xc7\x01\x02\0\
    \x03\x12\x04\x92.&'\n\r\n\x05\x04\xc7\x01\x02\x01\x12\x04\x94.\x02)\n\
    \x0e\n\x06\x04\xc7\x01\x02\x01\x06\x12\x04\x94.\x02\x12\n\x0e\n\x06\x04\
    \xc7\x01\x02\x01\x01\x12\x04\x94.\x13$\n\x0e\n\x06\x04\xc7\x01\x02\x01\
    \x03\x12\x04\x94.'(\n\x1f\n\x03\x04\xc8\x01\x12\x06\xb8.\0\xbf.\x01\x1a\
    \x10\x20GetUserRequest\n\n\x0c\n\x04\x04\xc8\x01\x01\x12\x04\xb8.\x08\
    \x16\n\xbe\x01\n\x05\x04\xc8\x01\x02\0\x12\x04\xbb.\x02,\x1a\xae\x01\x20\
    we\x20used\x20to\x20have\x20user_id\x20but\x20moved\x20to\x20the\x20stan\
    dard\x20convention.\x20Since\x20this\x20endpoint\n\x20hasn't\x20been\x20\
    exposed\x20and\x20only\x20used\x20by\x20portal\x20as\x20a\x20url\x20this\
    \x20won't\x20effect\x20anything\x20external.\n\n\x0e\n\x06\x04\xc8\x01\
    \x02\0\x06\x12\x04\xbb.\x02\x1b\n\x0e\n\x06\x04\xc8\x01\x02\0\x01\x12\
    \x04\xbb.\x1c'\n\x0e\n\x06\x04\xc8\x01\x02\0\x03\x12\x04\xbb.*+\n\x83\
    \x01\n\x05\x04\xc8\x01\x02\x01\x12\x04\xbe.\x02(\x1at\x20(optional\x20UR\
    L\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\x20inc\
    luded\x20in\x20the\x20response.\x20Currently\x20supported:\x20all,\x20st\
    ars\n\n\x0e\n\x06\x04\xc8\x01\x02\x01\x04\x12\x04\xbe.\x02\n\n\x0e\n\x06\
    \x04\xc8\x01\x02\x01\x05\x12\x04\xbe.\x0b\x11\n\x0e\n\x06\x04\xc8\x01\
    \x02\x01\x01\x12\x04\xbe.\x12#\n\x0e\n\x06\x04\xc8\x01\x02\x01\x03\x12\
    \x04\xbe.&'\n#\n\x03\x04\xc9\x01\x12\x06\xc4.\0\xc7.\x01\x1a\x14\x20Sing\
    leUserResponse\n\n\x0c\n\x04\x04\xc9\x01\x01\x12\x04\xc4.\x08\x1a\n\r\n\
    \x05\x04\xc9\x01\x02\0\x12\x04\xc5.\x02(\n\x0e\n\x06\x04\xc9\x01\x02\0\
    \x06\x12\x04\xc5.\x02\x1c\n\x0e\n\x06\x04\xc9\x01\x02\0\x01\x12\x04\xc5.\
    \x1d#\n\x0e\n\x06\x04\xc9\x01\x02\0\x03\x12\x04\xc5.&'\n\r\n\x05\x04\xc9\
    \x01\x02\x01\x12\x04\xc6.\x02\x10\n\x0e\n\x06\x04\xc9\x01\x02\x01\x06\
    \x12\x04\xc6.\x02\x06\n\x0e\n\x06\x04\xc9\x01\x02\x01\x01\x12\x04\xc6.\
    \x07\x0b\n\x0e\n\x06\x04\xc9\x01\x02\x01\x03\x12\x04\xc6.\x0e\x0f\n,\n\
    \x03\x04\xca\x01\x12\x06\xd8.\0\xdc.\x01\x1a\x1d\x20PostValidatePassword\
    Request\n\n\x0c\n\x04\x04\xca\x01\x01\x12\x04\xd8.\x08#\n\r\n\x05\x04\
    \xca\x01\x02\0\x12\x04\xd9.\x02,\n\x0e\n\x06\x04\xca\x01\x02\0\x06\x12\
    \x04\xd9.\x02\x1b\n\x0e\n\x06\x04\xca\x01\x02\0\x01\x12\x04\xd9.\x1c'\n\
    \x0e\n\x06\x04\xca\x01\x02\0\x03\x12\x04\xd9.*+\n)\n\x05\x04\xca\x01\x02\
    \x01\x12\x04\xdb.\x02\x18\x1a\x1a\x20password\x20to\x20be\x20validated\n\
    \n\x0e\n\x06\x04\xca\x01\x02\x01\x06\x12\x04\xdb.\x02\n\n\x0e\n\x06\x04\
    \xca\x01\x02\x01\x01\x12\x04\xdb.\x0b\x13\n\x0e\n\x06\x04\xca\x01\x02\
    \x01\x03\x12\x04\xdb.\x16\x17\n1\n\x03\x04\xcb\x01\x12\x06\xdf.\0\xe3.\
    \x01\x1a\"\x20SinglePasswordValidationResponse\n\n\x0c\n\x04\x04\xcb\x01\
    \x01\x12\x04\xdf.\x08(\n.\n\x05\x04\xcb\x01\x02\0\x12\x04\xe1.\x02(\x1a\
    \x1f\x20Standard\x20clarifai\x20status\x20code\n\n\x0e\n\x06\x04\xcb\x01\
    \x02\0\x06\x12\x04\xe1.\x02\x1c\n\x0e\n\x06\x04\xcb\x01\x02\0\x01\x12\
    \x04\xe1.\x1d#\n\x0e\n\x06\x04\xcb\x01\x02\0\x03\x12\x04\xe1.&'\n\r\n\
    \x05\x04\xcb\x01\x02\x01\x12\x04\xe2.\x02-\n\x0e\n\x06\x04\xcb\x01\x02\
    \x01\x06\x12\x04\xe2.\x02\x14\n\x0e\n\x06\x04\xcb\x01\x02\x01\x01\x12\
    \x04\xe2.\x15(\n\x0e\n\x06\x04\xcb\x01\x02\x01\x03\x12\x04\xe2.+,\n\x0c\
    \n\x02\x05\0\x12\x06\xfe.\0\x85/\x01\n\x0b\n\x03\x05\0\x01\x12\x04\xfe.\
    \x05!\n\x0c\n\x04\x05\0\x02\0\x12\x04\xff.\x02\x0e\n\r\n\x05\x05\0\x02\0\
    \x01\x12\x04\xff.\x02\t\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xff.\x0c\r\n\
    \x0c\n\x04\x05\0\x02\x01\x12\x04\x80/\x02\x0e\n\r\n\x05\x05\0\x02\x01\
    \x01\x12\x04\x80/\x02\t\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x80/\x0c\r\n\
    \x0c\n\x04\x05\0\x02\x02\x12\x04\x81/\x02\x0f\n\r\n\x05\x05\0\x02\x02\
    \x01\x12\x04\x81/\x02\n\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\x81/\r\x0e\n\
    \x0c\n\x04\x05\0\x02\x03\x12\x04\x82/\x02\x10\n\r\n\x05\x05\0\x02\x03\
    \x01\x12\x04\x82/\x02\x0b\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\x82/\x0e\
    \x0f\n\x0c\n\x04\x05\0\x02\x04\x12\x04\x83/\x02\x0f\n\r\n\x05\x05\0\x02\
    \x04\x01\x12\x04\x83/\x02\n\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\x83/\r\
    \x0e\n\x0c\n\x04\x05\0\x02\x05\x12\x04\x84/\x02\x0e\n\r\n\x05\x05\0\x02\
    \x05\x01\x12\x04\x84/\x02\t\n\r\n\x05\x05\0\x02\x05\x02\x12\x04\x84/\x0c\
    \r\n#\n\x03\x04\xcc\x01\x12\x06\xbb/\0\xca/\x01\x1a\x14\x20GetWorkflowRe\
    quest\n\n\x0c\n\x04\x04\xcc\x01\x01\x12\x04\xbb/\x08\x1a\n\r\n\x05\x04\
    \xcc\x01\x02\0\x12\x04\xbc/\x02,\n\x0e\n\x06\x04\xcc\x01\x02\0\x06\x12\
    \x04\xbc/\x02\x1b\n\x0e\n\x06\x04\xcc\x01\x02\0\x01\x12\x04\xbc/\x1c'\n\
    \x0e\n\x06\x04\xcc\x01\x02\0\x03\x12\x04\xbc/*+\n\xc9\x01\n\x05\x04\xcc\
    \x01\x02\x01\x12\x04\xc1/\x02\x19\x1a\xb9\x01\x20Workflow\x20ID\x20to\
    \x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified\x20we\x20return\x20d\
    efault\x20workflow\x20of\x20the\x20application\n\x20If\x20an\x20ID\x20is\
    \x20specified\x20by\x20default\x20we\x20first\x20looks\x20into\x20Clarif\
    ai\x20workflows\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\xcc\x01\
    \x02\x01\x05\x12\x04\xc1/\x02\x08\n\x0e\n\x06\x04\xcc\x01\x02\x01\x01\
    \x12\x04\xc1/\t\x14\n\x0e\n\x06\x04\xcc\x01\x02\x01\x03\x12\x04\xc1/\x17\
    \x18\n`\n\x05\x04\xcc\x01\x02\x02\x12\x04\xc4/\x02$\x1aQ\x20Use\x20this\
    \x20flag\x20to\x20look\x20into\x20clarifai\x20published\x20workflows\x20\
    first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\xcc\x01\x02\x02\
    \x05\x12\x04\xc4/\x02\x06\n\x0e\n\x06\x04\xcc\x01\x02\x02\x01\x12\x04\
    \xc4/\x07\x1f\n\x0e\n\x06\x04\xcc\x01\x02\x02\x03\x12\x04\xc4/\"#\n\x83\
    \x01\n\x05\x04\xcc\x01\x02\x03\x12\x04\xc6/\x02(\x1at\x20(optional\x20UR\
    L\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\x20inc\
    luded\x20in\x20the\x20response.\x20Currently\x20supported:\x20all,\x20st\
    ars\n\n\x0e\n\x06\x04\xcc\x01\x02\x03\x04\x12\x04\xc6/\x02\n\n\x0e\n\x06\
    \x04\xcc\x01\x02\x03\x05\x12\x04\xc6/\x0b\x11\n\x0e\n\x06\x04\xcc\x01\
    \x02\x03\x01\x12\x04\xc6/\x12#\n\x0e\n\x06\x04\xcc\x01\x02\x03\x03\x12\
    \x04\xc6/&'\nE\n\x05\x04\xcc\x01\x02\x04\x12\x04\xc9/\x02&\x1a6\x20if\
    \x20true\x20will\x20not\x20expand\x20search\x20to\x20clarifai\x20workflo\
    ws\n\n\x0e\n\x06\x04\xcc\x01\x02\x04\x05\x12\x04\xc9/\x02\x06\n\x0e\n\
    \x06\x04\xcc\x01\x02\x04\x01\x12\x04\xc9/\x07!\n\x0e\n\x06\x04\xcc\x01\
    \x02\x04\x03\x12\x04\xc9/$%\n%\n\x03\x04\xcd\x01\x12\x06\xcd/\0\x880\x01\
    \x1a\x16\x20ListWorkflowsRequest\n\n\x0c\n\x04\x04\xcd\x01\x01\x12\x04\
    \xcd/\x08\x1c\n\r\n\x05\x04\xcd\x01\x02\0\x12\x04\xce/\x02,\n\x0e\n\x06\
    \x04\xcd\x01\x02\0\x06\x12\x04\xce/\x02\x1b\n\x0e\n\x06\x04\xcd\x01\x02\
    \0\x01\x12\x04\xce/\x1c'\n\x0e\n\x06\x04\xcd\x01\x02\0\x03\x12\x04\xce/*\
    +\n\x7f\n\x05\x04\xcd\x01\x02\x01\x12\x04\xd1/\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xcd\x01\x02\x01\x05\x12\x04\xd1/\x02\x08\
    \n\x0e\n\x06\x04\xcd\x01\x02\x01\x01\x12\x04\xd1/\t\r\n\x0e\n\x06\x04\
    \xcd\x01\x02\x01\x03\x12\x04\xd1/\x10\x11\nv\n\x05\x04\xcd\x01\x02\x02\
    \x12\x04\xd4/\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xcd\x01\x02\x02\
    \x05\x12\x04\xd4/\x02\x08\n\x0e\n\x06\x04\xcd\x01\x02\x02\x01\x12\x04\
    \xd4/\t\x11\n\x0e\n\x06\x04\xcd\x01\x02\x02\x03\x12\x04\xd4/\x14\x15\n\
    \x83\x01\n\x05\x04\xcd\x01\x02\x03\x12\x04\xd7/\x02)\x1at\x20(optional\
    \x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\
    \x20included\x20in\x20the\x20response.\x20Currently\x20supported:\x20all\
    ,\x20stars\n\n\x0e\n\x06\x04\xcd\x01\x02\x03\x04\x12\x04\xd7/\x02\n\n\
    \x0e\n\x06\x04\xcd\x01\x02\x03\x05\x12\x04\xd7/\x0b\x11\n\x0e\n\x06\x04\
    \xcd\x01\x02\x03\x01\x12\x04\xd7/\x12#\n\x0e\n\x06\x04\xcd\x01\x02\x03\
    \x03\x12\x04\xd7/&(\np\n\x05\x04\xcd\x01\x02\x04\x12\x04\xdb/\x02\x1a\
    \x1aa\x20Sorting\x20options:\n\x20Whether\x20to\x20sort\x20in\x20ascendi\
    ng\x20order.\x20If\x20false,\x20will\x20order\x20in\x20descending\x20ord\
    er.\n\n\x0e\n\x06\x04\xcd\x01\x02\x04\x05\x12\x04\xdb/\x02\x06\n\x0e\n\
    \x06\x04\xcd\x01\x02\x04\x01\x12\x04\xdb/\x07\x15\n\x0e\n\x06\x04\xcd\
    \x01\x02\x04\x03\x12\x04\xdb/\x18\x19\n\x0f\n\x05\x04\xcd\x01\x08\0\x12\
    \x06\xdc/\x02\xe7/\x03\n\x0e\n\x06\x04\xcd\x01\x08\0\x01\x12\x04\xdc/\
    \x08\x0f\n-\n\x05\x04\xcd\x01\x02\x05\x12\x04\xde/\x04\x18\x1a\x1e\x20Wh\
    ether\x20to\x20order\x20by\x20the\x20name\n\n\x0e\n\x06\x04\xcd\x01\x02\
    \x05\x05\x12\x04\xde/\x04\x08\n\x0e\n\x06\x04\xcd\x01\x02\x05\x01\x12\
    \x04\xde/\t\x13\n\x0e\n\x06\x04\xcd\x01\x02\x05\x03\x12\x04\xde/\x16\x17\
    \n\x81\x01\n\x05\x04\xcd\x01\x02\x06\x12\x04\xe1/\x04!\x1ar\x20Whether\
    \x20to\x20order\x20by\x20the\x20modified_at\x20time.\n\x20If\x20none\x20\
    of\x20the\x20sort\x20options\x20is\x20set\x20to\x20true,\x20will\x20sort\
    \x20by\x20modified_at.\n\n\x0e\n\x06\x04\xcd\x01\x02\x06\x05\x12\x04\xe1\
    /\x04\x08\n\x0e\n\x06\x04\xcd\x01\x02\x06\x01\x12\x04\xe1/\t\x1c\n\x0e\n\
    \x06\x04\xcd\x01\x02\x06\x03\x12\x04\xe1/\x1f\x20\n9\n\x05\x04\xcd\x01\
    \x02\x07\x12\x04\xe4/\x04!\x1a*\x20Whether\x20to\x20order\x20by\x20the\
    \x20created_at\x20time.\n\n\x0e\n\x06\x04\xcd\x01\x02\x07\x05\x12\x04\
    \xe4/\x04\x08\n\x0e\n\x06\x04\xcd\x01\x02\x07\x01\x12\x04\xe4/\t\x1b\n\
    \x0e\n\x06\x04\xcd\x01\x02\x07\x03\x12\x04\xe4/\x1e\x20\nL\n\x05\x04\xcd\
    \x01\x02\x08\x12\x04\xe6/\x04!\x1a=\x20Whether\x20to\x20order\x20by\x20t\
    he\x20number\x20of\x20users\x20stared\x20the\x20workflow\n\n\x0e\n\x06\
    \x04\xcd\x01\x02\x08\x05\x12\x04\xe6/\x04\x08\n\x0e\n\x06\x04\xcd\x01\
    \x02\x08\x01\x12\x04\xe6/\t\x1b\n\x0e\n\x06\x04\xcd\x01\x02\x08\x03\x12\
    \x04\xe6/\x1e\x20\nl\n\x05\x04\xcd\x01\x02\t\x12\x04\xeb/\x02\x19\x1a]\
    \x20Filtering\x20options:\n\x20If\x20true,\x20we\x20only\x20return\x20wo\
    rkflows\x20that\x20are\x20handpicked\x20by\x20clarifai\x20staff\n\n\x0e\
    \n\x06\x04\xcd\x01\x02\t\x05\x12\x04\xeb/\x02\x06\n\x0e\n\x06\x04\xcd\
    \x01\x02\t\x01\x12\x04\xeb/\x07\x14\n\x0e\n\x06\x04\xcd\x01\x02\t\x03\
    \x12\x04\xeb/\x17\x18\nZ\n\x05\x04\xcd\x01\x02\n\x12\x04\xed/\x02\x19\
    \x1aK\x20If\x20true,\x20we\x20only\x20return\x20workflows\x20that\x20are\
    \x20starred\x20by\x20the\x20requesting\x20user\n\n\x0e\n\x06\x04\xcd\x01\
    \x02\n\x05\x12\x04\xed/\x02\x06\n\x0e\n\x06\x04\xcd\x01\x02\n\x01\x12\
    \x04\xed/\x07\x13\n\x0e\n\x06\x04\xcd\x01\x02\n\x03\x12\x04\xed/\x16\x18\
    \n\x82\x01\n\x05\x04\xcd\x01\x02\x0b\x12\x04\xef/\x02\x15\x1as\x20Filter\
    \x20workflows\x20by\x20bookmark.\x20If\x20set,\x20only\x20return\x20book\
    marked\x20workflows.\x20Otherwise\x20none\x20bookmarked\x20workflows\x20\
    only.\n\n\x0e\n\x06\x04\xcd\x01\x02\x0b\x05\x12\x04\xef/\x02\x06\n\x0e\n\
    \x06\x04\xcd\x01\x02\x0b\x01\x12\x04\xef/\x07\x0f\n\x0e\n\x06\x04\xcd\
    \x01\x02\x0b\x03\x12\x04\xef/\x12\x14\n\xae\x04\n\x05\x04\xcd\x01\x02\
    \x0c\x12\x04\xfe/\x02\x15\x1a\x9e\x04\x20Searching\x20options:\n\x20Spec\
    ify\x20a\x20search\x20parameter\x20in\x20order\x20to\x20perform\x20keywo\
    rd\x20search\x20on\x20the\n\x20following\x20fields\x20of\x20the\x20workf\
    low:\n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20description\n\x20\x20\x20-\
    \x20notes\n\x20\x20\x20-\x20user_id\x20(unless\x20user_app_id.user_id\
    \x20is\x20already\x20set)\n\n\x20Keywords\x20are\x20both\x20normalized\
    \x20for\x20search\x20(so\x20searching\x20for\x20\"satisfy\"\x20matches\
    \x20\"satisfied\")\n\x20and\x20used\x20for\x20partial\x20prefix-matching\
    \x20(so\x20searching\x20for\x20\"clari\"\x20matches\x20\"clarifai\").\n\
    \n\x20NOTE:\x20Both\x20the\x20list\x20of\x20fields\x20searched\x20and\
    \x20the\x20exact\x20keyword\x20matching\n\x20rules\x20are\x20subject\x20\
    to\x20change\x20and\x20not\x20guaranteed\x20to\x20be\x20backwards-compat\
    ible.\n\n\x0e\n\x06\x04\xcd\x01\x02\x0c\x05\x12\x04\xfe/\x02\x08\n\x0e\n\
    \x06\x04\xcd\x01\x02\x0c\x01\x12\x04\xfe/\t\x0f\n\x0e\n\x06\x04\xcd\x01\
    \x02\x0c\x03\x12\x04\xfe/\x12\x14\n\x98\x01\n\x05\x04\xcd\x01\x02\r\x12\
    \x04\x810\x02'\x1a\x88\x01\x20Query\x20various\x20text\x20fields\x20(id,\
    \x20description\x20and\x20notes)\x20that\x20can\x20contain\x20the\x20wor\
    ds\x20in\x20the\x20query\x20string.\n\x20Deprecated:\x20use\x20search\
    \x20instead.\n\n\x0e\n\x06\x04\xcd\x01\x02\r\x05\x12\x04\x810\x02\x08\n\
    \x0e\n\x06\x04\xcd\x01\x02\r\x01\x12\x04\x810\t\x0e\n\x0e\n\x06\x04\xcd\
    \x01\x02\r\x03\x12\x04\x810\x11\x12\n\x0e\n\x06\x04\xcd\x01\x02\r\x08\
    \x12\x04\x810\x13&\n\x0f\n\x07\x04\xcd\x01\x02\r\x08\x03\x12\x04\x810\
    \x14%\n\xa0\x01\n\x05\x04\xcd\x01\x02\x0e\x12\x04\x840\x02$\x1a\x90\x01\
    \x20Filter\x20by\x20the\x20id\x20of\x20the\x20workflow.\x20This\x20suppo\
    rts\x20wilcard\x20queries\x20like\x20\"gen*\"\x20to\x20match\x20\"genera\
    l\"\x20as\x20an\x20example.\n\x20Deprecated:\x20use\x20search\x20instead\
    .\n\n\x0e\n\x06\x04\xcd\x01\x02\x0e\x05\x12\x04\x840\x02\x08\n\x0e\n\x06\
    \x04\xcd\x01\x02\x0e\x01\x12\x04\x840\t\x0b\n\x0e\n\x06\x04\xcd\x01\x02\
    \x0e\x03\x12\x04\x840\x0e\x0f\n\x0e\n\x06\x04\xcd\x01\x02\x0e\x08\x12\
    \x04\x840\x10#\n\x0f\n\x07\x04\xcd\x01\x02\x0e\x08\x03\x12\x04\x840\x11\
    \"\n\x97\x01\n\x05\x04\xcd\x01\x02\x0f\x12\x04\x870\x02.\x1a\x87\x01\x20\
    Full\x20text\x20and\x20prefix\x20matching\x20on\x20id,\x20owner\x20id,\
    \x20description\x20and\x20notes.\x20Searchable\x20fields\x20may\x20be\
    \x20added\n\x20Deprecated:\x20use\x20search\x20instead.\n\n\x0e\n\x06\
    \x04\xcd\x01\x02\x0f\x05\x12\x04\x870\x02\x08\n\x0e\n\x06\x04\xcd\x01\
    \x02\x0f\x01\x12\x04\x870\t\x14\n\x0e\n\x06\x04\xcd\x01\x02\x0f\x03\x12\
    \x04\x870\x17\x19\n\x0e\n\x06\x04\xcd\x01\x02\x0f\x08\x12\x04\x870\x1a-\
    \n\x0f\n\x07\x04\xcd\x01\x02\x0f\x08\x03\x12\x04\x870\x1b,\n%\n\x03\x04\
    \xce\x01\x12\x06\x8c0\0\x8f0\x01\x1a\x16\x20PostWorkflowsRequest\n\n\x0c\
    \n\x04\x04\xce\x01\x01\x12\x04\x8c0\x08\x1c\n\r\n\x05\x04\xce\x01\x02\0\
    \x12\x04\x8d0\x02,\n\x0e\n\x06\x04\xce\x01\x02\0\x06\x12\x04\x8d0\x02\
    \x1b\n\x0e\n\x06\x04\xce\x01\x02\0\x01\x12\x04\x8d0\x1c'\n\x0e\n\x06\x04\
    \xce\x01\x02\0\x03\x12\x04\x8d0*+\n\r\n\x05\x04\xce\x01\x02\x01\x12\x04\
    \x8e0\x02\"\n\x0e\n\x06\x04\xce\x01\x02\x01\x04\x12\x04\x8e0\x02\n\n\x0e\
    \n\x06\x04\xce\x01\x02\x01\x06\x12\x04\x8e0\x0b\x13\n\x0e\n\x06\x04\xce\
    \x01\x02\x01\x01\x12\x04\x8e0\x14\x1d\n\x0e\n\x06\x04\xce\x01\x02\x01\
    \x03\x12\x04\x8e0\x20!\n&\n\x03\x04\xcf\x01\x12\x06\x920\0\x9d0\x01\x1a\
    \x17\x20PatchWorkflowsRequest\n\n\x0c\n\x04\x04\xcf\x01\x01\x12\x04\x920\
    \x08\x1d\n\r\n\x05\x04\xcf\x01\x02\0\x12\x04\x930\x02,\n\x0e\n\x06\x04\
    \xcf\x01\x02\0\x06\x12\x04\x930\x02\x1b\n\x0e\n\x06\x04\xcf\x01\x02\0\
    \x01\x12\x04\x930\x1c'\n\x0e\n\x06\x04\xcf\x01\x02\0\x03\x12\x04\x930*+\
    \n\r\n\x05\x04\xcf\x01\x02\x01\x12\x04\x940\x02\"\n\x0e\n\x06\x04\xcf\
    \x01\x02\x01\x04\x12\x04\x940\x02\n\n\x0e\n\x06\x04\xcf\x01\x02\x01\x06\
    \x12\x04\x940\x0b\x13\n\x0e\n\x06\x04\xcf\x01\x02\x01\x01\x12\x04\x940\
    \x14\x1d\n\x0e\n\x06\x04\xcf\x01\x02\x01\x03\x12\x04\x940\x20!\n\xdf\x02\
    \n\x05\x04\xcf\x01\x02\x02\x12\x04\x9c0\x02\x14\x1a\xcf\x02\x20The\x20ac\
    tion\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\
    \x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20sup\
    ported\n\n\x20Note\x20that\x20'remove'\x20can\x20be\x20used\x20to\x20rem\
    ove\x20the\x20workflow\x20image\x20by\x20setting\n\x20'image.url'\x20in\
    \x20the\x20request\x20to\x20the\x20current\x20value\x20returned\x20for\
    \x20that\x20workflow.\n\x20This\x20cannot\x20be\x20used\x20in\x20a\x20re\
    quest\x20that\x20is\x20patching\x20other\x20fields\x20as\x20well.\n\n\
    \x0e\n\x06\x04\xcf\x01\x02\x02\x05\x12\x04\x9c0\x02\x08\n\x0e\n\x06\x04\
    \xcf\x01\x02\x02\x01\x12\x04\x9c0\t\x0f\n\x0e\n\x06\x04\xcf\x01\x02\x02\
    \x03\x12\x04\x9c0\x12\x13\n(\n\x03\x04\xd0\x01\x12\x06\xa00\0\xa90\x01\
    \x1a\x19\x20PatchWorkflowIdsRequest\n\n\x0c\n\x04\x04\xd0\x01\x01\x12\
    \x04\xa00\x08\x1f\n\r\n\x05\x04\xd0\x01\x02\0\x12\x04\xa10\x02,\n\x0e\n\
    \x06\x04\xd0\x01\x02\0\x06\x12\x04\xa10\x02\x1b\n\x0e\n\x06\x04\xd0\x01\
    \x02\0\x01\x12\x04\xa10\x1c'\n\x0e\n\x06\x04\xd0\x01\x02\0\x03\x12\x04\
    \xa10*+\n)\n\x05\x04\xd0\x01\x02\x01\x12\x04\xa40\x02\"\x1a\x1a\x20Array\
    \x20containing\x201\x20entry\n\n\x0e\n\x06\x04\xd0\x01\x02\x01\x04\x12\
    \x04\xa40\x02\n\n\x0e\n\x06\x04\xd0\x01\x02\x01\x06\x12\x04\xa40\x0b\x19\
    \n\x0e\n\x06\x04\xd0\x01\x02\x01\x01\x12\x04\xa40\x1a\x1d\n\x0e\n\x06\
    \x04\xd0\x01\x02\x01\x03\x12\x04\xa40\x20!\n\\\n\x05\x04\xd0\x01\x02\x02\
    \x12\x04\xa80\x02\x14\x1aM\x20The\x20action\x20to\x20perform\x20on\x20th\
    e\x20patched\x20objects\n\x20Only\x20'overwrite'\x20is\x20supported\n\n\
    \x0e\n\x06\x04\xd0\x01\x02\x02\x05\x12\x04\xa80\x02\x08\n\x0e\n\x06\x04\
    \xd0\x01\x02\x02\x01\x12\x04\xa80\t\x0f\n\x0e\n\x06\x04\xd0\x01\x02\x02\
    \x03\x12\x04\xa80\x12\x13\n&\n\x03\x04\xd1\x01\x12\x06\xac0\0\xaf0\x01\
    \x1a\x17\x20DeleteWorkflowRequest\n\n\x0c\n\x04\x04\xd1\x01\x01\x12\x04\
    \xac0\x08\x1d\n\r\n\x05\x04\xd1\x01\x02\0\x12\x04\xad0\x02,\n\x0e\n\x06\
    \x04\xd1\x01\x02\0\x06\x12\x04\xad0\x02\x1b\n\x0e\n\x06\x04\xd1\x01\x02\
    \0\x01\x12\x04\xad0\x1c'\n\x0e\n\x06\x04\xd1\x01\x02\0\x03\x12\x04\xad0*\
    +\n\r\n\x05\x04\xd1\x01\x02\x01\x12\x04\xae0\x02\x19\n\x0e\n\x06\x04\xd1\
    \x01\x02\x01\x05\x12\x04\xae0\x02\x08\n\x0e\n\x06\x04\xd1\x01\x02\x01\
    \x01\x12\x04\xae0\t\x14\n\x0e\n\x06\x04\xd1\x01\x02\x01\x03\x12\x04\xae0\
    \x17\x18\nE\n\x03\x04\xd2\x01\x12\x06\xb20\0\xb60\x01\x1a6\x20Request\
    \x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\
    \n\n\x0c\n\x04\x04\xd2\x01\x01\x12\x04\xb20\x08\x1e\n\r\n\x05\x04\xd2\
    \x01\x02\0\x12\x04\xb30\x02,\n\x0e\n\x06\x04\xd2\x01\x02\0\x06\x12\x04\
    \xb30\x02\x1b\n\x0e\n\x06\x04\xd2\x01\x02\0\x01\x12\x04\xb30\x1c'\n\x0e\
    \n\x06\x04\xd2\x01\x02\0\x03\x12\x04\xb30*+\n\r\n\x05\x04\xd2\x01\x02\
    \x01\x12\x04\xb40\x02\x1a\n\x0e\n\x06\x04\xd2\x01\x02\x01\x04\x12\x04\
    \xb40\x02\n\n\x0e\n\x06\x04\xd2\x01\x02\x01\x05\x12\x04\xb40\x0b\x11\n\
    \x0e\n\x06\x04\xd2\x01\x02\x01\x01\x12\x04\xb40\x12\x15\n\x0e\n\x06\x04\
    \xd2\x01\x02\x01\x03\x12\x04\xb40\x18\x19\n\r\n\x05\x04\xd2\x01\x02\x02\
    \x12\x04\xb50\x02\x16\n\x0e\n\x06\x04\xd2\x01\x02\x02\x05\x12\x04\xb50\
    \x02\x06\n\x0e\n\x06\x04\xd2\x01\x02\x02\x01\x12\x04\xb50\x07\x11\n\x0e\
    \n\x06\x04\xd2\x01\x02\x02\x03\x12\x04\xb50\x14\x15\n'\n\x03\x04\xd3\x01\
    \x12\x06\xb90\0\xbc0\x01\x1a\x18\x20SingleWorkflowResponse\n\n\x0c\n\x04\
    \x04\xd3\x01\x01\x12\x04\xb90\x08\x1e\n\r\n\x05\x04\xd3\x01\x02\0\x12\
    \x04\xba0\x02(\n\x0e\n\x06\x04\xd3\x01\x02\0\x06\x12\x04\xba0\x02\x1c\n\
    \x0e\n\x06\x04\xd3\x01\x02\0\x01\x12\x04\xba0\x1d#\n\x0e\n\x06\x04\xd3\
    \x01\x02\0\x03\x12\x04\xba0&'\n\r\n\x05\x04\xd3\x01\x02\x01\x12\x04\xbb0\
    \x02\x18\n\x0e\n\x06\x04\xd3\x01\x02\x01\x06\x12\x04\xbb0\x02\n\n\x0e\n\
    \x06\x04\xd3\x01\x02\x01\x01\x12\x04\xbb0\x0b\x13\n\x0e\n\x06\x04\xd3\
    \x01\x02\x01\x03\x12\x04\xbb0\x16\x17\n&\n\x03\x04\xd4\x01\x12\x06\xbf0\
    \0\xc20\x01\x1a\x17\x20MultiWorkflowResponse\n\n\x0c\n\x04\x04\xd4\x01\
    \x01\x12\x04\xbf0\x08\x1d\n\r\n\x05\x04\xd4\x01\x02\0\x12\x04\xc00\x02(\
    \n\x0e\n\x06\x04\xd4\x01\x02\0\x06\x12\x04\xc00\x02\x1c\n\x0e\n\x06\x04\
    \xd4\x01\x02\0\x01\x12\x04\xc00\x1d#\n\x0e\n\x06\x04\xd4\x01\x02\0\x03\
    \x12\x04\xc00&'\n\r\n\x05\x04\xd4\x01\x02\x01\x12\x04\xc10\x02Q\n\x0e\n\
    \x06\x04\xd4\x01\x02\x01\x04\x12\x04\xc10\x02\n\n\x0e\n\x06\x04\xd4\x01\
    \x02\x01\x06\x12\x04\xc10\x0b\x13\n\x0e\n\x06\x04\xd4\x01\x02\x01\x01\
    \x12\x04\xc10\x14\x1d\n\x0e\n\x06\x04\xd4\x01\x02\x01\x03\x12\x04\xc10\
    \x20!\n\x0e\n\x06\x04\xd4\x01\x02\x01\x08\x12\x04\xc10\"P\n\x11\n\t\x04\
    \xd4\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xc10#O\n+\n\x03\x04\xd5\x01\x12\
    \x06\xc50\0\xe10\x01\x1a\x1c\x20PostWorkflowResultsRequest\n\n\x0c\n\x04\
    \x04\xd5\x01\x01\x12\x04\xc50\x08\"\n\r\n\x05\x04\xd5\x01\x02\0\x12\x04\
    \xc60\x02,\n\x0e\n\x06\x04\xd5\x01\x02\0\x06\x12\x04\xc60\x02\x1b\n\x0e\
    \n\x06\x04\xd5\x01\x02\0\x01\x12\x04\xc60\x1c'\n\x0e\n\x06\x04\xd5\x01\
    \x02\0\x03\x12\x04\xc60*+\n\xc9\x01\n\x05\x04\xd5\x01\x02\x01\x12\x04\
    \xcb0\x02\x19\x1a\xb9\x01\x20Workflow\x20ID\x20to\x20retrieve\n\x20If\
    \x20no\x20ID\x20is\x20specified\x20we\x20return\x20default\x20workflow\
    \x20of\x20the\x20application\n\x20If\x20an\x20ID\x20is\x20specified\x20b\
    y\x20default\x20we\x20first\x20looks\x20into\x20Clarifai\x20workflows\
    \x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\xd5\x01\x02\x01\x05\x12\
    \x04\xcb0\x02\x08\n\x0e\n\x06\x04\xd5\x01\x02\x01\x01\x12\x04\xcb0\t\x14\
    \n\x0e\n\x06\x04\xd5\x01\x02\x01\x03\x12\x04\xcb0\x17\x18\nh\n\x05\x04\
    \xd5\x01\x02\x02\x12\x04\xcf0\x02\x18\x1aY\x20Workflow\x20version\x20ID\
    \x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified,\x20latest\x20\
    workflow\x20version\x20is\x20used\n\n\x0e\n\x06\x04\xd5\x01\x02\x02\x05\
    \x12\x04\xcf0\x02\x08\n\x0e\n\x06\x04\xd5\x01\x02\x02\x01\x12\x04\xcf0\t\
    \x13\n\x0e\n\x06\x04\xd5\x01\x02\x02\x03\x12\x04\xcf0\x16\x17\n\r\n\x05\
    \x04\xd5\x01\x02\x03\x12\x04\xd10\x02\x1c\n\x0e\n\x06\x04\xd5\x01\x02\
    \x03\x04\x12\x04\xd10\x02\n\n\x0e\n\x06\x04\xd5\x01\x02\x03\x06\x12\x04\
    \xd10\x0b\x10\n\x0e\n\x06\x04\xd5\x01\x02\x03\x01\x12\x04\xd10\x11\x17\n\
    \x0e\n\x06\x04\xd5\x01\x02\x03\x03\x12\x04\xd10\x1a\x1b\n\xb4\x04\n\x05\
    \x04\xd5\x01\x02\x04\x12\x04\xd80\x02!\x1a\xa4\x04\x20FIXME(zeiler):\x20\
    the\x20request\x20for\x20post\x20workflows\x20is\x20using\x20an\x20outpu\
    tconfig\x20object\x20that\x20is\x20supposed\n\x20to\x20be\x20within\x20m\
    odels.\x20This\x20is\x20not\x20consistent\x20with\x20setting\x20this\x20\
    on\x20the\x20request\x20for\x20post\x20model\n\x20outputs\x20where\x20it\
    \x20is\x20inside\x20a\x20model\x20object.\x20To\x20make\x20this\x20consi\
    stent\x20we\x20would\x20send\x20in\x20the\n\x20workflow\x20object\x20so\
    \x20that\x20each\x20model\x20can\x20have\x20it's\x20own\x20output\x20con\
    fig.\x20If\x20nobody\x20is\x20setting\n\x20this\x20OutputConfig\x20it\
    \x20would\x20probably\x20be\x20easier\x20to\x20just\x20remove\x20it\x20f\
    or\x20now\x20to\x20keep\x20things\x20simpler\n\x20and\x20then\x20it's\
    \x20more\x20consistent\x20we\x20just\x20don't\x20support\x20the\x20Outpu\
    tConfig\x20on\x20workflows.\n\n\x0e\n\x06\x04\xd5\x01\x02\x04\x06\x12\
    \x04\xd80\x02\x0e\n\x0e\n\x06\x04\xd5\x01\x02\x04\x01\x12\x04\xd80\x0f\
    \x1c\n\x0e\n\x06\x04\xd5\x01\x02\x04\x03\x12\x04\xd80\x1f\x20\n`\n\x05\
    \x04\xd5\x01\x02\x05\x12\x04\xdb0\x02$\x1aQ\x20Use\x20this\x20flag\x20to\
    \x20look\x20into\x20clarifai\x20published\x20workflows\x20first\x20for\
    \x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\xd5\x01\x02\x05\x05\x12\x04\
    \xdb0\x02\x06\n\x0e\n\x06\x04\xd5\x01\x02\x05\x01\x12\x04\xdb0\x07\x1f\n\
    \x0e\n\x06\x04\xd5\x01\x02\x05\x03\x12\x04\xdb0\"#\n\xf5\x01\n\x05\x04\
    \xd5\x01\x02\x06\x12\x04\xe00\x02#\x1a\xe5\x01\x20A\x20workflow\x20state\
    \x20to\x20be\x20maintained\x20across\x20PostWorkflowResults\x20requests/\
    responses.\n\x20If\x20it\x20is\x20not\x20sent\x20in\x20the\x20initial\
    \x20request\x20with\x20workflow_state.id\x20=\x20\"init\"\x20then\x20no\
    \n\x20state\x20will\x20be\x20saved\x20or\x20returned\x20in\x20PostWorkfl\
    owResultsResponse.\n\n\x0e\n\x06\x04\xd5\x01\x02\x06\x06\x12\x04\xe00\
    \x02\x0f\n\x0e\n\x06\x04\xd5\x01\x02\x06\x01\x12\x04\xe00\x10\x1e\n\x0e\
    \n\x06\x04\xd5\x01\x02\x06\x03\x12\x04\xe00!\"\n,\n\x03\x04\xd6\x01\x12\
    \x06\xe40\0\xf10\x01\x1a\x1d\x20PostWorkflowResultsResponse\n\n\x0c\n\
    \x04\x04\xd6\x01\x01\x12\x04\xe40\x08#\n+\n\x05\x04\xd6\x01\x02\0\x12\
    \x04\xe60\x02(\x1a\x1c\x20The\x20status\x20of\x20the\x20request.\n\n\x0e\
    \n\x06\x04\xd6\x01\x02\0\x06\x12\x04\xe60\x02\x1c\n\x0e\n\x06\x04\xd6\
    \x01\x02\0\x01\x12\x04\xe60\x1d#\n\x0e\n\x06\x04\xd6\x01\x02\0\x03\x12\
    \x04\xe60&'\nS\n\x05\x04\xd6\x01\x02\x01\x12\x04\xe80\x02\x18\x1aD\x20Th\
    e\x20workflow\x20that\x20was\x20used\x20in\x20predictions\x20with\x20Pos\
    tWorkflowResults\n\n\x0e\n\x06\x04\xd6\x01\x02\x01\x06\x12\x04\xe80\x02\
    \n\n\x0e\n\x06\x04\xd6\x01\x02\x01\x01\x12\x04\xe80\x0b\x13\n\x0e\n\x06\
    \x04\xd6\x01\x02\x01\x03\x12\x04\xe80\x16\x17\nI\n\x05\x04\xd6\x01\x02\
    \x02\x12\x04\xea0\x02&\x1a:\x20The\x20resulting\x20predictions\x20of\x20\
    all\x20models\x20in\x20the\x20workflow.\n\n\x0e\n\x06\x04\xd6\x01\x02\
    \x02\x04\x12\x04\xea0\x02\n\n\x0e\n\x06\x04\xd6\x01\x02\x02\x06\x12\x04\
    \xea0\x0b\x19\n\x0e\n\x06\x04\xd6\x01\x02\x02\x01\x12\x04\xea0\x1a!\n\
    \x0e\n\x06\x04\xd6\x01\x02\x02\x03\x12\x04\xea0$%\n\xd3\x02\n\x05\x04\
    \xd6\x01\x02\x03\x12\x04\xf00\x02#\x1a\xc3\x02\x20A\x20workflow\x20state\
    \x20to\x20be\x20maintained\x20across\x20PostWorkflowResults\x20requests/\
    responses.\n\x20This\x20WorkflowState\x20should\x20be\x20passed\x20in\
    \x20to\x20subsequent\x20PostWorkflowResults\x20calls\n\x20if\x20you\x20w\
    ant\x20to\x20keep\x20track\x20of\x20state\x20across\x20requests.\n\x20If\
    \x20no\x20WorkflowState\x20was\x20initialized\x20in\x20a\x20request\x20t\
    hen\x20no\x20WorkflowState\x20will\x20be\x20returned\x20in\x20this\n\x20\
    response.\n\n\x0e\n\x06\x04\xd6\x01\x02\x03\x06\x12\x04\xf00\x02\x0f\n\
    \x0e\n\x06\x04\xd6\x01\x02\x03\x01\x12\x04\xf00\x10\x1e\n\x0e\n\x06\x04\
    \xd6\x01\x02\x03\x03\x12\x04\xf00!\"\n5\n\x03\x04\xd7\x01\x12\x06\xf40\0\
    \x821\x01\x1a&\x20PostWorkflowResultsSimilarityRequest\n\n\x0c\n\x04\x04\
    \xd7\x01\x01\x12\x04\xf40\x08,\n\r\n\x05\x04\xd7\x01\x02\0\x12\x04\xf50\
    \x02,\n\x0e\n\x06\x04\xd7\x01\x02\0\x06\x12\x04\xf50\x02\x1b\n\x0e\n\x06\
    \x04\xd7\x01\x02\0\x01\x12\x04\xf50\x1c'\n\x0e\n\x06\x04\xd7\x01\x02\0\
    \x03\x12\x04\xf50*+\n\r\n\x05\x04\xd7\x01\x02\x01\x12\x04\xf60\x02\x19\n\
    \x0e\n\x06\x04\xd7\x01\x02\x01\x05\x12\x04\xf60\x02\x08\n\x0e\n\x06\x04\
    \xd7\x01\x02\x01\x01\x12\x04\xf60\t\x14\n\x0e\n\x06\x04\xd7\x01\x02\x01\
    \x03\x12\x04\xf60\x17\x18\nh\n\x05\x04\xd7\x01\x02\x02\x12\x04\xf90\x02\
    \x18\x1aY\x20Workflow\x20version\x20ID\x20to\x20retrieve\n\x20If\x20no\
    \x20ID\x20is\x20specified,\x20latest\x20workflow\x20version\x20is\x20use\
    d\n\n\x0e\n\x06\x04\xd7\x01\x02\x02\x05\x12\x04\xf90\x02\x08\n\x0e\n\x06\
    \x04\xd7\x01\x02\x02\x01\x12\x04\xf90\t\x13\n\x0e\n\x06\x04\xd7\x01\x02\
    \x02\x03\x12\x04\xf90\x16\x17\nJ\n\x05\x04\xd7\x01\x02\x03\x12\x04\xfb0\
    \x02\x1e\x1a;\x20The\x20specific\x20model\x20version\x20whose\x20outputs\
    \x20we\x20are\x20comparing\n\n\x0e\n\x06\x04\xd7\x01\x02\x03\x05\x12\x04\
    \xfb0\x02\x08\n\x0e\n\x06\x04\xd7\x01\x02\x03\x01\x12\x04\xfb0\t\x19\n\
    \x0e\n\x06\x04\xd7\x01\x02\x03\x03\x12\x04\xfb0\x1c\x1d\n@\n\x05\x04\xd7\
    \x01\x02\x04\x12\x04\xfd0\x02\"\x1a1\x20Each\x20probe\x20is\x20compared\
    \x20against\x20every\x20pool\x20input\n\n\x0e\n\x06\x04\xd7\x01\x02\x04\
    \x04\x12\x04\xfd0\x02\n\n\x0e\n\x06\x04\xd7\x01\x02\x04\x06\x12\x04\xfd0\
    \x0b\x10\n\x0e\n\x06\x04\xd7\x01\x02\x04\x01\x12\x04\xfd0\x11\x1d\n\x0e\
    \n\x06\x04\xd7\x01\x02\x04\x03\x12\x04\xfd0\x20!\nE\n\x05\x04\xd7\x01\
    \x02\x05\x12\x04\xff0\x02!\x1a6\x20Each\x20pool\x20input\x20is\x20compar\
    ed\x20against\x20ever\x20probe\x20input\n\n\x0e\n\x06\x04\xd7\x01\x02\
    \x05\x04\x12\x04\xff0\x02\n\n\x0e\n\x06\x04\xd7\x01\x02\x05\x06\x12\x04\
    \xff0\x0b\x10\n\x0e\n\x06\x04\xd7\x01\x02\x05\x01\x12\x04\xff0\x11\x1c\n\
    \x0e\n\x06\x04\xd7\x01\x02\x05\x03\x12\x04\xff0\x1f\x20\n`\n\x05\x04\xd7\
    \x01\x02\x06\x12\x04\x811\x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\
    \x20into\x20clarifai\x20published\x20workflows\x20first\x20for\x20a\x20W\
    orkflow\x20ID\n\n\x0e\n\x06\x04\xd7\x01\x02\x06\x05\x12\x04\x811\x02\x06\
    \n\x0e\n\x06\x04\xd7\x01\x02\x06\x01\x12\x04\x811\x07\x1f\n\x0e\n\x06\
    \x04\xd7\x01\x02\x06\x03\x12\x04\x811\"#\n6\n\x03\x04\xd8\x01\x12\x06\
    \x851\0\x881\x01\x1a'\x20PostWorkflowResultsSimilarityResponse\n\n\x0c\n\
    \x04\x04\xd8\x01\x01\x12\x04\x851\x08-\n\r\n\x05\x04\xd8\x01\x02\0\x12\
    \x04\x861\x02(\n\x0e\n\x06\x04\xd8\x01\x02\0\x06\x12\x04\x861\x02\x1c\n\
    \x0e\n\x06\x04\xd8\x01\x02\0\x01\x12\x04\x861\x1d#\n\x0e\n\x06\x04\xd8\
    \x01\x02\0\x03\x12\x04\x861&'\n\r\n\x05\x04\xd8\x01\x02\x01\x12\x04\x871\
    \x021\n\x0e\n\x06\x04\xd8\x01\x02\x01\x04\x12\x04\x871\x02\n\n\x0e\n\x06\
    \x04\xd8\x01\x02\x01\x06\x12\x04\x871\x0b$\n\x0e\n\x06\x04\xd8\x01\x02\
    \x01\x01\x12\x04\x871%,\n\x0e\n\x06\x04\xd8\x01\x02\x01\x03\x12\x04\x871\
    /0\n,\n\x03\x04\xd9\x01\x12\x06\x8b1\0\x951\x01\x1a\x1d\x20ListWorkflowV\
    ersionsRequest\n\n\x0c\n\x04\x04\xd9\x01\x01\x12\x04\x8b1\x08#\n\r\n\x05\
    \x04\xd9\x01\x02\0\x12\x04\x8c1\x02,\n\x0e\n\x06\x04\xd9\x01\x02\0\x06\
    \x12\x04\x8c1\x02\x1b\n\x0e\n\x06\x04\xd9\x01\x02\0\x01\x12\x04\x8c1\x1c\
    '\n\x0e\n\x06\x04\xd9\x01\x02\0\x03\x12\x04\x8c1*+\nE\n\x05\x04\xd9\x01\
    \x02\x01\x12\x04\x8e1\x02\x19\x1a6\x20List\x20versions\x20for\x20the\x20\
    workflow\x20identified\x20by\x20this\x20id\n\n\x0e\n\x06\x04\xd9\x01\x02\
    \x01\x05\x12\x04\x8e1\x02\x08\n\x0e\n\x06\x04\xd9\x01\x02\x01\x01\x12\
    \x04\x8e1\t\x14\n\x0e\n\x06\x04\xd9\x01\x02\x01\x03\x12\x04\x8e1\x17\x18\
    \n\x7f\n\x05\x04\xd9\x01\x02\x02\x12\x04\x911\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xd9\x01\x02\x02\x05\x12\x04\x911\x02\x08\
    \n\x0e\n\x06\x04\xd9\x01\x02\x02\x01\x12\x04\x911\t\r\n\x0e\n\x06\x04\
    \xd9\x01\x02\x02\x03\x12\x04\x911\x10\x11\nv\n\x05\x04\xd9\x01\x02\x03\
    \x12\x04\x941\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xd9\x01\x02\x03\
    \x05\x12\x04\x941\x02\x08\n\x0e\n\x06\x04\xd9\x01\x02\x03\x01\x12\x04\
    \x941\t\x11\n\x0e\n\x06\x04\xd9\x01\x02\x03\x03\x12\x04\x941\x14\x15\n*\
    \n\x03\x04\xda\x01\x12\x06\x981\0\x9e1\x01\x1a\x1b\x20GetWorkflowVersion\
    Request\n\n\x0c\n\x04\x04\xda\x01\x01\x12\x04\x981\x08!\n\r\n\x05\x04\
    \xda\x01\x02\0\x12\x04\x991\x04.\n\x0e\n\x06\x04\xda\x01\x02\0\x06\x12\
    \x04\x991\x04\x1d\n\x0e\n\x06\x04\xda\x01\x02\0\x01\x12\x04\x991\x1e)\n\
    \x0e\n\x06\x04\xda\x01\x02\0\x03\x12\x04\x991,-\nG\n\x05\x04\xda\x01\x02\
    \x01\x12\x04\x9b1\x04\x1b\x1a8\x20The\x20id\x20of\x20the\x20workflow\x20\
    that\x20has\x20the\x20requested\x20version.\n\n\x0e\n\x06\x04\xda\x01\
    \x02\x01\x05\x12\x04\x9b1\x04\n\n\x0e\n\x06\x04\xda\x01\x02\x01\x01\x12\
    \x04\x9b1\x0b\x16\n\x0e\n\x06\x04\xda\x01\x02\x01\x03\x12\x04\x9b1\x19\
    \x1a\n.\n\x05\x04\xda\x01\x02\x02\x12\x04\x9d1\x04#\x1a\x1f\x20Get\x20th\
    e\x20identified\x20by\x20this\x20id\n\n\x0e\n\x06\x04\xda\x01\x02\x02\
    \x05\x12\x04\x9d1\x04\n\n\x0e\n\x06\x04\xda\x01\x02\x02\x01\x12\x04\x9d1\
    \x0b\x1e\n\x0e\n\x06\x04\xda\x01\x02\x02\x03\x12\x04\x9d1!\"\n.\n\x03\
    \x04\xdb\x01\x12\x06\xa11\0\xa71\x01\x1a\x1f\x20DeleteWorkflowVersionsRe\
    quest\n\n\x0c\n\x04\x04\xdb\x01\x01\x12\x04\xa11\x08%\n\r\n\x05\x04\xdb\
    \x01\x02\0\x12\x04\xa21\x04.\n\x0e\n\x06\x04\xdb\x01\x02\0\x06\x12\x04\
    \xa21\x04\x1d\n\x0e\n\x06\x04\xdb\x01\x02\0\x01\x12\x04\xa21\x1e)\n\x0e\
    \n\x06\x04\xdb\x01\x02\0\x03\x12\x04\xa21,-\nR\n\x05\x04\xdb\x01\x02\x01\
    \x12\x04\xa41\x04\x1b\x1aC\x20The\x20id\x20of\x20the\x20workflow\x20that\
    \x20has\x20the\x20requested\x20versions\x20to\x20delete.\n\n\x0e\n\x06\
    \x04\xdb\x01\x02\x01\x05\x12\x04\xa41\x04\n\n\x0e\n\x06\x04\xdb\x01\x02\
    \x01\x01\x12\x04\xa41\x0b\x16\n\x0e\n\x06\x04\xdb\x01\x02\x01\x03\x12\
    \x04\xa41\x19\x1a\n<\n\x05\x04\xdb\x01\x02\x02\x12\x04\xa61\x04-\x1a-\
    \x20Delete\x20the\x20versions\x20identified\x20by\x20these\x20ids\n\n\
    \x0e\n\x06\x04\xdb\x01\x02\x02\x04\x12\x04\xa61\x04\x0c\n\x0e\n\x06\x04\
    \xdb\x01\x02\x02\x05\x12\x04\xa61\r\x13\n\x0e\n\x06\x04\xdb\x01\x02\x02\
    \x01\x12\x04\xa61\x14(\n\x0e\n\x06\x04\xdb\x01\x02\x02\x03\x12\x04\xa61+\
    ,\n-\n\x03\x04\xdc\x01\x12\x06\xaa1\0\xb31\x01\x1a\x1e\x20PatchWorkflowV\
    ersionsRequest\n\n\x0c\n\x04\x04\xdc\x01\x01\x12\x04\xaa1\x08$\n\r\n\x05\
    \x04\xdc\x01\x02\0\x12\x04\xab1\x04.\n\x0e\n\x06\x04\xdc\x01\x02\0\x06\
    \x12\x04\xab1\x04\x1d\n\x0e\n\x06\x04\xdc\x01\x02\0\x01\x12\x04\xab1\x1e\
    )\n\x0e\n\x06\x04\xdc\x01\x02\0\x03\x12\x04\xab1,-\nQ\n\x05\x04\xdc\x01\
    \x02\x01\x12\x04\xad1\x04\x1b\x1aB\x20The\x20id\x20of\x20the\x20workflow\
    \x20that\x20has\x20the\x20requested\x20versions\x20to\x20patch.\n\n\x0e\
    \n\x06\x04\xdc\x01\x02\x01\x05\x12\x04\xad1\x04\n\n\x0e\n\x06\x04\xdc\
    \x01\x02\x01\x01\x12\x04\xad1\x0b\x16\n\x0e\n\x06\x04\xdc\x01\x02\x01\
    \x03\x12\x04\xad1\x19\x1a\n&\n\x05\x04\xdc\x01\x02\x02\x12\x04\xaf1\x043\
    \x1a\x17\x20Patch\x20these\x20versions.\n\n\x0e\n\x06\x04\xdc\x01\x02\
    \x02\x04\x12\x04\xaf1\x04\x0c\n\x0e\n\x06\x04\xdc\x01\x02\x02\x06\x12\
    \x04\xaf1\r\x1c\n\x0e\n\x06\x04\xdc\x01\x02\x02\x01\x12\x04\xaf1\x1d.\n\
    \x0e\n\x06\x04\xdc\x01\x02\x02\x03\x12\x04\xaf112\n\x7f\n\x05\x04\xdc\
    \x01\x02\x03\x12\x04\xb21\x04\x16\x1ap\x20The\x20action\x20to\x20perform\
    \x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge\
    ',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\
    \x04\xdc\x01\x02\x03\x05\x12\x04\xb21\x04\n\n\x0e\n\x06\x04\xdc\x01\x02\
    \x03\x01\x12\x04\xb21\x0b\x11\n\x0e\n\x06\x04\xdc\x01\x02\x03\x03\x12\
    \x04\xb21\x14\x15\n-\n\x03\x04\xdd\x01\x12\x06\xb61\0\xb91\x01\x1a\x1e\
    \x20MultiWorkflowVersionResponse\n\n\x0c\n\x04\x04\xdd\x01\x01\x12\x04\
    \xb61\x08$\n\r\n\x05\x04\xdd\x01\x02\0\x12\x04\xb71\x04*\n\x0e\n\x06\x04\
    \xdd\x01\x02\0\x06\x12\x04\xb71\x04\x1e\n\x0e\n\x06\x04\xdd\x01\x02\0\
    \x01\x12\x04\xb71\x1f%\n\x0e\n\x06\x04\xdd\x01\x02\0\x03\x12\x04\xb71()\
    \n\r\n\x05\x04\xdd\x01\x02\x01\x12\x04\xb81\x04b\n\x0e\n\x06\x04\xdd\x01\
    \x02\x01\x04\x12\x04\xb81\x04\x0c\n\x0e\n\x06\x04\xdd\x01\x02\x01\x06\
    \x12\x04\xb81\r\x1c\n\x0e\n\x06\x04\xdd\x01\x02\x01\x01\x12\x04\xb81\x1d\
    .\n\x0e\n\x06\x04\xdd\x01\x02\x01\x03\x12\x04\xb8112\n\x0e\n\x06\x04\xdd\
    \x01\x02\x01\x08\x12\x04\xb813a\n\x11\n\t\x04\xdd\x01\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xb814`\n.\n\x03\x04\xde\x01\x12\x06\xbc1\0\xbf1\x01\x1a\
    \x1f\x20SingleWorkflowVersionResponse\n\n\x0c\n\x04\x04\xde\x01\x01\x12\
    \x04\xbc1\x08%\n\r\n\x05\x04\xde\x01\x02\0\x12\x04\xbd1\x04*\n\x0e\n\x06\
    \x04\xde\x01\x02\0\x06\x12\x04\xbd1\x04\x1e\n\x0e\n\x06\x04\xde\x01\x02\
    \0\x01\x12\x04\xbd1\x1f%\n\x0e\n\x06\x04\xde\x01\x02\0\x03\x12\x04\xbd1(\
    )\n\r\n\x05\x04\xde\x01\x02\x01\x12\x04\xbe1\x04)\n\x0e\n\x06\x04\xde\
    \x01\x02\x01\x06\x12\x04\xbe1\x04\x13\n\x0e\n\x06\x04\xde\x01\x02\x01\
    \x01\x12\x04\xbe1\x14$\n\x0e\n\x06\x04\xde\x01\x02\x01\x03\x12\x04\xbe1'\
    (\n7\n\x03\x04\xdf\x01\x12\x06\xca1\0\xce1\x01\x1a(\x20Request\x20to\x20\
    start\x20app\x20duplication\x20jobs.\n\n\x0c\n\x04\x04\xdf\x01\x01\x12\
    \x04\xca1\x08\"\nT\n\x05\x04\xdf\x01\x02\0\x12\x04\xcc1\x02,\x1aE\x20The\
    \x20user\x20and\x20application\x20ID\x20of\x20the\x20source\x20applicati\
    on\x20to\x20duplicate.\n\n\x0e\n\x06\x04\xdf\x01\x02\0\x06\x12\x04\xcc1\
    \x02\x1b\n\x0e\n\x06\x04\xdf\x01\x02\0\x01\x12\x04\xcc1\x1c'\n\x0e\n\x06\
    \x04\xdf\x01\x02\0\x03\x12\x04\xcc1*+\n\r\n\x05\x04\xdf\x01\x02\x01\x12\
    \x04\xcd1\x02/\n\x0e\n\x06\x04\xdf\x01\x02\x01\x04\x12\x04\xcd1\x02\n\n\
    \x0e\n\x06\x04\xdf\x01\x02\x01\x06\x12\x04\xcd1\x0b\x19\n\x0e\n\x06\x04\
    \xdf\x01\x02\x01\x01\x12\x04\xcd1\x1a*\n\x0e\n\x06\x04\xdf\x01\x02\x01\
    \x03\x12\x04\xcd1-.\n7\n\x03\x04\xe0\x01\x12\x06\xd11\0\xd51\x01\x1a(\
    \x20Request\x20to\x20get\x20an\x20app\x20duplication\x20job.\n\n\x0c\n\
    \x04\x04\xe0\x01\x01\x12\x04\xd11\x08\x20\nI\n\x05\x04\xe0\x01\x02\0\x12\
    \x04\xd31\x02,\x1a:\x20The\x20ID\x20of\x20the\x20user\x20that\x20created\
    \x20the\x20app\x20duplication\x20job.\n\n\x0e\n\x06\x04\xe0\x01\x02\0\
    \x06\x12\x04\xd31\x02\x1b\n\x0e\n\x06\x04\xe0\x01\x02\0\x01\x12\x04\xd31\
    \x1c'\n\x0e\n\x06\x04\xe0\x01\x02\0\x03\x12\x04\xd31*+\n\r\n\x05\x04\xe0\
    \x01\x02\x01\x12\x04\xd41\x02\x20\n\x0e\n\x06\x04\xe0\x01\x02\x01\x05\
    \x12\x04\xd41\x02\x08\n\x0e\n\x06\x04\xe0\x01\x02\x01\x01\x12\x04\xd41\t\
    \x1b\n\x0e\n\x06\x04\xe0\x01\x02\x01\x03\x12\x04\xd41\x1e\x1f\nR\n\x03\
    \x04\xe1\x01\x12\x06\xd81\0\xe11\x01\x1aC\x20Request\x20to\x20list\x20al\
    l\x20the\x20app\x20duplication\x20jobs\x20that\x20a\x20user\x20created.\
    \n\n\x0c\n\x04\x04\xe1\x01\x01\x12\x04\xd81\x08\"\nG\n\x05\x04\xe1\x01\
    \x02\0\x12\x04\xda1\x02,\x1a8\x20The\x20ID\x20of\x20the\x20user\x20whose\
    \x20app\x20duplication\x20jobs\x20to\x20list.\n\n\x0e\n\x06\x04\xe1\x01\
    \x02\0\x06\x12\x04\xda1\x02\x1b\n\x0e\n\x06\x04\xe1\x01\x02\0\x01\x12\
    \x04\xda1\x1c'\n\x0e\n\x06\x04\xe1\x01\x02\0\x03\x12\x04\xda1*+\n\x7f\n\
    \x05\x04\xe1\x01\x02\x01\x12\x04\xdd1\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\x0e\n\x06\x04\xe1\x01\x02\x01\x05\x12\x04\xdd1\x02\x08\n\x0e\n\
    \x06\x04\xe1\x01\x02\x01\x01\x12\x04\xdd1\t\r\n\x0e\n\x06\x04\xe1\x01\
    \x02\x01\x03\x12\x04\xdd1\x10\x11\nv\n\x05\x04\xe1\x01\x02\x02\x12\x04\
    \xe01\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\
    \x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20pa\
    ge.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xe1\x01\x02\x02\x05\
    \x12\x04\xe01\x02\x08\n\x0e\n\x06\x04\xe1\x01\x02\x02\x01\x12\x04\xe01\t\
    \x11\n\x0e\n\x06\x04\xe1\x01\x02\x02\x03\x12\x04\xe01\x14\x15\n-\n\x03\
    \x04\xe2\x01\x12\x06\xe41\0\xe71\x01\x1a\x1e\x20MultiAppDuplicationsResp\
    onse\n\n\x0c\n\x04\x04\xe2\x01\x01\x12\x04\xe41\x08$\n\r\n\x05\x04\xe2\
    \x01\x02\0\x12\x04\xe51\x02(\n\x0e\n\x06\x04\xe2\x01\x02\0\x06\x12\x04\
    \xe51\x02\x1c\n\x0e\n\x06\x04\xe2\x01\x02\0\x01\x12\x04\xe51\x1d#\n\x0e\
    \n\x06\x04\xe2\x01\x02\0\x03\x12\x04\xe51&'\n\r\n\x05\x04\xe2\x01\x02\
    \x01\x12\x04\xe61\x02/\n\x0e\n\x06\x04\xe2\x01\x02\x01\x04\x12\x04\xe61\
    \x02\n\n\x0e\n\x06\x04\xe2\x01\x02\x01\x06\x12\x04\xe61\x0b\x19\n\x0e\n\
    \x06\x04\xe2\x01\x02\x01\x01\x12\x04\xe61\x1a*\n\x0e\n\x06\x04\xe2\x01\
    \x02\x01\x03\x12\x04\xe61-.\n-\n\x03\x04\xe3\x01\x12\x06\xea1\0\xed1\x01\
    \x1a\x1e\x20SingleAppDuplicationResponse\n\n\x0c\n\x04\x04\xe3\x01\x01\
    \x12\x04\xea1\x08$\n\r\n\x05\x04\xe3\x01\x02\0\x12\x04\xeb1\x02(\n\x0e\n\
    \x06\x04\xe3\x01\x02\0\x06\x12\x04\xeb1\x02\x1c\n\x0e\n\x06\x04\xe3\x01\
    \x02\0\x01\x12\x04\xeb1\x1d#\n\x0e\n\x06\x04\xe3\x01\x02\0\x03\x12\x04\
    \xeb1&'\n\r\n\x05\x04\xe3\x01\x02\x01\x12\x04\xec1\x02%\n\x0e\n\x06\x04\
    \xe3\x01\x02\x01\x06\x12\x04\xec1\x02\x10\n\x0e\n\x06\x04\xe3\x01\x02\
    \x01\x01\x12\x04\xec1\x11\x20\n\x0e\n\x06\x04\xe3\x01\x02\x01\x03\x12\
    \x04\xec1#$\n)\n\x03\x04\xe4\x01\x12\x06\xf01\0\xf31\x01\x1a\x1a\x20Requ\
    est\x20to\x20create\x20Tasks.\n\n\x0c\n\x04\x04\xe4\x01\x01\x12\x04\xf01\
    \x08\x18\n\r\n\x05\x04\xe4\x01\x02\0\x12\x04\xf11\x02,\n\x0e\n\x06\x04\
    \xe4\x01\x02\0\x06\x12\x04\xf11\x02\x1b\n\x0e\n\x06\x04\xe4\x01\x02\0\
    \x01\x12\x04\xf11\x1c'\n\x0e\n\x06\x04\xe4\x01\x02\0\x03\x12\x04\xf11*+\
    \n\r\n\x05\x04\xe4\x01\x02\x01\x12\x04\xf21\x02\x1a\n\x0e\n\x06\x04\xe4\
    \x01\x02\x01\x04\x12\x04\xf21\x02\n\n\x0e\n\x06\x04\xe4\x01\x02\x01\x06\
    \x12\x04\xf21\x0b\x0f\n\x0e\n\x06\x04\xe4\x01\x02\x01\x01\x12\x04\xf21\
    \x10\x15\n\x0e\n\x06\x04\xe4\x01\x02\x01\x03\x12\x04\xf21\x18\x19\n)\n\
    \x03\x04\xe5\x01\x12\x06\xf61\0\xfd1\x01\x1a\x1a\x20Request\x20to\x20get\
    \x20one\x20task.\n\n\x0c\n\x04\x04\xe5\x01\x01\x12\x04\xf61\x08\x16\n\r\
    \n\x05\x04\xe5\x01\x02\0\x12\x04\xf71\x02,\n\x0e\n\x06\x04\xe5\x01\x02\0\
    \x06\x12\x04\xf71\x02\x1b\n\x0e\n\x06\x04\xe5\x01\x02\0\x01\x12\x04\xf71\
    \x1c'\n\x0e\n\x06\x04\xe5\x01\x02\0\x03\x12\x04\xf71*+\n\r\n\x05\x04\xe5\
    \x01\x02\x01\x12\x04\xf81\x02\x15\n\x0e\n\x06\x04\xe5\x01\x02\x01\x05\
    \x12\x04\xf81\x02\x08\n\x0e\n\x06\x04\xe5\x01\x02\x01\x01\x12\x04\xf81\t\
    \x10\n\x0e\n\x06\x04\xe5\x01\x02\x01\x03\x12\x04\xf81\x13\x14\n\x9b\x01\
    \n\x05\x04\xe5\x01\x02\x02\x12\x04\xfc1\x02(\x1a\x8b\x01\x20(optional\
    \x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\
    \x20included\x20in\x20the\x20response.\n\x20Currently\x20supported:\x20a\
    ll,\x20worker.users,\x20review.users.\n\n\x0e\n\x06\x04\xe5\x01\x02\x02\
    \x04\x12\x04\xfc1\x02\n\n\x0e\n\x06\x04\xe5\x01\x02\x02\x05\x12\x04\xfc1\
    \x0b\x11\n\x0e\n\x06\x04\xe5\x01\x02\x02\x01\x12\x04\xfc1\x12#\n\x0e\n\
    \x06\x04\xe5\x01\x02\x02\x03\x12\x04\xfc1&'\n0\n\x03\x04\xe6\x01\x12\x06\
    \x802\0\x962\x01\x1a!\x20Request\x20to\x20list\x20multiple\x20tasks.\n\n\
    \x0c\n\x04\x04\xe6\x01\x01\x12\x04\x802\x08\x18\n\r\n\x05\x04\xe6\x01\
    \x02\0\x12\x04\x812\x02,\n\x0e\n\x06\x04\xe6\x01\x02\0\x06\x12\x04\x812\
    \x02\x1b\n\x0e\n\x06\x04\xe6\x01\x02\0\x01\x12\x04\x812\x1c'\n\x0e\n\x06\
    \x04\xe6\x01\x02\0\x03\x12\x04\x812*+\n\x7f\n\x05\x04\xe6\x01\x02\x01\
    \x12\x04\x842\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20p\
    age\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resu\
    lts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xe6\
    \x01\x02\x01\x05\x12\x04\x842\x02\x08\n\x0e\n\x06\x04\xe6\x01\x02\x01\
    \x01\x12\x04\x842\t\r\n\x0e\n\x06\x04\xe6\x01\x02\x01\x03\x12\x04\x842\
    \x10\x11\nv\n\x05\x04\xe6\x01\x02\x02\x12\x04\x872\x02\x16\x1ag\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128\
    .\n\n\x0e\n\x06\x04\xe6\x01\x02\x02\x05\x12\x04\x872\x02\x08\n\x0e\n\x06\
    \x04\xe6\x01\x02\x02\x01\x12\x04\x872\t\x11\n\x0e\n\x06\x04\xe6\x01\x02\
    \x02\x03\x12\x04\x872\x14\x15\nP\n\x05\x04\xe6\x01\x02\x03\x12\x04\x892\
    \x02&\x1aA\x20Get\x20tasks\x20that\x20have\x20ANY\x20user\x20from\x20thi\
    s\x20list\x20assigned\x20as\x20worker.\n\n\x0e\n\x06\x04\xe6\x01\x02\x03\
    \x04\x12\x04\x892\x02\n\n\x0e\n\x06\x04\xe6\x01\x02\x03\x05\x12\x04\x892\
    \x0b\x11\n\x0e\n\x06\x04\xe6\x01\x02\x03\x01\x12\x04\x892\x12!\n\x0e\n\
    \x06\x04\xe6\x01\x02\x03\x03\x12\x04\x892$%\nR\n\x05\x04\xe6\x01\x02\x04\
    \x12\x04\x8b2\x02&\x1aC\x20Get\x20tasks\x20that\x20have\x20ANY\x20user\
    \x20from\x20this\x20list\x20assigned\x20as\x20reviewer.\n\n\x0e\n\x06\
    \x04\xe6\x01\x02\x04\x04\x12\x04\x8b2\x02\n\n\x0e\n\x06\x04\xe6\x01\x02\
    \x04\x05\x12\x04\x8b2\x0b\x11\n\x0e\n\x06\x04\xe6\x01\x02\x04\x01\x12\
    \x04\x8b2\x12!\n\x0e\n\x06\x04\xe6\x01\x02\x04\x03\x12\x04\x8b2$%\nQ\n\
    \x05\x04\xe6\x01\x02\x05\x12\x04\x8d2\x02&\x1aB\x20Get\x20tasks\x20that\
    \x20are\x20associated\x20to\x20ANY\x20label\x20order\x20from\x20this\x20\
    list.\n\n\x0e\n\x06\x04\xe6\x01\x02\x05\x04\x12\x04\x8d2\x02\n\n\x0e\n\
    \x06\x04\xe6\x01\x02\x05\x05\x12\x04\x8d2\x0b\x11\n\x0e\n\x06\x04\xe6\
    \x01\x02\x05\x01\x12\x04\x8d2\x12!\n\x0e\n\x06\x04\xe6\x01\x02\x05\x03\
    \x12\x04\x8d2$%\nj\n\x05\x04\xe6\x01\x02\x06\x12\x04\x912\x02'\x1a[\x20G\
    et\x20label\x20order\x20tasks\x20as\x20well\n\x20It\x20is\x20automatical\
    ly\x20set\x20to\x20true\x20if\x20label_order_ids\x20is\x20set.\n\n\x0e\n\
    \x06\x04\xe6\x01\x02\x06\x05\x12\x04\x912\x02\x06\n\x0e\n\x06\x04\xe6\
    \x01\x02\x06\x01\x12\x04\x912\x07\"\n\x0e\n\x06\x04\xe6\x01\x02\x06\x03\
    \x12\x04\x912%&\n\x9b\x01\n\x05\x04\xe6\x01\x02\x07\x12\x04\x952\x02(\
    \x1a\x8b\x01\x20(optional\x20URL\x20parameter)\x20List\x20of\x20addition\
    al\x20fields\x20to\x20be\x20included\x20in\x20the\x20response.\n\x20Curr\
    ently\x20supported:\x20all,\x20worker.users,\x20review.users.\n\n\x0e\n\
    \x06\x04\xe6\x01\x02\x07\x04\x12\x04\x952\x02\n\n\x0e\n\x06\x04\xe6\x01\
    \x02\x07\x05\x12\x04\x952\x0b\x11\n\x0e\n\x06\x04\xe6\x01\x02\x07\x01\
    \x12\x04\x952\x12#\n\x0e\n\x06\x04\xe6\x01\x02\x07\x03\x12\x04\x952&'\n2\
    \n\x03\x04\xe7\x01\x12\x06\x992\0\x9f2\x01\x1a#\x20Request\x20to\x20patc\
    h\x20a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\x04\xe7\x01\x01\x12\x04\x99\
    2\x08\x19\n\r\n\x05\x04\xe7\x01\x02\0\x12\x04\x9a2\x02,\n\x0e\n\x06\x04\
    \xe7\x01\x02\0\x06\x12\x04\x9a2\x02\x1b\n\x0e\n\x06\x04\xe7\x01\x02\0\
    \x01\x12\x04\x9a2\x1c'\n\x0e\n\x06\x04\xe7\x01\x02\0\x03\x12\x04\x9a2*+\
    \n\r\n\x05\x04\xe7\x01\x02\x01\x12\x04\x9b2\x02\x1a\n\x0e\n\x06\x04\xe7\
    \x01\x02\x01\x04\x12\x04\x9b2\x02\n\n\x0e\n\x06\x04\xe7\x01\x02\x01\x06\
    \x12\x04\x9b2\x0b\x0f\n\x0e\n\x06\x04\xe7\x01\x02\x01\x01\x12\x04\x9b2\
    \x10\x15\n\x0e\n\x06\x04\xe7\x01\x02\x01\x03\x12\x04\x9b2\x18\x19\n\x7f\
    \n\x05\x04\xe7\x01\x02\x02\x12\x04\x9e2\x02\x14\x1ap\x20The\x20action\
    \x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20\
    actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20support\
    ed\n\n\x0e\n\x06\x04\xe7\x01\x02\x02\x05\x12\x04\x9e2\x02\x08\n\x0e\n\
    \x06\x04\xe7\x01\x02\x02\x01\x12\x04\x9e2\t\x0f\n\x0e\n\x06\x04\xe7\x01\
    \x02\x02\x03\x12\x04\x9e2\x12\x13\n3\n\x03\x04\xe8\x01\x12\x06\xa22\0\
    \xa52\x01\x1a$\x20Request\x20to\x20delete\x20a\x20list\x20of\x20tasks.\n\
    \n\x0c\n\x04\x04\xe8\x01\x01\x12\x04\xa22\x08\x1a\n\r\n\x05\x04\xe8\x01\
    \x02\0\x12\x04\xa32\x02,\n\x0e\n\x06\x04\xe8\x01\x02\0\x06\x12\x04\xa32\
    \x02\x1b\n\x0e\n\x06\x04\xe8\x01\x02\0\x01\x12\x04\xa32\x1c'\n\x0e\n\x06\
    \x04\xe8\x01\x02\0\x03\x12\x04\xa32*+\n\r\n\x05\x04\xe8\x01\x02\x01\x12\
    \x04\xa42\x02\x1a\n\x0e\n\x06\x04\xe8\x01\x02\x01\x04\x12\x04\xa42\x02\n\
    \n\x0e\n\x06\x04\xe8\x01\x02\x01\x05\x12\x04\xa42\x0b\x11\n\x0e\n\x06\
    \x04\xe8\x01\x02\x01\x01\x12\x04\xa42\x12\x15\n\x0e\n\x06\x04\xe8\x01\
    \x02\x01\x03\x12\x04\xa42\x18\x19\n.\n\x03\x04\xe9\x01\x12\x06\xa82\0\
    \xab2\x01\x1a\x1f\x20Response\x20with\x20multiple\x20Tasks.\n\n\x0c\n\
    \x04\x04\xe9\x01\x01\x12\x04\xa82\x08\x19\n\r\n\x05\x04\xe9\x01\x02\0\
    \x12\x04\xa92\x02(\n\x0e\n\x06\x04\xe9\x01\x02\0\x06\x12\x04\xa92\x02\
    \x1c\n\x0e\n\x06\x04\xe9\x01\x02\0\x01\x12\x04\xa92\x1d#\n\x0e\n\x06\x04\
    \xe9\x01\x02\0\x03\x12\x04\xa92&'\n\r\n\x05\x04\xe9\x01\x02\x01\x12\x04\
    \xaa2\x02I\n\x0e\n\x06\x04\xe9\x01\x02\x01\x04\x12\x04\xaa2\x02\n\n\x0e\
    \n\x06\x04\xe9\x01\x02\x01\x06\x12\x04\xaa2\x0b\x0f\n\x0e\n\x06\x04\xe9\
    \x01\x02\x01\x01\x12\x04\xaa2\x10\x15\n\x0e\n\x06\x04\xe9\x01\x02\x01\
    \x03\x12\x04\xaa2\x18\x19\n\x0e\n\x06\x04\xe9\x01\x02\x01\x08\x12\x04\
    \xaa2\x1aH\n\x11\n\t\x04\xe9\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xaa2\
    \x1bG\n-\n\x03\x04\xea\x01\x12\x06\xae2\0\xb12\x01\x1a\x1e\x20Response\
    \x20with\x20a\x20single\x20Task.\n\n\x0c\n\x04\x04\xea\x01\x01\x12\x04\
    \xae2\x08\x1a\n\r\n\x05\x04\xea\x01\x02\0\x12\x04\xaf2\x02(\n\x0e\n\x06\
    \x04\xea\x01\x02\0\x06\x12\x04\xaf2\x02\x1c\n\x0e\n\x06\x04\xea\x01\x02\
    \0\x01\x12\x04\xaf2\x1d#\n\x0e\n\x06\x04\xea\x01\x02\0\x03\x12\x04\xaf2&\
    '\n\r\n\x05\x04\xea\x01\x02\x01\x12\x04\xb02\x02\x10\n\x0e\n\x06\x04\xea\
    \x01\x02\x01\x06\x12\x04\xb02\x02\x06\n\x0e\n\x06\x04\xea\x01\x02\x01\
    \x01\x12\x04\xb02\x07\x0b\n\x0e\n\x06\x04\xea\x01\x02\x01\x03\x12\x04\
    \xb02\x0e\x0f\n\xae\x01\n\x03\x04\xeb\x01\x12\x06\xb62\0\xbe2\x01\x1a\
    \x9e\x01\x20GetTaskCountRequest\x20can\x20be\x20used\x20for\x20fetching\
    \x20-\n\x201.\x20Task\x20annotation\x20count\x20per\x20user,\x20per\x20s\
    tatus\n\x201.\x20Task\x20input\x20(anchor\x20annotations)\x20count\x20pe\
    r\x20user,\x20per\x20status\n\n\x0c\n\x04\x04\xeb\x01\x01\x12\x04\xb62\
    \x08\x1b\n\r\n\x05\x04\xeb\x01\x02\0\x12\x04\xb72\x02,\n\x0e\n\x06\x04\
    \xeb\x01\x02\0\x06\x12\x04\xb72\x02\x1b\n\x0e\n\x06\x04\xeb\x01\x02\0\
    \x01\x12\x04\xb72\x1c'\n\x0e\n\x06\x04\xeb\x01\x02\0\x03\x12\x04\xb72*+\
    \nF\n\x05\x04\xeb\x01\x02\x01\x12\x04\xba2\x02\x15\x1a7\x20task_id\x20fo\
    r\x20which\x20count\x20per\x20user\x20per\x20status\x20is\x20needed\n\n\
    \x0e\n\x06\x04\xeb\x01\x02\x01\x05\x12\x04\xba2\x02\x08\n\x0e\n\x06\x04\
    \xeb\x01\x02\x01\x01\x12\x04\xba2\t\x10\n\x0e\n\x06\x04\xeb\x01\x02\x01\
    \x03\x12\x04\xba2\x13\x14\nD\n\x05\x04\xeb\x01\x02\x02\x12\x04\xbd2\x02\
    \x1e\x1a5\x20for\x20given\x20task_id,\x20user_ids\x20to\x20filter\x20on\
    \x20(optional)\n\n\x0e\n\x06\x04\xeb\x01\x02\x02\x04\x12\x04\xbd2\x02\n\
    \n\x0e\n\x06\x04\xeb\x01\x02\x02\x05\x12\x04\xbd2\x0b\x11\n\x0e\n\x06\
    \x04\xeb\x01\x02\x02\x01\x12\x04\xbd2\x12\x1a\n\x0e\n\x06\x04\xeb\x01\
    \x02\x02\x03\x12\x04\xbd2\x1c\x1d\n\x81\x01\n\x03\x04\xec\x01\x12\x06\
    \xc32\0\xc82\x01\x1ar\x20SingleTaskCountResponse\x20represent\x20counts\
    \x20of\x20annotations\x20or\x20inputs(anchor\x20annotations)\x20for\x20l\
    abelers\x20in\x20given\x20task\n\n\x0c\n\x04\x04\xec\x01\x01\x12\x04\xc3\
    2\x08\x1f\n\r\n\x05\x04\xec\x01\x02\0\x12\x04\xc42\x02(\n\x0e\n\x06\x04\
    \xec\x01\x02\0\x06\x12\x04\xc42\x02\x1c\n\x0e\n\x06\x04\xec\x01\x02\0\
    \x01\x12\x04\xc42\x1d#\n\x0e\n\x06\x04\xec\x01\x02\0\x03\x12\x04\xc42&'\
    \n\r\n\x05\x04\xec\x01\x02\x01\x12\x04\xc52\x02\x14\n\x0e\n\x06\x04\xec\
    \x01\x02\x01\x05\x12\x04\xc52\x02\x08\n\x0e\n\x06\x04\xec\x01\x02\x01\
    \x01\x12\x04\xc52\t\x0f\n\x0e\n\x06\x04\xec\x01\x02\x01\x03\x12\x04\xc52\
    \x12\x13\n\r\n\x05\x04\xec\x01\x02\x02\x12\x04\xc62\x02\x15\n\x0e\n\x06\
    \x04\xec\x01\x02\x02\x05\x12\x04\xc62\x02\x08\n\x0e\n\x06\x04\xec\x01\
    \x02\x02\x01\x12\x04\xc62\t\x10\n\x0e\n\x06\x04\xec\x01\x02\x02\x03\x12\
    \x04\xc62\x13\x14\n\r\n\x05\x04\xec\x01\x02\x03\x12\x04\xc72\x02-\n\x0e\
    \n\x06\x04\xec\x01\x02\x03\x04\x12\x04\xc72\x02\n\n\x0e\n\x06\x04\xec\
    \x01\x02\x03\x06\x12\x04\xc72\x0b!\n\x0e\n\x06\x04\xec\x01\x02\x03\x01\
    \x12\x04\xc72\"(\n\x0e\n\x06\x04\xec\x01\x02\x03\x03\x12\x04\xc72+,\n\
    \xdf\x01\n\x03\x04\xed\x01\x12\x06\xd12\0\xd42\x01\x1a!\x20Request\x20to\
    \x20create\x20label\x20orders.\n2\xac\x01///////////////////////////////\
    ///////////////////////////////////////////////\n\x20Label\x20Orders\n//\
    ////////////////////////////////////////////////////////////////////////\
    ////\n\n\x0c\n\x04\x04\xed\x01\x01\x12\x04\xd12\x08\x1e\n\r\n\x05\x04\
    \xed\x01\x02\0\x12\x04\xd22\x02,\n\x0e\n\x06\x04\xed\x01\x02\0\x06\x12\
    \x04\xd22\x02\x1b\n\x0e\n\x06\x04\xed\x01\x02\0\x01\x12\x04\xd22\x1c'\n\
    \x0e\n\x06\x04\xed\x01\x02\0\x03\x12\x04\xd22*+\n\r\n\x05\x04\xed\x01\
    \x02\x01\x12\x04\xd32\x02'\n\x0e\n\x06\x04\xed\x01\x02\x01\x04\x12\x04\
    \xd32\x02\n\n\x0e\n\x06\x04\xed\x01\x02\x01\x06\x12\x04\xd32\x0b\x15\n\
    \x0e\n\x06\x04\xed\x01\x02\x01\x01\x12\x04\xd32\x16\"\n\x0e\n\x06\x04\
    \xed\x01\x02\x01\x03\x12\x04\xd32%&\n0\n\x03\x04\xee\x01\x12\x06\xd72\0\
    \xda2\x01\x1a!\x20Request\x20to\x20get\x20one\x20label\x20order.\n\n\x0c\
    \n\x04\x04\xee\x01\x01\x12\x04\xd72\x08\x1c\n\r\n\x05\x04\xee\x01\x02\0\
    \x12\x04\xd82\x02,\n\x0e\n\x06\x04\xee\x01\x02\0\x06\x12\x04\xd82\x02\
    \x1b\n\x0e\n\x06\x04\xee\x01\x02\0\x01\x12\x04\xd82\x1c'\n\x0e\n\x06\x04\
    \xee\x01\x02\0\x03\x12\x04\xd82*+\n\r\n\x05\x04\xee\x01\x02\x01\x12\x04\
    \xd92\x02\x1c\n\x0e\n\x06\x04\xee\x01\x02\x01\x05\x12\x04\xd92\x02\x08\n\
    \x0e\n\x06\x04\xee\x01\x02\x01\x01\x12\x04\xd92\t\x17\n\x0e\n\x06\x04\
    \xee\x01\x02\x01\x03\x12\x04\xd92\x1a\x1b\n7\n\x03\x04\xef\x01\x12\x06\
    \xdd2\0\xe52\x01\x1a(\x20Request\x20to\x20list\x20multiple\x20label\x20o\
    rders.\n\n\x0c\n\x04\x04\xef\x01\x01\x12\x04\xdd2\x08\x1e\n\r\n\x05\x04\
    \xef\x01\x02\0\x12\x04\xde2\x02,\n\x0e\n\x06\x04\xef\x01\x02\0\x06\x12\
    \x04\xde2\x02\x1b\n\x0e\n\x06\x04\xef\x01\x02\0\x01\x12\x04\xde2\x1c'\n\
    \x0e\n\x06\x04\xef\x01\x02\0\x03\x12\x04\xde2*+\n\x7f\n\x05\x04\xef\x01\
    \x02\x01\x12\x04\xe12\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20\
    The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\xef\x01\x02\x01\x05\x12\x04\xe12\x02\x08\n\x0e\n\x06\x04\xef\x01\
    \x02\x01\x01\x12\x04\xe12\t\r\n\x0e\n\x06\x04\xef\x01\x02\x01\x03\x12\
    \x04\xe12\x10\x11\nv\n\x05\x04\xef\x01\x02\x02\x12\x04\xe42\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\xef\x01\x02\x02\x05\x12\x04\xe42\x02\x08\n\
    \x0e\n\x06\x04\xef\x01\x02\x02\x01\x12\x04\xe42\t\x11\n\x0e\n\x06\x04\
    \xef\x01\x02\x02\x03\x12\x04\xe42\x14\x15\n9\n\x03\x04\xf0\x01\x12\x06\
    \xe82\0\xf02\x01\x1a*\x20Request\x20to\x20patch\x20a\x20list\x20of\x20la\
    bel\x20orders.\n\n\x0c\n\x04\x04\xf0\x01\x01\x12\x04\xe82\x08\x1f\n\r\n\
    \x05\x04\xf0\x01\x02\0\x12\x04\xe92\x02,\n\x0e\n\x06\x04\xf0\x01\x02\0\
    \x06\x12\x04\xe92\x02\x1b\n\x0e\n\x06\x04\xf0\x01\x02\0\x01\x12\x04\xe92\
    \x1c'\n\x0e\n\x06\x04\xf0\x01\x02\0\x03\x12\x04\xe92*+\n\r\n\x05\x04\xf0\
    \x01\x02\x01\x12\x04\xeb2\x02'\n\x0e\n\x06\x04\xf0\x01\x02\x01\x04\x12\
    \x04\xeb2\x02\n\n\x0e\n\x06\x04\xf0\x01\x02\x01\x06\x12\x04\xeb2\x0b\x15\
    \n\x0e\n\x06\x04\xf0\x01\x02\x01\x01\x12\x04\xeb2\x16\"\n\x0e\n\x06\x04\
    \xf0\x01\x02\x01\x03\x12\x04\xeb2%&\n\x7f\n\x05\x04\xf0\x01\x02\x02\x12\
    \x04\xef2\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwr\
    ite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\xf0\x01\
    \x02\x02\x05\x12\x04\xef2\x02\x08\n\x0e\n\x06\x04\xf0\x01\x02\x02\x01\
    \x12\x04\xef2\t\x0f\n\x0e\n\x06\x04\xf0\x01\x02\x02\x03\x12\x04\xef2\x12\
    \x13\n:\n\x03\x04\xf1\x01\x12\x06\xf32\0\xf62\x01\x1a+\x20Request\x20to\
    \x20delete\x20a\x20list\x20of\x20label\x20orders.\n\n\x0c\n\x04\x04\xf1\
    \x01\x01\x12\x04\xf32\x08\x20\n\r\n\x05\x04\xf1\x01\x02\0\x12\x04\xf42\
    \x02,\n\x0e\n\x06\x04\xf1\x01\x02\0\x06\x12\x04\xf42\x02\x1b\n\x0e\n\x06\
    \x04\xf1\x01\x02\0\x01\x12\x04\xf42\x1c'\n\x0e\n\x06\x04\xf1\x01\x02\0\
    \x03\x12\x04\xf42*+\n\r\n\x05\x04\xf1\x01\x02\x01\x12\x04\xf52\x02\x1a\n\
    \x0e\n\x06\x04\xf1\x01\x02\x01\x04\x12\x04\xf52\x02\n\n\x0e\n\x06\x04\
    \xf1\x01\x02\x01\x05\x12\x04\xf52\x0b\x11\n\x0e\n\x06\x04\xf1\x01\x02\
    \x01\x01\x12\x04\xf52\x12\x15\n\x0e\n\x06\x04\xf1\x01\x02\x01\x03\x12\
    \x04\xf52\x18\x19\n4\n\x03\x04\xf2\x01\x12\x06\xf92\0\xfc2\x01\x1a%\x20R\
    esponse\x20with\x20multiple\x20label\x20order.\n\n\x0c\n\x04\x04\xf2\x01\
    \x01\x12\x04\xf92\x08\x1f\n\r\n\x05\x04\xf2\x01\x02\0\x12\x04\xfa2\x02(\
    \n\x0e\n\x06\x04\xf2\x01\x02\0\x06\x12\x04\xfa2\x02\x1c\n\x0e\n\x06\x04\
    \xf2\x01\x02\0\x01\x12\x04\xfa2\x1d#\n\x0e\n\x06\x04\xf2\x01\x02\0\x03\
    \x12\x04\xfa2&'\n\r\n\x05\x04\xf2\x01\x02\x01\x12\x04\xfb2\x02V\n\x0e\n\
    \x06\x04\xf2\x01\x02\x01\x04\x12\x04\xfb2\x02\n\n\x0e\n\x06\x04\xf2\x01\
    \x02\x01\x06\x12\x04\xfb2\x0b\x15\n\x0e\n\x06\x04\xf2\x01\x02\x01\x01\
    \x12\x04\xfb2\x16\"\n\x0e\n\x06\x04\xf2\x01\x02\x01\x03\x12\x04\xfb2%&\n\
    \x0e\n\x06\x04\xf2\x01\x02\x01\x08\x12\x04\xfb2'U\n\x11\n\t\x04\xf2\x01\
    \x02\x01\x08\xd0\x86\x03\x12\x04\xfb2(T\n-\n\x03\x04\xf3\x01\x12\x06\xff\
    2\0\x823\x01\x1a\x1e\x20Response\x20with\x20a\x20label\x20order.\n\n\x0c\
    \n\x04\x04\xf3\x01\x01\x12\x04\xff2\x08\x20\n\r\n\x05\x04\xf3\x01\x02\0\
    \x12\x04\x803\x02(\n\x0e\n\x06\x04\xf3\x01\x02\0\x06\x12\x04\x803\x02\
    \x1c\n\x0e\n\x06\x04\xf3\x01\x02\0\x01\x12\x04\x803\x1d#\n\x0e\n\x06\x04\
    \xf3\x01\x02\0\x03\x12\x04\x803&'\n\r\n\x05\x04\xf3\x01\x02\x01\x12\x04\
    \x813\x02\x1d\n\x0e\n\x06\x04\xf3\x01\x02\x01\x06\x12\x04\x813\x02\x0c\n\
    \x0e\n\x06\x04\xf3\x01\x02\x01\x01\x12\x04\x813\r\x18\n\x0e\n\x06\x04\
    \xf3\x01\x02\x01\x03\x12\x04\x813\x1b\x1c\n.\n\x03\x04\xf4\x01\x12\x06\
    \x853\0\x883\x01\x1a\x1f\x20Request\x20to\x20create\x20Collectors.\n\n\
    \x0c\n\x04\x04\xf4\x01\x01\x12\x04\x853\x08\x1d\n\r\n\x05\x04\xf4\x01\
    \x02\0\x12\x04\x863\x02,\n\x0e\n\x06\x04\xf4\x01\x02\0\x06\x12\x04\x863\
    \x02\x1b\n\x0e\n\x06\x04\xf4\x01\x02\0\x01\x12\x04\x863\x1c'\n\x0e\n\x06\
    \x04\xf4\x01\x02\0\x03\x12\x04\x863*+\n\r\n\x05\x04\xf4\x01\x02\x01\x12\
    \x04\x873\x02$\n\x0e\n\x06\x04\xf4\x01\x02\x01\x04\x12\x04\x873\x02\n\n\
    \x0e\n\x06\x04\xf4\x01\x02\x01\x06\x12\x04\x873\x0b\x14\n\x0e\n\x06\x04\
    \xf4\x01\x02\x01\x01\x12\x04\x873\x15\x1f\n\x0e\n\x06\x04\xf4\x01\x02\
    \x01\x03\x12\x04\x873\"#\n'\n\x03\x04\xf5\x01\x12\x06\x8b3\0\x933\x01\
    \x1a\x18\x20PatchCollectorsRequest\n\n\x0c\n\x04\x04\xf5\x01\x01\x12\x04\
    \x8b3\x08\x1e\n\r\n\x05\x04\xf5\x01\x02\0\x12\x04\x8c3\x02,\n\x0e\n\x06\
    \x04\xf5\x01\x02\0\x06\x12\x04\x8c3\x02\x1b\n\x0e\n\x06\x04\xf5\x01\x02\
    \0\x01\x12\x04\x8c3\x1c'\n\x0e\n\x06\x04\xf5\x01\x02\0\x03\x12\x04\x8c3*\
    +\n\r\n\x05\x04\xf5\x01\x02\x01\x12\x04\x8e3\x02$\n\x0e\n\x06\x04\xf5\
    \x01\x02\x01\x04\x12\x04\x8e3\x02\n\n\x0e\n\x06\x04\xf5\x01\x02\x01\x06\
    \x12\x04\x8e3\x0b\x14\n\x0e\n\x06\x04\xf5\x01\x02\x01\x01\x12\x04\x8e3\
    \x15\x1f\n\x0e\n\x06\x04\xf5\x01\x02\x01\x03\x12\x04\x8e3\"#\n\\\n\x05\
    \x04\xf5\x01\x02\x02\x12\x04\x923\x02\x14\x1aM\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20Only\x20'overwrite'\
    \x20is\x20supported\n\n\x0e\n\x06\x04\xf5\x01\x02\x02\x05\x12\x04\x923\
    \x02\x08\n\x0e\n\x06\x04\xf5\x01\x02\x02\x01\x12\x04\x923\t\x0f\n\x0e\n\
    \x06\x04\xf5\x01\x02\x02\x03\x12\x04\x923\x12\x13\nE\n\x03\x04\xf6\x01\
    \x12\x06\x963\0\x9a3\x01\x1a6\x20Request\x20to\x20delete\x20several\x20t\
    hings\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xf6\x01\x01\
    \x12\x04\x963\x08\x1f\n\r\n\x05\x04\xf6\x01\x02\0\x12\x04\x973\x02,\n\
    \x0e\n\x06\x04\xf6\x01\x02\0\x06\x12\x04\x973\x02\x1b\n\x0e\n\x06\x04\
    \xf6\x01\x02\0\x01\x12\x04\x973\x1c'\n\x0e\n\x06\x04\xf6\x01\x02\0\x03\
    \x12\x04\x973*+\n\r\n\x05\x04\xf6\x01\x02\x01\x12\x04\x983\x02\x1a\n\x0e\
    \n\x06\x04\xf6\x01\x02\x01\x04\x12\x04\x983\x02\n\n\x0e\n\x06\x04\xf6\
    \x01\x02\x01\x05\x12\x04\x983\x0b\x11\n\x0e\n\x06\x04\xf6\x01\x02\x01\
    \x01\x12\x04\x983\x12\x15\n\x0e\n\x06\x04\xf6\x01\x02\x01\x03\x12\x04\
    \x983\x18\x19\n\r\n\x05\x04\xf6\x01\x02\x02\x12\x04\x993\x02\x16\n\x0e\n\
    \x06\x04\xf6\x01\x02\x02\x05\x12\x04\x993\x02\x06\n\x0e\n\x06\x04\xf6\
    \x01\x02\x02\x01\x12\x04\x993\x07\x11\n\x0e\n\x06\x04\xf6\x01\x02\x02\
    \x03\x12\x04\x993\x14\x15\n3\n\x03\x04\xf7\x01\x12\x06\x9d3\0\xa03\x01\
    \x1a$\x20Request\x20to\x20GET\x20a\x20single\x20Collector.\n\n\x0c\n\x04\
    \x04\xf7\x01\x01\x12\x04\x9d3\x08\x1b\n\r\n\x05\x04\xf7\x01\x02\0\x12\
    \x04\x9e3\x02,\n\x0e\n\x06\x04\xf7\x01\x02\0\x06\x12\x04\x9e3\x02\x1b\n\
    \x0e\n\x06\x04\xf7\x01\x02\0\x01\x12\x04\x9e3\x1c'\n\x0e\n\x06\x04\xf7\
    \x01\x02\0\x03\x12\x04\x9e3*+\n\r\n\x05\x04\xf7\x01\x02\x01\x12\x04\x9f3\
    \x02\x1a\n\x0e\n\x06\x04\xf7\x01\x02\x01\x05\x12\x04\x9f3\x02\x08\n\x0e\
    \n\x06\x04\xf7\x01\x02\x01\x01\x12\x04\x9f3\t\x15\n\x0e\n\x06\x04\xf7\
    \x01\x02\x01\x03\x12\x04\x9f3\x18\x19\n3\n\x03\x04\xf8\x01\x12\x06\xa33\
    \0\xab3\x01\x1a$\x20Request\x20to\x20GET\x20all\x20the\x20Collectors.\n\
    \n\x0c\n\x04\x04\xf8\x01\x01\x12\x04\xa33\x08\x1d\n\r\n\x05\x04\xf8\x01\
    \x02\0\x12\x04\xa43\x02,\n\x0e\n\x06\x04\xf8\x01\x02\0\x06\x12\x04\xa43\
    \x02\x1b\n\x0e\n\x06\x04\xf8\x01\x02\0\x01\x12\x04\xa43\x1c'\n\x0e\n\x06\
    \x04\xf8\x01\x02\0\x03\x12\x04\xa43*+\n\x7f\n\x05\x04\xf8\x01\x02\x01\
    \x12\x04\xa73\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20p\
    age\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resu\
    lts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xf8\
    \x01\x02\x01\x05\x12\x04\xa73\x02\x08\n\x0e\n\x06\x04\xf8\x01\x02\x01\
    \x01\x12\x04\xa73\t\r\n\x0e\n\x06\x04\xf8\x01\x02\x01\x03\x12\x04\xa73\
    \x10\x11\nv\n\x05\x04\xf8\x01\x02\x02\x12\x04\xaa3\x02\x16\x1ag\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128\
    .\n\n\x0e\n\x06\x04\xf8\x01\x02\x02\x05\x12\x04\xaa3\x02\x08\n\x0e\n\x06\
    \x04\xf8\x01\x02\x02\x01\x12\x04\xaa3\t\x11\n\x0e\n\x06\x04\xf8\x01\x02\
    \x02\x03\x12\x04\xaa3\x14\x15\n3\n\x03\x04\xf9\x01\x12\x06\xae3\0\xb13\
    \x01\x1a$\x20Response\x20with\x20multiple\x20Collectors.\n\n\x0c\n\x04\
    \x04\xf9\x01\x01\x12\x04\xae3\x08\x1e\n\r\n\x05\x04\xf9\x01\x02\0\x12\
    \x04\xaf3\x02(\n\x0e\n\x06\x04\xf9\x01\x02\0\x06\x12\x04\xaf3\x02\x1c\n\
    \x0e\n\x06\x04\xf9\x01\x02\0\x01\x12\x04\xaf3\x1d#\n\x0e\n\x06\x04\xf9\
    \x01\x02\0\x03\x12\x04\xaf3&'\n\r\n\x05\x04\xf9\x01\x02\x01\x12\x04\xb03\
    \x02$\n\x0e\n\x06\x04\xf9\x01\x02\x01\x04\x12\x04\xb03\x02\n\n\x0e\n\x06\
    \x04\xf9\x01\x02\x01\x06\x12\x04\xb03\x0b\x14\n\x0e\n\x06\x04\xf9\x01\
    \x02\x01\x01\x12\x04\xb03\x15\x1f\n\x0e\n\x06\x04\xf9\x01\x02\x01\x03\
    \x12\x04\xb03\"#\n2\n\x03\x04\xfa\x01\x12\x06\xb43\0\xb73\x01\x1a#\x20Re\
    sponse\x20with\x20a\x20single\x20Collector.\n\n\x0c\n\x04\x04\xfa\x01\
    \x01\x12\x04\xb43\x08\x1f\n\r\n\x05\x04\xfa\x01\x02\0\x12\x04\xb53\x02(\
    \n\x0e\n\x06\x04\xfa\x01\x02\0\x06\x12\x04\xb53\x02\x1c\n\x0e\n\x06\x04\
    \xfa\x01\x02\0\x01\x12\x04\xb53\x1d#\n\x0e\n\x06\x04\xfa\x01\x02\0\x03\
    \x12\x04\xb53&'\n\r\n\x05\x04\xfa\x01\x02\x01\x12\x04\xb63\x02\x1a\n\x0e\
    \n\x06\x04\xfa\x01\x02\x01\x06\x12\x04\xb63\x02\x0b\n\x0e\n\x06\x04\xfa\
    \x01\x02\x01\x01\x12\x04\xb63\x0c\x15\n\x0e\n\x06\x04\xfa\x01\x02\x01\
    \x03\x12\x04\xb63\x18\x19\n&\n\x03\x04\xfb\x01\x12\x06\xba3\0\xbf3\x01\
    \x1a\x17\x20PostStatValuesRequest\n\n\x0c\n\x04\x04\xfb\x01\x01\x12\x04\
    \xba3\x08\x1d\n>\n\x05\x04\xfb\x01\x02\0\x12\x04\xbc3\x02,\x1a/\x20The\
    \x20user\x20and\x20app\x20information\x20for\x20the\x20request.\n\n\x0e\
    \n\x06\x04\xfb\x01\x02\0\x06\x12\x04\xbc3\x02\x1b\n\x0e\n\x06\x04\xfb\
    \x01\x02\0\x01\x12\x04\xbc3\x1c'\n\x0e\n\x06\x04\xfb\x01\x02\0\x03\x12\
    \x04\xbc3*+\nE\n\x05\x04\xfb\x01\x02\x01\x12\x04\xbe3\x02%\x1a6\x20The\
    \x20stats\x20to\x20post,\x20can\x20post\x20more\x20than\x20one\x20at\x20\
    a\x20time.\n\n\x0e\n\x06\x04\xfb\x01\x02\x01\x04\x12\x04\xbe3\x02\n\n\
    \x0e\n\x06\x04\xfb\x01\x02\x01\x06\x12\x04\xbe3\x0b\x14\n\x0e\n\x06\x04\
    \xfb\x01\x02\x01\x01\x12\x04\xbe3\x15\x20\n\x0e\n\x06\x04\xfb\x01\x02\
    \x01\x03\x12\x04\xbe3#$\n'\n\x03\x04\xfc\x01\x12\x06\xc23\0\xc73\x01\x1a\
    \x18\x20MultiStatValueResponse\n\n\x0c\n\x04\x04\xfc\x01\x01\x12\x04\xc2\
    3\x08\x1e\n%\n\x05\x04\xfc\x01\x02\0\x12\x04\xc43\x02(\x1a\x16\x20The\
    \x20response\x20status.\n\n\x0e\n\x06\x04\xfc\x01\x02\0\x06\x12\x04\xc43\
    \x02\x1c\n\x0e\n\x06\x04\xfc\x01\x02\0\x01\x12\x04\xc43\x1d#\n\x0e\n\x06\
    \x04\xfc\x01\x02\0\x03\x12\x04\xc43&'\n+\n\x05\x04\xfc\x01\x02\x01\x12\
    \x04\xc63\x02T\x1a\x1c\x20The\x20returned\x20stats\x20values.\n\n\x0e\n\
    \x06\x04\xfc\x01\x02\x01\x04\x12\x04\xc63\x02\n\n\x0e\n\x06\x04\xfc\x01\
    \x02\x01\x06\x12\x04\xc63\x0b\x14\n\x0e\n\x06\x04\xfc\x01\x02\x01\x01\
    \x12\x04\xc63\x15\x20\n\x0e\n\x06\x04\xfc\x01\x02\x01\x03\x12\x04\xc63#$\
    \n\x0e\n\x06\x04\xfc\x01\x02\x01\x08\x12\x04\xc63%S\n\x11\n\t\x04\xfc\
    \x01\x02\x01\x08\xd0\x86\x03\x12\x04\xc63&R\n/\n\x03\x04\xfd\x01\x12\x06\
    \xca3\0\xd03\x01\x1a\x20\x20PostStatValuesAggregateRequest\n\n\x0c\n\x04\
    \x04\xfd\x01\x01\x12\x04\xca3\x08&\n7\n\x05\x04\xfd\x01\x02\0\x12\x04\
    \xcc3\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20of\x20the\x20re\
    quest.\n\n\x0e\n\x06\x04\xfd\x01\x02\0\x06\x12\x04\xcc3\x02\x1b\n\x0e\n\
    \x06\x04\xfd\x01\x02\0\x01\x12\x04\xcc3\x1c'\n\x0e\n\x06\x04\xfd\x01\x02\
    \0\x03\x12\x04\xcc3*+\n4\n\x05\x04\xfd\x01\x02\x01\x12\x04\xcf3\x02D\x1a\
    %\x20Query\x20to\x20retrieve\x20aggregate\x20values.\n\n\x0e\n\x06\x04\
    \xfd\x01\x02\x01\x04\x12\x04\xcf3\x02\n\n\x0e\n\x06\x04\xfd\x01\x02\x01\
    \x06\x12\x04\xcf3\x0b\"\n\x0e\n\x06\x04\xfd\x01\x02\x01\x01\x12\x04\xcf3\
    #?\n\x0e\n\x06\x04\xfd\x01\x02\x01\x03\x12\x04\xcf3BC\n0\n\x03\x04\xfe\
    \x01\x12\x06\xd33\0\xd93\x01\x1a!\x20MultiStatValueAggregateResponse\n\n\
    \x0c\n\x04\x04\xfe\x01\x01\x12\x04\xd33\x08'\n%\n\x05\x04\xfe\x01\x02\0\
    \x12\x04\xd53\x02(\x1a\x16\x20The\x20response\x20status.\n\n\x0e\n\x06\
    \x04\xfe\x01\x02\0\x06\x12\x04\xd53\x02\x1c\n\x0e\n\x06\x04\xfe\x01\x02\
    \0\x01\x12\x04\xd53\x1d#\n\x0e\n\x06\x04\xfe\x01\x02\0\x03\x12\x04\xd53&\
    '\n?\n\x05\x04\xfe\x01\x02\x01\x12\x04\xd83\x02E\x1a0\x20The\x20aggregat\
    e\x20results\x20for\x20each\x20query\x20passedin.\n\n\x0e\n\x06\x04\xfe\
    \x01\x02\x01\x04\x12\x04\xd83\x02\n\n\x0e\n\x06\x04\xfe\x01\x02\x01\x06\
    \x12\x04\xd83\x0b#\n\x0e\n\x06\x04\xfe\x01\x02\x01\x01\x12\x04\xd83$@\n\
    \x0e\n\x06\x04\xfe\x01\x02\x01\x03\x12\x04\xd83CD\n/\n\x03\x04\xff\x01\
    \x12\x06\xe63\0\xed3\x01\x1a\x20\x20PostTrendingMetricsViewRequest\n\n\
    \x0c\n\x04\x04\xff\x01\x01\x12\x04\xe63\x08&\n4\n\x05\x04\xff\x01\x02\0\
    \x12\x04\xe83\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20informatio\
    n.\n\n\x0e\n\x06\x04\xff\x01\x02\0\x06\x12\x04\xe83\x02\x1b\n\x0e\n\x06\
    \x04\xff\x01\x02\0\x01\x12\x04\xe83\x1c'\n\x0e\n\x06\x04\xff\x01\x02\0\
    \x03\x12\x04\xe83*+\nT\n\x05\x04\xff\x01\x02\x01\x12\x04\xea3\x02\x17\
    \x1aE\x20For\x20now\x20view\x20types\x20'apps',\x20'workflows',\x20and\
    \x20'models'\x20are\x20supported.\n\n\x0e\n\x06\x04\xff\x01\x02\x01\x05\
    \x12\x04\xea3\x02\x08\n\x0e\n\x06\x04\xff\x01\x02\x01\x01\x12\x04\xea3\t\
    \x12\n\x0e\n\x06\x04\xff\x01\x02\x01\x03\x12\x04\xea3\x15\x16\n(\n\x05\
    \x04\xff\x01\x02\x02\x12\x04\xec3\x02\x17\x1a\x19\x20ID\x20of\x20the\x20\
    views\x20object.\n\n\x0e\n\x06\x04\xff\x01\x02\x02\x05\x12\x04\xec3\x02\
    \x08\n\x0e\n\x06\x04\xff\x01\x02\x02\x01\x12\x04\xec3\t\x12\n\x0e\n\x06\
    \x04\xff\x01\x02\x02\x03\x12\x04\xec3\x15\x16\n0\n\x03\x04\x80\x02\x12\
    \x06\xf03\0\xfb3\x01\x1a!\x20ListTrendingMetricsViewsRequest\n\n\x0c\n\
    \x04\x04\x80\x02\x01\x12\x04\xf03\x08'\n4\n\x05\x04\x80\x02\x02\0\x12\
    \x04\xf23\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20information.\n\
    \n\x0e\n\x06\x04\x80\x02\x02\0\x06\x12\x04\xf23\x02\x1b\n\x0e\n\x06\x04\
    \x80\x02\x02\0\x01\x12\x04\xf23\x1c'\n\x0e\n\x06\x04\x80\x02\x02\0\x03\
    \x12\x04\xf23*+\nT\n\x05\x04\x80\x02\x02\x01\x12\x04\xf43\x02\x17\x1aE\
    \x20For\x20now\x20view\x20types\x20'apps',\x20'workflows',\x20and\x20'mo\
    dels'\x20are\x20supported.\n\n\x0e\n\x06\x04\x80\x02\x02\x01\x05\x12\x04\
    \xf43\x02\x08\n\x0e\n\x06\x04\x80\x02\x02\x01\x01\x12\x04\xf43\t\x12\n\
    \x0e\n\x06\x04\x80\x02\x02\x01\x03\x12\x04\xf43\x15\x16\n\x7f\n\x05\x04\
    \x80\x02\x02\x02\x12\x04\xf73\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\x80\x02\x02\x02\x05\x12\x04\xf73\x02\x08\n\x0e\n\x06\x04\x80\
    \x02\x02\x02\x01\x12\x04\xf73\t\r\n\x0e\n\x06\x04\x80\x02\x02\x02\x03\
    \x12\x04\xf73\x10\x11\nv\n\x05\x04\x80\x02\x02\x03\x12\x04\xfa3\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\x80\x02\x02\x03\x05\x12\x04\xfa3\x02\
    \x08\n\x0e\n\x06\x04\x80\x02\x02\x03\x01\x12\x04\xfa3\t\x11\n\x0e\n\x06\
    \x04\x80\x02\x02\x03\x03\x12\x04\xfa3\x14\x15\n1\n\x03\x04\x81\x02\x12\
    \x06\xfe3\0\x814\x01\x1a\"\x20MultiTrendingMetricsViewResponse\n\n\x0c\n\
    \x04\x04\x81\x02\x01\x12\x04\xfe3\x08(\n\r\n\x05\x04\x81\x02\x02\0\x12\
    \x04\xff3\x02(\n\x0e\n\x06\x04\x81\x02\x02\0\x06\x12\x04\xff3\x02\x1c\n\
    \x0e\n\x06\x04\x81\x02\x02\0\x01\x12\x04\xff3\x1d#\n\x0e\n\x06\x04\x81\
    \x02\x02\0\x03\x12\x04\xff3&'\n\r\n\x05\x04\x81\x02\x02\x01\x12\x04\x804\
    \x02&\n\x0e\n\x06\x04\x81\x02\x02\x01\x04\x12\x04\x804\x02\n\n\x0e\n\x06\
    \x04\x81\x02\x02\x01\x06\x12\x04\x804\x0b\x19\n\x0e\n\x06\x04\x81\x02\
    \x02\x01\x01\x12\x04\x804\x1a!\n\x0e\n\x06\x04\x81\x02\x02\x01\x03\x12\
    \x04\x804$%\n!\n\x03\x04\x82\x02\x12\x06\xb04\0\xb44\x01\x1a\x12\x20GetM\
    oduleRequest\n\n\x0c\n\x04\x04\x82\x02\x01\x12\x04\xb04\x08\x18\n\r\n\
    \x05\x04\x82\x02\x02\0\x12\x04\xb14\x02,\n\x0e\n\x06\x04\x82\x02\x02\0\
    \x06\x12\x04\xb14\x02\x1b\n\x0e\n\x06\x04\x82\x02\x02\0\x01\x12\x04\xb14\
    \x1c'\n\x0e\n\x06\x04\x82\x02\x02\0\x03\x12\x04\xb14*+\n\r\n\x05\x04\x82\
    \x02\x02\x01\x12\x04\xb24\x02\x17\n\x0e\n\x06\x04\x82\x02\x02\x01\x05\
    \x12\x04\xb24\x02\x08\n\x0e\n\x06\x04\x82\x02\x02\x01\x01\x12\x04\xb24\t\
    \x12\n\x0e\n\x06\x04\x82\x02\x02\x01\x03\x12\x04\xb24\x15\x16\n\r\n\x05\
    \x04\x82\x02\x02\x02\x12\x04\xb34\x02(\n\x0e\n\x06\x04\x82\x02\x02\x02\
    \x04\x12\x04\xb34\x02\n\n\x0e\n\x06\x04\x82\x02\x02\x02\x05\x12\x04\xb34\
    \x0b\x11\n\x0e\n\x06\x04\x82\x02\x02\x02\x01\x12\x04\xb34\x12#\n\x0e\n\
    \x06\x04\x82\x02\x02\x02\x03\x12\x04\xb34&'\n#\n\x03\x04\x83\x02\x12\x06\
    \xb74\0\xe84\x01\x1a\x14\x20ListModulesRequest\n\n\x0c\n\x04\x04\x83\x02\
    \x01\x12\x04\xb74\x08\x1a\n\r\n\x05\x04\x83\x02\x02\0\x12\x04\xb84\x02,\
    \n\x0e\n\x06\x04\x83\x02\x02\0\x06\x12\x04\xb84\x02\x1b\n\x0e\n\x06\x04\
    \x83\x02\x02\0\x01\x12\x04\xb84\x1c'\n\x0e\n\x06\x04\x83\x02\x02\0\x03\
    \x12\x04\xb84*+\n\x7f\n\x05\x04\x83\x02\x02\x01\x12\x04\xbb4\x02\x12\x1a\
    p\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginat\
    ion\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x83\x02\x02\x01\x05\x12\x04\
    \xbb4\x02\x08\n\x0e\n\x06\x04\x83\x02\x02\x01\x01\x12\x04\xbb4\t\r\n\x0e\
    \n\x06\x04\x83\x02\x02\x01\x03\x12\x04\xbb4\x10\x11\nv\n\x05\x04\x83\x02\
    \x02\x02\x12\x04\xbe4\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x83\x02\
    \x02\x02\x05\x12\x04\xbe4\x02\x08\n\x0e\n\x06\x04\x83\x02\x02\x02\x01\
    \x12\x04\xbe4\t\x11\n\x0e\n\x06\x04\x83\x02\x02\x02\x03\x12\x04\xbe4\x14\
    \x15\n\r\n\x05\x04\x83\x02\x02\x03\x12\x04\xc04\x02(\n\x0e\n\x06\x04\x83\
    \x02\x02\x03\x04\x12\x04\xc04\x02\n\n\x0e\n\x06\x04\x83\x02\x02\x03\x05\
    \x12\x04\xc04\x0b\x11\n\x0e\n\x06\x04\x83\x02\x02\x03\x01\x12\x04\xc04\
    \x12#\n\x0e\n\x06\x04\x83\x02\x02\x03\x03\x12\x04\xc04&'\np\n\x05\x04\
    \x83\x02\x02\x04\x12\x04\xc44\x02\x1a\x1aa\x20Sorting\x20options:\n\x20W\
    hether\x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\x20wil\
    l\x20order\x20in\x20descending\x20order.\n\n\x0e\n\x06\x04\x83\x02\x02\
    \x04\x05\x12\x04\xc44\x02\x06\n\x0e\n\x06\x04\x83\x02\x02\x04\x01\x12\
    \x04\xc44\x07\x15\n\x0e\n\x06\x04\x83\x02\x02\x04\x03\x12\x04\xc44\x18\
    \x19\n\x0f\n\x05\x04\x83\x02\x08\0\x12\x06\xc54\x02\xce4\x03\n\x0e\n\x06\
    \x04\x83\x02\x08\0\x01\x12\x04\xc54\x08\x0f\n9\n\x05\x04\x83\x02\x02\x05\
    \x12\x04\xc74\x04\x20\x1a*\x20Whether\x20to\x20order\x20by\x20the\x20cre\
    ated_at\x20time.\n\n\x0e\n\x06\x04\x83\x02\x02\x05\x05\x12\x04\xc74\x04\
    \x08\n\x0e\n\x06\x04\x83\x02\x02\x05\x01\x12\x04\xc74\t\x1b\n\x0e\n\x06\
    \x04\x83\x02\x02\x05\x03\x12\x04\xc74\x1e\x1f\nG\n\x05\x04\x83\x02\x02\
    \x06\x12\x04\xc94\x04\x20\x1a8\x20Whether\x20to\x20order\x20by\x20the\
    \x20number\x20of\x20users\x20stared\x20the\x20app\n\n\x0e\n\x06\x04\x83\
    \x02\x02\x06\x05\x12\x04\xc94\x04\x08\n\x0e\n\x06\x04\x83\x02\x02\x06\
    \x01\x12\x04\xc94\t\x1b\n\x0e\n\x06\x04\x83\x02\x02\x06\x03\x12\x04\xc94\
    \x1e\x1f\nQ\n\x05\x04\x83\x02\x02\x07\x12\x04\xcb4\x04!\x1aB\x20If\x20ne\
    ither\x20sort\x20option\x20is\x20set\x20to\x20true,\x20will\x20sort\x20b\
    y\x20modified_at.\n\n\x0e\n\x06\x04\x83\x02\x02\x07\x05\x12\x04\xcb4\x04\
    \x08\n\x0e\n\x06\x04\x83\x02\x02\x07\x01\x12\x04\xcb4\t\x1c\n\x0e\n\x06\
    \x04\x83\x02\x02\x07\x03\x12\x04\xcb4\x1f\x20\n4\n\x05\x04\x83\x02\x02\
    \x08\x12\x04\xcd4\x04\x19\x1a%\x20Whether\x20to\x20order\x20by\x20the\
    \x20external\x20id\n\n\x0e\n\x06\x04\x83\x02\x02\x08\x05\x12\x04\xcd4\
    \x04\x08\n\x0e\n\x06\x04\x83\x02\x02\x08\x01\x12\x04\xcd4\t\x13\n\x0e\n\
    \x06\x04\x83\x02\x02\x08\x03\x12\x04\xcd4\x16\x18\n#\n\x05\x04\x83\x02\
    \x02\t\x12\x04\xd14\x02\x18\x1a\x14\x20Filtering\x20options:\n\n\x0e\n\
    \x06\x04\x83\x02\x02\t\x05\x12\x04\xd14\x02\x06\n\x0e\n\x06\x04\x83\x02\
    \x02\t\x01\x12\x04\xd14\x07\x13\n\x0e\n\x06\x04\x83\x02\x02\t\x03\x12\
    \x04\xd14\x16\x17\n|\n\x05\x04\x83\x02\x02\n\x12\x04\xd34\x02\x15\x1am\
    \x20Filter\x20modules\x20by\x20bookmark.\x20If\x20set,\x20only\x20return\
    \x20bookmarked\x20modules.\x20Otherwise\x20none\x20bookmarked\x20modules\
    \x20only.\n\n\x0e\n\x06\x04\x83\x02\x02\n\x05\x12\x04\xd34\x02\x06\n\x0e\
    \n\x06\x04\x83\x02\x02\n\x01\x12\x04\xd34\x07\x0f\n\x0e\n\x06\x04\x83\
    \x02\x02\n\x03\x12\x04\xd34\x12\x14\n\xa1\x04\n\x05\x04\x83\x02\x02\x0b\
    \x12\x04\xe14\x02\x15\x1a\x91\x04\x20Searching\x20options:\n\x20Specify\
    \x20a\x20search\x20parameter\x20in\x20order\x20to\x20perform\x20keyword\
    \x20search\x20on\x20the\n\x20following\x20fields\x20of\x20the\x20module:\
    \n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20description\n\x20\x20\x20-\x20us\
    er_id\x20(unless\x20user_app_id.user_id\x20is\x20already\x20set)\n\n\x20\
    Keywords\x20are\x20both\x20normalized\x20for\x20search\x20(so\x20searchi\
    ng\x20for\x20\"satisfy\"\x20matches\x20\"satisfied\")\n\x20and\x20used\
    \x20for\x20partial\x20prefix-matching\x20(so\x20searching\x20for\x20\"cl\
    ari\"\x20matches\x20\"clarifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\
    \x20of\x20fields\x20searched\x20and\x20the\x20exact\x20keyword\x20matchi\
    ng\n\x20rules\x20are\x20subject\x20to\x20change\x20and\x20not\x20guarant\
    eed\x20to\x20be\x20backwards-compatible.\n\n\x0e\n\x06\x04\x83\x02\x02\
    \x0b\x05\x12\x04\xe14\x02\x08\n\x0e\n\x06\x04\x83\x02\x02\x0b\x01\x12\
    \x04\xe14\t\x0f\n\x0e\n\x06\x04\x83\x02\x02\x0b\x03\x12\x04\xe14\x12\x14\
    \n\xaf\x01\n\x05\x04\x83\x02\x02\x0c\x12\x04\xe44\x02'\x1a\x9f\x01\x20Fi\
    lter\x20by\x20the\x20id\x20and\x20description\x20of\x20the\x20module.\
    \x20This\x20supports\x20wildcard\x20queries\x20like\x20\"gen*\"\x20to\
    \x20match\x20\"general\"\x20as\x20an\x20example.\n\x20Deprecated:\x20use\
    \x20search\x20instead.\n\n\x0e\n\x06\x04\x83\x02\x02\x0c\x05\x12\x04\xe4\
    4\x02\x08\n\x0e\n\x06\x04\x83\x02\x02\x0c\x01\x12\x04\xe44\t\r\n\x0e\n\
    \x06\x04\x83\x02\x02\x0c\x03\x12\x04\xe44\x10\x12\n\x0e\n\x06\x04\x83\
    \x02\x02\x0c\x08\x12\x04\xe44\x13&\n\x0f\n\x07\x04\x83\x02\x02\x0c\x08\
    \x03\x12\x04\xe44\x14%\nv\n\x05\x04\x83\x02\x02\r\x12\x04\xe74\x022\x1ag\
    \x20Filter\x20by\x20the\x20application\x20owner\x20whose\x20this\x20modu\
    le\x20belongs\x20to\n\x20Deprecated:\x20use\x20search\x20instead\x20of\
    \x20name.\n\n\x0e\n\x06\x04\x83\x02\x02\r\x05\x12\x04\xe74\x02\x06\n\x0e\
    \n\x06\x04\x83\x02\x02\r\x01\x12\x04\xe74\x07\x18\n\x0e\n\x06\x04\x83\
    \x02\x02\r\x03\x12\x04\xe74\x1b\x1d\n\x0e\n\x06\x04\x83\x02\x02\r\x08\
    \x12\x04\xe74\x1e1\n\x0f\n\x07\x04\x83\x02\x02\r\x08\x03\x12\x04\xe74\
    \x1f0\n#\n\x03\x04\x84\x02\x12\x06\xeb4\0\xef4\x01\x1a\x14\x20PostModule\
    sRequest\n\n\x0c\n\x04\x04\x84\x02\x01\x12\x04\xeb4\x08\x1a\n\r\n\x05\
    \x04\x84\x02\x02\0\x12\x04\xec4\x02,\n\x0e\n\x06\x04\x84\x02\x02\0\x06\
    \x12\x04\xec4\x02\x1b\n\x0e\n\x06\x04\x84\x02\x02\0\x01\x12\x04\xec4\x1c\
    '\n\x0e\n\x06\x04\x84\x02\x02\0\x03\x12\x04\xec4*+\nW\n\x05\x04\x84\x02\
    \x02\x01\x12\x04\xee4\x02\x1e\x1aH\x20This\x20allows\x20you\x20to\x20cre\
    ate\x20one\x20or\x20more\x20module\x20by\x20posting\x20it\x20to\x20the\
    \x20API.\n\n\x0e\n\x06\x04\x84\x02\x02\x01\x04\x12\x04\xee4\x02\n\n\x0e\
    \n\x06\x04\x84\x02\x02\x01\x06\x12\x04\xee4\x0b\x11\n\x0e\n\x06\x04\x84\
    \x02\x02\x01\x01\x12\x04\xee4\x12\x19\n\x0e\n\x06\x04\x84\x02\x02\x01\
    \x03\x12\x04\xee4\x1c\x1d\n$\n\x03\x04\x85\x02\x12\x06\xf24\0\xfc4\x01\
    \x1a\x15\x20PatchModulesRequest\n\n\x0c\n\x04\x04\x85\x02\x01\x12\x04\
    \xf24\x08\x1b\n\r\n\x05\x04\x85\x02\x02\0\x12\x04\xf34\x02,\n\x0e\n\x06\
    \x04\x85\x02\x02\0\x06\x12\x04\xf34\x02\x1b\n\x0e\n\x06\x04\x85\x02\x02\
    \0\x01\x12\x04\xf34\x1c'\n\x0e\n\x06\x04\x85\x02\x02\0\x03\x12\x04\xf34*\
    +\n\r\n\x05\x04\x85\x02\x02\x01\x12\x04\xf44\x02\x1e\n\x0e\n\x06\x04\x85\
    \x02\x02\x01\x04\x12\x04\xf44\x02\n\n\x0e\n\x06\x04\x85\x02\x02\x01\x06\
    \x12\x04\xf44\x0b\x11\n\x0e\n\x06\x04\x85\x02\x02\x01\x01\x12\x04\xf44\
    \x12\x19\n\x0e\n\x06\x04\x85\x02\x02\x01\x03\x12\x04\xf44\x1c\x1d\n\x82\
    \x02\n\x05\x04\x85\x02\x02\x02\x12\x04\xfb4\x02\x14\x1a\xf2\x01\x20The\
    \x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20Supp\
    orted\x20values:\x20'overwrite'\x20and\x20'remove'.\n\n\x20Note\x20that\
    \x20'remove'\x20can\x20only\x20be\x20used\x20to\x20remove\x20the\x20modu\
    le\x20image\x20by\x20setting\n\x20'image.url'\x20in\x20the\x20request\
    \x20to\x20the\x20current\x20value\x20returned\x20for\x20that\x20module.\
    \n\n\x0e\n\x06\x04\x85\x02\x02\x02\x05\x12\x04\xfb4\x02\x08\n\x0e\n\x06\
    \x04\x85\x02\x02\x02\x01\x12\x04\xfb4\t\x0f\n\x0e\n\x06\x04\x85\x02\x02\
    \x02\x03\x12\x04\xfb4\x12\x13\nE\n\x03\x04\x86\x02\x12\x06\xff4\0\x825\
    \x01\x1a6\x20Request\x20to\x20delete\x20several\x20things\x20by\x20the\
    \x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\x86\x02\x01\x12\x04\xff4\x08\
    \x1c\n\r\n\x05\x04\x86\x02\x02\0\x12\x04\x805\x02,\n\x0e\n\x06\x04\x86\
    \x02\x02\0\x06\x12\x04\x805\x02\x1b\n\x0e\n\x06\x04\x86\x02\x02\0\x01\
    \x12\x04\x805\x1c'\n\x0e\n\x06\x04\x86\x02\x02\0\x03\x12\x04\x805*+\n\r\
    \n\x05\x04\x86\x02\x02\x01\x12\x04\x815\x02\x1a\n\x0e\n\x06\x04\x86\x02\
    \x02\x01\x04\x12\x04\x815\x02\n\n\x0e\n\x06\x04\x86\x02\x02\x01\x05\x12\
    \x04\x815\x0b\x11\n\x0e\n\x06\x04\x86\x02\x02\x01\x01\x12\x04\x815\x12\
    \x15\n\x0e\n\x06\x04\x86\x02\x02\x01\x03\x12\x04\x815\x18\x19\n%\n\x03\
    \x04\x87\x02\x12\x06\x855\0\x885\x01\x1a\x16\x20SingleModuleResponse\n\n\
    \x0c\n\x04\x04\x87\x02\x01\x12\x04\x855\x08\x1c\n\r\n\x05\x04\x87\x02\
    \x02\0\x12\x04\x865\x02(\n\x0e\n\x06\x04\x87\x02\x02\0\x06\x12\x04\x865\
    \x02\x1c\n\x0e\n\x06\x04\x87\x02\x02\0\x01\x12\x04\x865\x1d#\n\x0e\n\x06\
    \x04\x87\x02\x02\0\x03\x12\x04\x865&'\n\r\n\x05\x04\x87\x02\x02\x01\x12\
    \x04\x875\x02\x14\n\x0e\n\x06\x04\x87\x02\x02\x01\x06\x12\x04\x875\x02\
    \x08\n\x0e\n\x06\x04\x87\x02\x02\x01\x01\x12\x04\x875\t\x0f\n\x0e\n\x06\
    \x04\x87\x02\x02\x01\x03\x12\x04\x875\x12\x13\n$\n\x03\x04\x88\x02\x12\
    \x06\x8b5\0\x8e5\x01\x1a\x15\x20MultiModuleResponse\n\n\x0c\n\x04\x04\
    \x88\x02\x01\x12\x04\x8b5\x08\x1b\n\r\n\x05\x04\x88\x02\x02\0\x12\x04\
    \x8c5\x02(\n\x0e\n\x06\x04\x88\x02\x02\0\x06\x12\x04\x8c5\x02\x1c\n\x0e\
    \n\x06\x04\x88\x02\x02\0\x01\x12\x04\x8c5\x1d#\n\x0e\n\x06\x04\x88\x02\
    \x02\0\x03\x12\x04\x8c5&'\n\r\n\x05\x04\x88\x02\x02\x01\x12\x04\x8d5\x02\
    M\n\x0e\n\x06\x04\x88\x02\x02\x01\x04\x12\x04\x8d5\x02\n\n\x0e\n\x06\x04\
    \x88\x02\x02\x01\x06\x12\x04\x8d5\x0b\x11\n\x0e\n\x06\x04\x88\x02\x02\
    \x01\x01\x12\x04\x8d5\x12\x19\n\x0e\n\x06\x04\x88\x02\x02\x01\x03\x12\
    \x04\x8d5\x1c\x1d\n\x0e\n\x06\x04\x88\x02\x02\x01\x08\x12\x04\x8d5\x1eL\
    \n\x11\n\t\x04\x88\x02\x02\x01\x08\xd0\x86\x03\x12\x04\x8d5\x1fK\n;\n\
    \x03\x04\x89\x02\x12\x06\x915\0\x955\x01\x1a,\x20request\x20for\x20diffe\
    rent\x20endpoints\x20currently.\n\n\x0c\n\x04\x04\x89\x02\x01\x12\x04\
    \x915\x08\x1f\n\r\n\x05\x04\x89\x02\x02\0\x12\x04\x925\x02,\n\x0e\n\x06\
    \x04\x89\x02\x02\0\x06\x12\x04\x925\x02\x1b\n\x0e\n\x06\x04\x89\x02\x02\
    \0\x01\x12\x04\x925\x1c'\n\x0e\n\x06\x04\x89\x02\x02\0\x03\x12\x04\x925*\
    +\n\r\n\x05\x04\x89\x02\x02\x01\x12\x04\x935\x02\x17\n\x0e\n\x06\x04\x89\
    \x02\x02\x01\x05\x12\x04\x935\x02\x08\n\x0e\n\x06\x04\x89\x02\x02\x01\
    \x01\x12\x04\x935\t\x12\n\x0e\n\x06\x04\x89\x02\x02\x01\x03\x12\x04\x935\
    \x15\x16\n\r\n\x05\x04\x89\x02\x02\x02\x12\x04\x945\x02\x1f\n\x0e\n\x06\
    \x04\x89\x02\x02\x02\x05\x12\x04\x945\x02\x08\n\x0e\n\x06\x04\x89\x02\
    \x02\x02\x01\x12\x04\x945\t\x1a\n\x0e\n\x06\x04\x89\x02\x02\x02\x03\x12\
    \x04\x945\x1d\x1e\n*\n\x03\x04\x8a\x02\x12\x06\x985\0\xa15\x01\x1a\x1b\
    \x20ListModuleVersionsRequest\n\n\x0c\n\x04\x04\x8a\x02\x01\x12\x04\x985\
    \x08!\n\r\n\x05\x04\x8a\x02\x02\0\x12\x04\x995\x02,\n\x0e\n\x06\x04\x8a\
    \x02\x02\0\x06\x12\x04\x995\x02\x1b\n\x0e\n\x06\x04\x8a\x02\x02\0\x01\
    \x12\x04\x995\x1c'\n\x0e\n\x06\x04\x8a\x02\x02\0\x03\x12\x04\x995*+\n\r\
    \n\x05\x04\x8a\x02\x02\x01\x12\x04\x9a5\x02\x17\n\x0e\n\x06\x04\x8a\x02\
    \x02\x01\x05\x12\x04\x9a5\x02\x08\n\x0e\n\x06\x04\x8a\x02\x02\x01\x01\
    \x12\x04\x9a5\t\x12\n\x0e\n\x06\x04\x8a\x02\x02\x01\x03\x12\x04\x9a5\x15\
    \x16\n\x7f\n\x05\x04\x8a\x02\x02\x02\x12\x04\x9d5\x02\x12\x1ap\x20(optio\
    nal\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\x0e\n\x06\x04\x8a\x02\x02\x02\x05\x12\x04\x9d5\x02\
    \x08\n\x0e\n\x06\x04\x8a\x02\x02\x02\x01\x12\x04\x9d5\t\r\n\x0e\n\x06\
    \x04\x8a\x02\x02\x02\x03\x12\x04\x9d5\x10\x11\nv\n\x05\x04\x8a\x02\x02\
    \x03\x12\x04\xa05\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x8a\x02\x02\
    \x03\x05\x12\x04\xa05\x02\x08\n\x0e\n\x06\x04\x8a\x02\x02\x03\x01\x12\
    \x04\xa05\t\x11\n\x0e\n\x06\x04\x8a\x02\x02\x03\x03\x12\x04\xa05\x14\x15\
    \n*\n\x03\x04\x8b\x02\x12\x06\xa45\0\xa95\x01\x1a\x1b\x20PostModuleVersi\
    onsRequest\n\n\x0c\n\x04\x04\x8b\x02\x01\x12\x04\xa45\x08!\n\r\n\x05\x04\
    \x8b\x02\x02\0\x12\x04\xa55\x02,\n\x0e\n\x06\x04\x8b\x02\x02\0\x06\x12\
    \x04\xa55\x02\x1b\n\x0e\n\x06\x04\x8b\x02\x02\0\x01\x12\x04\xa55\x1c'\n\
    \x0e\n\x06\x04\x8b\x02\x02\0\x03\x12\x04\xa55*+\n\r\n\x05\x04\x8b\x02\
    \x02\x01\x12\x04\xa65\x02\x17\n\x0e\n\x06\x04\x8b\x02\x02\x01\x05\x12\
    \x04\xa65\x02\x08\n\x0e\n\x06\x04\x8b\x02\x02\x01\x01\x12\x04\xa65\t\x12\
    \n\x0e\n\x06\x04\x8b\x02\x02\x01\x03\x12\x04\xa65\x15\x16\nW\n\x05\x04\
    \x8b\x02\x02\x02\x12\x04\xa85\x02-\x1aH\x20This\x20allows\x20you\x20to\
    \x20create\x20one\x20or\x20more\x20module\x20by\x20posting\x20it\x20to\
    \x20the\x20API.\n\n\x0e\n\x06\x04\x8b\x02\x02\x02\x04\x12\x04\xa85\x02\n\
    \n\x0e\n\x06\x04\x8b\x02\x02\x02\x06\x12\x04\xa85\x0b\x18\n\x0e\n\x06\
    \x04\x8b\x02\x02\x02\x01\x12\x04\xa85\x19(\n\x0e\n\x06\x04\x8b\x02\x02\
    \x02\x03\x12\x04\xa85+,\nN\n\x03\x04\x8c\x02\x12\x06\xac5\0\xb05\x01\x1a\
    ?\x20Request\x20to\x20delete\x20several\x20module\x20versions\x20by\x20t\
    he\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\x8c\x02\x01\x12\x04\xac5\x08#\
    \n\r\n\x05\x04\x8c\x02\x02\0\x12\x04\xad5\x02,\n\x0e\n\x06\x04\x8c\x02\
    \x02\0\x06\x12\x04\xad5\x02\x1b\n\x0e\n\x06\x04\x8c\x02\x02\0\x01\x12\
    \x04\xad5\x1c'\n\x0e\n\x06\x04\x8c\x02\x02\0\x03\x12\x04\xad5*+\n\r\n\
    \x05\x04\x8c\x02\x02\x01\x12\x04\xae5\x02\x17\n\x0e\n\x06\x04\x8c\x02\
    \x02\x01\x05\x12\x04\xae5\x02\x08\n\x0e\n\x06\x04\x8c\x02\x02\x01\x01\
    \x12\x04\xae5\t\x12\n\x0e\n\x06\x04\x8c\x02\x02\x01\x03\x12\x04\xae5\x15\
    \x16\n\r\n\x05\x04\x8c\x02\x02\x02\x12\x04\xaf5\x02\x1a\n\x0e\n\x06\x04\
    \x8c\x02\x02\x02\x04\x12\x04\xaf5\x02\n\n\x0e\n\x06\x04\x8c\x02\x02\x02\
    \x05\x12\x04\xaf5\x0b\x11\n\x0e\n\x06\x04\x8c\x02\x02\x02\x01\x12\x04\
    \xaf5\x12\x15\n\x0e\n\x06\x04\x8c\x02\x02\x02\x03\x12\x04\xaf5\x18\x19\n\
    b\n\x03\x04\x8d\x02\x12\x06\xb35\0\xb75\x01\x1aS\x20Request\x20to\x20get\
    \x20the\x20number\x20of\x20installations\x20(by\x20all\x20users)\x20for\
    \x20the\x20module\x20version\x20\n\n\x0c\n\x04\x04\x8d\x02\x01\x12\x04\
    \xb35\x08)\n\r\n\x05\x04\x8d\x02\x02\0\x12\x04\xb45\x02,\n\x0e\n\x06\x04\
    \x8d\x02\x02\0\x06\x12\x04\xb45\x02\x1b\n\x0e\n\x06\x04\x8d\x02\x02\0\
    \x01\x12\x04\xb45\x1c'\n\x0e\n\x06\x04\x8d\x02\x02\0\x03\x12\x04\xb45*+\
    \n\r\n\x05\x04\x8d\x02\x02\x01\x12\x04\xb55\x02\x17\n\x0e\n\x06\x04\x8d\
    \x02\x02\x01\x05\x12\x04\xb55\x02\x08\n\x0e\n\x06\x04\x8d\x02\x02\x01\
    \x01\x12\x04\xb55\t\x12\n\x0e\n\x06\x04\x8d\x02\x02\x01\x03\x12\x04\xb55\
    \x15\x16\n\r\n\x05\x04\x8d\x02\x02\x02\x12\x04\xb65\x02\x1f\n\x0e\n\x06\
    \x04\x8d\x02\x02\x02\x05\x12\x04\xb65\x02\x08\n\x0e\n\x06\x04\x8d\x02\
    \x02\x02\x01\x12\x04\xb65\t\x1a\n\x0e\n\x06\x04\x8d\x02\x02\x02\x03\x12\
    \x04\xb65\x1d\x1e\n,\n\x03\x04\x8e\x02\x12\x06\xba5\0\xbd5\x01\x1a\x1d\
    \x20SingleModuleVersionResponse\n\n\x0c\n\x04\x04\x8e\x02\x01\x12\x04\
    \xba5\x08#\n\r\n\x05\x04\x8e\x02\x02\0\x12\x04\xbb5\x02(\n\x0e\n\x06\x04\
    \x8e\x02\x02\0\x06\x12\x04\xbb5\x02\x1c\n\x0e\n\x06\x04\x8e\x02\x02\0\
    \x01\x12\x04\xbb5\x1d#\n\x0e\n\x06\x04\x8e\x02\x02\0\x03\x12\x04\xbb5&'\
    \n\r\n\x05\x04\x8e\x02\x02\x01\x12\x04\xbc5\x02#\n\x0e\n\x06\x04\x8e\x02\
    \x02\x01\x06\x12\x04\xbc5\x02\x0f\n\x0e\n\x06\x04\x8e\x02\x02\x01\x01\
    \x12\x04\xbc5\x10\x1e\n\x0e\n\x06\x04\x8e\x02\x02\x01\x03\x12\x04\xbc5!\
    \"\n+\n\x03\x04\x8f\x02\x12\x06\xc05\0\xc35\x01\x1a\x1c\x20MultiModuleVe\
    rsionResponse\n\n\x0c\n\x04\x04\x8f\x02\x01\x12\x04\xc05\x08\"\n\r\n\x05\
    \x04\x8f\x02\x02\0\x12\x04\xc15\x02(\n\x0e\n\x06\x04\x8f\x02\x02\0\x06\
    \x12\x04\xc15\x02\x1c\n\x0e\n\x06\x04\x8f\x02\x02\0\x01\x12\x04\xc15\x1d\
    #\n\x0e\n\x06\x04\x8f\x02\x02\0\x03\x12\x04\xc15&'\n\r\n\x05\x04\x8f\x02\
    \x02\x01\x12\x04\xc25\x02\\\n\x0e\n\x06\x04\x8f\x02\x02\x01\x04\x12\x04\
    \xc25\x02\n\n\x0e\n\x06\x04\x8f\x02\x02\x01\x06\x12\x04\xc25\x0b\x18\n\
    \x0e\n\x06\x04\x8f\x02\x02\x01\x01\x12\x04\xc25\x19(\n\x0e\n\x06\x04\x8f\
    \x02\x02\x01\x03\x12\x04\xc25+,\n\x0e\n\x06\x04\x8f\x02\x02\x01\x08\x12\
    \x04\xc25-[\n\x11\n\t\x04\x8f\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xc25.Z\
    \n6\n\x03\x04\x90\x02\x12\x06\xc65\0\xc95\x01\x1a'\x20SingleModuleVersio\
    nUsageCountResponse\n\n\x0c\n\x04\x04\x90\x02\x01\x12\x04\xc65\x08-\n\r\
    \n\x05\x04\x90\x02\x02\0\x12\x04\xc75\x02(\n\x0e\n\x06\x04\x90\x02\x02\0\
    \x06\x12\x04\xc75\x02\x1c\n\x0e\n\x06\x04\x90\x02\x02\0\x01\x12\x04\xc75\
    \x1d#\n\x0e\n\x06\x04\x90\x02\x02\0\x03\x12\x04\xc75&'\n\r\n\x05\x04\x90\
    \x02\x02\x01\x12\x04\xc85\x02\x19\n\x0e\n\x06\x04\x90\x02\x02\x01\x05\
    \x12\x04\xc85\x02\x08\n\x0e\n\x06\x04\x90\x02\x02\x01\x01\x12\x04\xc85\t\
    \x14\n\x0e\n\x06\x04\x90\x02\x02\x01\x03\x12\x04\xc85\x17\x18\n1\n\x03\
    \x04\x91\x02\x12\x06\xcc5\0\xd05\x01\x1a\"\x20GetInstalledModuleVersionR\
    equest\n\n\x0c\n\x04\x04\x91\x02\x01\x12\x04\xcc5\x08(\n\r\n\x05\x04\x91\
    \x02\x02\0\x12\x04\xcd5\x02,\n\x0e\n\x06\x04\x91\x02\x02\0\x06\x12\x04\
    \xcd5\x02\x1b\n\x0e\n\x06\x04\x91\x02\x02\0\x01\x12\x04\xcd5\x1c'\n\x0e\
    \n\x06\x04\x91\x02\x02\0\x03\x12\x04\xcd5*+\n=\n\x05\x04\x91\x02\x02\x01\
    \x12\x04\xcf5\x02)\x1a.\x20the\x20ID\x20to\x20get\x20of\x20the\x20instal\
    l\x20module\x20version.\n\n\x0e\n\x06\x04\x91\x02\x02\x01\x05\x12\x04\
    \xcf5\x02\x08\n\x0e\n\x06\x04\x91\x02\x02\x01\x01\x12\x04\xcf5\t$\n\x0e\
    \n\x06\x04\x91\x02\x02\x01\x03\x12\x04\xcf5'(\n3\n\x03\x04\x92\x02\x12\
    \x06\xd35\0\xdb5\x01\x1a$\x20ListInstalledModuleVersionsRequest\n\n\x0c\
    \n\x04\x04\x92\x02\x01\x12\x04\xd35\x08*\n\r\n\x05\x04\x92\x02\x02\0\x12\
    \x04\xd45\x02,\n\x0e\n\x06\x04\x92\x02\x02\0\x06\x12\x04\xd45\x02\x1b\n\
    \x0e\n\x06\x04\x92\x02\x02\0\x01\x12\x04\xd45\x1c'\n\x0e\n\x06\x04\x92\
    \x02\x02\0\x03\x12\x04\xd45*+\n\x7f\n\x05\x04\x92\x02\x02\x01\x12\x04\
    \xd75\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20n\
    umber.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20i\
    nto\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x92\x02\x02\
    \x01\x05\x12\x04\xd75\x02\x08\n\x0e\n\x06\x04\x92\x02\x02\x01\x01\x12\
    \x04\xd75\t\r\n\x0e\n\x06\x04\x92\x02\x02\x01\x03\x12\x04\xd75\x10\x11\n\
    v\n\x05\x04\x92\x02\x02\x02\x12\x04\xda5\x02\x16\x1ag\x20(optional\x20UR\
    L\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\x92\x02\x02\x02\x05\x12\x04\xda5\x02\x08\n\x0e\n\x06\x04\x92\
    \x02\x02\x02\x01\x12\x04\xda5\t\x11\n\x0e\n\x06\x04\x92\x02\x02\x02\x03\
    \x12\x04\xda5\x14\x15\ng\n\x03\x04\x93\x02\x12\x06\xde5\0\xe25\x01\x1aX\
    \x20PostInstalledModuleVersionsRequest\x20to\x20install\x20a\x20module\
    \x20version\x20into\x20the\x20app\x20in\x20the\x20URL\n\n\x0c\n\x04\x04\
    \x93\x02\x01\x12\x04\xde5\x08*\n\r\n\x05\x04\x93\x02\x02\0\x12\x04\xdf5\
    \x02,\n\x0e\n\x06\x04\x93\x02\x02\0\x06\x12\x04\xdf5\x02\x1b\n\x0e\n\x06\
    \x04\x93\x02\x02\0\x01\x12\x04\xdf5\x1c'\n\x0e\n\x06\x04\x93\x02\x02\0\
    \x03\x12\x04\xdf5*+\nW\n\x05\x04\x93\x02\x02\x01\x12\x04\xe15\x02@\x1aH\
    \x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20module\
    \x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\x93\x02\
    \x02\x01\x04\x12\x04\xe15\x02\n\n\x0e\n\x06\x04\x93\x02\x02\x01\x06\x12\
    \x04\xe15\x0b!\n\x0e\n\x06\x04\x93\x02\x02\x01\x01\x12\x04\xe15\";\n\x0e\
    \n\x06\x04\x93\x02\x02\x01\x03\x12\x04\xe15>?\n{\n\x03\x04\x94\x02\x12\
    \x06\xe65\0\xee5\x01\x1al\x20PostInstalledModuleVersionsKeyRequest\x20to\
    \x20associate\x20a\x20key\x20of\x20the\x20caller's\x20to\x20the\x20insta\
    lled\x20module\n\x20version.\n\n\x0c\n\x04\x04\x94\x02\x01\x12\x04\xe65\
    \x08-\n\r\n\x05\x04\x94\x02\x02\0\x12\x04\xe75\x02,\n\x0e\n\x06\x04\x94\
    \x02\x02\0\x06\x12\x04\xe75\x02\x1b\n\x0e\n\x06\x04\x94\x02\x02\0\x01\
    \x12\x04\xe75\x1c'\n\x0e\n\x06\x04\x94\x02\x02\0\x03\x12\x04\xe75*+\n\
    \xf6\x02\n\x05\x04\x94\x02\x02\x01\x12\x04\xe95\x02)\x1a.\x20the\x20ID\
    \x20to\x20get\x20of\x20the\x20install\x20module\x20version.\n\"\xb6\x02\
    \x20Note(zeiler):\x20we\x20don't\x20provide\x20a\x20key\x20to\x20create\
    \x20since\x20it's\x20always\x20deterministic.\n\x20we'll\x20create\x20a\
    \x20PAT,\x20owned\x20by\x20the\x20caller\x20with\x20the\x20scopes\x20tha\
    t\x20the\x20module\x20requests.\n\x20in\x20the\x20future\x20if\x20we\x20\
    want\x20we\x20can\x20pass\x20in\x20a\x20Key\x20key\x20=\x203;\x20field\
    \x20so\x20that\x20the\x20caller\n\x20can\x20adjust\x20the\x20scopes,\x20\
    but\x20for\x20now\x20that\x20doesn't\x20seem\x20necessary.\n\n\x0e\n\x06\
    \x04\x94\x02\x02\x01\x05\x12\x04\xe95\x02\x08\n\x0e\n\x06\x04\x94\x02\
    \x02\x01\x01\x12\x04\xe95\t$\n\x0e\n\x06\x04\x94\x02\x02\x01\x03\x12\x04\
    \xe95'(\nX\n\x03\x04\x95\x02\x12\x06\xf15\0\xf45\x01\x1aI\x20Request\x20\
    to\x20delete\x20several\x20installed\x20module\x20versions\x20by\x20the\
    \x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\x95\x02\x01\x12\x04\xf15\x08,\n\
    \r\n\x05\x04\x95\x02\x02\0\x12\x04\xf25\x02,\n\x0e\n\x06\x04\x95\x02\x02\
    \0\x06\x12\x04\xf25\x02\x1b\n\x0e\n\x06\x04\x95\x02\x02\0\x01\x12\x04\
    \xf25\x1c'\n\x0e\n\x06\x04\x95\x02\x02\0\x03\x12\x04\xf25*+\n\r\n\x05\
    \x04\x95\x02\x02\x01\x12\x04\xf35\x02\x1a\n\x0e\n\x06\x04\x95\x02\x02\
    \x01\x04\x12\x04\xf35\x02\n\n\x0e\n\x06\x04\x95\x02\x02\x01\x05\x12\x04\
    \xf35\x0b\x11\n\x0e\n\x06\x04\x95\x02\x02\x01\x01\x12\x04\xf35\x12\x15\n\
    \x0e\n\x06\x04\x95\x02\x02\x01\x03\x12\x04\xf35\x18\x19\n5\n\x03\x04\x96\
    \x02\x12\x06\xf75\0\xfa5\x01\x1a&\x20SingleInstalledModuleVersionRespons\
    e\n\n\x0c\n\x04\x04\x96\x02\x01\x12\x04\xf75\x08,\n\r\n\x05\x04\x96\x02\
    \x02\0\x12\x04\xf85\x02(\n\x0e\n\x06\x04\x96\x02\x02\0\x06\x12\x04\xf85\
    \x02\x1c\n\x0e\n\x06\x04\x96\x02\x02\0\x01\x12\x04\xf85\x1d#\n\x0e\n\x06\
    \x04\x96\x02\x02\0\x03\x12\x04\xf85&'\n\r\n\x05\x04\x96\x02\x02\x01\x12\
    \x04\xf95\x026\n\x0e\n\x06\x04\x96\x02\x02\x01\x06\x12\x04\xf95\x02\x18\
    \n\x0e\n\x06\x04\x96\x02\x02\x01\x01\x12\x04\xf95\x191\n\x0e\n\x06\x04\
    \x96\x02\x02\x01\x03\x12\x04\xf9545\n4\n\x03\x04\x97\x02\x12\x06\xfd5\0\
    \x806\x01\x1a%\x20MultiInstalledModuleVersionResponse\n\n\x0c\n\x04\x04\
    \x97\x02\x01\x12\x04\xfd5\x08+\n\r\n\x05\x04\x97\x02\x02\0\x12\x04\xfe5\
    \x02(\n\x0e\n\x06\x04\x97\x02\x02\0\x06\x12\x04\xfe5\x02\x1c\n\x0e\n\x06\
    \x04\x97\x02\x02\0\x01\x12\x04\xfe5\x1d#\n\x0e\n\x06\x04\x97\x02\x02\0\
    \x03\x12\x04\xfe5&'\n\r\n\x05\x04\x97\x02\x02\x01\x12\x04\xff5\x02o\n\
    \x0e\n\x06\x04\x97\x02\x02\x01\x04\x12\x04\xff5\x02\n\n\x0e\n\x06\x04\
    \x97\x02\x02\x01\x06\x12\x04\xff5\x0b!\n\x0e\n\x06\x04\x97\x02\x02\x01\
    \x01\x12\x04\xff5\";\n\x0e\n\x06\x04\x97\x02\x02\x01\x03\x12\x04\xff5>?\
    \n\x0e\n\x06\x04\x97\x02\x02\x01\x08\x12\x04\xff5@n\n\x11\n\t\x04\x97\
    \x02\x02\x01\x08\xd0\x86\x03\x12\x04\xff5Am\n/\n\x03\x04\x98\x02\x12\x06\
    \x836\0\x866\x01\x1a\x20\x20ListNextTaskAssignmentsRequest\n\n\x0c\n\x04\
    \x04\x98\x02\x01\x12\x04\x836\x08&\n\r\n\x05\x04\x98\x02\x02\0\x12\x04\
    \x846\x02,\n\x0e\n\x06\x04\x98\x02\x02\0\x06\x12\x04\x846\x02\x1b\n\x0e\
    \n\x06\x04\x98\x02\x02\0\x01\x12\x04\x846\x1c'\n\x0e\n\x06\x04\x98\x02\
    \x02\0\x03\x12\x04\x846*+\n\r\n\x05\x04\x98\x02\x02\x01\x12\x04\x856\x02\
    \x15\n\x0e\n\x06\x04\x98\x02\x02\x01\x05\x12\x04\x856\x02\x08\n\x0e\n\
    \x06\x04\x98\x02\x02\x01\x01\x12\x04\x856\t\x10\n\x0e\n\x06\x04\x98\x02\
    \x02\x01\x03\x12\x04\x856\x13\x14\n^\n\x03\x04\x99\x02\x12\x06\x896\0\
    \x8d6\x01\x1aO\x20Request\x20to\x20perform\x20bulk\x20operations\x20on\
    \x20a\x20list\x20of\x20inputs\x20based\x20on\x20input\x20source.\n\n\x0c\
    \n\x04\x04\x99\x02\x01\x12\x04\x896\x08!\n\r\n\x05\x04\x99\x02\x02\0\x12\
    \x04\x8a6\x02,\n\x0e\n\x06\x04\x99\x02\x02\0\x06\x12\x04\x8a6\x02\x1b\n\
    \x0e\n\x06\x04\x99\x02\x02\0\x01\x12\x04\x8a6\x1c'\n\x0e\n\x06\x04\x99\
    \x02\x02\0\x03\x12\x04\x8a6*+\nj\n\x05\x04\x99\x02\x02\x01\x12\x04\x8c6\
    \x02:\x1a[\x20List\x20of\x20bulk\x20operation(s)\x20to\x20be\x20performe\
    d\x20e.g\x20bulk\x20update\x20metadata\x20or\x20tags\x20or\x20labels\x20\
    etc.\n\n\x0e\n\x06\x04\x99\x02\x02\x01\x04\x12\x04\x8c6\x02\n\n\x0e\n\
    \x06\x04\x99\x02\x02\x01\x06\x12\x04\x8c6\x0b%\n\x0e\n\x06\x04\x99\x02\
    \x02\x01\x01\x12\x04\x8c6&5\n\x0e\n\x06\x04\x99\x02\x02\x01\x03\x12\x04\
    \x8c689\n9\n\x03\x04\x9a\x02\x12\x06\x906\0\x986\x01\x1a*\x20Request\x20\
    to\x20list\x20all\x20the\x20bulk\x20operations.\n\n\x0c\n\x04\x04\x9a\
    \x02\x01\x12\x04\x906\x08!\n\r\n\x05\x04\x9a\x02\x02\0\x12\x04\x916\x02,\
    \n\x0e\n\x06\x04\x9a\x02\x02\0\x06\x12\x04\x916\x02\x1b\n\x0e\n\x06\x04\
    \x9a\x02\x02\0\x01\x12\x04\x916\x1c'\n\x0e\n\x06\x04\x9a\x02\x02\0\x03\
    \x12\x04\x916*+\n\x7f\n\x05\x04\x9a\x02\x02\x01\x12\x04\x946\x02\x12\x1a\
    p\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginat\
    ion\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x9a\x02\x02\x01\x05\x12\x04\
    \x946\x02\x08\n\x0e\n\x06\x04\x9a\x02\x02\x01\x01\x12\x04\x946\t\r\n\x0e\
    \n\x06\x04\x9a\x02\x02\x01\x03\x12\x04\x946\x10\x11\nv\n\x05\x04\x9a\x02\
    \x02\x02\x12\x04\x976\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x9a\x02\
    \x02\x02\x05\x12\x04\x976\x02\x08\n\x0e\n\x06\x04\x9a\x02\x02\x02\x01\
    \x12\x04\x976\t\x11\n\x0e\n\x06\x04\x9a\x02\x02\x02\x03\x12\x04\x976\x14\
    \x15\nF\n\x03\x04\x9b\x02\x12\x06\x9b6\0\x9f6\x01\x1a7\x20Request\x20to\
    \x20get\x20the\x20details\x20of\x20a\x20bulk\x20operation\x20by\x20ID.\n\
    \n\x0c\n\x04\x04\x9b\x02\x01\x12\x04\x9b6\x08\x1f\n\r\n\x05\x04\x9b\x02\
    \x02\0\x12\x04\x9c6\x02,\n\x0e\n\x06\x04\x9b\x02\x02\0\x06\x12\x04\x9c6\
    \x02\x1b\n\x0e\n\x06\x04\x9b\x02\x02\0\x01\x12\x04\x9c6\x1c'\n\x0e\n\x06\
    \x04\x9b\x02\x02\0\x03\x12\x04\x9c6*+\n&\n\x05\x04\x9b\x02\x02\x01\x12\
    \x04\x9e6\x02\x10\x1a\x17\x20The\x20bulk\x20operation\x20id\n\n\x0e\n\
    \x06\x04\x9b\x02\x02\x01\x05\x12\x04\x9e6\x02\x08\n\x0e\n\x06\x04\x9b\
    \x02\x02\x01\x01\x12\x04\x9e6\t\x0b\n\x0e\n\x06\x04\x9b\x02\x02\x01\x03\
    \x12\x04\x9e6\x0e\x0f\n4\n\x03\x04\x9c\x02\x12\x06\xa26\0\xa66\x01\x1a%\
    \x20Cancel\x20a\x20list\x20of\x20bulk\x20operation\x20ids\n\n\x0c\n\x04\
    \x04\x9c\x02\x01\x12\x04\xa26\x08\"\n\r\n\x05\x04\x9c\x02\x02\0\x12\x04\
    \xa36\x02,\n\x0e\n\x06\x04\x9c\x02\x02\0\x06\x12\x04\xa36\x02\x1b\n\x0e\
    \n\x06\x04\x9c\x02\x02\0\x01\x12\x04\xa36\x1c'\n\x0e\n\x06\x04\x9c\x02\
    \x02\0\x03\x12\x04\xa36*+\n;\n\x05\x04\x9c\x02\x02\x01\x12\x04\xa56\x02\
    \x1a\x1a,\x20List\x20of\x20bulk\x20operation\x20ids\x20to\x20be\x20cance\
    lled\n\n\x0e\n\x06\x04\x9c\x02\x02\x01\x04\x12\x04\xa56\x02\n\n\x0e\n\
    \x06\x04\x9c\x02\x02\x01\x05\x12\x04\xa56\x0b\x11\n\x0e\n\x06\x04\x9c\
    \x02\x02\x01\x01\x12\x04\xa56\x12\x15\n\x0e\n\x06\x04\x9c\x02\x02\x01\
    \x03\x12\x04\xa56\x18\x19\n|\n\x03\x04\x9d\x02\x12\x06\xaa6\0\xae6\x01\
    \x1am\x20Request\x20to\x20delete\x20the\x20terminated\x20bulk\x20operati\
    ons\x20by\x20ID\n\x20Only\x20operations\x20in\x20terminated\x20state\x20\
    can\x20be\x20deleted.\n\n\x0c\n\x04\x04\x9d\x02\x01\x12\x04\xaa6\x08\"\n\
    \r\n\x05\x04\x9d\x02\x02\0\x12\x04\xab6\x02,\n\x0e\n\x06\x04\x9d\x02\x02\
    \0\x06\x12\x04\xab6\x02\x1b\n\x0e\n\x06\x04\x9d\x02\x02\0\x01\x12\x04\
    \xab6\x1c'\n\x0e\n\x06\x04\x9d\x02\x02\0\x03\x12\x04\xab6*+\n9\n\x05\x04\
    \x9d\x02\x02\x01\x12\x04\xad6\x02\x1a\x1a*\x20List\x20of\x20bulk\x20oper\
    ation\x20ids\x20to\x20be\x20deleted\n\n\x0e\n\x06\x04\x9d\x02\x02\x01\
    \x04\x12\x04\xad6\x02\n\n\x0e\n\x06\x04\x9d\x02\x02\x01\x05\x12\x04\xad6\
    \x0b\x11\n\x0e\n\x06\x04\x9d\x02\x02\x01\x01\x12\x04\xad6\x12\x15\n\x0e\
    \n\x06\x04\x9d\x02\x02\x01\x03\x12\x04\xad6\x18\x19\n-\n\x03\x04\x9e\x02\
    \x12\x06\xb16\0\xb46\x01\x1a\x1e\x20SingleBulkOperationsResponse\n\n\x0c\
    \n\x04\x04\x9e\x02\x01\x12\x04\xb16\x08$\n\r\n\x05\x04\x9e\x02\x02\0\x12\
    \x04\xb26\x02(\n\x0e\n\x06\x04\x9e\x02\x02\0\x06\x12\x04\xb26\x02\x1c\n\
    \x0e\n\x06\x04\x9e\x02\x02\0\x01\x12\x04\xb26\x1d#\n\x0e\n\x06\x04\x9e\
    \x02\x02\0\x03\x12\x04\xb26&'\n\r\n\x05\x04\x9e\x02\x02\x01\x12\x04\xb36\
    \x020\n\x0e\n\x06\x04\x9e\x02\x02\x01\x06\x12\x04\xb36\x02\x1c\n\x0e\n\
    \x06\x04\x9e\x02\x02\x01\x01\x12\x04\xb36\x1d+\n\x0e\n\x06\x04\x9e\x02\
    \x02\x01\x03\x12\x04\xb36./\n,\n\x03\x04\x9f\x02\x12\x06\xb76\0\xba6\x01\
    \x1a\x1d\x20MultiBulkOperationsResponse\n\n\x0c\n\x04\x04\x9f\x02\x01\
    \x12\x04\xb76\x08#\n\r\n\x05\x04\x9f\x02\x02\0\x12\x04\xb86\x02(\n\x0e\n\
    \x06\x04\x9f\x02\x02\0\x06\x12\x04\xb86\x02\x1c\n\x0e\n\x06\x04\x9f\x02\
    \x02\0\x01\x12\x04\xb86\x1d#\n\x0e\n\x06\x04\x9f\x02\x02\0\x03\x12\x04\
    \xb86&'\n\r\n\x05\x04\x9f\x02\x02\x01\x12\x04\xb96\x029\n\x0e\n\x06\x04\
    \x9f\x02\x02\x01\x04\x12\x04\xb96\x02\n\n\x0e\n\x06\x04\x9f\x02\x02\x01\
    \x06\x12\x04\xb96\x0b%\n\x0e\n\x06\x04\x9f\x02\x02\x01\x01\x12\x04\xb96&\
    4\n\x0e\n\x06\x04\x9f\x02\x02\x01\x03\x12\x04\xb9678\n*\n\x03\x04\xa0\
    \x02\x12\x06\xc16\0\xc56\x01\x1a\x1b\x20PutTaskAssignmentsRequest\n\n\
    \x0c\n\x04\x04\xa0\x02\x01\x12\x04\xc16\x08!\n\r\n\x05\x04\xa0\x02\x02\0\
    \x12\x04\xc26\x02,\n\x0e\n\x06\x04\xa0\x02\x02\0\x06\x12\x04\xc26\x02\
    \x1b\n\x0e\n\x06\x04\xa0\x02\x02\0\x01\x12\x04\xc26\x1c'\n\x0e\n\x06\x04\
    \xa0\x02\x02\0\x03\x12\x04\xc26*+\n\r\n\x05\x04\xa0\x02\x02\x01\x12\x04\
    \xc36\x02\x15\n\x0e\n\x06\x04\xa0\x02\x02\x01\x05\x12\x04\xc36\x02\x08\n\
    \x0e\n\x06\x04\xa0\x02\x02\x01\x01\x12\x04\xc36\t\x10\n\x0e\n\x06\x04\
    \xa0\x02\x02\x01\x03\x12\x04\xc36\x13\x14\n\r\n\x05\x04\xa0\x02\x02\x02\
    \x12\x04\xc46\x02\x16\n\x0e\n\x06\x04\xa0\x02\x02\x02\x05\x12\x04\xc46\
    \x02\x08\n\x0e\n\x06\x04\xa0\x02\x02\x02\x01\x12\x04\xc46\t\x11\n\x0e\n\
    \x06\x04\xa0\x02\x02\x02\x03\x12\x04\xc46\x14\x15\n2\n\x03\x04\xa1\x02\
    \x12\x06\xcd6\0\xd56\x01\x1a#\x20List\x20all\x20the\x20input\x20ingestio\
    n\x20jobs\n\n\x0c\n\x04\x04\xa1\x02\x01\x12\x04\xcd6\x08\x20\n\r\n\x05\
    \x04\xa1\x02\x02\0\x12\x04\xce6\x02,\n\x0e\n\x06\x04\xa1\x02\x02\0\x06\
    \x12\x04\xce6\x02\x1b\n\x0e\n\x06\x04\xa1\x02\x02\0\x01\x12\x04\xce6\x1c\
    '\n\x0e\n\x06\x04\xa1\x02\x02\0\x03\x12\x04\xce6*+\n\x7f\n\x05\x04\xa1\
    \x02\x02\x01\x12\x04\xd16\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\xa1\x02\x02\x01\x05\x12\x04\xd16\x02\x08\n\x0e\n\x06\x04\xa1\
    \x02\x02\x01\x01\x12\x04\xd16\t\r\n\x0e\n\x06\x04\xa1\x02\x02\x01\x03\
    \x12\x04\xd16\x10\x11\nv\n\x05\x04\xa1\x02\x02\x02\x12\x04\xd46\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\xa1\x02\x02\x02\x05\x12\x04\xd46\x02\
    \x08\n\x0e\n\x06\x04\xa1\x02\x02\x02\x01\x12\x04\xd46\t\x11\n\x0e\n\x06\
    \x04\xa1\x02\x02\x02\x03\x12\x04\xd46\x14\x15\n\r\n\x03\x04\xa2\x02\x12\
    \x06\xd76\0\xdb6\x01\n\x0c\n\x04\x04\xa2\x02\x01\x12\x04\xd76\x08\x1e\n\
    \r\n\x05\x04\xa2\x02\x02\0\x12\x04\xd86\x02,\n\x0e\n\x06\x04\xa2\x02\x02\
    \0\x06\x12\x04\xd86\x02\x1b\n\x0e\n\x06\x04\xa2\x02\x02\0\x01\x12\x04\
    \xd86\x1c'\n\x0e\n\x06\x04\xa2\x02\x02\0\x03\x12\x04\xd86*+\n%\n\x05\x04\
    \xa2\x02\x02\x01\x12\x04\xda6\x02\x10\x1a\x16\x20id\x20of\x20add\x20inpu\
    ts\x20job\n\n\x0e\n\x06\x04\xa2\x02\x02\x01\x05\x12\x04\xda6\x02\x08\n\
    \x0e\n\x06\x04\xa2\x02\x02\x01\x01\x12\x04\xda6\t\x0b\n\x0e\n\x06\x04\
    \xa2\x02\x02\x01\x03\x12\x04\xda6\x0e\x0f\n\r\n\x03\x04\xa3\x02\x12\x06\
    \xdd6\0\xe16\x01\n\x0c\n\x04\x04\xa3\x02\x01\x12\x04\xdd6\x08!\n\r\n\x05\
    \x04\xa3\x02\x02\0\x12\x04\xde6\x02,\n\x0e\n\x06\x04\xa3\x02\x02\0\x06\
    \x12\x04\xde6\x02\x1b\n\x0e\n\x06\x04\xa3\x02\x02\0\x01\x12\x04\xde6\x1c\
    '\n\x0e\n\x06\x04\xa3\x02\x02\0\x03\x12\x04\xde6*+\n5\n\x05\x04\xa3\x02\
    \x02\x01\x12\x04\xe06\x02\x10\x1a&\x20id\x20of\x20add\x20inputs\x20job\
    \x20to\x20be\x20cancelled\n\n\x0e\n\x06\x04\xa3\x02\x02\x01\x05\x12\x04\
    \xe06\x02\x08\n\x0e\n\x06\x04\xa3\x02\x02\x01\x01\x12\x04\xe06\t\x0b\n\
    \x0e\n\x06\x04\xa3\x02\x02\x01\x03\x12\x04\xe06\x0e\x0f\n*\n\x03\x04\xa4\
    \x02\x12\x06\xe46\0\xe76\x01\x1a\x1b\x20MultiInputsAddJobResponse\n\n\
    \x0c\n\x04\x04\xa4\x02\x01\x12\x04\xe46\x08!\n\r\n\x05\x04\xa4\x02\x02\0\
    \x12\x04\xe56\x02(\n\x0e\n\x06\x04\xa4\x02\x02\0\x06\x12\x04\xe56\x02\
    \x1c\n\x0e\n\x06\x04\xa4\x02\x02\0\x01\x12\x04\xe56\x1d#\n\x0e\n\x06\x04\
    \xa4\x02\x02\0\x03\x12\x04\xe56&'\n\r\n\x05\x04\xa4\x02\x02\x01\x12\x04\
    \xe66\x02h\n\x0e\n\x06\x04\xa4\x02\x02\x01\x04\x12\x04\xe66\x02\n\n\x0e\
    \n\x06\x04\xa4\x02\x02\x01\x06\x12\x04\xe66\x0b$\n\x0e\n\x06\x04\xa4\x02\
    \x02\x01\x01\x12\x04\xe66%4\n\x0e\n\x06\x04\xa4\x02\x02\x01\x03\x12\x04\
    \xe6678\n\x0e\n\x06\x04\xa4\x02\x02\x01\x08\x12\x04\xe669g\n\x11\n\t\x04\
    \xa4\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xe66:f\n+\n\x03\x04\xa5\x02\x12\
    \x06\xea6\0\xed6\x01\x1a\x1c\x20SingleInputsAddJobResponse\n\n\x0c\n\x04\
    \x04\xa5\x02\x01\x12\x04\xea6\x08\"\n\r\n\x05\x04\xa5\x02\x02\0\x12\x04\
    \xeb6\x02(\n\x0e\n\x06\x04\xa5\x02\x02\0\x06\x12\x04\xeb6\x02\x1c\n\x0e\
    \n\x06\x04\xa5\x02\x02\0\x01\x12\x04\xeb6\x1d#\n\x0e\n\x06\x04\xa5\x02\
    \x02\0\x03\x12\x04\xeb6&'\n\r\n\x05\x04\xa5\x02\x02\x01\x12\x04\xec6\x02\
    /\n\x0e\n\x06\x04\xa5\x02\x02\x01\x06\x12\x04\xec6\x02\x1b\n\x0e\n\x06\
    \x04\xa5\x02\x02\x01\x01\x12\x04\xec6\x1c*\n\x0e\n\x06\x04\xa5\x02\x02\
    \x01\x03\x12\x04\xec6-.\n)\n\x03\x04\xa6\x02\x12\x06\xf06\0\xf36\x01\x1a\
    \x1a\x20Start\x20a\x20multipart\x20upload\n\n\x0c\n\x04\x04\xa6\x02\x01\
    \x12\x04\xf06\x08\x1a\n\r\n\x05\x04\xa6\x02\x02\0\x12\x04\xf16\x02,\n\
    \x0e\n\x06\x04\xa6\x02\x02\0\x06\x12\x04\xf16\x02\x1b\n\x0e\n\x06\x04\
    \xa6\x02\x02\0\x01\x12\x04\xf16\x1c'\n\x0e\n\x06\x04\xa6\x02\x02\0\x03\
    \x12\x04\xf16*+\n\r\n\x05\x04\xa6\x02\x02\x01\x12\x04\xf26\x02+\n\x0e\n\
    \x06\x04\xa6\x02\x02\x01\x04\x12\x04\xf26\x02\n\n\x0e\n\x06\x04\xa6\x02\
    \x02\x01\x06\x12\x04\xf26\x0b\x1e\n\x0e\n\x06\x04\xa6\x02\x02\x01\x01\
    \x12\x04\xf26\x1f&\n\x0e\n\x06\x04\xa6\x02\x02\x01\x03\x12\x04\xf26)*\n2\
    \n\x03\x04\xa7\x02\x12\x06\xf66\0\xf96\x01\x1a#\x20Stops\x20or\x20delete\
    s\x20multipart\x20upload\n\n\x0c\n\x04\x04\xa7\x02\x01\x12\x04\xf66\x08\
    \x1c\n\r\n\x05\x04\xa7\x02\x02\0\x12\x04\xf76\x02,\n\x0e\n\x06\x04\xa7\
    \x02\x02\0\x06\x12\x04\xf76\x02\x1b\n\x0e\n\x06\x04\xa7\x02\x02\0\x01\
    \x12\x04\xf76\x1c'\n\x0e\n\x06\x04\xa7\x02\x02\0\x03\x12\x04\xf76*+\n\r\
    \n\x05\x04\xa7\x02\x02\x01\x12\x04\xf86\x02\x1a\n\x0e\n\x06\x04\xa7\x02\
    \x02\x01\x04\x12\x04\xf86\x02\n\n\x0e\n\x06\x04\xa7\x02\x02\x01\x05\x12\
    \x04\xf86\x0b\x11\n\x0e\n\x06\x04\xa7\x02\x02\x01\x01\x12\x04\xf86\x12\
    \x15\n\x0e\n\x06\x04\xa7\x02\x02\x01\x03\x12\x04\xf86\x18\x19\n\r\n\x03\
    \x04\xa8\x02\x12\x06\xfb6\0\x837\x01\n\x0c\n\x04\x04\xa8\x02\x01\x12\x04\
    \xfb6\x08\x1a\n\r\n\x05\x04\xa8\x02\x02\0\x12\x04\xfc6\x02,\n\x0e\n\x06\
    \x04\xa8\x02\x02\0\x06\x12\x04\xfc6\x02\x1b\n\x0e\n\x06\x04\xa8\x02\x02\
    \0\x01\x12\x04\xfc6\x1c'\n\x0e\n\x06\x04\xa8\x02\x02\0\x03\x12\x04\xfc6*\
    +\n\x7f\n\x05\x04\xa8\x02\x02\x01\x12\x04\xff6\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xa8\x02\x02\x01\x05\x12\x04\xff6\x02\x08\
    \n\x0e\n\x06\x04\xa8\x02\x02\x01\x01\x12\x04\xff6\t\r\n\x0e\n\x06\x04\
    \xa8\x02\x02\x01\x03\x12\x04\xff6\x10\x11\nv\n\x05\x04\xa8\x02\x02\x02\
    \x12\x04\x827\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xa8\x02\x02\x02\
    \x05\x12\x04\x827\x02\x08\n\x0e\n\x06\x04\xa8\x02\x02\x02\x01\x12\x04\
    \x827\t\x11\n\x0e\n\x06\x04\xa8\x02\x02\x02\x03\x12\x04\x827\x14\x15\n\r\
    \n\x03\x04\xa9\x02\x12\x06\x857\0\x8a7\x01\n\x0c\n\x04\x04\xa9\x02\x01\
    \x12\x04\x857\x08\x18\n\r\n\x05\x04\xa9\x02\x02\0\x12\x04\x867\x02,\n\
    \x0e\n\x06\x04\xa9\x02\x02\0\x06\x12\x04\x867\x02\x1b\n\x0e\n\x06\x04\
    \xa9\x02\x02\0\x01\x12\x04\x867\x1c'\n\x0e\n\x06\x04\xa9\x02\x02\0\x03\
    \x12\x04\x867*+\n\x1a\n\x05\x04\xa9\x02\x02\x01\x12\x04\x897\x02\x17\x1a\
    \x0b\x20Upload\x20ID\n\n\x0e\n\x06\x04\xa9\x02\x02\x01\x05\x12\x04\x897\
    \x02\x08\n\x0e\n\x06\x04\xa9\x02\x02\x01\x01\x12\x04\x897\t\x12\n\x0e\n\
    \x06\x04\xa9\x02\x02\x01\x03\x12\x04\x897\x15\x16\n\r\n\x03\x04\xaa\x02\
    \x12\x06\x8c7\0\x8f7\x01\n\x0c\n\x04\x04\xaa\x02\x01\x12\x04\x8c7\x08\
    \x1c\n\r\n\x05\x04\xaa\x02\x02\0\x12\x04\x8d7\x02(\n\x0e\n\x06\x04\xaa\
    \x02\x02\0\x06\x12\x04\x8d7\x02\x1c\n\x0e\n\x06\x04\xaa\x02\x02\0\x01\
    \x12\x04\x8d7\x1d#\n\x0e\n\x06\x04\xaa\x02\x02\0\x03\x12\x04\x8d7&'\n\r\
    \n\x05\x04\xaa\x02\x02\x01\x12\x04\x8e7\x02!\n\x0e\n\x06\x04\xaa\x02\x02\
    \x01\x06\x12\x04\x8e7\x02\x15\n\x0e\n\x06\x04\xaa\x02\x02\x01\x01\x12\
    \x04\x8e7\x16\x1c\n\x0e\n\x06\x04\xaa\x02\x02\x01\x03\x12\x04\x8e7\x1f\
    \x20\n\r\n\x03\x04\xab\x02\x12\x06\x917\0\x947\x01\n\x0c\n\x04\x04\xab\
    \x02\x01\x12\x04\x917\x08\x1b\n\r\n\x05\x04\xab\x02\x02\0\x12\x04\x927\
    \x02(\n\x0e\n\x06\x04\xab\x02\x02\0\x06\x12\x04\x927\x02\x1c\n\x0e\n\x06\
    \x04\xab\x02\x02\0\x01\x12\x04\x927\x1d#\n\x0e\n\x06\x04\xab\x02\x02\0\
    \x03\x12\x04\x927&'\n\r\n\x05\x04\xab\x02\x02\x01\x12\x04\x937\x02+\n\
    \x0e\n\x06\x04\xab\x02\x02\x01\x04\x12\x04\x937\x02\n\n\x0e\n\x06\x04\
    \xab\x02\x02\x01\x06\x12\x04\x937\x0b\x1e\n\x0e\n\x06\x04\xab\x02\x02\
    \x01\x01\x12\x04\x937\x1f&\n\x0e\n\x06\x04\xab\x02\x02\x01\x03\x12\x04\
    \x937)*\n\x8c\x01\n\x03\x04\xac\x02\x12\x06\x987\0\x9c7\x01\x1a}\x20Uplo\
    ad\x20a\x20part\x20of\x20a\x20multipart\x20upload.\n\x20Behaviour\x20on\
    \x20completion\x20depends\x20on\x20the\x20endpoint\x20that\x20was\x20use\
    d\x20to\x20initiate\x20the\x20upload.\n\n\x0c\n\x04\x04\xac\x02\x01\x12\
    \x04\x987\x08$\n\r\n\x05\x04\xac\x02\x02\0\x12\x04\x997\x02,\n\x0e\n\x06\
    \x04\xac\x02\x02\0\x06\x12\x04\x997\x02\x1b\n\x0e\n\x06\x04\xac\x02\x02\
    \0\x01\x12\x04\x997\x1c'\n\x0e\n\x06\x04\xac\x02\x02\0\x03\x12\x04\x997*\
    +\n\r\n\x05\x04\xac\x02\x02\x01\x12\x04\x9a7\x02\x17\n\x0e\n\x06\x04\xac\
    \x02\x02\x01\x05\x12\x04\x9a7\x02\x08\n\x0e\n\x06\x04\xac\x02\x02\x01\
    \x01\x12\x04\x9a7\t\x12\n\x0e\n\x06\x04\xac\x02\x02\x01\x03\x12\x04\x9a7\
    \x15\x16\n\r\n\x05\x04\xac\x02\x02\x02\x12\x04\x9b7\x02/\n\x0e\n\x06\x04\
    \xac\x02\x02\x02\x04\x12\x04\x9b7\x02\n\n\x0e\n\x06\x04\xac\x02\x02\x02\
    \x06\x12\x04\x9b7\x0b\x1c\n\x0e\n\x06\x04\xac\x02\x02\x02\x01\x12\x04\
    \x9b7\x1d*\n\x0e\n\x06\x04\xac\x02\x02\x02\x03\x12\x04\x9b7-.\n\xad\x06\
    \n\x03\x04\xad\x02\x12\x06\xab7\0\xb57\x01\x1a\x9d\x06\x20Initiates\x20r\
    etrieval\x20of\x20inputs\x20from\x20cloud\x20storage\x20from\x20a\x20use\
    r\x20provided\x20data\x20source.\n\x20Will\x20create\x20and\x20return\
    \x20an\x20inputs-add-job\x20for\x20tracking\x20progress.\n\x20Archives\
    \x20will\x20be\x20extracted\x20and\x20their\x20contents\x20will\x20be\
    \x20processed\x20as\x20inputs.\n\n\x20The\x20cloud\x20URL\x20will\x20be\
    \x20treated\x20as\x20a\x20filter\x20prefix.\x20For\x20example\x20s3:/buc\
    ket/images_folder/abc\x20will\x20process\n\x20files\x20in\x20the\x20imag\
    es_folder\x20beginning\x20with\x20abc\x20or\x20in\x20a\x20subfolder\x20b\
    eginning\x20with\x20abc.\n\x20For\x20example:\n\x20bucket/images_folder/\
    abcImage.png\n\x20bucket/images_folder/abc-1/Data.zip\n\n\x20If\x20given\
    \x20URL\x20is\x20for\x20a\x20private\x20bucket\x20or\x20file,\x20then\
    \x20credentials\x20should\x20be\x20provided\x20to\x20access\x20the\x20bu\
    cket.\n\x20Credentials\x20should\x20include\x20rights\x20to\x20list\x20t\
    he\x20objects\x20in\x20the\x20bucket,\x20except\x20when\x20pointed\x20di\
    rectly\x20at\x20a\x20file\x20archive,\n\x20in\x20which\x20case\x20it\x20\
    only\x20requires\x20rights\x20to\x20access\x20that\x20particular\x20file\
    .\n\n\x0c\n\x04\x04\xad\x02\x01\x12\x04\xab7\x08$\n\r\n\x05\x04\xad\x02\
    \x02\0\x12\x04\xac7\x02,\n\x0e\n\x06\x04\xad\x02\x02\0\x06\x12\x04\xac7\
    \x02\x1b\n\x0e\n\x06\x04\xad\x02\x02\0\x01\x12\x04\xac7\x1c'\n\x0e\n\x06\
    \x04\xad\x02\x02\0\x03\x12\x04\xac7*+\n\r\n\x05\x04\xad\x02\x02\x01\x12\
    \x04\xae7\x02-\n\x0e\n\x06\x04\xad\x02\x02\x01\x04\x12\x04\xae7\x02\n\n\
    \x0e\n\x06\x04\xad\x02\x02\x01\x06\x12\x04\xae7\x0b\x1b\n\x0e\n\x06\x04\
    \xad\x02\x02\x01\x01\x12\x04\xae7\x1c(\n\x0e\n\x06\x04\xad\x02\x02\x01\
    \x03\x12\x04\xae7+,\ng\n\x05\x04\xad\x02\x02\x02\x12\x04\xb17\x02\x1b\
    \x1aX\x20If\x20call\x20back\x20url\x20is\x20set,\x20we\x20will\x20send\
    \x20a\x20Post\x20request\x20to\x20this\x20endpoint\x20with\x20job\x20sta\
    tus.\n\n\x0e\n\x06\x04\xad\x02\x02\x02\x05\x12\x04\xb17\x02\x08\n\x0e\n\
    \x06\x04\xad\x02\x02\x02\x01\x12\x04\xb17\t\x16\n\x0e\n\x06\x04\xad\x02\
    \x02\x02\x03\x12\x04\xb17\x19\x1a\nS\n\x05\x04\xad\x02\x02\x03\x12\x04\
    \xb47\x02\x15\x1aD\x20Personal\x20Access\x20Token\x20to\x20the\x20applic\
    ation\x20to\x20which\x20inputs\x20are\x20added\n\n\x0e\n\x06\x04\xad\x02\
    \x02\x03\x05\x12\x04\xb47\x02\x08\n\x0e\n\x06\x04\xad\x02\x02\x03\x01\
    \x12\x04\xb47\t\x10\n\x0e\n\x06\x04\xad\x02\x02\x03\x03\x12\x04\xb47\x13\
    \x14\n\r\n\x03\x04\xae\x02\x12\x06\xb77\0\xbb7\x01\n\x0c\n\x04\x04\xae\
    \x02\x01\x12\x04\xb77\x08%\n\r\n\x05\x04\xae\x02\x02\0\x12\x04\xb87\x02,\
    \n\x0e\n\x06\x04\xae\x02\x02\0\x06\x12\x04\xb87\x02\x1b\n\x0e\n\x06\x04\
    \xae\x02\x02\0\x01\x12\x04\xb87\x1c'\n\x0e\n\x06\x04\xae\x02\x02\0\x03\
    \x12\x04\xb87*+\n\r\n\x05\x04\xae\x02\x02\x01\x12\x04\xba7\x02&\n\x0e\n\
    \x06\x04\xae\x02\x02\x01\x05\x12\x04\xba7\x02\x08\n\x0e\n\x06\x04\xae\
    \x02\x02\x01\x01\x12\x04\xba7\t!\n\x0e\n\x06\x04\xae\x02\x02\x01\x03\x12\
    \x04\xba7$%\n\r\n\x03\x04\xaf\x02\x12\x06\xbd7\0\xc57\x01\n\x0c\n\x04\
    \x04\xaf\x02\x01\x12\x04\xbd7\x08'\n\r\n\x05\x04\xaf\x02\x02\0\x12\x04\
    \xbe7\x02,\n\x0e\n\x06\x04\xaf\x02\x02\0\x06\x12\x04\xbe7\x02\x1b\n\x0e\
    \n\x06\x04\xaf\x02\x02\0\x01\x12\x04\xbe7\x1c'\n\x0e\n\x06\x04\xaf\x02\
    \x02\0\x03\x12\x04\xbe7*+\n\x7f\n\x05\x04\xaf\x02\x02\x01\x12\x04\xc17\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xaf\x02\x02\x01\
    \x05\x12\x04\xc17\x02\x08\n\x0e\n\x06\x04\xaf\x02\x02\x01\x01\x12\x04\
    \xc17\t\r\n\x0e\n\x06\x04\xaf\x02\x02\x01\x03\x12\x04\xc17\x10\x11\nv\n\
    \x05\x04\xaf\x02\x02\x02\x12\x04\xc47\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\xaf\x02\x02\x02\x05\x12\x04\xc47\x02\x08\n\x0e\n\x06\x04\xaf\
    \x02\x02\x02\x01\x12\x04\xc47\t\x11\n\x0e\n\x06\x04\xaf\x02\x02\x02\x03\
    \x12\x04\xc47\x14\x15\n\r\n\x03\x04\xb0\x02\x12\x06\xc77\0\xca7\x01\n\
    \x0c\n\x04\x04\xb0\x02\x01\x12\x04\xc77\x08)\n\r\n\x05\x04\xb0\x02\x02\0\
    \x12\x04\xc87\x02(\n\x0e\n\x06\x04\xb0\x02\x02\0\x06\x12\x04\xc87\x02\
    \x1c\n\x0e\n\x06\x04\xb0\x02\x02\0\x01\x12\x04\xc87\x1d#\n\x0e\n\x06\x04\
    \xb0\x02\x02\0\x03\x12\x04\xc87&'\n\r\n\x05\x04\xb0\x02\x02\x01\x12\x04\
    \xc97\x02=\n\x0e\n\x06\x04\xb0\x02\x02\x01\x06\x12\x04\xc97\x02\"\n\x0e\
    \n\x06\x04\xb0\x02\x02\x01\x01\x12\x04\xc97#8\n\x0e\n\x06\x04\xb0\x02\
    \x02\x01\x03\x12\x04\xc97;<\n\r\n\x03\x04\xb1\x02\x12\x06\xcc7\0\xcf7\
    \x01\n\x0c\n\x04\x04\xb1\x02\x01\x12\x04\xcc7\x08(\n\r\n\x05\x04\xb1\x02\
    \x02\0\x12\x04\xcd7\x02(\n\x0e\n\x06\x04\xb1\x02\x02\0\x06\x12\x04\xcd7\
    \x02\x1c\n\x0e\n\x06\x04\xb1\x02\x02\0\x01\x12\x04\xcd7\x1d#\n\x0e\n\x06\
    \x04\xb1\x02\x02\0\x03\x12\x04\xcd7&'\n\r\n\x05\x04\xb1\x02\x02\x01\x12\
    \x04\xce7\x02G\n\x0e\n\x06\x04\xb1\x02\x02\x01\x04\x12\x04\xce7\x02\n\n\
    \x0e\n\x06\x04\xb1\x02\x02\x01\x06\x12\x04\xce7\x0b+\n\x0e\n\x06\x04\xb1\
    \x02\x02\x01\x01\x12\x04\xce7,B\n\x0e\n\x06\x04\xb1\x02\x02\x01\x03\x12\
    \x04\xce7EF\n4\n\x03\x04\xb2\x02\x12\x06\xd27\0\xd67\x01\x1a%\x20Cancel\
    \x20a\x20list\x20of\x20extraction\x20job\x20ids\n\n\x0c\n\x04\x04\xb2\
    \x02\x01\x12\x04\xd27\x08)\n\r\n\x05\x04\xb2\x02\x02\0\x12\x04\xd37\x02,\
    \n\x0e\n\x06\x04\xb2\x02\x02\0\x06\x12\x04\xd37\x02\x1b\n\x0e\n\x06\x04\
    \xb2\x02\x02\0\x01\x12\x04\xd37\x1c'\n\x0e\n\x06\x04\xb2\x02\x02\0\x03\
    \x12\x04\xd37*+\n;\n\x05\x04\xb2\x02\x02\x01\x12\x04\xd57\x02\x1a\x1a,\
    \x20List\x20of\x20extraction\x20job\x20ids\x20to\x20be\x20cancelled\n\n\
    \x0e\n\x06\x04\xb2\x02\x02\x01\x04\x12\x04\xd57\x02\n\n\x0e\n\x06\x04\
    \xb2\x02\x02\x01\x05\x12\x04\xd57\x0b\x11\n\x0e\n\x06\x04\xb2\x02\x02\
    \x01\x01\x12\x04\xd57\x12\x15\n\x0e\n\x06\x04\xb2\x02\x02\x01\x03\x12\
    \x04\xd57\x18\x19\n\xe6\x02\n\x03\x04\xb3\x02\x12\x06\xdd7\0\xe07\x01\
    \x1a\xd6\x02\x20Start\x20uploading\x20a\x20file\x20archive\x20containing\
    \x20inputs.\n\x20Will\x20create\x20and\x20return\x20an\x20inputs-add-job\
    \x20for\x20tracking\x20progress.\n\n\x20Associated\x20inputs-add-job\x20\
    contains\x20an\x20upload\x20id\x20which\x20should\x20be\x20completed\x20\
    through\x20`PutUploadContentParts`\x20endpoint.\n\x20Completing\x20the\
    \x20upload\x20will\x20automatically\x20begin\x20unpacking\x20the\x20arch\
    ive\x20and\x20uploading\x20the\x20contents\x20as\x20inputs.\n\n\x0c\n\
    \x04\x04\xb3\x02\x01\x12\x04\xdd7\x08\x20\n\r\n\x05\x04\xb3\x02\x02\0\
    \x12\x04\xde7\x02,\n\x0e\n\x06\x04\xb3\x02\x02\0\x06\x12\x04\xde7\x02\
    \x1b\n\x0e\n\x06\x04\xb3\x02\x02\0\x01\x12\x04\xde7\x1c'\n\x0e\n\x06\x04\
    \xb3\x02\x02\0\x03\x12\x04\xde7*+\n\r\n\x05\x04\xb3\x02\x02\x01\x12\x04\
    \xdf7\x028\n\x0e\n\x06\x04\xb3\x02\x02\x01\x04\x12\x04\xdf7\x02\n\n\x0e\
    \n\x06\x04\xb3\x02\x02\x01\x06\x12\x04\xdf7\x0b$\n\x0e\n\x06\x04\xb3\x02\
    \x02\x01\x01\x12\x04\xdf7%3\n\x0e\n\x06\x04\xb3\x02\x02\x01\x03\x12\x04\
    \xdf767\n!\n\x03\x04\xb4\x02\x12\x06\xe37\0\xe67\x01\x1a\x12\x20GetRunne\
    rRequest\n\n\x0c\n\x04\x04\xb4\x02\x01\x12\x04\xe37\x08\x18\n\r\n\x05\
    \x04\xb4\x02\x02\0\x12\x04\xe47\x02,\n\x0e\n\x06\x04\xb4\x02\x02\0\x06\
    \x12\x04\xe47\x02\x1b\n\x0e\n\x06\x04\xb4\x02\x02\0\x01\x12\x04\xe47\x1c\
    '\n\x0e\n\x06\x04\xb4\x02\x02\0\x03\x12\x04\xe47*+\n\r\n\x05\x04\xb4\x02\
    \x02\x01\x12\x04\xe57\x02\x17\n\x0e\n\x06\x04\xb4\x02\x02\x01\x05\x12\
    \x04\xe57\x02\x08\n\x0e\n\x06\x04\xb4\x02\x02\x01\x01\x12\x04\xe57\t\x12\
    \n\x0e\n\x06\x04\xb4\x02\x02\x01\x03\x12\x04\xe57\x15\x16\n#\n\x03\x04\
    \xb5\x02\x12\x06\xe97\0\xf17\x01\x1a\x14\x20ListRunnersRequest\n\n\x0c\n\
    \x04\x04\xb5\x02\x01\x12\x04\xe97\x08\x1a\n\r\n\x05\x04\xb5\x02\x02\0\
    \x12\x04\xea7\x02,\n\x0e\n\x06\x04\xb5\x02\x02\0\x06\x12\x04\xea7\x02\
    \x1b\n\x0e\n\x06\x04\xb5\x02\x02\0\x01\x12\x04\xea7\x1c'\n\x0e\n\x06\x04\
    \xb5\x02\x02\0\x03\x12\x04\xea7*+\n\x7f\n\x05\x04\xb5\x02\x02\x01\x12\
    \x04\xed7\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xb5\x02\
    \x02\x01\x05\x12\x04\xed7\x02\x08\n\x0e\n\x06\x04\xb5\x02\x02\x01\x01\
    \x12\x04\xed7\t\r\n\x0e\n\x06\x04\xb5\x02\x02\x01\x03\x12\x04\xed7\x10\
    \x11\nv\n\x05\x04\xb5\x02\x02\x02\x12\x04\xf07\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\xb5\x02\x02\x02\x05\x12\x04\xf07\x02\x08\n\x0e\n\x06\
    \x04\xb5\x02\x02\x02\x01\x12\x04\xf07\t\x11\n\x0e\n\x06\x04\xb5\x02\x02\
    \x02\x03\x12\x04\xf07\x14\x15\n#\n\x03\x04\xb6\x02\x12\x06\xf47\0\xf87\
    \x01\x1a\x14\x20PostRunnersRequest\n\n\x0c\n\x04\x04\xb6\x02\x01\x12\x04\
    \xf47\x08\x1a\n\r\n\x05\x04\xb6\x02\x02\0\x12\x04\xf57\x02,\n\x0e\n\x06\
    \x04\xb6\x02\x02\0\x06\x12\x04\xf57\x02\x1b\n\x0e\n\x06\x04\xb6\x02\x02\
    \0\x01\x12\x04\xf57\x1c'\n\x0e\n\x06\x04\xb6\x02\x02\0\x03\x12\x04\xf57*\
    +\nW\n\x05\x04\xb6\x02\x02\x01\x12\x04\xf77\x02\x1e\x1aH\x20This\x20allo\
    ws\x20you\x20to\x20create\x20one\x20or\x20more\x20runner\x20by\x20postin\
    g\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\xb6\x02\x02\x01\x04\x12\
    \x04\xf77\x02\n\n\x0e\n\x06\x04\xb6\x02\x02\x01\x06\x12\x04\xf77\x0b\x11\
    \n\x0e\n\x06\x04\xb6\x02\x02\x01\x01\x12\x04\xf77\x12\x19\n\x0e\n\x06\
    \x04\xb6\x02\x02\x01\x03\x12\x04\xf77\x1c\x1d\nE\n\x03\x04\xb7\x02\x12\
    \x06\xfb7\0\xfe7\x01\x1a6\x20Request\x20to\x20delete\x20several\x20thing\
    s\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xb7\x02\x01\x12\
    \x04\xfb7\x08\x1c\n\r\n\x05\x04\xb7\x02\x02\0\x12\x04\xfc7\x02,\n\x0e\n\
    \x06\x04\xb7\x02\x02\0\x06\x12\x04\xfc7\x02\x1b\n\x0e\n\x06\x04\xb7\x02\
    \x02\0\x01\x12\x04\xfc7\x1c'\n\x0e\n\x06\x04\xb7\x02\x02\0\x03\x12\x04\
    \xfc7*+\n\r\n\x05\x04\xb7\x02\x02\x01\x12\x04\xfd7\x02\x1a\n\x0e\n\x06\
    \x04\xb7\x02\x02\x01\x04\x12\x04\xfd7\x02\n\n\x0e\n\x06\x04\xb7\x02\x02\
    \x01\x05\x12\x04\xfd7\x0b\x11\n\x0e\n\x06\x04\xb7\x02\x02\x01\x01\x12\
    \x04\xfd7\x12\x15\n\x0e\n\x06\x04\xb7\x02\x02\x01\x03\x12\x04\xfd7\x18\
    \x19\n%\n\x03\x04\xb8\x02\x12\x06\x838\0\x868\x01\x1a\x16\x20SingleRunne\
    rResponse\n\n\x0c\n\x04\x04\xb8\x02\x01\x12\x04\x838\x08\x1c\n\r\n\x05\
    \x04\xb8\x02\x02\0\x12\x04\x848\x02(\n\x0e\n\x06\x04\xb8\x02\x02\0\x06\
    \x12\x04\x848\x02\x1c\n\x0e\n\x06\x04\xb8\x02\x02\0\x01\x12\x04\x848\x1d\
    #\n\x0e\n\x06\x04\xb8\x02\x02\0\x03\x12\x04\x848&'\n\r\n\x05\x04\xb8\x02\
    \x02\x01\x12\x04\x858\x02\x14\n\x0e\n\x06\x04\xb8\x02\x02\x01\x06\x12\
    \x04\x858\x02\x08\n\x0e\n\x06\x04\xb8\x02\x02\x01\x01\x12\x04\x858\t\x0f\
    \n\x0e\n\x06\x04\xb8\x02\x02\x01\x03\x12\x04\x858\x12\x13\n$\n\x03\x04\
    \xb9\x02\x12\x06\x898\0\x8c8\x01\x1a\x15\x20MultiRunnerResponse\n\n\x0c\
    \n\x04\x04\xb9\x02\x01\x12\x04\x898\x08\x1b\n\r\n\x05\x04\xb9\x02\x02\0\
    \x12\x04\x8a8\x02(\n\x0e\n\x06\x04\xb9\x02\x02\0\x06\x12\x04\x8a8\x02\
    \x1c\n\x0e\n\x06\x04\xb9\x02\x02\0\x01\x12\x04\x8a8\x1d#\n\x0e\n\x06\x04\
    \xb9\x02\x02\0\x03\x12\x04\x8a8&'\n\r\n\x05\x04\xb9\x02\x02\x01\x12\x04\
    \x8b8\x02M\n\x0e\n\x06\x04\xb9\x02\x02\x01\x04\x12\x04\x8b8\x02\n\n\x0e\
    \n\x06\x04\xb9\x02\x02\x01\x06\x12\x04\x8b8\x0b\x11\n\x0e\n\x06\x04\xb9\
    \x02\x02\x01\x01\x12\x04\x8b8\x12\x19\n\x0e\n\x06\x04\xb9\x02\x02\x01\
    \x03\x12\x04\x8b8\x1c\x1d\n\x0e\n\x06\x04\xb9\x02\x02\x01\x08\x12\x04\
    \x8b8\x1eL\n\x11\n\t\x04\xb9\x02\x02\x01\x08\xd0\x86\x03\x12\x04\x8b8\
    \x1fK\n\r\n\x03\x04\xba\x02\x12\x06\x928\0\x958\x01\n\x0c\n\x04\x04\xba\
    \x02\x01\x12\x04\x928\x08\x1e\n\r\n\x05\x04\xba\x02\x02\0\x12\x04\x938\
    \x02,\n\x0e\n\x06\x04\xba\x02\x02\0\x06\x12\x04\x938\x02\x1b\n\x0e\n\x06\
    \x04\xba\x02\x02\0\x01\x12\x04\x938\x1c'\n\x0e\n\x06\x04\xba\x02\x02\0\
    \x03\x12\x04\x938*+\n\r\n\x05\x04\xba\x02\x02\x01\x12\x04\x948\x02\x17\n\
    \x0e\n\x06\x04\xba\x02\x02\x01\x05\x12\x04\x948\x02\x08\n\x0e\n\x06\x04\
    \xba\x02\x02\x01\x01\x12\x04\x948\t\x12\n\x0e\n\x06\x04\xba\x02\x02\x01\
    \x03\x12\x04\x948\x15\x16\n-\n\x03\x04\xbb\x02\x12\x06\x988\0\x9e8\x01\
    \x1a\x1e\x20PostRunnerItemOutputsRequest\n\n\x0c\n\x04\x04\xbb\x02\x01\
    \x12\x04\x988\x08$\n\r\n\x05\x04\xbb\x02\x02\0\x12\x04\x998\x02,\n\x0e\n\
    \x06\x04\xbb\x02\x02\0\x06\x12\x04\x998\x02\x1b\n\x0e\n\x06\x04\xbb\x02\
    \x02\0\x01\x12\x04\x998\x1c'\n\x0e\n\x06\x04\xbb\x02\x02\0\x03\x12\x04\
    \x998*+\n\r\n\x05\x04\xbb\x02\x02\x01\x12\x04\x9a8\x02\x17\n\x0e\n\x06\
    \x04\xbb\x02\x02\x01\x05\x12\x04\x9a8\x02\x08\n\x0e\n\x06\x04\xbb\x02\
    \x02\x01\x01\x12\x04\x9a8\t\x12\n\x0e\n\x06\x04\xbb\x02\x02\x01\x03\x12\
    \x04\x9a8\x15\x16\n\r\n\x05\x04\xbb\x02\x02\x02\x12\x04\x9b8\x02\x15\n\
    \x0e\n\x06\x04\xbb\x02\x02\x02\x05\x12\x04\x9b8\x02\x08\n\x0e\n\x06\x04\
    \xbb\x02\x02\x02\x01\x12\x04\x9b8\t\x10\n\x0e\n\x06\x04\xbb\x02\x02\x02\
    \x03\x12\x04\x9b8\x13\x14\nW\n\x05\x04\xbb\x02\x02\x03\x12\x04\x9d8\x024\
    \x1aH\x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20r\
    unner\x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\xbb\
    \x02\x02\x03\x04\x12\x04\x9d8\x02\n\n\x0e\n\x06\x04\xbb\x02\x02\x03\x06\
    \x12\x04\x9d8\x0b\x1b\n\x0e\n\x06\x04\xbb\x02\x02\x03\x01\x12\x04\x9d8\
    \x1c/\n\x0e\n\x06\x04\xbb\x02\x02\x03\x03\x12\x04\x9d823\n(\n\x03\x04\
    \xbc\x02\x12\x06\xa58\0\xa88\x01\x1a\x19\x20MultiRunnerItemResponse\n\n\
    \x0c\n\x04\x04\xbc\x02\x01\x12\x04\xa58\x08\x1f\n\r\n\x05\x04\xbc\x02\
    \x02\0\x12\x04\xa68\x02(\n\x0e\n\x06\x04\xbc\x02\x02\0\x06\x12\x04\xa68\
    \x02\x1c\n\x0e\n\x06\x04\xbc\x02\x02\0\x01\x12\x04\xa68\x1d#\n\x0e\n\x06\
    \x04\xbc\x02\x02\0\x03\x12\x04\xa68&'\n\r\n\x05\x04\xbc\x02\x02\x01\x12\
    \x04\xa78\x02O\n\x0e\n\x06\x04\xbc\x02\x02\x01\x04\x12\x04\xa78\x02\n\n\
    \x0e\n\x06\x04\xbc\x02\x02\x01\x06\x12\x04\xa78\x0b\x15\n\x0e\n\x06\x04\
    \xbc\x02\x02\x01\x01\x12\x04\xa78\x16\x1b\n\x0e\n\x06\x04\xbc\x02\x02\
    \x01\x03\x12\x04\xa78\x1e\x1f\n\x0e\n\x06\x04\xbc\x02\x02\x01\x08\x12\
    \x04\xa78\x20N\n\x11\n\t\x04\xbc\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xa7\
    8!M\n\r\n\x03\x04\xbd\x02\x12\x06\xaa8\0\xb58\x01\n\x0c\n\x04\x04\xbd\
    \x02\x01\x12\x04\xaa8\x08\x12\n0\n\x05\x04\xbd\x02\x02\0\x12\x04\xac8\
    \x02\x10\x1a!\x20A\x20UUID\x20hash\x20for\x20this\x20work\x20item.\n\n\
    \x0e\n\x06\x04\xbd\x02\x02\0\x05\x12\x04\xac8\x02\x08\n\x0e\n\x06\x04\
    \xbd\x02\x02\0\x01\x12\x04\xac8\t\x0b\n\x0e\n\x06\x04\xbd\x02\x02\0\x03\
    \x12\x04\xac8\x0e\x0f\nM\n\x05\x04\xbd\x02\x02\x01\x12\x04\xaf8\x02\x19\
    \x1a>\x20A\x20description\x20of\x20the\x20work\x20to\x20be\x20done\x20in\
    \x20case\x20needed\x20for\x20UIs.\n\n\x0e\n\x06\x04\xbd\x02\x02\x01\x05\
    \x12\x04\xaf8\x02\x08\n\x0e\n\x06\x04\xbd\x02\x02\x01\x01\x12\x04\xaf8\t\
    \x14\n\x0e\n\x06\x04\xbd\x02\x02\x01\x03\x12\x04\xaf8\x17\x18\n\x84\x01\
    \n\x05\x04\xbd\x02\x02\x02\x12\x04\xb38\x029\x1a[\x20TODO(zeiler):\x20ma\
    ke\x20these\x20options\x20a\x20oneof.\n\x20first\x20work\x20to\x20do\x20\
    would\x20be\x20an\x20inference\x20runner.\n\"\x18\x20training\x20request\
    \x20next.\n\n\x0e\n\x06\x04\xbd\x02\x02\x02\x06\x12\x04\xb38\x02\x19\n\
    \x0e\n\x06\x04\xbd\x02\x02\x02\x01\x12\x04\xb38\x1a4\n\x0e\n\x06\x04\xbd\
    \x02\x02\x02\x03\x12\x04\xb3878\n\r\n\x03\x04\xbe\x02\x12\x06\xb98\0\xc1\
    8\x01\n\x0c\n\x04\x04\xbe\x02\x01\x12\x04\xb98\x08\x18\n\x9a\x01\n\x05\
    \x04\xbe\x02\x02\0\x12\x04\xbc8\x020\x1a\x8a\x01\x20The\x20output\x20of\
    \x20the\x20first\x20task\x20type.\n\x20TODO(zeiler):\x20should\x20the\
    \x20interface\x20be\x20more\x20like\x20pairs\x20of\x20things\x20wiht\x20\
    request/response\x20in\x20one\x20\"item\"?\n\n\x0e\n\x06\x04\xbe\x02\x02\
    \0\x06\x12\x04\xbc8\x02\x15\n\x0e\n\x06\x04\xbe\x02\x02\0\x01\x12\x04\
    \xbc8\x16+\n\x0e\n\x06\x04\xbe\x02\x02\0\x03\x12\x04\xbc8./\n\r\n\x03\
    \x04\xbf\x02\x12\x06\xc58\0\xc88\x01\n\x0c\n\x04\x04\xbf\x02\x01\x12\x04\
    \xc58\x08%\n\r\n\x05\x04\xbf\x02\x02\0\x12\x04\xc68\x02(\n\x0e\n\x06\x04\
    \xbf\x02\x02\0\x06\x12\x04\xc68\x02\x1c\n\x0e\n\x06\x04\xbf\x02\x02\0\
    \x01\x12\x04\xc68\x1d#\n\x0e\n\x06\x04\xbf\x02\x02\0\x03\x12\x04\xc68&'\
    \n\r\n\x05\x04\xbf\x02\x02\x01\x12\x04\xc78\x02c\n\x0e\n\x06\x04\xbf\x02\
    \x02\x01\x04\x12\x04\xc78\x02\n\n\x0e\n\x06\x04\xbf\x02\x02\x01\x06\x12\
    \x04\xc78\x0b\x1b\n\x0e\n\x06\x04\xbf\x02\x02\x01\x01\x12\x04\xc78\x1c/\
    \n\x0e\n\x06\x04\xbf\x02\x02\x01\x03\x12\x04\xc7823\n\x0e\n\x06\x04\xbf\
    \x02\x02\x01\x08\x12\x04\xc784b\n\x11\n\t\x04\xbf\x02\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xc785a\nD\n\x03\x04\xc0\x02\x12\x06\xcb8\0\xd08\x01\x1a\
    5\x20Get\x20the\x20estimated\x20training\x20time\x20for\x20a\x20model\
    \x20version\n\n\x0c\n\x04\x04\xc0\x02\x01\x12\x04\xcb8\x084\n\r\n\x05\
    \x04\xc0\x02\x02\0\x12\x04\xcc8\x02,\n\x0e\n\x06\x04\xc0\x02\x02\0\x06\
    \x12\x04\xcc8\x02\x1b\n\x0e\n\x06\x04\xc0\x02\x02\0\x01\x12\x04\xcc8\x1c\
    '\n\x0e\n\x06\x04\xc0\x02\x02\0\x03\x12\x04\xcc8*+\n\r\n\x05\x04\xc0\x02\
    \x02\x01\x12\x04\xcd8\x02\x16\n\x0e\n\x06\x04\xc0\x02\x02\x01\x05\x12\
    \x04\xcd8\x02\x08\n\x0e\n\x06\x04\xc0\x02\x02\x01\x01\x12\x04\xcd8\t\x11\
    \n\x0e\n\x06\x04\xc0\x02\x02\x01\x03\x12\x04\xcd8\x14\x15\n\r\n\x05\x04\
    \xc0\x02\x02\x02\x12\x04\xce8\x02+\n\x0e\n\x06\x04\xc0\x02\x02\x02\x04\
    \x12\x04\xce8\x02\n\n\x0e\n\x06\x04\xc0\x02\x02\x02\x06\x12\x04\xce8\x0b\
    \x17\n\x0e\n\x06\x04\xc0\x02\x02\x02\x01\x12\x04\xce8\x18&\n\x0e\n\x06\
    \x04\xc0\x02\x02\x02\x03\x12\x04\xce8)*\n\r\n\x05\x04\xc0\x02\x02\x03\
    \x12\x04\xcf8\x02#\n\x0e\n\x06\x04\xc0\x02\x02\x03\x05\x12\x04\xcf8\x02\
    \x08\n\x0e\n\x06\x04\xc0\x02\x02\x03\x01\x12\x04\xcf8\t\x1e\n\x0e\n\x06\
    \x04\xc0\x02\x02\x03\x03\x12\x04\xcf8!\"\n3\n\x03\x04\xc1\x02\x12\x06\
    \xd38\0\xd68\x01\x1a$\x20Estimated\x20training\x20time\x20in\x20seconds\
    \n\n\x0c\n\x04\x04\xc1\x02\x01\x12\x04\xd38\x08)\n\r\n\x05\x04\xc1\x02\
    \x02\0\x12\x04\xd48\x02(\n\x0e\n\x06\x04\xc1\x02\x02\0\x06\x12\x04\xd48\
    \x02\x1c\n\x0e\n\x06\x04\xc1\x02\x02\0\x01\x12\x04\xd48\x1d#\n\x0e\n\x06\
    \x04\xc1\x02\x02\0\x03\x12\x04\xd48&'\n\r\n\x05\x04\xc1\x02\x02\x01\x12\
    \x04\xd58\x02@\n\x0e\n\x06\x04\xc1\x02\x02\x01\x04\x12\x04\xd58\x02\n\n\
    \x0e\n\x06\x04\xc1\x02\x02\x01\x06\x12\x04\xd58\x0b#\n\x0e\n\x06\x04\xc1\
    \x02\x02\x01\x01\x12\x04\xd58$;\n\x0e\n\x06\x04\xc1\x02\x02\x01\x03\x12\
    \x04\xd58>?b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(10);
            deps.push(super::resources::file_descriptor().clone());
            deps.push(super::status::file_descriptor().clone());
            deps.push(super::extensions::file_descriptor().clone());
            deps.push(super::scope::file_descriptor().clone());
            deps.push(super::extension::file_descriptor().clone());
            deps.push(super::status_code::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(322);
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(GetAnnotationRequest::generated_message_descriptor_data());
            messages.push(ListAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsStatusRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsStatusResponse::generated_message_descriptor_data());
            messages.push(DeleteAnnotationRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationsRequest::generated_message_descriptor_data());
            messages.push(SingleAnnotationResponse::generated_message_descriptor_data());
            messages.push(MultiAnnotationResponse::generated_message_descriptor_data());
            messages.push(ListAnnotationWorkersRequest::generated_message_descriptor_data());
            messages.push(MultiWorkerResponse::generated_message_descriptor_data());
            messages.push(GetAppRequest::generated_message_descriptor_data());
            messages.push(ListAppsRequest::generated_message_descriptor_data());
            messages.push(PostAppsRequest::generated_message_descriptor_data());
            messages.push(DeleteAppRequest::generated_message_descriptor_data());
            messages.push(PatchAppsRequest::generated_message_descriptor_data());
            messages.push(PatchAppRequest::generated_message_descriptor_data());
            messages.push(PatchAppsIdsRequest::generated_message_descriptor_data());
            messages.push(PostAppsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleAppResponse::generated_message_descriptor_data());
            messages.push(MultiAppResponse::generated_message_descriptor_data());
            messages.push(ListCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(PostCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(PatchCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(DeleteCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(MultiCollaboratorsResponse::generated_message_descriptor_data());
            messages.push(ListCollaborationsRequest::generated_message_descriptor_data());
            messages.push(MultiCollaborationsResponse::generated_message_descriptor_data());
            messages.push(GetStatusCodeRequest::generated_message_descriptor_data());
            messages.push(ListStatusCodesRequest::generated_message_descriptor_data());
            messages.push(SingleStatusCodeResponse::generated_message_descriptor_data());
            messages.push(MultiStatusCodeResponse::generated_message_descriptor_data());
            messages.push(GetConceptRequest::generated_message_descriptor_data());
            messages.push(ListConceptsRequest::generated_message_descriptor_data());
            messages.push(ListModelConceptsRequest::generated_message_descriptor_data());
            messages.push(PostConceptsSearchesRequest::generated_message_descriptor_data());
            messages.push(ConceptExtraInfoRequest::generated_message_descriptor_data());
            messages.push(PostConceptsRequest::generated_message_descriptor_data());
            messages.push(PatchConceptsRequest::generated_message_descriptor_data());
            messages.push(GetConceptCountsRequest::generated_message_descriptor_data());
            messages.push(SingleConceptResponse::generated_message_descriptor_data());
            messages.push(MultiConceptResponse::generated_message_descriptor_data());
            messages.push(MultiConceptCountResponse::generated_message_descriptor_data());
            messages.push(ListConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(PostConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(DeleteConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(ListKnowledgeGraphsRequest::generated_message_descriptor_data());
            messages.push(PostKnowledgeGraphsRequest::generated_message_descriptor_data());
            messages.push(PostConceptMappingJobsRequest::generated_message_descriptor_data());
            messages.push(MultiConceptRelationResponse::generated_message_descriptor_data());
            messages.push(MultiKnowledgeGraphResponse::generated_message_descriptor_data());
            messages.push(MultiConceptMappingJobResponse::generated_message_descriptor_data());
            messages.push(GetConceptLanguageRequest::generated_message_descriptor_data());
            messages.push(ListConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(PatchConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(PostConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(SingleConceptLanguageResponse::generated_message_descriptor_data());
            messages.push(MultiConceptLanguageResponse::generated_message_descriptor_data());
            messages.push(GetInputRequest::generated_message_descriptor_data());
            messages.push(GetVideoManifestRequest::generated_message_descriptor_data());
            messages.push(GetInputSamplesRequest::generated_message_descriptor_data());
            messages.push(ListInputsRequest::generated_message_descriptor_data());
            messages.push(StreamInputsRequest::generated_message_descriptor_data());
            messages.push(PostInputsRequest::generated_message_descriptor_data());
            messages.push(PatchInputsRequest::generated_message_descriptor_data());
            messages.push(DeleteInputRequest::generated_message_descriptor_data());
            messages.push(DeleteInputsRequest::generated_message_descriptor_data());
            messages.push(SingleInputResponse::generated_message_descriptor_data());
            messages.push(GetVideoManifestResponse::generated_message_descriptor_data());
            messages.push(MultiInputResponse::generated_message_descriptor_data());
            messages.push(MultiInputAnnotationResponse::generated_message_descriptor_data());
            messages.push(SingleInputCountResponse::generated_message_descriptor_data());
            messages.push(GetInputCountRequest::generated_message_descriptor_data());
            messages.push(ListDatasetsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetRequest::generated_message_descriptor_data());
            messages.push(PostDatasetsRequest::generated_message_descriptor_data());
            messages.push(PatchDatasetsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetResponse::generated_message_descriptor_data());
            messages.push(ListDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetInputRequest::generated_message_descriptor_data());
            messages.push(PostDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetInputResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetInputResponse::generated_message_descriptor_data());
            messages.push(ListDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetVersionRequest::generated_message_descriptor_data());
            messages.push(ListDatasetVersionMetricsGroupsRequest::generated_message_descriptor_data());
            messages.push(PostDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(PutDatasetVersionExportsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionResponse::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionExportResponse::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionMetricsGroupResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetVersionResponse::generated_message_descriptor_data());
            messages.push(PostModelOutputsRequest::generated_message_descriptor_data());
            messages.push(ListModelInputsRequest::generated_message_descriptor_data());
            messages.push(GetKeyRequest::generated_message_descriptor_data());
            messages.push(ListKeysRequest::generated_message_descriptor_data());
            messages.push(ListAppKeysRequest::generated_message_descriptor_data());
            messages.push(PostKeysRequest::generated_message_descriptor_data());
            messages.push(DeleteKeyRequest::generated_message_descriptor_data());
            messages.push(PatchKeysRequest::generated_message_descriptor_data());
            messages.push(SingleKeyResponse::generated_message_descriptor_data());
            messages.push(MultiKeyResponse::generated_message_descriptor_data());
            messages.push(GetModelRequest::generated_message_descriptor_data());
            messages.push(ListModelsRequest::generated_message_descriptor_data());
            messages.push(GetResourceCountsRequest::generated_message_descriptor_data());
            messages.push(GetResourceCountsResponse::generated_message_descriptor_data());
            messages.push(PatchModelToolkitsRequest::generated_message_descriptor_data());
            messages.push(PatchModelCheckConsentsRequest::generated_message_descriptor_data());
            messages.push(PatchModelUseCasesRequest::generated_message_descriptor_data());
            messages.push(PatchModelLanguagesRequest::generated_message_descriptor_data());
            messages.push(MultiModelToolkitResponse::generated_message_descriptor_data());
            messages.push(MultiModelCheckConsentResponse::generated_message_descriptor_data());
            messages.push(MultiModelUseCaseResponse::generated_message_descriptor_data());
            messages.push(MultiModelLanguageResponse::generated_message_descriptor_data());
            messages.push(PostModelsRequest::generated_message_descriptor_data());
            messages.push(PatchModelsRequest::generated_message_descriptor_data());
            messages.push(IdUpdateSource::generated_message_descriptor_data());
            messages.push(PatchModelIdsRequest::generated_message_descriptor_data());
            messages.push(DeleteModelRequest::generated_message_descriptor_data());
            messages.push(DeleteModelsRequest::generated_message_descriptor_data());
            messages.push(PostModelsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleModelResponse::generated_message_descriptor_data());
            messages.push(MultiModelResponse::generated_message_descriptor_data());
            messages.push(PatchModelVersionsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteModelVersionRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionResponse::generated_message_descriptor_data());
            messages.push(MultiModelVersionResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowVersionsUnPublishRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowVersionsPublishRequest::generated_message_descriptor_data());
            messages.push(WorkflowVersionPublishRequest::generated_message_descriptor_data());
            messages.push(WorkflowVersionUnPublishRequest::generated_message_descriptor_data());
            messages.push(ModelVersionPublishRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsPublishRequest::generated_message_descriptor_data());
            messages.push(ModelVersionUnpublishRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsUnPublishRequest::generated_message_descriptor_data());
            messages.push(PostEvaluationsRequest::generated_message_descriptor_data());
            messages.push(ListEvaluationsRequest::generated_message_descriptor_data());
            messages.push(GetEvaluationRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionEvaluationsRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionEvaluationsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionEvaluationRequest::generated_message_descriptor_data());
            messages.push(SingleEvalMetricsResponse::generated_message_descriptor_data());
            messages.push(MultiEvalMetricsResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionMetricsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionMetricsRequest::generated_message_descriptor_data());
            messages.push(GetModelTypeRequest::generated_message_descriptor_data());
            messages.push(ListModelTypesRequest::generated_message_descriptor_data());
            messages.push(ListOpenSourceLicensesRequest::generated_message_descriptor_data());
            messages.push(ListOpenSourceLicensesResponse::generated_message_descriptor_data());
            messages.push(SingleModelTypeResponse::generated_message_descriptor_data());
            messages.push(MultiModelTypeResponse::generated_message_descriptor_data());
            messages.push(GetModelVersionInputExampleRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionInputExamplesRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionInputExampleResponse::generated_message_descriptor_data());
            messages.push(MultiModelVersionInputExampleResponse::generated_message_descriptor_data());
            messages.push(ListModelReferencesRequest::generated_message_descriptor_data());
            messages.push(MultiModelReferenceResponse::generated_message_descriptor_data());
            messages.push(MultiOutputResponse::generated_message_descriptor_data());
            messages.push(ListScopesRequest::generated_message_descriptor_data());
            messages.push(MyScopesRequest::generated_message_descriptor_data());
            messages.push(MyScopesUserRequest::generated_message_descriptor_data());
            messages.push(MyScopesRootRequest::generated_message_descriptor_data());
            messages.push(MultiScopeDepsResponse::generated_message_descriptor_data());
            messages.push(MultiScopeResponse::generated_message_descriptor_data());
            messages.push(MultiScopeUserResponse::generated_message_descriptor_data());
            messages.push(MultiScopeRootResponse::generated_message_descriptor_data());
            messages.push(GetSearchRequest::generated_message_descriptor_data());
            messages.push(ListSearchesRequest::generated_message_descriptor_data());
            messages.push(PostSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchInputsSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchSearchesRequest::generated_message_descriptor_data());
            messages.push(PostSearchesByIDRequest::generated_message_descriptor_data());
            messages.push(DeleteSearchRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationsSearchesRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(PostInputsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleSearchResponse::generated_message_descriptor_data());
            messages.push(MultiSearchResponse::generated_message_descriptor_data());
            messages.push(PostAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(GetAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(ListAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(MultiAnnotationSearchMetricsResponse::generated_message_descriptor_data());
            messages.push(ListAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(GetAnnotationFilterRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(MultiAnnotationFilterResponse::generated_message_descriptor_data());
            messages.push(SingleAnnotationFilterResponse::generated_message_descriptor_data());
            messages.push(GetUserRequest::generated_message_descriptor_data());
            messages.push(SingleUserResponse::generated_message_descriptor_data());
            messages.push(PostValidatePasswordRequest::generated_message_descriptor_data());
            messages.push(SinglePasswordValidationResponse::generated_message_descriptor_data());
            messages.push(GetWorkflowRequest::generated_message_descriptor_data());
            messages.push(ListWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowIdsRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowsRequest::generated_message_descriptor_data());
            messages.push(SingleWorkflowResponse::generated_message_descriptor_data());
            messages.push(MultiWorkflowResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsSimilarityRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsSimilarityResponse::generated_message_descriptor_data());
            messages.push(ListWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(GetWorkflowVersionRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(MultiWorkflowVersionResponse::generated_message_descriptor_data());
            messages.push(SingleWorkflowVersionResponse::generated_message_descriptor_data());
            messages.push(PostAppDuplicationsRequest::generated_message_descriptor_data());
            messages.push(GetAppDuplicationRequest::generated_message_descriptor_data());
            messages.push(ListAppDuplicationsRequest::generated_message_descriptor_data());
            messages.push(MultiAppDuplicationsResponse::generated_message_descriptor_data());
            messages.push(SingleAppDuplicationResponse::generated_message_descriptor_data());
            messages.push(PostTasksRequest::generated_message_descriptor_data());
            messages.push(GetTaskRequest::generated_message_descriptor_data());
            messages.push(ListTasksRequest::generated_message_descriptor_data());
            messages.push(PatchTasksRequest::generated_message_descriptor_data());
            messages.push(DeleteTasksRequest::generated_message_descriptor_data());
            messages.push(MultiTaskResponse::generated_message_descriptor_data());
            messages.push(SingleTaskResponse::generated_message_descriptor_data());
            messages.push(GetTaskCountRequest::generated_message_descriptor_data());
            messages.push(SingleTaskCountResponse::generated_message_descriptor_data());
            messages.push(PostLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(GetLabelOrderRequest::generated_message_descriptor_data());
            messages.push(ListLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(PatchLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(DeleteLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(MultiLabelOrderResponse::generated_message_descriptor_data());
            messages.push(SingleLabelOrderResponse::generated_message_descriptor_data());
            messages.push(PostCollectorsRequest::generated_message_descriptor_data());
            messages.push(PatchCollectorsRequest::generated_message_descriptor_data());
            messages.push(DeleteCollectorsRequest::generated_message_descriptor_data());
            messages.push(GetCollectorRequest::generated_message_descriptor_data());
            messages.push(ListCollectorsRequest::generated_message_descriptor_data());
            messages.push(MultiCollectorResponse::generated_message_descriptor_data());
            messages.push(SingleCollectorResponse::generated_message_descriptor_data());
            messages.push(PostStatValuesRequest::generated_message_descriptor_data());
            messages.push(MultiStatValueResponse::generated_message_descriptor_data());
            messages.push(PostStatValuesAggregateRequest::generated_message_descriptor_data());
            messages.push(MultiStatValueAggregateResponse::generated_message_descriptor_data());
            messages.push(PostTrendingMetricsViewRequest::generated_message_descriptor_data());
            messages.push(ListTrendingMetricsViewsRequest::generated_message_descriptor_data());
            messages.push(MultiTrendingMetricsViewResponse::generated_message_descriptor_data());
            messages.push(GetModuleRequest::generated_message_descriptor_data());
            messages.push(ListModulesRequest::generated_message_descriptor_data());
            messages.push(PostModulesRequest::generated_message_descriptor_data());
            messages.push(PatchModulesRequest::generated_message_descriptor_data());
            messages.push(DeleteModulesRequest::generated_message_descriptor_data());
            messages.push(SingleModuleResponse::generated_message_descriptor_data());
            messages.push(MultiModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleVersionRequest::generated_message_descriptor_data());
            messages.push(ListModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(GetModuleVersionUsageCountRequest::generated_message_descriptor_data());
            messages.push(SingleModuleVersionResponse::generated_message_descriptor_data());
            messages.push(MultiModuleVersionResponse::generated_message_descriptor_data());
            messages.push(SingleModuleVersionUsageCountResponse::generated_message_descriptor_data());
            messages.push(GetInstalledModuleVersionRequest::generated_message_descriptor_data());
            messages.push(ListInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostInstalledModuleVersionsKeyRequest::generated_message_descriptor_data());
            messages.push(DeleteInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(SingleInstalledModuleVersionResponse::generated_message_descriptor_data());
            messages.push(MultiInstalledModuleVersionResponse::generated_message_descriptor_data());
            messages.push(ListNextTaskAssignmentsRequest::generated_message_descriptor_data());
            messages.push(PostBulkOperationsRequest::generated_message_descriptor_data());
            messages.push(ListBulkOperationsRequest::generated_message_descriptor_data());
            messages.push(GetBulkOperationRequest::generated_message_descriptor_data());
            messages.push(CancelBulkOperationRequest::generated_message_descriptor_data());
            messages.push(DeleteBulkOperationRequest::generated_message_descriptor_data());
            messages.push(SingleBulkOperationsResponse::generated_message_descriptor_data());
            messages.push(MultiBulkOperationsResponse::generated_message_descriptor_data());
            messages.push(PutTaskAssignmentsRequest::generated_message_descriptor_data());
            messages.push(ListInputsAddJobsRequest::generated_message_descriptor_data());
            messages.push(GetInputsAddJobRequest::generated_message_descriptor_data());
            messages.push(CancelInputsAddJobRequest::generated_message_descriptor_data());
            messages.push(MultiInputsAddJobResponse::generated_message_descriptor_data());
            messages.push(SingleInputsAddJobResponse::generated_message_descriptor_data());
            messages.push(PostUploadsRequest::generated_message_descriptor_data());
            messages.push(DeleteUploadsRequest::generated_message_descriptor_data());
            messages.push(ListUploadsRequest::generated_message_descriptor_data());
            messages.push(GetUploadRequest::generated_message_descriptor_data());
            messages.push(SingleUploadResponse::generated_message_descriptor_data());
            messages.push(MultiUploadResponse::generated_message_descriptor_data());
            messages.push(PutUploadContentPartsRequest::generated_message_descriptor_data());
            messages.push(PostInputsDataSourcesRequest::generated_message_descriptor_data());
            messages.push(GetInputsExtractionJobRequest::generated_message_descriptor_data());
            messages.push(ListInputsExtractionJobsRequest::generated_message_descriptor_data());
            messages.push(SingleInputsExtractionJobResponse::generated_message_descriptor_data());
            messages.push(MultiInputsExtractionJobResponse::generated_message_descriptor_data());
            messages.push(CancelInputsExtractionJobsRequest::generated_message_descriptor_data());
            messages.push(PostInputsUploadsRequest::generated_message_descriptor_data());
            messages.push(GetRunnerRequest::generated_message_descriptor_data());
            messages.push(ListRunnersRequest::generated_message_descriptor_data());
            messages.push(PostRunnersRequest::generated_message_descriptor_data());
            messages.push(DeleteRunnersRequest::generated_message_descriptor_data());
            messages.push(SingleRunnerResponse::generated_message_descriptor_data());
            messages.push(MultiRunnerResponse::generated_message_descriptor_data());
            messages.push(ListRunnerItemsRequest::generated_message_descriptor_data());
            messages.push(PostRunnerItemOutputsRequest::generated_message_descriptor_data());
            messages.push(MultiRunnerItemResponse::generated_message_descriptor_data());
            messages.push(RunnerItem::generated_message_descriptor_data());
            messages.push(RunnerItemOutput::generated_message_descriptor_data());
            messages.push(MultiRunnerItemOutputResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionsTrainingTimeEstimateRequest::generated_message_descriptor_data());
            messages.push(MultiTrainingTimeEstimateResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(OrganizationInvitationStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
