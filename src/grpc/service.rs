// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/clarifai/api/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct Pagination {
    // message fields
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    // uint32 page = 1;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 2;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for Pagination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page != 0 {
            os.write_uint32(1, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &Pagination| { &m.page },
                |m: &mut Pagination| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &Pagination| { &m.per_page },
                |m: &mut Pagination| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pagination>(
                "Pagination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pagination {
        static instance: ::protobuf::rt::LazyV2<Pagination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pagination::new)
    }
}

impl ::protobuf::Clear for Pagination {
    fn clear(&mut self) {
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAnnotationRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub annotation_id: ::std::string::String,
    pub input_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAnnotationRequest {
    fn default() -> &'a GetAnnotationRequest {
        <GetAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationRequest {
    pub fn new() -> GetAnnotationRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string annotation_id = 2;


    pub fn get_annotation_id(&self) -> &str {
        &self.annotation_id
    }
    pub fn clear_annotation_id(&mut self) {
        self.annotation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_id(&mut self, v: ::std::string::String) {
        self.annotation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation_id(&mut self) -> &mut ::std::string::String {
        &mut self.annotation_id
    }

    // Take field
    pub fn take_annotation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.annotation_id, ::std::string::String::new())
    }

    // string input_id = 3;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAnnotationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.annotation_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(2, &self.annotation_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAnnotationRequest {
        GetAnnotationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAnnotationRequest| { &m.user_app_id },
                |m: &mut GetAnnotationRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotation_id",
                |m: &GetAnnotationRequest| { &m.annotation_id },
                |m: &mut GetAnnotationRequest| { &mut m.annotation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &GetAnnotationRequest| { &m.input_id },
                |m: &mut GetAnnotationRequest| { &mut m.input_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAnnotationRequest>(
                "GetAnnotationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAnnotationRequest {
        static instance: ::protobuf::rt::LazyV2<GetAnnotationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAnnotationRequest::new)
    }
}

impl ::protobuf::Clear for GetAnnotationRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_id.clear();
        self.input_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub input_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub model_version_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub statuses: ::protobuf::RepeatedField<super::status::Status>,
    pub list_all_annotations: bool,
    pub page: u32,
    pub per_page: u32,
    pub task_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAnnotationsRequest {
    fn default() -> &'a ListAnnotationsRequest {
        <ListAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationsRequest {
    pub fn new() -> ListAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // repeated string input_ids = 3;


    pub fn get_input_ids(&self) -> &[::std::string::String] {
        &self.input_ids
    }
    pub fn clear_input_ids(&mut self) {
        self.input_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input_ids
    }

    // Take field
    pub fn take_input_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string user_ids = 9;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string model_version_ids = 10;


    pub fn get_model_version_ids(&self) -> &[::std::string::String] {
        &self.model_version_ids
    }
    pub fn clear_model_version_ids(&mut self) {
        self.model_version_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.model_version_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_version_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.model_version_ids
    }

    // Take field
    pub fn take_model_version_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.model_version_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.status.Status statuses = 5;


    pub fn get_statuses(&self) -> &[super::status::Status] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<super::status::Status>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<super::status::Status> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<super::status::Status> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }

    // bool list_all_annotations = 6;


    pub fn get_list_all_annotations(&self) -> bool {
        self.list_all_annotations
    }
    pub fn clear_list_all_annotations(&mut self) {
        self.list_all_annotations = false;
    }

    // Param is passed by value, moved
    pub fn set_list_all_annotations(&mut self, v: bool) {
        self.list_all_annotations = v;
    }

    // uint32 page = 7;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 8;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // string task_id = 11;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.model_version_ids)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.list_all_annotations = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.model_version_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.list_all_annotations != false {
            my_size += 2;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(7, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(8, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.user_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.model_version_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.statuses {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.list_all_annotations != false {
            os.write_bool(6, self.list_all_annotations)?;
        }
        if self.page != 0 {
            os.write_uint32(7, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(8, self.per_page)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(11, &self.task_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAnnotationsRequest {
        ListAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAnnotationsRequest| { &m.user_app_id },
                |m: &mut ListAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &ListAnnotationsRequest| { &m.ids },
                |m: &mut ListAnnotationsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_ids",
                |m: &ListAnnotationsRequest| { &m.input_ids },
                |m: &mut ListAnnotationsRequest| { &mut m.input_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &ListAnnotationsRequest| { &m.user_ids },
                |m: &mut ListAnnotationsRequest| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_ids",
                |m: &ListAnnotationsRequest| { &m.model_version_ids },
                |m: &mut ListAnnotationsRequest| { &mut m.model_version_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "statuses",
                |m: &ListAnnotationsRequest| { &m.statuses },
                |m: &mut ListAnnotationsRequest| { &mut m.statuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "list_all_annotations",
                |m: &ListAnnotationsRequest| { &m.list_all_annotations },
                |m: &mut ListAnnotationsRequest| { &mut m.list_all_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAnnotationsRequest| { &m.page },
                |m: &mut ListAnnotationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAnnotationsRequest| { &m.per_page },
                |m: &mut ListAnnotationsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &ListAnnotationsRequest| { &m.task_id },
                |m: &mut ListAnnotationsRequest| { &mut m.task_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAnnotationsRequest>(
                "ListAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for ListAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.user_ids.clear();
        self.model_version_ids.clear();
        self.statuses.clear();
        self.list_all_annotations = false;
        self.page = 0;
        self.per_page = 0;
        self.task_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub annotations: ::protobuf::RepeatedField<super::resources::Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsRequest {
    fn default() -> &'a PostAnnotationsRequest {
        <PostAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsRequest {
    pub fn new() -> PostAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[super::resources::Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<super::resources::Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<super::resources::Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAnnotationsRequest {
        PostAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAnnotationsRequest| { &m.user_app_id },
                |m: &mut PostAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotations",
                |m: &PostAnnotationsRequest| { &m.annotations },
                |m: &mut PostAnnotationsRequest| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAnnotationsRequest>(
                "PostAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for PostAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub annotations: ::protobuf::RepeatedField<super::resources::Annotation>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsRequest {
    fn default() -> &'a PatchAnnotationsRequest {
        <PatchAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsRequest {
    pub fn new() -> PatchAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[super::resources::Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<super::resources::Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<super::resources::Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsRequest {
        PatchAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAnnotationsRequest| { &m.user_app_id },
                |m: &mut PatchAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotations",
                |m: &PatchAnnotationsRequest| { &m.annotations },
                |m: &mut PatchAnnotationsRequest| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAnnotationsRequest| { &m.action },
                |m: &mut PatchAnnotationsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsRequest>(
                "PatchAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsStatusRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub status_code: super::status_code::StatusCode,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub task_id: ::std::string::String,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusRequest {
    fn default() -> &'a PatchAnnotationsStatusRequest {
        <PatchAnnotationsStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusRequest {
    pub fn new() -> PatchAnnotationsStatusRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.status.StatusCode status_code = 2;


    pub fn get_status_code(&self) -> super::status_code::StatusCode {
        self.status_code
    }
    pub fn clear_status_code(&mut self) {
        self.status_code = super::status_code::StatusCode::ZERO;
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: super::status_code::StatusCode) {
        self.status_code = v;
    }

    // repeated string user_ids = 3;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // string task_id = 4;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // string action = 5;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.status_code != super::status_code::StatusCode::ZERO {
            my_size += ::protobuf::rt::enum_size(2, self.status_code);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.task_id);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.status_code != super::status_code::StatusCode::ZERO {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.status_code))?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        if !self.task_id.is_empty() {
            os.write_string(4, &self.task_id)?;
        }
        if !self.action.is_empty() {
            os.write_string(5, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsStatusRequest {
        PatchAnnotationsStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAnnotationsStatusRequest| { &m.user_app_id },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::status_code::StatusCode>>(
                "status_code",
                |m: &PatchAnnotationsStatusRequest| { &m.status_code },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &PatchAnnotationsStatusRequest| { &m.user_ids },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &PatchAnnotationsStatusRequest| { &m.task_id },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAnnotationsStatusRequest| { &m.action },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsStatusRequest>(
                "PatchAnnotationsStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsStatusRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsStatusRequest::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsStatusRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.status_code = super::status_code::StatusCode::ZERO;
        self.user_ids.clear();
        self.task_id.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsStatusResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub updated_count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusResponse {
    fn default() -> &'a PatchAnnotationsStatusResponse {
        <PatchAnnotationsStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusResponse {
    pub fn new() -> PatchAnnotationsStatusResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string user_ids = 2;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // uint32 updated_count = 3;


    pub fn get_updated_count(&self) -> u32 {
        self.updated_count
    }
    pub fn clear_updated_count(&mut self) {
        self.updated_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_count(&mut self, v: u32) {
        self.updated_count = v;
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.updated_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.updated_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.updated_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if self.updated_count != 0 {
            os.write_uint32(3, self.updated_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsStatusResponse {
        PatchAnnotationsStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &PatchAnnotationsStatusResponse| { &m.status },
                |m: &mut PatchAnnotationsStatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &PatchAnnotationsStatusResponse| { &m.user_ids },
                |m: &mut PatchAnnotationsStatusResponse| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "updated_count",
                |m: &PatchAnnotationsStatusResponse| { &m.updated_count },
                |m: &mut PatchAnnotationsStatusResponse| { &mut m.updated_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsStatusResponse>(
                "PatchAnnotationsStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsStatusResponse {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsStatusResponse::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsStatusResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.user_ids.clear();
        self.updated_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAnnotationRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub input_id: ::std::string::String,
    pub annotation_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationRequest {
    fn default() -> &'a DeleteAnnotationRequest {
        <DeleteAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationRequest {
    pub fn new() -> DeleteAnnotationRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }

    // string annotation_id = 3;


    pub fn get_annotation_id(&self) -> &str {
        &self.annotation_id
    }
    pub fn clear_annotation_id(&mut self) {
        self.annotation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_id(&mut self, v: ::std::string::String) {
        self.annotation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation_id(&mut self) -> &mut ::std::string::String {
        &mut self.annotation_id
    }

    // Take field
    pub fn take_annotation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.annotation_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteAnnotationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.annotation_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.annotation_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(3, &self.annotation_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAnnotationRequest {
        DeleteAnnotationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAnnotationRequest| { &m.user_app_id },
                |m: &mut DeleteAnnotationRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &DeleteAnnotationRequest| { &m.input_id },
                |m: &mut DeleteAnnotationRequest| { &mut m.input_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotation_id",
                |m: &DeleteAnnotationRequest| { &m.annotation_id },
                |m: &mut DeleteAnnotationRequest| { &mut m.annotation_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAnnotationRequest>(
                "DeleteAnnotationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAnnotationRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAnnotationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAnnotationRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAnnotationRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.annotation_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub input_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationsRequest {
    fn default() -> &'a DeleteAnnotationsRequest {
        <DeleteAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationsRequest {
    pub fn new() -> DeleteAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // repeated string input_ids = 3;


    pub fn get_input_ids(&self) -> &[::std::string::String] {
        &self.input_ids
    }
    pub fn clear_input_ids(&mut self) {
        self.input_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input_ids
    }

    // Take field
    pub fn take_input_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAnnotationsRequest {
        DeleteAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAnnotationsRequest| { &m.user_app_id },
                |m: &mut DeleteAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteAnnotationsRequest| { &m.ids },
                |m: &mut DeleteAnnotationsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_ids",
                |m: &DeleteAnnotationsRequest| { &m.input_ids },
                |m: &mut DeleteAnnotationsRequest| { &mut m.input_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAnnotationsRequest>(
                "DeleteAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleAnnotationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub annotation: ::protobuf::SingularPtrField<super::resources::Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationResponse {
    fn default() -> &'a SingleAnnotationResponse {
        <SingleAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationResponse {
    pub fn new() -> SingleAnnotationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Annotation annotation = 2;


    pub fn get_annotation(&self) -> &super::resources::Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <super::resources::Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: super::resources::Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut super::resources::Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> super::resources::Annotation {
        self.annotation.take().unwrap_or_else(|| super::resources::Annotation::new())
    }
}

impl ::protobuf::Message for SingleAnnotationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleAnnotationResponse {
        SingleAnnotationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleAnnotationResponse| { &m.status },
                |m: &mut SingleAnnotationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotation",
                |m: &SingleAnnotationResponse| { &m.annotation },
                |m: &mut SingleAnnotationResponse| { &mut m.annotation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleAnnotationResponse>(
                "SingleAnnotationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleAnnotationResponse {
        static instance: ::protobuf::rt::LazyV2<SingleAnnotationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleAnnotationResponse::new)
    }
}

impl ::protobuf::Clear for SingleAnnotationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAnnotationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub annotations: ::protobuf::RepeatedField<super::resources::Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationResponse {
    fn default() -> &'a MultiAnnotationResponse {
        <MultiAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationResponse {
    pub fn new() -> MultiAnnotationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[super::resources::Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<super::resources::Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<super::resources::Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAnnotationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAnnotationResponse {
        MultiAnnotationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAnnotationResponse| { &m.status },
                |m: &mut MultiAnnotationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotations",
                |m: &MultiAnnotationResponse| { &m.annotations },
                |m: &mut MultiAnnotationResponse| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAnnotationResponse>(
                "MultiAnnotationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAnnotationResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAnnotationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAnnotationResponse::new)
    }
}

impl ::protobuf::Clear for MultiAnnotationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAppRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAppRequest {
    fn default() -> &'a GetAppRequest {
        <GetAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppRequest {
    pub fn new() -> GetAppRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for GetAppRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAppRequest {
        GetAppRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAppRequest| { &m.user_app_id },
                |m: &mut GetAppRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAppRequest>(
                "GetAppRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAppRequest {
        static instance: ::protobuf::rt::LazyV2<GetAppRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAppRequest::new)
    }
}

impl ::protobuf::Clear for GetAppRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAppsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAppsRequest {
    fn default() -> &'a ListAppsRequest {
        <ListAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppsRequest {
    pub fn new() -> ListAppsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAppsRequest {
        ListAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAppsRequest| { &m.user_app_id },
                |m: &mut ListAppsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAppsRequest| { &m.page },
                |m: &mut ListAppsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAppsRequest| { &m.per_page },
                |m: &mut ListAppsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAppsRequest>(
                "ListAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAppsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAppsRequest::new)
    }
}

impl ::protobuf::Clear for ListAppsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAppsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub apps: ::protobuf::RepeatedField<super::resources::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAppsRequest {
    fn default() -> &'a PostAppsRequest {
        <PostAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsRequest {
    pub fn new() -> PostAppsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.App apps = 2;


    pub fn get_apps(&self) -> &[super::resources::App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<super::resources::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<super::resources::App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAppsRequest {
        PostAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAppsRequest| { &m.user_app_id },
                |m: &mut PostAppsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "apps",
                |m: &PostAppsRequest| { &m.apps },
                |m: &mut PostAppsRequest| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAppsRequest>(
                "PostAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAppsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAppsRequest::new)
    }
}

impl ::protobuf::Clear for PostAppsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAppRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAppRequest {
    fn default() -> &'a DeleteAppRequest {
        <DeleteAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAppRequest {
    pub fn new() -> DeleteAppRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for DeleteAppRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAppRequest {
        DeleteAppRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAppRequest| { &m.user_app_id },
                |m: &mut DeleteAppRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAppRequest>(
                "DeleteAppRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAppRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAppRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAppRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAppRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAppRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAppsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub apps: ::protobuf::RepeatedField<super::resources::App>,
    pub action: ::std::string::String,
    pub metadata_action: ::protobuf::SingularPtrField<super::resources::PatchAction>,
    pub reindex: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAppsRequest {
    fn default() -> &'a PatchAppsRequest {
        <PatchAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsRequest {
    pub fn new() -> PatchAppsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.App apps = 2;


    pub fn get_apps(&self) -> &[super::resources::App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<super::resources::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<super::resources::App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }

    // .clarifai.api.PatchAction metadata_action = 4;


    pub fn get_metadata_action(&self) -> &super::resources::PatchAction {
        self.metadata_action.as_ref().unwrap_or_else(|| <super::resources::PatchAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_action(&mut self) {
        self.metadata_action.clear();
    }

    pub fn has_metadata_action(&self) -> bool {
        self.metadata_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_action(&mut self, v: super::resources::PatchAction) {
        self.metadata_action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_action(&mut self) -> &mut super::resources::PatchAction {
        if self.metadata_action.is_none() {
            self.metadata_action.set_default();
        }
        self.metadata_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_action(&mut self) -> super::resources::PatchAction {
        self.metadata_action.take().unwrap_or_else(|| super::resources::PatchAction::new())
    }

    // bool reindex = 5;


    pub fn get_reindex(&self) -> bool {
        self.reindex
    }
    pub fn clear_reindex(&mut self) {
        self.reindex = false;
    }

    // Param is passed by value, moved
    pub fn set_reindex(&mut self, v: bool) {
        self.reindex = v;
    }
}

impl ::protobuf::Message for PatchAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata_action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_action)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reindex = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(ref v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.reindex != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(ref v) = self.metadata_action.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAppsRequest {
        PatchAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAppsRequest| { &m.user_app_id },
                |m: &mut PatchAppsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "apps",
                |m: &PatchAppsRequest| { &m.apps },
                |m: &mut PatchAppsRequest| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAppsRequest| { &m.action },
                |m: &mut PatchAppsRequest| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::PatchAction>>(
                "metadata_action",
                |m: &PatchAppsRequest| { &m.metadata_action },
                |m: &mut PatchAppsRequest| { &mut m.metadata_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reindex",
                |m: &PatchAppsRequest| { &m.reindex },
                |m: &mut PatchAppsRequest| { &mut m.reindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAppsRequest>(
                "PatchAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAppsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAppsRequest::new)
    }
}

impl ::protobuf::Clear for PatchAppsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAppsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub app_query: ::protobuf::SingularPtrField<super::resources::AppQuery>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAppsSearchesRequest {
    fn default() -> &'a PostAppsSearchesRequest {
        <PostAppsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsSearchesRequest {
    pub fn new() -> PostAppsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.AppQuery app_query = 2;


    pub fn get_app_query(&self) -> &super::resources::AppQuery {
        self.app_query.as_ref().unwrap_or_else(|| <super::resources::AppQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app_query(&mut self) {
        self.app_query.clear();
    }

    pub fn has_app_query(&self) -> bool {
        self.app_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_query(&mut self, v: super::resources::AppQuery) {
        self.app_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_query(&mut self) -> &mut super::resources::AppQuery {
        if self.app_query.is_none() {
            self.app_query.set_default();
        }
        self.app_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_query(&mut self) -> super::resources::AppQuery {
        self.app_query.take().unwrap_or_else(|| super::resources::AppQuery::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostAppsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAppsSearchesRequest {
        PostAppsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAppsSearchesRequest| { &m.user_app_id },
                |m: &mut PostAppsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppQuery>>(
                "app_query",
                |m: &PostAppsSearchesRequest| { &m.app_query },
                |m: &mut PostAppsSearchesRequest| { &mut m.app_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostAppsSearchesRequest| { &m.pagination },
                |m: &mut PostAppsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAppsSearchesRequest>(
                "PostAppsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAppsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostAppsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAppsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostAppsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_query.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAppsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleAppResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app: ::protobuf::SingularPtrField<super::resources::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleAppResponse {
    fn default() -> &'a SingleAppResponse {
        <SingleAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppResponse {
    pub fn new() -> SingleAppResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.App app = 2;


    pub fn get_app(&self) -> &super::resources::App {
        self.app.as_ref().unwrap_or_else(|| <super::resources::App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: super::resources::App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut super::resources::App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> super::resources::App {
        self.app.take().unwrap_or_else(|| super::resources::App::new())
    }
}

impl ::protobuf::Message for SingleAppResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleAppResponse {
        SingleAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleAppResponse| { &m.status },
                |m: &mut SingleAppResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "app",
                |m: &SingleAppResponse| { &m.app },
                |m: &mut SingleAppResponse| { &mut m.app },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleAppResponse>(
                "SingleAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleAppResponse {
        static instance: ::protobuf::rt::LazyV2<SingleAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleAppResponse::new)
    }
}

impl ::protobuf::Clear for SingleAppResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAppResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub apps: ::protobuf::RepeatedField<super::resources::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAppResponse {
    fn default() -> &'a MultiAppResponse {
        <MultiAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppResponse {
    pub fn new() -> MultiAppResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.App apps = 2;


    pub fn get_apps(&self) -> &[super::resources::App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<super::resources::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<super::resources::App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAppResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAppResponse {
        MultiAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAppResponse| { &m.status },
                |m: &mut MultiAppResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "apps",
                |m: &MultiAppResponse| { &m.apps },
                |m: &mut MultiAppResponse| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAppResponse>(
                "MultiAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAppResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAppResponse::new)
    }
}

impl ::protobuf::Clear for MultiAppResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub list_all_collaborators: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCollaboratorsRequest {
    fn default() -> &'a ListCollaboratorsRequest {
        <ListCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaboratorsRequest {
    pub fn new() -> ListCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // bool list_all_collaborators = 2;


    pub fn get_list_all_collaborators(&self) -> bool {
        self.list_all_collaborators
    }
    pub fn clear_list_all_collaborators(&mut self) {
        self.list_all_collaborators = false;
    }

    // Param is passed by value, moved
    pub fn set_list_all_collaborators(&mut self, v: bool) {
        self.list_all_collaborators = v;
    }
}

impl ::protobuf::Message for ListCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.list_all_collaborators = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.list_all_collaborators != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.list_all_collaborators != false {
            os.write_bool(2, self.list_all_collaborators)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollaboratorsRequest {
        ListCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListCollaboratorsRequest| { &m.user_app_id },
                |m: &mut ListCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "list_all_collaborators",
                |m: &ListCollaboratorsRequest| { &m.list_all_collaborators },
                |m: &mut ListCollaboratorsRequest| { &mut m.list_all_collaborators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCollaboratorsRequest>(
                "ListCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<ListCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for ListCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.list_all_collaborators = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collaborators: ::protobuf::RepeatedField<super::resources::Collaborator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostCollaboratorsRequest {
    fn default() -> &'a PostCollaboratorsRequest {
        <PostCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollaboratorsRequest {
    pub fn new() -> PostCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collaborator collaborators = 2;


    pub fn get_collaborators(&self) -> &[super::resources::Collaborator] {
        &self.collaborators
    }
    pub fn clear_collaborators(&mut self) {
        self.collaborators.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborators(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaborator>) {
        self.collaborators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborators(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaborator> {
        &mut self.collaborators
    }

    // Take field
    pub fn take_collaborators(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaborator> {
        ::std::mem::replace(&mut self.collaborators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostCollaboratorsRequest {
        PostCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostCollaboratorsRequest| { &m.user_app_id },
                |m: &mut PostCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaborator>>(
                "collaborators",
                |m: &PostCollaboratorsRequest| { &m.collaborators },
                |m: &mut PostCollaboratorsRequest| { &mut m.collaborators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostCollaboratorsRequest>(
                "PostCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<PostCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for PostCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collaborators: ::protobuf::RepeatedField<super::resources::Collaborator>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchCollaboratorsRequest {
    fn default() -> &'a PatchCollaboratorsRequest {
        <PatchCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollaboratorsRequest {
    pub fn new() -> PatchCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collaborator collaborators = 2;


    pub fn get_collaborators(&self) -> &[super::resources::Collaborator] {
        &self.collaborators
    }
    pub fn clear_collaborators(&mut self) {
        self.collaborators.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborators(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaborator>) {
        self.collaborators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborators(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaborator> {
        &mut self.collaborators
    }

    // Take field
    pub fn take_collaborators(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaborator> {
        ::std::mem::replace(&mut self.collaborators, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborators)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchCollaboratorsRequest {
        PatchCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchCollaboratorsRequest| { &m.user_app_id },
                |m: &mut PatchCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaborator>>(
                "collaborators",
                |m: &PatchCollaboratorsRequest| { &m.collaborators },
                |m: &mut PatchCollaboratorsRequest| { &mut m.collaborators },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchCollaboratorsRequest| { &m.action },
                |m: &mut PatchCollaboratorsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchCollaboratorsRequest>(
                "PatchCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for PatchCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collaborator_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub user_emails: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteCollaboratorsRequest {
    fn default() -> &'a DeleteCollaboratorsRequest {
        <DeleteCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollaboratorsRequest {
    pub fn new() -> DeleteCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string collaborator_ids = 2;


    pub fn get_collaborator_ids(&self) -> &[::std::string::String] {
        &self.collaborator_ids
    }
    pub fn clear_collaborator_ids(&mut self) {
        self.collaborator_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborator_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.collaborator_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborator_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.collaborator_ids
    }

    // Take field
    pub fn take_collaborator_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.collaborator_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string user_emails = 3;


    pub fn get_user_emails(&self) -> &[::std::string::String] {
        &self.user_emails
    }
    pub fn clear_user_emails(&mut self) {
        self.user_emails.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_emails(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_emails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_emails(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_emails
    }

    // Take field
    pub fn take_user_emails(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_emails, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.collaborator_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_emails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborator_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.user_emails {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborator_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.user_emails {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteCollaboratorsRequest {
        DeleteCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteCollaboratorsRequest| { &m.user_app_id },
                |m: &mut DeleteCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "collaborator_ids",
                |m: &DeleteCollaboratorsRequest| { &m.collaborator_ids },
                |m: &mut DeleteCollaboratorsRequest| { &mut m.collaborator_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_emails",
                |m: &DeleteCollaboratorsRequest| { &m.user_emails },
                |m: &mut DeleteCollaboratorsRequest| { &mut m.user_emails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteCollaboratorsRequest>(
                "DeleteCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborator_ids.clear();
        self.user_emails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiCollaboratorsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collaborators: ::protobuf::RepeatedField<super::resources::Collaborator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiCollaboratorsResponse {
    fn default() -> &'a MultiCollaboratorsResponse {
        <MultiCollaboratorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaboratorsResponse {
    pub fn new() -> MultiCollaboratorsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Collaborator collaborators = 2;


    pub fn get_collaborators(&self) -> &[super::resources::Collaborator] {
        &self.collaborators
    }
    pub fn clear_collaborators(&mut self) {
        self.collaborators.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborators(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaborator>) {
        self.collaborators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborators(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaborator> {
        &mut self.collaborators
    }

    // Take field
    pub fn take_collaborators(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaborator> {
        ::std::mem::replace(&mut self.collaborators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiCollaboratorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiCollaboratorsResponse {
        MultiCollaboratorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiCollaboratorsResponse| { &m.status },
                |m: &mut MultiCollaboratorsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaborator>>(
                "collaborators",
                |m: &MultiCollaboratorsResponse| { &m.collaborators },
                |m: &mut MultiCollaboratorsResponse| { &mut m.collaborators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiCollaboratorsResponse>(
                "MultiCollaboratorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiCollaboratorsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiCollaboratorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiCollaboratorsResponse::new)
    }
}

impl ::protobuf::Clear for MultiCollaboratorsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collaborators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiCollaboratorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaboratorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollaborationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCollaborationsRequest {
    fn default() -> &'a ListCollaborationsRequest {
        <ListCollaborationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaborationsRequest {
    pub fn new() -> ListCollaborationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListCollaborationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollaborationsRequest {
        ListCollaborationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListCollaborationsRequest| { &m.user_app_id },
                |m: &mut ListCollaborationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListCollaborationsRequest| { &m.page },
                |m: &mut ListCollaborationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListCollaborationsRequest| { &m.per_page },
                |m: &mut ListCollaborationsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCollaborationsRequest>(
                "ListCollaborationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCollaborationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListCollaborationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCollaborationsRequest::new)
    }
}

impl ::protobuf::Clear for ListCollaborationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollaborationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaborationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiCollaborationsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collaborations: ::protobuf::RepeatedField<super::resources::Collaboration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiCollaborationsResponse {
    fn default() -> &'a MultiCollaborationsResponse {
        <MultiCollaborationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaborationsResponse {
    pub fn new() -> MultiCollaborationsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Collaboration collaborations = 2;


    pub fn get_collaborations(&self) -> &[super::resources::Collaboration] {
        &self.collaborations
    }
    pub fn clear_collaborations(&mut self) {
        self.collaborations.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborations(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaboration>) {
        self.collaborations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaboration> {
        &mut self.collaborations
    }

    // Take field
    pub fn take_collaborations(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaboration> {
        ::std::mem::replace(&mut self.collaborations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiCollaborationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiCollaborationsResponse {
        MultiCollaborationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiCollaborationsResponse| { &m.status },
                |m: &mut MultiCollaborationsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaboration>>(
                "collaborations",
                |m: &MultiCollaborationsResponse| { &m.collaborations },
                |m: &mut MultiCollaborationsResponse| { &mut m.collaborations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiCollaborationsResponse>(
                "MultiCollaborationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiCollaborationsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiCollaborationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiCollaborationsResponse::new)
    }
}

impl ::protobuf::Clear for MultiCollaborationsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collaborations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiCollaborationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaborationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStatusCodeRequest {
    // message fields
    pub status_code_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStatusCodeRequest {
    fn default() -> &'a GetStatusCodeRequest {
        <GetStatusCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusCodeRequest {
    pub fn new() -> GetStatusCodeRequest {
        ::std::default::Default::default()
    }

    // string status_code_id = 1;


    pub fn get_status_code_id(&self) -> &str {
        &self.status_code_id
    }
    pub fn clear_status_code_id(&mut self) {
        self.status_code_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_code_id(&mut self, v: ::std::string::String) {
        self.status_code_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_code_id(&mut self) -> &mut ::std::string::String {
        &mut self.status_code_id
    }

    // Take field
    pub fn take_status_code_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_code_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetStatusCodeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_code_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status_code_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status_code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status_code_id.is_empty() {
            os.write_string(1, &self.status_code_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStatusCodeRequest {
        GetStatusCodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_code_id",
                |m: &GetStatusCodeRequest| { &m.status_code_id },
                |m: &mut GetStatusCodeRequest| { &mut m.status_code_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStatusCodeRequest>(
                "GetStatusCodeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStatusCodeRequest {
        static instance: ::protobuf::rt::LazyV2<GetStatusCodeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStatusCodeRequest::new)
    }
}

impl ::protobuf::Clear for GetStatusCodeRequest {
    fn clear(&mut self) {
        self.status_code_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStatusCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusCodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStatusCodesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListStatusCodesRequest {
    fn default() -> &'a ListStatusCodesRequest {
        <ListStatusCodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStatusCodesRequest {
    pub fn new() -> ListStatusCodesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListStatusCodesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStatusCodesRequest {
        ListStatusCodesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListStatusCodesRequest>(
                "ListStatusCodesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListStatusCodesRequest {
        static instance: ::protobuf::rt::LazyV2<ListStatusCodesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListStatusCodesRequest::new)
    }
}

impl ::protobuf::Clear for ListStatusCodesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStatusCodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCodesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleStatusCodeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleStatusCodeResponse {
    fn default() -> &'a SingleStatusCodeResponse {
        <SingleStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleStatusCodeResponse {
    pub fn new() -> SingleStatusCodeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }
}

impl ::protobuf::Message for SingleStatusCodeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleStatusCodeResponse {
        SingleStatusCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleStatusCodeResponse| { &m.status },
                |m: &mut SingleStatusCodeResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleStatusCodeResponse>(
                "SingleStatusCodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleStatusCodeResponse {
        static instance: ::protobuf::rt::LazyV2<SingleStatusCodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleStatusCodeResponse::new)
    }
}

impl ::protobuf::Clear for SingleStatusCodeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleStatusCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiStatusCodeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub statuses: ::protobuf::RepeatedField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiStatusCodeResponse {
    fn default() -> &'a MultiStatusCodeResponse {
        <MultiStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatusCodeResponse {
    pub fn new() -> MultiStatusCodeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.status.Status statuses = 2;


    pub fn get_statuses(&self) -> &[super::status::Status] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<super::status::Status>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<super::status::Status> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<super::status::Status> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiStatusCodeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.statuses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiStatusCodeResponse {
        MultiStatusCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiStatusCodeResponse| { &m.status },
                |m: &mut MultiStatusCodeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "statuses",
                |m: &MultiStatusCodeResponse| { &m.statuses },
                |m: &mut MultiStatusCodeResponse| { &mut m.statuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiStatusCodeResponse>(
                "MultiStatusCodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiStatusCodeResponse {
        static instance: ::protobuf::rt::LazyV2<MultiStatusCodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiStatusCodeResponse::new)
    }
}

impl ::protobuf::Clear for MultiStatusCodeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.statuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatusCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConceptRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConceptRequest {
    fn default() -> &'a GetConceptRequest {
        <GetConceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptRequest {
    pub fn new() -> GetConceptRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetConceptRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConceptRequest {
        GetConceptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetConceptRequest| { &m.user_app_id },
                |m: &mut GetConceptRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &GetConceptRequest| { &m.concept_id },
                |m: &mut GetConceptRequest| { &mut m.concept_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConceptRequest>(
                "GetConceptRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConceptRequest {
        static instance: ::protobuf::rt::LazyV2<GetConceptRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConceptRequest::new)
    }
}

impl ::protobuf::Clear for GetConceptRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListConceptsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListConceptsRequest {
    fn default() -> &'a ListConceptsRequest {
        <ListConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptsRequest {
    pub fn new() -> ListConceptsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListConceptsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListConceptsRequest {
        ListConceptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListConceptsRequest| { &m.user_app_id },
                |m: &mut ListConceptsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListConceptsRequest| { &m.page },
                |m: &mut ListConceptsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListConceptsRequest| { &m.per_page },
                |m: &mut ListConceptsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListConceptsRequest>(
                "ListConceptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListConceptsRequest {
        static instance: ::protobuf::rt::LazyV2<ListConceptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListConceptsRequest::new)
    }
}

impl ::protobuf::Clear for ListConceptsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_query: ::protobuf::SingularPtrField<super::resources::ConceptQuery>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptsSearchesRequest {
    fn default() -> &'a PostConceptsSearchesRequest {
        <PostConceptsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsSearchesRequest {
    pub fn new() -> PostConceptsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.ConceptQuery concept_query = 2;


    pub fn get_concept_query(&self) -> &super::resources::ConceptQuery {
        self.concept_query.as_ref().unwrap_or_else(|| <super::resources::ConceptQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept_query(&mut self) {
        self.concept_query.clear();
    }

    pub fn has_concept_query(&self) -> bool {
        self.concept_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept_query(&mut self, v: super::resources::ConceptQuery) {
        self.concept_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_query(&mut self) -> &mut super::resources::ConceptQuery {
        if self.concept_query.is_none() {
            self.concept_query.set_default();
        }
        self.concept_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept_query(&mut self) -> super::resources::ConceptQuery {
        self.concept_query.take().unwrap_or_else(|| super::resources::ConceptQuery::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostConceptsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.concept_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.concept_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptsSearchesRequest {
        PostConceptsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptsSearchesRequest| { &m.user_app_id },
                |m: &mut PostConceptsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptQuery>>(
                "concept_query",
                |m: &PostConceptsSearchesRequest| { &m.concept_query },
                |m: &mut PostConceptsSearchesRequest| { &mut m.concept_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostConceptsSearchesRequest| { &m.pagination },
                |m: &mut PostConceptsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptsSearchesRequest>(
                "PostConceptsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_query.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concepts: ::protobuf::RepeatedField<super::resources::Concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptsRequest {
    fn default() -> &'a PostConceptsRequest {
        <PostConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsRequest {
    pub fn new() -> PostConceptsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Concept concepts = 2;


    pub fn get_concepts(&self) -> &[super::resources::Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<super::resources::Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<super::resources::Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptsRequest {
        PostConceptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptsRequest| { &m.user_app_id },
                |m: &mut PostConceptsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concepts",
                |m: &PostConceptsRequest| { &m.concepts },
                |m: &mut PostConceptsRequest| { &mut m.concepts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptsRequest>(
                "PostConceptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptsRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptsRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchConceptsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concepts: ::protobuf::RepeatedField<super::resources::Concept>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchConceptsRequest {
    fn default() -> &'a PatchConceptsRequest {
        <PatchConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptsRequest {
    pub fn new() -> PatchConceptsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Concept concepts = 2;


    pub fn get_concepts(&self) -> &[super::resources::Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<super::resources::Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<super::resources::Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchConceptsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchConceptsRequest {
        PatchConceptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchConceptsRequest| { &m.user_app_id },
                |m: &mut PatchConceptsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concepts",
                |m: &PatchConceptsRequest| { &m.concepts },
                |m: &mut PatchConceptsRequest| { &mut m.concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchConceptsRequest| { &m.action },
                |m: &mut PatchConceptsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchConceptsRequest>(
                "PatchConceptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchConceptsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchConceptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchConceptsRequest::new)
    }
}

impl ::protobuf::Clear for PatchConceptsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConceptCountsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConceptCountsRequest {
    fn default() -> &'a GetConceptCountsRequest {
        <GetConceptCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptCountsRequest {
    pub fn new() -> GetConceptCountsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for GetConceptCountsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConceptCountsRequest {
        GetConceptCountsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetConceptCountsRequest| { &m.user_app_id },
                |m: &mut GetConceptCountsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &GetConceptCountsRequest| { &m.page },
                |m: &mut GetConceptCountsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &GetConceptCountsRequest| { &m.per_page },
                |m: &mut GetConceptCountsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConceptCountsRequest>(
                "GetConceptCountsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConceptCountsRequest {
        static instance: ::protobuf::rt::LazyV2<GetConceptCountsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConceptCountsRequest::new)
    }
}

impl ::protobuf::Clear for GetConceptCountsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConceptCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptCountsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleConceptResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept: ::protobuf::SingularPtrField<super::resources::Concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleConceptResponse {
    fn default() -> &'a SingleConceptResponse {
        <SingleConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptResponse {
    pub fn new() -> SingleConceptResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Concept concept = 2;


    pub fn get_concept(&self) -> &super::resources::Concept {
        self.concept.as_ref().unwrap_or_else(|| <super::resources::Concept as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept(&mut self) {
        self.concept.clear();
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: super::resources::Concept) {
        self.concept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept(&mut self) -> &mut super::resources::Concept {
        if self.concept.is_none() {
            self.concept.set_default();
        }
        self.concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept(&mut self) -> super::resources::Concept {
        self.concept.take().unwrap_or_else(|| super::resources::Concept::new())
    }
}

impl ::protobuf::Message for SingleConceptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.concept.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleConceptResponse {
        SingleConceptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleConceptResponse| { &m.status },
                |m: &mut SingleConceptResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concept",
                |m: &SingleConceptResponse| { &m.concept },
                |m: &mut SingleConceptResponse| { &mut m.concept },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleConceptResponse>(
                "SingleConceptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleConceptResponse {
        static instance: ::protobuf::rt::LazyV2<SingleConceptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleConceptResponse::new)
    }
}

impl ::protobuf::Clear for SingleConceptResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concepts: ::protobuf::RepeatedField<super::resources::Concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptResponse {
    fn default() -> &'a MultiConceptResponse {
        <MultiConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptResponse {
    pub fn new() -> MultiConceptResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Concept concepts = 2;


    pub fn get_concepts(&self) -> &[super::resources::Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<super::resources::Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<super::resources::Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptResponse {
        MultiConceptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptResponse| { &m.status },
                |m: &mut MultiConceptResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concepts",
                |m: &MultiConceptResponse| { &m.concepts },
                |m: &mut MultiConceptResponse| { &mut m.concepts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptResponse>(
                "MultiConceptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concepts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptCountResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_counts: ::protobuf::RepeatedField<super::resources::ConceptCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptCountResponse {
    fn default() -> &'a MultiConceptCountResponse {
        <MultiConceptCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptCountResponse {
    pub fn new() -> MultiConceptCountResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ConceptCount concept_counts = 2;


    pub fn get_concept_counts(&self) -> &[super::resources::ConceptCount] {
        &self.concept_counts
    }
    pub fn clear_concept_counts(&mut self) {
        self.concept_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_counts(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptCount>) {
        self.concept_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_counts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptCount> {
        &mut self.concept_counts
    }

    // Take field
    pub fn take_concept_counts(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptCount> {
        ::std::mem::replace(&mut self.concept_counts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptCountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_counts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptCountResponse {
        MultiConceptCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptCountResponse| { &m.status },
                |m: &mut MultiConceptCountResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptCount>>(
                "concept_counts",
                |m: &MultiConceptCountResponse| { &m.concept_counts },
                |m: &mut MultiConceptCountResponse| { &mut m.concept_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptCountResponse>(
                "MultiConceptCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptCountResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptCountResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptCountResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListConceptRelationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub predicate: ::std::string::String,
    pub knowledge_graph_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListConceptRelationsRequest {
    fn default() -> &'a ListConceptRelationsRequest {
        <ListConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptRelationsRequest {
    pub fn new() -> ListConceptRelationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // string predicate = 3;


    pub fn get_predicate(&self) -> &str {
        &self.predicate
    }
    pub fn clear_predicate(&mut self) {
        self.predicate.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicate(&mut self, v: ::std::string::String) {
        self.predicate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate(&mut self) -> &mut ::std::string::String {
        &mut self.predicate
    }

    // Take field
    pub fn take_predicate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.predicate, ::std::string::String::new())
    }

    // string knowledge_graph_id = 4;


    pub fn get_knowledge_graph_id(&self) -> &str {
        &self.knowledge_graph_id
    }
    pub fn clear_knowledge_graph_id(&mut self) {
        self.knowledge_graph_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graph_id(&mut self, v: ::std::string::String) {
        self.knowledge_graph_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_knowledge_graph_id(&mut self) -> &mut ::std::string::String {
        &mut self.knowledge_graph_id
    }

    // Take field
    pub fn take_knowledge_graph_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.knowledge_graph_id, ::std::string::String::new())
    }

    // uint32 page = 5;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 6;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListConceptRelationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.predicate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.knowledge_graph_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.knowledge_graph_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(6, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(3, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(4, &self.knowledge_graph_id)?;
        }
        if self.page != 0 {
            os.write_uint32(5, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(6, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListConceptRelationsRequest {
        ListConceptRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListConceptRelationsRequest| { &m.user_app_id },
                |m: &mut ListConceptRelationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &ListConceptRelationsRequest| { &m.concept_id },
                |m: &mut ListConceptRelationsRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "predicate",
                |m: &ListConceptRelationsRequest| { &m.predicate },
                |m: &mut ListConceptRelationsRequest| { &mut m.predicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "knowledge_graph_id",
                |m: &ListConceptRelationsRequest| { &m.knowledge_graph_id },
                |m: &mut ListConceptRelationsRequest| { &mut m.knowledge_graph_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListConceptRelationsRequest| { &m.page },
                |m: &mut ListConceptRelationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListConceptRelationsRequest| { &m.per_page },
                |m: &mut ListConceptRelationsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListConceptRelationsRequest>(
                "ListConceptRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListConceptRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListConceptRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListConceptRelationsRequest::new)
    }
}

impl ::protobuf::Clear for ListConceptRelationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptRelationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub concept_relations: ::protobuf::RepeatedField<super::resources::ConceptRelation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptRelationsRequest {
    fn default() -> &'a PostConceptRelationsRequest {
        <PostConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptRelationsRequest {
    pub fn new() -> PostConceptRelationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ConceptRelation concept_relations = 3;


    pub fn get_concept_relations(&self) -> &[super::resources::ConceptRelation] {
        &self.concept_relations
    }
    pub fn clear_concept_relations(&mut self) {
        self.concept_relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_relations(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptRelation>) {
        self.concept_relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_relations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        &mut self.concept_relations
    }

    // Take field
    pub fn take_concept_relations(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        ::std::mem::replace(&mut self.concept_relations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptRelationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_relations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptRelationsRequest {
        PostConceptRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptRelationsRequest| { &m.user_app_id },
                |m: &mut PostConceptRelationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &PostConceptRelationsRequest| { &m.concept_id },
                |m: &mut PostConceptRelationsRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptRelation>>(
                "concept_relations",
                |m: &PostConceptRelationsRequest| { &m.concept_relations },
                |m: &mut PostConceptRelationsRequest| { &mut m.concept_relations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptRelationsRequest>(
                "PostConceptRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptRelationsRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptRelationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_relations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteConceptRelationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteConceptRelationsRequest {
    fn default() -> &'a DeleteConceptRelationsRequest {
        <DeleteConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConceptRelationsRequest {
    pub fn new() -> DeleteConceptRelationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated string ids = 3;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteConceptRelationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteConceptRelationsRequest {
        DeleteConceptRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteConceptRelationsRequest| { &m.user_app_id },
                |m: &mut DeleteConceptRelationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &DeleteConceptRelationsRequest| { &m.concept_id },
                |m: &mut DeleteConceptRelationsRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteConceptRelationsRequest| { &m.ids },
                |m: &mut DeleteConceptRelationsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteConceptRelationsRequest>(
                "DeleteConceptRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteConceptRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteConceptRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteConceptRelationsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteConceptRelationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConceptRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListKnowledgeGraphsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListKnowledgeGraphsRequest {
    fn default() -> &'a ListKnowledgeGraphsRequest {
        <ListKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKnowledgeGraphsRequest {
    pub fn new() -> ListKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for ListKnowledgeGraphsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListKnowledgeGraphsRequest {
        ListKnowledgeGraphsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListKnowledgeGraphsRequest| { &m.user_app_id },
                |m: &mut ListKnowledgeGraphsRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListKnowledgeGraphsRequest>(
                "ListKnowledgeGraphsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListKnowledgeGraphsRequest {
        static instance: ::protobuf::rt::LazyV2<ListKnowledgeGraphsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListKnowledgeGraphsRequest::new)
    }
}

impl ::protobuf::Clear for ListKnowledgeGraphsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKnowledgeGraphsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostKnowledgeGraphsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub knowledge_graphs: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostKnowledgeGraphsRequest {
    fn default() -> &'a PostKnowledgeGraphsRequest {
        <PostKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKnowledgeGraphsRequest {
    pub fn new() -> PostKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.KnowledgeGraph knowledge_graphs = 2;


    pub fn get_knowledge_graphs(&self) -> &[super::resources::KnowledgeGraph] {
        &self.knowledge_graphs
    }
    pub fn clear_knowledge_graphs(&mut self) {
        self.knowledge_graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graphs(&mut self, v: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>) {
        self.knowledge_graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_knowledge_graphs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        &mut self.knowledge_graphs
    }

    // Take field
    pub fn take_knowledge_graphs(&mut self) -> ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        ::std::mem::replace(&mut self.knowledge_graphs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostKnowledgeGraphsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knowledge_graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.knowledge_graphs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.knowledge_graphs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostKnowledgeGraphsRequest {
        PostKnowledgeGraphsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostKnowledgeGraphsRequest| { &m.user_app_id },
                |m: &mut PostKnowledgeGraphsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::KnowledgeGraph>>(
                "knowledge_graphs",
                |m: &PostKnowledgeGraphsRequest| { &m.knowledge_graphs },
                |m: &mut PostKnowledgeGraphsRequest| { &mut m.knowledge_graphs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostKnowledgeGraphsRequest>(
                "PostKnowledgeGraphsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostKnowledgeGraphsRequest {
        static instance: ::protobuf::rt::LazyV2<PostKnowledgeGraphsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostKnowledgeGraphsRequest::new)
    }
}

impl ::protobuf::Clear for PostKnowledgeGraphsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.knowledge_graphs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKnowledgeGraphsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptMappingJobsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_mapping_jobs: ::protobuf::RepeatedField<super::resources::ConceptMappingJob>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptMappingJobsRequest {
    fn default() -> &'a PostConceptMappingJobsRequest {
        <PostConceptMappingJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptMappingJobsRequest {
    pub fn new() -> PostConceptMappingJobsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.ConceptMappingJob concept_mapping_jobs = 2;


    pub fn get_concept_mapping_jobs(&self) -> &[super::resources::ConceptMappingJob] {
        &self.concept_mapping_jobs
    }
    pub fn clear_concept_mapping_jobs(&mut self) {
        self.concept_mapping_jobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_mapping_jobs(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptMappingJob>) {
        self.concept_mapping_jobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_mapping_jobs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptMappingJob> {
        &mut self.concept_mapping_jobs
    }

    // Take field
    pub fn take_concept_mapping_jobs(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptMappingJob> {
        ::std::mem::replace(&mut self.concept_mapping_jobs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptMappingJobsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_mapping_jobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_mapping_jobs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_mapping_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_mapping_jobs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptMappingJobsRequest {
        PostConceptMappingJobsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptMappingJobsRequest| { &m.user_app_id },
                |m: &mut PostConceptMappingJobsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptMappingJob>>(
                "concept_mapping_jobs",
                |m: &PostConceptMappingJobsRequest| { &m.concept_mapping_jobs },
                |m: &mut PostConceptMappingJobsRequest| { &mut m.concept_mapping_jobs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptMappingJobsRequest>(
                "PostConceptMappingJobsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptMappingJobsRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptMappingJobsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptMappingJobsRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptMappingJobsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_mapping_jobs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptMappingJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptMappingJobsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptRelationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_relations: ::protobuf::RepeatedField<super::resources::ConceptRelation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptRelationResponse {
    fn default() -> &'a MultiConceptRelationResponse {
        <MultiConceptRelationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptRelationResponse {
    pub fn new() -> MultiConceptRelationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ConceptRelation concept_relations = 2;


    pub fn get_concept_relations(&self) -> &[super::resources::ConceptRelation] {
        &self.concept_relations
    }
    pub fn clear_concept_relations(&mut self) {
        self.concept_relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_relations(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptRelation>) {
        self.concept_relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_relations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        &mut self.concept_relations
    }

    // Take field
    pub fn take_concept_relations(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        ::std::mem::replace(&mut self.concept_relations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptRelationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_relations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptRelationResponse {
        MultiConceptRelationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptRelationResponse| { &m.status },
                |m: &mut MultiConceptRelationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptRelation>>(
                "concept_relations",
                |m: &MultiConceptRelationResponse| { &m.concept_relations },
                |m: &mut MultiConceptRelationResponse| { &mut m.concept_relations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptRelationResponse>(
                "MultiConceptRelationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptRelationResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptRelationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptRelationResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptRelationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_relations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptRelationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptRelationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiKnowledgeGraphResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub knowledge_graphs: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiKnowledgeGraphResponse {
    fn default() -> &'a MultiKnowledgeGraphResponse {
        <MultiKnowledgeGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKnowledgeGraphResponse {
    pub fn new() -> MultiKnowledgeGraphResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.KnowledgeGraph knowledge_graphs = 2;


    pub fn get_knowledge_graphs(&self) -> &[super::resources::KnowledgeGraph] {
        &self.knowledge_graphs
    }
    pub fn clear_knowledge_graphs(&mut self) {
        self.knowledge_graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graphs(&mut self, v: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>) {
        self.knowledge_graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_knowledge_graphs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        &mut self.knowledge_graphs
    }

    // Take field
    pub fn take_knowledge_graphs(&mut self) -> ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        ::std::mem::replace(&mut self.knowledge_graphs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiKnowledgeGraphResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knowledge_graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.knowledge_graphs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.knowledge_graphs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiKnowledgeGraphResponse {
        MultiKnowledgeGraphResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiKnowledgeGraphResponse| { &m.status },
                |m: &mut MultiKnowledgeGraphResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::KnowledgeGraph>>(
                "knowledge_graphs",
                |m: &MultiKnowledgeGraphResponse| { &m.knowledge_graphs },
                |m: &mut MultiKnowledgeGraphResponse| { &mut m.knowledge_graphs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiKnowledgeGraphResponse>(
                "MultiKnowledgeGraphResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiKnowledgeGraphResponse {
        static instance: ::protobuf::rt::LazyV2<MultiKnowledgeGraphResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiKnowledgeGraphResponse::new)
    }
}

impl ::protobuf::Clear for MultiKnowledgeGraphResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.knowledge_graphs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiKnowledgeGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKnowledgeGraphResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptMappingJobResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptMappingJobResponse {
    fn default() -> &'a MultiConceptMappingJobResponse {
        <MultiConceptMappingJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptMappingJobResponse {
    pub fn new() -> MultiConceptMappingJobResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptMappingJobResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptMappingJobResponse {
        MultiConceptMappingJobResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptMappingJobResponse| { &m.status },
                |m: &mut MultiConceptMappingJobResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &MultiConceptMappingJobResponse| { &m.ids },
                |m: &mut MultiConceptMappingJobResponse| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptMappingJobResponse>(
                "MultiConceptMappingJobResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptMappingJobResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptMappingJobResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptMappingJobResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptMappingJobResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptMappingJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptMappingJobResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConceptLanguageRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub language: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConceptLanguageRequest {
    fn default() -> &'a GetConceptLanguageRequest {
        <GetConceptLanguageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptLanguageRequest {
    pub fn new() -> GetConceptLanguageRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // string language = 3;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetConceptLanguageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(3, &self.language)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConceptLanguageRequest {
        GetConceptLanguageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetConceptLanguageRequest| { &m.user_app_id },
                |m: &mut GetConceptLanguageRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &GetConceptLanguageRequest| { &m.concept_id },
                |m: &mut GetConceptLanguageRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &GetConceptLanguageRequest| { &m.language },
                |m: &mut GetConceptLanguageRequest| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConceptLanguageRequest>(
                "GetConceptLanguageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConceptLanguageRequest {
        static instance: ::protobuf::rt::LazyV2<GetConceptLanguageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConceptLanguageRequest::new)
    }
}

impl ::protobuf::Clear for GetConceptLanguageRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConceptLanguageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptLanguageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListConceptLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListConceptLanguagesRequest {
    fn default() -> &'a ListConceptLanguagesRequest {
        <ListConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptLanguagesRequest {
    pub fn new() -> ListConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListConceptLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListConceptLanguagesRequest {
        ListConceptLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListConceptLanguagesRequest| { &m.user_app_id },
                |m: &mut ListConceptLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &ListConceptLanguagesRequest| { &m.concept_id },
                |m: &mut ListConceptLanguagesRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListConceptLanguagesRequest| { &m.page },
                |m: &mut ListConceptLanguagesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListConceptLanguagesRequest| { &m.per_page },
                |m: &mut ListConceptLanguagesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListConceptLanguagesRequest>(
                "ListConceptLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListConceptLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<ListConceptLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListConceptLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for ListConceptLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchConceptLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub concept_languages: ::protobuf::RepeatedField<super::resources::ConceptLanguage>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchConceptLanguagesRequest {
    fn default() -> &'a PatchConceptLanguagesRequest {
        <PatchConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptLanguagesRequest {
    pub fn new() -> PatchConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ConceptLanguage concept_languages = 3;


    pub fn get_concept_languages(&self) -> &[super::resources::ConceptLanguage] {
        &self.concept_languages
    }
    pub fn clear_concept_languages(&mut self) {
        self.concept_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_languages(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptLanguage>) {
        self.concept_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_languages(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        &mut self.concept_languages
    }

    // Take field
    pub fn take_concept_languages(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        ::std::mem::replace(&mut self.concept_languages, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchConceptLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_languages)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchConceptLanguagesRequest {
        PatchConceptLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchConceptLanguagesRequest| { &m.user_app_id },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &PatchConceptLanguagesRequest| { &m.concept_id },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_languages",
                |m: &PatchConceptLanguagesRequest| { &m.concept_languages },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_languages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchConceptLanguagesRequest| { &m.action },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchConceptLanguagesRequest>(
                "PatchConceptLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchConceptLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchConceptLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchConceptLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for PatchConceptLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub concept_languages: ::protobuf::RepeatedField<super::resources::ConceptLanguage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptLanguagesRequest {
    fn default() -> &'a PostConceptLanguagesRequest {
        <PostConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptLanguagesRequest {
    pub fn new() -> PostConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ConceptLanguage concept_languages = 3;


    pub fn get_concept_languages(&self) -> &[super::resources::ConceptLanguage] {
        &self.concept_languages
    }
    pub fn clear_concept_languages(&mut self) {
        self.concept_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_languages(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptLanguage>) {
        self.concept_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_languages(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        &mut self.concept_languages
    }

    // Take field
    pub fn take_concept_languages(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        ::std::mem::replace(&mut self.concept_languages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_languages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptLanguagesRequest {
        PostConceptLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptLanguagesRequest| { &m.user_app_id },
                |m: &mut PostConceptLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &PostConceptLanguagesRequest| { &m.concept_id },
                |m: &mut PostConceptLanguagesRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_languages",
                |m: &PostConceptLanguagesRequest| { &m.concept_languages },
                |m: &mut PostConceptLanguagesRequest| { &mut m.concept_languages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptLanguagesRequest>(
                "PostConceptLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleConceptLanguageResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_language: ::protobuf::SingularPtrField<super::resources::ConceptLanguage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleConceptLanguageResponse {
    fn default() -> &'a SingleConceptLanguageResponse {
        <SingleConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptLanguageResponse {
    pub fn new() -> SingleConceptLanguageResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ConceptLanguage concept_language = 2;


    pub fn get_concept_language(&self) -> &super::resources::ConceptLanguage {
        self.concept_language.as_ref().unwrap_or_else(|| <super::resources::ConceptLanguage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept_language(&mut self) {
        self.concept_language.clear();
    }

    pub fn has_concept_language(&self) -> bool {
        self.concept_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept_language(&mut self, v: super::resources::ConceptLanguage) {
        self.concept_language = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_language(&mut self) -> &mut super::resources::ConceptLanguage {
        if self.concept_language.is_none() {
            self.concept_language.set_default();
        }
        self.concept_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept_language(&mut self) -> super::resources::ConceptLanguage {
        self.concept_language.take().unwrap_or_else(|| super::resources::ConceptLanguage::new())
    }
}

impl ::protobuf::Message for SingleConceptLanguageResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_language {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept_language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.concept_language.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.concept_language.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleConceptLanguageResponse {
        SingleConceptLanguageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleConceptLanguageResponse| { &m.status },
                |m: &mut SingleConceptLanguageResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_language",
                |m: &SingleConceptLanguageResponse| { &m.concept_language },
                |m: &mut SingleConceptLanguageResponse| { &mut m.concept_language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleConceptLanguageResponse>(
                "SingleConceptLanguageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleConceptLanguageResponse {
        static instance: ::protobuf::rt::LazyV2<SingleConceptLanguageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleConceptLanguageResponse::new)
    }
}

impl ::protobuf::Clear for SingleConceptLanguageResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptLanguageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptLanguageResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_languages: ::protobuf::RepeatedField<super::resources::ConceptLanguage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptLanguageResponse {
    fn default() -> &'a MultiConceptLanguageResponse {
        <MultiConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptLanguageResponse {
    pub fn new() -> MultiConceptLanguageResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ConceptLanguage concept_languages = 2;


    pub fn get_concept_languages(&self) -> &[super::resources::ConceptLanguage] {
        &self.concept_languages
    }
    pub fn clear_concept_languages(&mut self) {
        self.concept_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_languages(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptLanguage>) {
        self.concept_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_languages(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        &mut self.concept_languages
    }

    // Take field
    pub fn take_concept_languages(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        ::std::mem::replace(&mut self.concept_languages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptLanguageResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_languages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_languages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptLanguageResponse {
        MultiConceptLanguageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptLanguageResponse| { &m.status },
                |m: &mut MultiConceptLanguageResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_languages",
                |m: &MultiConceptLanguageResponse| { &m.concept_languages },
                |m: &mut MultiConceptLanguageResponse| { &mut m.concept_languages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptLanguageResponse>(
                "MultiConceptLanguageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptLanguageResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptLanguageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptLanguageResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptLanguageResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_languages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptLanguageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInputRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub input_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInputRequest {
    fn default() -> &'a GetInputRequest {
        <GetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputRequest {
    pub fn new() -> GetInputRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInputRequest {
        GetInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetInputRequest| { &m.user_app_id },
                |m: &mut GetInputRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &GetInputRequest| { &m.input_id },
                |m: &mut GetInputRequest| { &mut m.input_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInputRequest>(
                "GetInputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInputRequest {
        static instance: ::protobuf::rt::LazyV2<GetInputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInputRequest::new)
    }
}

impl ::protobuf::Clear for GetInputRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInputSamplesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub task_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInputSamplesRequest {
    fn default() -> &'a GetInputSamplesRequest {
        <GetInputSamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputSamplesRequest {
    pub fn new() -> GetInputSamplesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // repeated string user_ids = 3;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetInputSamplesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInputSamplesRequest {
        GetInputSamplesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetInputSamplesRequest| { &m.user_app_id },
                |m: &mut GetInputSamplesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &GetInputSamplesRequest| { &m.task_id },
                |m: &mut GetInputSamplesRequest| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &GetInputSamplesRequest| { &m.user_ids },
                |m: &mut GetInputSamplesRequest| { &mut m.user_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInputSamplesRequest>(
                "GetInputSamplesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInputSamplesRequest {
        static instance: ::protobuf::rt::LazyV2<GetInputSamplesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInputSamplesRequest::new)
    }
}

impl ::protobuf::Clear for GetInputSamplesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInputSamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputSamplesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInputsRequest {
    fn default() -> &'a ListInputsRequest {
        <ListInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsRequest {
    pub fn new() -> ListInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // .clarifai.api.status.Status status = 5;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string ids = 4;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInputsRequest {
        ListInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListInputsRequest| { &m.user_app_id },
                |m: &mut ListInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListInputsRequest| { &m.page },
                |m: &mut ListInputsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListInputsRequest| { &m.per_page },
                |m: &mut ListInputsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &ListInputsRequest| { &m.status },
                |m: &mut ListInputsRequest| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &ListInputsRequest| { &m.ids },
                |m: &mut ListInputsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInputsRequest>(
                "ListInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListInputsRequest {
        static instance: ::protobuf::rt::LazyV2<ListInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListInputsRequest::new)
    }
}

impl ::protobuf::Clear for ListInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.status.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub per_page: u32,
    pub last_id: ::std::string::String,
    pub descending: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamInputsRequest {
    fn default() -> &'a StreamInputsRequest {
        <StreamInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamInputsRequest {
    pub fn new() -> StreamInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 per_page = 2;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // string last_id = 3;


    pub fn get_last_id(&self) -> &str {
        &self.last_id
    }
    pub fn clear_last_id(&mut self) {
        self.last_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_id(&mut self, v: ::std::string::String) {
        self.last_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_id(&mut self) -> &mut ::std::string::String {
        &mut self.last_id
    }

    // Take field
    pub fn take_last_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_id, ::std::string::String::new())
    }

    // bool descending = 4;


    pub fn get_descending(&self) -> bool {
        self.descending
    }
    pub fn clear_descending(&mut self) {
        self.descending = false;
    }

    // Param is passed by value, moved
    pub fn set_descending(&mut self, v: bool) {
        self.descending = v;
    }
}

impl ::protobuf::Message for StreamInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.descending = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.last_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.last_id);
        }
        if self.descending != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        if !self.last_id.is_empty() {
            os.write_string(3, &self.last_id)?;
        }
        if self.descending != false {
            os.write_bool(4, self.descending)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamInputsRequest {
        StreamInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &StreamInputsRequest| { &m.user_app_id },
                |m: &mut StreamInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &StreamInputsRequest| { &m.per_page },
                |m: &mut StreamInputsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_id",
                |m: &StreamInputsRequest| { &m.last_id },
                |m: &mut StreamInputsRequest| { &mut m.last_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "descending",
                |m: &StreamInputsRequest| { &m.descending },
                |m: &mut StreamInputsRequest| { &mut m.descending },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamInputsRequest>(
                "StreamInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamInputsRequest {
        static instance: ::protobuf::rt::LazyV2<StreamInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamInputsRequest::new)
    }
}

impl ::protobuf::Clear for StreamInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.per_page = 0;
        self.last_id.clear();
        self.descending = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostInputsRequest {
    fn default() -> &'a PostInputsRequest {
        <PostInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsRequest {
    pub fn new() -> PostInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Input inputs = 2;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostInputsRequest {
        PostInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostInputsRequest| { &m.user_app_id },
                |m: &mut PostInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PostInputsRequest| { &m.inputs },
                |m: &mut PostInputsRequest| { &mut m.inputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostInputsRequest>(
                "PostInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostInputsRequest {
        static instance: ::protobuf::rt::LazyV2<PostInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostInputsRequest::new)
    }
}

impl ::protobuf::Clear for PostInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchInputsRequest {
    fn default() -> &'a PatchInputsRequest {
        <PatchInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsRequest {
    pub fn new() -> PatchInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Input inputs = 2;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchInputsRequest {
        PatchInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchInputsRequest| { &m.user_app_id },
                |m: &mut PatchInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PatchInputsRequest| { &m.inputs },
                |m: &mut PatchInputsRequest| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchInputsRequest| { &m.action },
                |m: &mut PatchInputsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchInputsRequest>(
                "PatchInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchInputsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchInputsRequest::new)
    }
}

impl ::protobuf::Clear for PatchInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteInputRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub input_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteInputRequest {
    fn default() -> &'a DeleteInputRequest {
        <DeleteInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputRequest {
    pub fn new() -> DeleteInputRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteInputRequest {
        DeleteInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteInputRequest| { &m.user_app_id },
                |m: &mut DeleteInputRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &DeleteInputRequest| { &m.input_id },
                |m: &mut DeleteInputRequest| { &mut m.input_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteInputRequest>(
                "DeleteInputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteInputRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteInputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteInputRequest::new)
    }
}

impl ::protobuf::Clear for DeleteInputRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteInputsRequest {
    fn default() -> &'a DeleteInputsRequest {
        <DeleteInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputsRequest {
    pub fn new() -> DeleteInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteInputsRequest {
        DeleteInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteInputsRequest| { &m.user_app_id },
                |m: &mut DeleteInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteInputsRequest| { &m.ids },
                |m: &mut DeleteInputsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteInputsRequest>(
                "DeleteInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteInputsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteInputsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleInputResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub input: ::protobuf::SingularPtrField<super::resources::Input>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleInputResponse {
    fn default() -> &'a SingleInputResponse {
        <SingleInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputResponse {
    pub fn new() -> SingleInputResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Input input = 2;


    pub fn get_input(&self) -> &super::resources::Input {
        self.input.as_ref().unwrap_or_else(|| <super::resources::Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: super::resources::Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut super::resources::Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> super::resources::Input {
        self.input.take().unwrap_or_else(|| super::resources::Input::new())
    }
}

impl ::protobuf::Message for SingleInputResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleInputResponse {
        SingleInputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleInputResponse| { &m.status },
                |m: &mut SingleInputResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "input",
                |m: &SingleInputResponse| { &m.input },
                |m: &mut SingleInputResponse| { &mut m.input },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleInputResponse>(
                "SingleInputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleInputResponse {
        static instance: ::protobuf::rt::LazyV2<SingleInputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleInputResponse::new)
    }
}

impl ::protobuf::Clear for SingleInputResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.input.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiInputResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiInputResponse {
    fn default() -> &'a MultiInputResponse {
        <MultiInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputResponse {
    pub fn new() -> MultiInputResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Input inputs = 2;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiInputResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiInputResponse {
        MultiInputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiInputResponse| { &m.status },
                |m: &mut MultiInputResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &MultiInputResponse| { &m.inputs },
                |m: &mut MultiInputResponse| { &mut m.inputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiInputResponse>(
                "MultiInputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiInputResponse {
        static instance: ::protobuf::rt::LazyV2<MultiInputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiInputResponse::new)
    }
}

impl ::protobuf::Clear for MultiInputResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.inputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiInputAnnotationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub hits: ::protobuf::RepeatedField<super::resources::Hit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiInputAnnotationResponse {
    fn default() -> &'a MultiInputAnnotationResponse {
        <MultiInputAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputAnnotationResponse {
    pub fn new() -> MultiInputAnnotationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Hit hits = 3;


    pub fn get_hits(&self) -> &[super::resources::Hit] {
        &self.hits
    }
    pub fn clear_hits(&mut self) {
        self.hits.clear();
    }

    // Param is passed by value, moved
    pub fn set_hits(&mut self, v: ::protobuf::RepeatedField<super::resources::Hit>) {
        self.hits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hits(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Hit> {
        &mut self.hits
    }

    // Take field
    pub fn take_hits(&mut self) -> ::protobuf::RepeatedField<super::resources::Hit> {
        ::std::mem::replace(&mut self.hits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiInputAnnotationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.hits {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiInputAnnotationResponse {
        MultiInputAnnotationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiInputAnnotationResponse| { &m.status },
                |m: &mut MultiInputAnnotationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Hit>>(
                "hits",
                |m: &MultiInputAnnotationResponse| { &m.hits },
                |m: &mut MultiInputAnnotationResponse| { &mut m.hits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiInputAnnotationResponse>(
                "MultiInputAnnotationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiInputAnnotationResponse {
        static instance: ::protobuf::rt::LazyV2<MultiInputAnnotationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiInputAnnotationResponse::new)
    }
}

impl ::protobuf::Clear for MultiInputAnnotationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.hits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiInputAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputAnnotationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleInputCountResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub counts: ::protobuf::SingularPtrField<super::resources::InputCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleInputCountResponse {
    fn default() -> &'a SingleInputCountResponse {
        <SingleInputCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputCountResponse {
    pub fn new() -> SingleInputCountResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.InputCount counts = 2;


    pub fn get_counts(&self) -> &super::resources::InputCount {
        self.counts.as_ref().unwrap_or_else(|| <super::resources::InputCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_counts(&mut self) {
        self.counts.clear();
    }

    pub fn has_counts(&self) -> bool {
        self.counts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counts(&mut self, v: super::resources::InputCount) {
        self.counts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counts(&mut self) -> &mut super::resources::InputCount {
        if self.counts.is_none() {
            self.counts.set_default();
        }
        self.counts.as_mut().unwrap()
    }

    // Take field
    pub fn take_counts(&mut self) -> super::resources::InputCount {
        self.counts.take().unwrap_or_else(|| super::resources::InputCount::new())
    }
}

impl ::protobuf::Message for SingleInputCountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.counts.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleInputCountResponse {
        SingleInputCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleInputCountResponse| { &m.status },
                |m: &mut SingleInputCountResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::InputCount>>(
                "counts",
                |m: &SingleInputCountResponse| { &m.counts },
                |m: &mut SingleInputCountResponse| { &mut m.counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleInputCountResponse>(
                "SingleInputCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleInputCountResponse {
        static instance: ::protobuf::rt::LazyV2<SingleInputCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleInputCountResponse::new)
    }
}

impl ::protobuf::Clear for SingleInputCountResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleInputCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInputCountRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInputCountRequest {
    fn default() -> &'a GetInputCountRequest {
        <GetInputCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputCountRequest {
    pub fn new() -> GetInputCountRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for GetInputCountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInputCountRequest {
        GetInputCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetInputCountRequest| { &m.user_app_id },
                |m: &mut GetInputCountRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInputCountRequest>(
                "GetInputCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInputCountRequest {
        static instance: ::protobuf::rt::LazyV2<GetInputCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInputCountRequest::new)
    }
}

impl ::protobuf::Clear for GetInputCountRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInputCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelOutputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub model: ::protobuf::SingularPtrField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelOutputsRequest {
    fn default() -> &'a PostModelOutputsRequest {
        <PostModelOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelOutputsRequest {
    pub fn new() -> PostModelOutputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Input inputs = 4;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Model model = 5;


    pub fn get_model(&self) -> &super::resources::Model {
        self.model.as_ref().unwrap_or_else(|| <super::resources::Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: super::resources::Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut super::resources::Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> super::resources::Model {
        self.model.take().unwrap_or_else(|| super::resources::Model::new())
    }
}

impl ::protobuf::Message for PostModelOutputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        for v in &self.inputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelOutputsRequest {
        PostModelOutputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelOutputsRequest| { &m.user_app_id },
                |m: &mut PostModelOutputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelOutputsRequest| { &m.model_id },
                |m: &mut PostModelOutputsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &PostModelOutputsRequest| { &m.version_id },
                |m: &mut PostModelOutputsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PostModelOutputsRequest| { &m.inputs },
                |m: &mut PostModelOutputsRequest| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "model",
                |m: &PostModelOutputsRequest| { &m.model },
                |m: &mut PostModelOutputsRequest| { &mut m.model },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelOutputsRequest>(
                "PostModelOutputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelOutputsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelOutputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelOutputsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelOutputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.model.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelOutputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelInputsRequest {
    fn default() -> &'a ListModelInputsRequest {
        <ListModelInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelInputsRequest {
    pub fn new() -> ListModelInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // uint32 page = 4;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 5;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListModelInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(5, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelInputsRequest {
        ListModelInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelInputsRequest| { &m.user_app_id },
                |m: &mut ListModelInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ListModelInputsRequest| { &m.model_id },
                |m: &mut ListModelInputsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &ListModelInputsRequest| { &m.version_id },
                |m: &mut ListModelInputsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelInputsRequest| { &m.page },
                |m: &mut ListModelInputsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelInputsRequest| { &m.per_page },
                |m: &mut ListModelInputsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelInputsRequest>(
                "ListModelInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelInputsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelInputsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetKeyRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub key_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetKeyRequest {
    fn default() -> &'a GetKeyRequest {
        <GetKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyRequest {
    pub fn new() -> GetKeyRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string key_id = 2;


    pub fn get_key_id(&self) -> &str {
        &self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: ::std::string::String) {
        self.key_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_id(&mut self) -> &mut ::std::string::String {
        &mut self.key_id
    }

    // Take field
    pub fn take_key_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetKeyRequest {
        GetKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetKeyRequest| { &m.user_app_id },
                |m: &mut GetKeyRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_id",
                |m: &GetKeyRequest| { &m.key_id },
                |m: &mut GetKeyRequest| { &mut m.key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetKeyRequest>(
                "GetKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetKeyRequest {
        static instance: ::protobuf::rt::LazyV2<GetKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetKeyRequest::new)
    }
}

impl ::protobuf::Clear for GetKeyRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListKeysRequest| { &m.user_app_id },
                |m: &mut ListKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListKeysRequest| { &m.page },
                |m: &mut ListKeysRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListKeysRequest| { &m.per_page },
                |m: &mut ListKeysRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListKeysRequest>(
                "ListKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ::protobuf::rt::LazyV2<ListKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListKeysRequest::new)
    }
}

impl ::protobuf::Clear for ListKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAppKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAppKeysRequest {
    fn default() -> &'a ListAppKeysRequest {
        <ListAppKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppKeysRequest {
    pub fn new() -> ListAppKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListAppKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAppKeysRequest {
        ListAppKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAppKeysRequest| { &m.user_app_id },
                |m: &mut ListAppKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAppKeysRequest| { &m.page },
                |m: &mut ListAppKeysRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAppKeysRequest| { &m.per_page },
                |m: &mut ListAppKeysRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAppKeysRequest>(
                "ListAppKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAppKeysRequest {
        static instance: ::protobuf::rt::LazyV2<ListAppKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAppKeysRequest::new)
    }
}

impl ::protobuf::Clear for ListAppKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAppKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub keys: ::protobuf::RepeatedField<super::resources::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostKeysRequest {
    fn default() -> &'a PostKeysRequest {
        <PostKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKeysRequest {
    pub fn new() -> PostKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Key keys = 2;


    pub fn get_keys(&self) -> &[super::resources::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::resources::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::resources::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostKeysRequest {
        PostKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostKeysRequest| { &m.user_app_id },
                |m: &mut PostKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "keys",
                |m: &PostKeysRequest| { &m.keys },
                |m: &mut PostKeysRequest| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostKeysRequest>(
                "PostKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostKeysRequest {
        static instance: ::protobuf::rt::LazyV2<PostKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostKeysRequest::new)
    }
}

impl ::protobuf::Clear for PostKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteKeyRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub key_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteKeyRequest {
    fn default() -> &'a DeleteKeyRequest {
        <DeleteKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteKeyRequest {
    pub fn new() -> DeleteKeyRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string key_id = 2;


    pub fn get_key_id(&self) -> &str {
        &self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: ::std::string::String) {
        self.key_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_id(&mut self) -> &mut ::std::string::String {
        &mut self.key_id
    }

    // Take field
    pub fn take_key_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteKeyRequest {
        DeleteKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteKeyRequest| { &m.user_app_id },
                |m: &mut DeleteKeyRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_id",
                |m: &DeleteKeyRequest| { &m.key_id },
                |m: &mut DeleteKeyRequest| { &mut m.key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteKeyRequest>(
                "DeleteKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteKeyRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteKeyRequest::new)
    }
}

impl ::protobuf::Clear for DeleteKeyRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub keys: ::protobuf::RepeatedField<super::resources::Key>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchKeysRequest {
    fn default() -> &'a PatchKeysRequest {
        <PatchKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchKeysRequest {
    pub fn new() -> PatchKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Key keys = 2;


    pub fn get_keys(&self) -> &[super::resources::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::resources::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::resources::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchKeysRequest {
        PatchKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchKeysRequest| { &m.user_app_id },
                |m: &mut PatchKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "keys",
                |m: &PatchKeysRequest| { &m.keys },
                |m: &mut PatchKeysRequest| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchKeysRequest| { &m.action },
                |m: &mut PatchKeysRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchKeysRequest>(
                "PatchKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchKeysRequest {
        static instance: ::protobuf::rt::LazyV2<PatchKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchKeysRequest::new)
    }
}

impl ::protobuf::Clear for PatchKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleKeyResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub key: ::protobuf::SingularPtrField<super::resources::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleKeyResponse {
    fn default() -> &'a SingleKeyResponse {
        <SingleKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleKeyResponse {
    pub fn new() -> SingleKeyResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Key key = 2;


    pub fn get_key(&self) -> &super::resources::Key {
        self.key.as_ref().unwrap_or_else(|| <super::resources::Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: super::resources::Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut super::resources::Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> super::resources::Key {
        self.key.take().unwrap_or_else(|| super::resources::Key::new())
    }
}

impl ::protobuf::Message for SingleKeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleKeyResponse {
        SingleKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleKeyResponse| { &m.status },
                |m: &mut SingleKeyResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "key",
                |m: &SingleKeyResponse| { &m.key },
                |m: &mut SingleKeyResponse| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleKeyResponse>(
                "SingleKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleKeyResponse {
        static instance: ::protobuf::rt::LazyV2<SingleKeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleKeyResponse::new)
    }
}

impl ::protobuf::Clear for SingleKeyResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiKeyResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub keys: ::protobuf::RepeatedField<super::resources::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiKeyResponse {
    fn default() -> &'a MultiKeyResponse {
        <MultiKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKeyResponse {
    pub fn new() -> MultiKeyResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Key keys = 2;


    pub fn get_keys(&self) -> &[super::resources::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::resources::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::resources::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiKeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiKeyResponse {
        MultiKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiKeyResponse| { &m.status },
                |m: &mut MultiKeyResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "keys",
                |m: &MultiKeyResponse| { &m.keys },
                |m: &mut MultiKeyResponse| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiKeyResponse>(
                "MultiKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiKeyResponse {
        static instance: ::protobuf::rt::LazyV2<MultiKeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiKeyResponse::new)
    }
}

impl ::protobuf::Clear for MultiKeyResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub language: ::std::string::String,
    pub trained_before: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelRequest {
    fn default() -> &'a GetModelRequest {
        <GetModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelRequest {
    pub fn new() -> GetModelRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // string language = 4;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // bool trained_before = 5;


    pub fn get_trained_before(&self) -> bool {
        self.trained_before
    }
    pub fn clear_trained_before(&mut self) {
        self.trained_before = false;
    }

    // Param is passed by value, moved
    pub fn set_trained_before(&mut self, v: bool) {
        self.trained_before = v;
    }
}

impl ::protobuf::Message for GetModelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trained_before = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if self.trained_before != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if self.trained_before != false {
            os.write_bool(5, self.trained_before)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelRequest {
        GetModelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelRequest| { &m.user_app_id },
                |m: &mut GetModelRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelRequest| { &m.model_id },
                |m: &mut GetModelRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &GetModelRequest| { &m.version_id },
                |m: &mut GetModelRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &GetModelRequest| { &m.language },
                |m: &mut GetModelRequest| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trained_before",
                |m: &GetModelRequest| { &m.trained_before },
                |m: &mut GetModelRequest| { &mut m.trained_before },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelRequest>(
                "GetModelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelRequest::new)
    }
}

impl ::protobuf::Clear for GetModelRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.language.clear();
        self.trained_before = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelsRequest {
    fn default() -> &'a ListModelsRequest {
        <ListModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelsRequest {
    pub fn new() -> ListModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // repeated string ids = 4;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelsRequest {
        ListModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelsRequest| { &m.user_app_id },
                |m: &mut ListModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelsRequest| { &m.page },
                |m: &mut ListModelsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelsRequest| { &m.per_page },
                |m: &mut ListModelsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &ListModelsRequest| { &m.ids },
                |m: &mut ListModelsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelsRequest>(
                "ListModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model: ::protobuf::SingularPtrField<super::resources::Model>,
    pub models: ::protobuf::RepeatedField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelsRequest {
    fn default() -> &'a PostModelsRequest {
        <PostModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsRequest {
    pub fn new() -> PostModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.Model model = 2;


    pub fn get_model(&self) -> &super::resources::Model {
        self.model.as_ref().unwrap_or_else(|| <super::resources::Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: super::resources::Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut super::resources::Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> super::resources::Model {
        self.model.take().unwrap_or_else(|| super::resources::Model::new())
    }

    // repeated .clarifai.api.Model models = 3;


    pub fn get_models(&self) -> &[super::resources::Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<super::resources::Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<super::resources::Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.models {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelsRequest {
        PostModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelsRequest| { &m.user_app_id },
                |m: &mut PostModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "model",
                |m: &PostModelsRequest| { &m.model },
                |m: &mut PostModelsRequest| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "models",
                |m: &PostModelsRequest| { &m.models },
                |m: &mut PostModelsRequest| { &mut m.models },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelsRequest>(
                "PostModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model.clear();
        self.models.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub models: ::protobuf::RepeatedField<super::resources::Model>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelsRequest {
    fn default() -> &'a PatchModelsRequest {
        <PatchModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelsRequest {
    pub fn new() -> PatchModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Model models = 2;


    pub fn get_models(&self) -> &[super::resources::Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<super::resources::Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<super::resources::Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.models {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelsRequest {
        PatchModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelsRequest| { &m.user_app_id },
                |m: &mut PatchModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "models",
                |m: &PatchModelsRequest| { &m.models },
                |m: &mut PatchModelsRequest| { &mut m.models },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelsRequest| { &m.action },
                |m: &mut PatchModelsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelsRequest>(
                "PatchModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelsRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.models.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteModelRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteModelRequest {
    fn default() -> &'a DeleteModelRequest {
        <DeleteModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelRequest {
    pub fn new() -> DeleteModelRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteModelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteModelRequest {
        DeleteModelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteModelRequest| { &m.user_app_id },
                |m: &mut DeleteModelRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &DeleteModelRequest| { &m.model_id },
                |m: &mut DeleteModelRequest| { &mut m.model_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteModelRequest>(
                "DeleteModelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteModelRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteModelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteModelRequest::new)
    }
}

impl ::protobuf::Clear for DeleteModelRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub delete_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteModelsRequest {
    fn default() -> &'a DeleteModelsRequest {
        <DeleteModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelsRequest {
    pub fn new() -> DeleteModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool delete_all = 3;


    pub fn get_delete_all(&self) -> bool {
        self.delete_all
    }
    pub fn clear_delete_all(&mut self) {
        self.delete_all = false;
    }

    // Param is passed by value, moved
    pub fn set_delete_all(&mut self, v: bool) {
        self.delete_all = v;
    }
}

impl ::protobuf::Message for DeleteModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteModelsRequest {
        DeleteModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteModelsRequest| { &m.user_app_id },
                |m: &mut DeleteModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteModelsRequest| { &m.ids },
                |m: &mut DeleteModelsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_all",
                |m: &DeleteModelsRequest| { &m.delete_all },
                |m: &mut DeleteModelsRequest| { &mut m.delete_all },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteModelsRequest>(
                "DeleteModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteModelsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteModelsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_query: ::protobuf::SingularPtrField<super::resources::ModelQuery>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelsSearchesRequest {
    fn default() -> &'a PostModelsSearchesRequest {
        <PostModelsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsSearchesRequest {
    pub fn new() -> PostModelsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.ModelQuery model_query = 2;


    pub fn get_model_query(&self) -> &super::resources::ModelQuery {
        self.model_query.as_ref().unwrap_or_else(|| <super::resources::ModelQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_query(&mut self) {
        self.model_query.clear();
    }

    pub fn has_model_query(&self) -> bool {
        self.model_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_query(&mut self, v: super::resources::ModelQuery) {
        self.model_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_query(&mut self) -> &mut super::resources::ModelQuery {
        if self.model_query.is_none() {
            self.model_query.set_default();
        }
        self.model_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_query(&mut self) -> super::resources::ModelQuery {
        self.model_query.take().unwrap_or_else(|| super::resources::ModelQuery::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostModelsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelsSearchesRequest {
        PostModelsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelsSearchesRequest| { &m.user_app_id },
                |m: &mut PostModelsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelQuery>>(
                "model_query",
                |m: &PostModelsSearchesRequest| { &m.model_query },
                |m: &mut PostModelsSearchesRequest| { &mut m.model_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostModelsSearchesRequest| { &m.pagination },
                |m: &mut PostModelsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelsSearchesRequest>(
                "PostModelsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostModelsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_query.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model: ::protobuf::SingularPtrField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelResponse {
    fn default() -> &'a SingleModelResponse {
        <SingleModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelResponse {
    pub fn new() -> SingleModelResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Model model = 2;


    pub fn get_model(&self) -> &super::resources::Model {
        self.model.as_ref().unwrap_or_else(|| <super::resources::Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: super::resources::Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut super::resources::Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> super::resources::Model {
        self.model.take().unwrap_or_else(|| super::resources::Model::new())
    }
}

impl ::protobuf::Message for SingleModelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelResponse {
        SingleModelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelResponse| { &m.status },
                |m: &mut SingleModelResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "model",
                |m: &SingleModelResponse| { &m.model },
                |m: &mut SingleModelResponse| { &mut m.model },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelResponse>(
                "SingleModelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub models: ::protobuf::RepeatedField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelResponse {
    fn default() -> &'a MultiModelResponse {
        <MultiModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelResponse {
    pub fn new() -> MultiModelResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Model models = 2;


    pub fn get_models(&self) -> &[super::resources::Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<super::resources::Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<super::resources::Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.models {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelResponse {
        MultiModelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelResponse| { &m.status },
                |m: &mut MultiModelResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "models",
                |m: &MultiModelResponse| { &m.models },
                |m: &mut MultiModelResponse| { &mut m.models },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelResponse>(
                "MultiModelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.models.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub model_versions: ::protobuf::RepeatedField<super::resources::ModelVersion>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelVersionsRequest {
    fn default() -> &'a PatchModelVersionsRequest {
        <PatchModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelVersionsRequest {
    pub fn new() -> PatchModelVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelVersion model_versions = 3;


    pub fn get_model_versions(&self) -> &[super::resources::ModelVersion] {
        &self.model_versions
    }
    pub fn clear_model_versions(&mut self) {
        self.model_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersion>) {
        self.model_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersion> {
        &mut self.model_versions
    }

    // Take field
    pub fn take_model_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersion> {
        ::std::mem::replace(&mut self.model_versions, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_versions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelVersionsRequest {
        PatchModelVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelVersionsRequest| { &m.user_app_id },
                |m: &mut PatchModelVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PatchModelVersionsRequest| { &m.model_id },
                |m: &mut PatchModelVersionsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_versions",
                |m: &PatchModelVersionsRequest| { &m.model_versions },
                |m: &mut PatchModelVersionsRequest| { &mut m.model_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelVersionsRequest| { &m.action },
                |m: &mut PatchModelVersionsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelVersionsRequest>(
                "PatchModelVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelVersionsRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelVersionRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelVersionRequest {
    fn default() -> &'a GetModelVersionRequest {
        <GetModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionRequest {
    pub fn new() -> GetModelVersionRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModelVersionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelVersionRequest {
        GetModelVersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelVersionRequest| { &m.user_app_id },
                |m: &mut GetModelVersionRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelVersionRequest| { &m.model_id },
                |m: &mut GetModelVersionRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &GetModelVersionRequest| { &m.version_id },
                |m: &mut GetModelVersionRequest| { &mut m.version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelVersionRequest>(
                "GetModelVersionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelVersionRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelVersionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelVersionRequest::new)
    }
}

impl ::protobuf::Clear for GetModelVersionRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    pub concept_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelVersionsRequest {
    fn default() -> &'a ListModelVersionsRequest {
        <ListModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionsRequest {
    pub fn new() -> ListModelVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // repeated string concept_ids = 5;


    pub fn get_concept_ids(&self) -> &[::std::string::String] {
        &self.concept_ids
    }
    pub fn clear_concept_ids(&mut self) {
        self.concept_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_ids
    }

    // Take field
    pub fn take_concept_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListModelVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        for v in &self.concept_ids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelVersionsRequest {
        ListModelVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelVersionsRequest| { &m.user_app_id },
                |m: &mut ListModelVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ListModelVersionsRequest| { &m.model_id },
                |m: &mut ListModelVersionsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelVersionsRequest| { &m.page },
                |m: &mut ListModelVersionsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelVersionsRequest| { &m.per_page },
                |m: &mut ListModelVersionsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_ids",
                |m: &ListModelVersionsRequest| { &m.concept_ids },
                |m: &mut ListModelVersionsRequest| { &mut m.concept_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelVersionsRequest>(
                "ListModelVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelVersionsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.concept_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteModelVersionRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteModelVersionRequest {
    fn default() -> &'a DeleteModelVersionRequest {
        <DeleteModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelVersionRequest {
    pub fn new() -> DeleteModelVersionRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 3;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 4;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteModelVersionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(4, &self.version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteModelVersionRequest {
        DeleteModelVersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteModelVersionRequest| { &m.user_app_id },
                |m: &mut DeleteModelVersionRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &DeleteModelVersionRequest| { &m.model_id },
                |m: &mut DeleteModelVersionRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &DeleteModelVersionRequest| { &m.version_id },
                |m: &mut DeleteModelVersionRequest| { &mut m.version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteModelVersionRequest>(
                "DeleteModelVersionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteModelVersionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteModelVersionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteModelVersionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteModelVersionRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelVersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelVersionResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_version: ::protobuf::SingularPtrField<super::resources::ModelVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionResponse {
    fn default() -> &'a SingleModelVersionResponse {
        <SingleModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionResponse {
    pub fn new() -> SingleModelVersionResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ModelVersion model_version = 2;


    pub fn get_model_version(&self) -> &super::resources::ModelVersion {
        self.model_version.as_ref().unwrap_or_else(|| <super::resources::ModelVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_version(&mut self) {
        self.model_version.clear();
    }

    pub fn has_model_version(&self) -> bool {
        self.model_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_version(&mut self, v: super::resources::ModelVersion) {
        self.model_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version(&mut self) -> &mut super::resources::ModelVersion {
        if self.model_version.is_none() {
            self.model_version.set_default();
        }
        self.model_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_version(&mut self) -> super::resources::ModelVersion {
        self.model_version.take().unwrap_or_else(|| super::resources::ModelVersion::new())
    }
}

impl ::protobuf::Message for SingleModelVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_version.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelVersionResponse {
        SingleModelVersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelVersionResponse| { &m.status },
                |m: &mut SingleModelVersionResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_version",
                |m: &SingleModelVersionResponse| { &m.model_version },
                |m: &mut SingleModelVersionResponse| { &mut m.model_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelVersionResponse>(
                "SingleModelVersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelVersionResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelVersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelVersionResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelVersionResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelVersionResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_versions: ::protobuf::RepeatedField<super::resources::ModelVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionResponse {
    fn default() -> &'a MultiModelVersionResponse {
        <MultiModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionResponse {
    pub fn new() -> MultiModelVersionResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ModelVersion model_versions = 2;


    pub fn get_model_versions(&self) -> &[super::resources::ModelVersion] {
        &self.model_versions
    }
    pub fn clear_model_versions(&mut self) {
        self.model_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersion>) {
        self.model_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersion> {
        &mut self.model_versions
    }

    // Take field
    pub fn take_model_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersion> {
        ::std::mem::replace(&mut self.model_versions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_versions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.model_versions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelVersionResponse {
        MultiModelVersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelVersionResponse| { &m.status },
                |m: &mut MultiModelVersionResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_versions",
                |m: &MultiModelVersionResponse| { &m.model_versions },
                |m: &mut MultiModelVersionResponse| { &mut m.model_versions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelVersionResponse>(
                "MultiModelVersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelVersionResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelVersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelVersionResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelVersionResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_versions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub model_versions: ::protobuf::RepeatedField<super::resources::ModelVersion>,
    pub search: ::protobuf::SingularPtrField<super::resources::Search>,
    pub train_search: ::protobuf::SingularPtrField<super::resources::Search>,
    pub test_search: ::protobuf::SingularPtrField<super::resources::Search>,
    pub evaluate_after_training: bool,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsRequest {
    fn default() -> &'a PostModelVersionsRequest {
        <PostModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsRequest {
    pub fn new() -> PostModelVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelVersion model_versions = 3;


    pub fn get_model_versions(&self) -> &[super::resources::ModelVersion] {
        &self.model_versions
    }
    pub fn clear_model_versions(&mut self) {
        self.model_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersion>) {
        self.model_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersion> {
        &mut self.model_versions
    }

    // Take field
    pub fn take_model_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersion> {
        ::std::mem::replace(&mut self.model_versions, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Search search = 4;


    pub fn get_search(&self) -> &super::resources::Search {
        self.search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search(&mut self) {
        self.search.clear();
    }

    pub fn has_search(&self) -> bool {
        self.search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: super::resources::Search) {
        self.search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut super::resources::Search {
        if self.search.is_none() {
            self.search.set_default();
        }
        self.search.as_mut().unwrap()
    }

    // Take field
    pub fn take_search(&mut self) -> super::resources::Search {
        self.search.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Search train_search = 5;


    pub fn get_train_search(&self) -> &super::resources::Search {
        self.train_search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_train_search(&mut self) {
        self.train_search.clear();
    }

    pub fn has_train_search(&self) -> bool {
        self.train_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train_search(&mut self, v: super::resources::Search) {
        self.train_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_train_search(&mut self) -> &mut super::resources::Search {
        if self.train_search.is_none() {
            self.train_search.set_default();
        }
        self.train_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_train_search(&mut self) -> super::resources::Search {
        self.train_search.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Search test_search = 6;


    pub fn get_test_search(&self) -> &super::resources::Search {
        self.test_search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_test_search(&mut self) {
        self.test_search.clear();
    }

    pub fn has_test_search(&self) -> bool {
        self.test_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_search(&mut self, v: super::resources::Search) {
        self.test_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_search(&mut self) -> &mut super::resources::Search {
        if self.test_search.is_none() {
            self.test_search.set_default();
        }
        self.test_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_test_search(&mut self) -> super::resources::Search {
        self.test_search.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // bool evaluate_after_training = 7;


    pub fn get_evaluate_after_training(&self) -> bool {
        self.evaluate_after_training
    }
    pub fn clear_evaluate_after_training(&mut self) {
        self.evaluate_after_training = false;
    }

    // Param is passed by value, moved
    pub fn set_evaluate_after_training(&mut self, v: bool) {
        self.evaluate_after_training = v;
    }

    // string description = 8;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PostModelVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.train_search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.test_search {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_versions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.train_search)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.test_search)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.evaluate_after_training = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.train_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.evaluate_after_training != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.search.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.train_search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.test_search.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.evaluate_after_training != false {
            os.write_bool(7, self.evaluate_after_training)?;
        }
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelVersionsRequest {
        PostModelVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelVersionsRequest| { &m.user_app_id },
                |m: &mut PostModelVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelVersionsRequest| { &m.model_id },
                |m: &mut PostModelVersionsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_versions",
                |m: &PostModelVersionsRequest| { &m.model_versions },
                |m: &mut PostModelVersionsRequest| { &mut m.model_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "search",
                |m: &PostModelVersionsRequest| { &m.search },
                |m: &mut PostModelVersionsRequest| { &mut m.search },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "train_search",
                |m: &PostModelVersionsRequest| { &m.train_search },
                |m: &mut PostModelVersionsRequest| { &mut m.train_search },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "test_search",
                |m: &PostModelVersionsRequest| { &m.test_search },
                |m: &mut PostModelVersionsRequest| { &mut m.test_search },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "evaluate_after_training",
                |m: &PostModelVersionsRequest| { &m.evaluate_after_training },
                |m: &mut PostModelVersionsRequest| { &mut m.evaluate_after_training },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PostModelVersionsRequest| { &m.description },
                |m: &mut PostModelVersionsRequest| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelVersionsRequest>(
                "PostModelVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelVersionsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.search.clear();
        self.train_search.clear();
        self.test_search.clear();
        self.evaluate_after_training = false;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelVersionMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub max_examples: u32,
    pub test_search: ::protobuf::SingularPtrField<super::resources::Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelVersionMetricsRequest {
    fn default() -> &'a PostModelVersionMetricsRequest {
        <PostModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionMetricsRequest {
    pub fn new() -> PostModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // uint32 max_examples = 4;


    pub fn get_max_examples(&self) -> u32 {
        self.max_examples
    }
    pub fn clear_max_examples(&mut self) {
        self.max_examples = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_examples(&mut self, v: u32) {
        self.max_examples = v;
    }

    // .clarifai.api.Search test_search = 5;


    pub fn get_test_search(&self) -> &super::resources::Search {
        self.test_search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_test_search(&mut self) {
        self.test_search.clear();
    }

    pub fn has_test_search(&self) -> bool {
        self.test_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_search(&mut self, v: super::resources::Search) {
        self.test_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_search(&mut self) -> &mut super::resources::Search {
        if self.test_search.is_none() {
            self.test_search.set_default();
        }
        self.test_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_test_search(&mut self) -> super::resources::Search {
        self.test_search.take().unwrap_or_else(|| super::resources::Search::new())
    }
}

impl ::protobuf::Message for PostModelVersionMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.test_search {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_examples = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.test_search)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.max_examples != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_examples, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.max_examples != 0 {
            os.write_uint32(4, self.max_examples)?;
        }
        if let Some(ref v) = self.test_search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelVersionMetricsRequest {
        PostModelVersionMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelVersionMetricsRequest| { &m.user_app_id },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelVersionMetricsRequest| { &m.model_id },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &PostModelVersionMetricsRequest| { &m.version_id },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_examples",
                |m: &PostModelVersionMetricsRequest| { &m.max_examples },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.max_examples },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "test_search",
                |m: &PostModelVersionMetricsRequest| { &m.test_search },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.test_search },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelVersionMetricsRequest>(
                "PostModelVersionMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelVersionMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelVersionMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelVersionMetricsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelVersionMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.max_examples = 0;
        self.test_search.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelVersionMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub fields: ::protobuf::SingularPtrField<super::resources::FieldsValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelVersionMetricsRequest {
    fn default() -> &'a GetModelVersionMetricsRequest {
        <GetModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionMetricsRequest {
    pub fn new() -> GetModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // .clarifai.api.FieldsValue fields = 4;


    pub fn get_fields(&self) -> &super::resources::FieldsValue {
        self.fields.as_ref().unwrap_or_else(|| <super::resources::FieldsValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    pub fn has_fields(&self) -> bool {
        self.fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: super::resources::FieldsValue) {
        self.fields = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields(&mut self) -> &mut super::resources::FieldsValue {
        if self.fields.is_none() {
            self.fields.set_default();
        }
        self.fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_fields(&mut self) -> super::resources::FieldsValue {
        self.fields.take().unwrap_or_else(|| super::resources::FieldsValue::new())
    }
}

impl ::protobuf::Message for GetModelVersionMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(ref v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(ref v) = self.fields.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelVersionMetricsRequest {
        GetModelVersionMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelVersionMetricsRequest| { &m.user_app_id },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelVersionMetricsRequest| { &m.model_id },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &GetModelVersionMetricsRequest| { &m.version_id },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::FieldsValue>>(
                "fields",
                |m: &GetModelVersionMetricsRequest| { &m.fields },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelVersionMetricsRequest>(
                "GetModelVersionMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelVersionMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelVersionMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelVersionMetricsRequest::new)
    }
}

impl ::protobuf::Clear for GetModelVersionMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelTypeRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_type_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelTypeRequest {
    fn default() -> &'a GetModelTypeRequest {
        <GetModelTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelTypeRequest {
    pub fn new() -> GetModelTypeRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_type_id = 2;


    pub fn get_model_type_id(&self) -> &str {
        &self.model_type_id
    }
    pub fn clear_model_type_id(&mut self) {
        self.model_type_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_id(&mut self, v: ::std::string::String) {
        self.model_type_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_type_id
    }

    // Take field
    pub fn take_model_type_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_type_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModelTypeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_type_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(2, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelTypeRequest {
        GetModelTypeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelTypeRequest| { &m.user_app_id },
                |m: &mut GetModelTypeRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_type_id",
                |m: &GetModelTypeRequest| { &m.model_type_id },
                |m: &mut GetModelTypeRequest| { &mut m.model_type_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelTypeRequest>(
                "GetModelTypeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelTypeRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelTypeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelTypeRequest::new)
    }
}

impl ::protobuf::Clear for GetModelTypeRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_type_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelTypeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelTypesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelTypesRequest {
    fn default() -> &'a ListModelTypesRequest {
        <ListModelTypesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelTypesRequest {
    pub fn new() -> ListModelTypesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListModelTypesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelTypesRequest {
        ListModelTypesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelTypesRequest| { &m.user_app_id },
                |m: &mut ListModelTypesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelTypesRequest| { &m.page },
                |m: &mut ListModelTypesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelTypesRequest| { &m.per_page },
                |m: &mut ListModelTypesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelTypesRequest>(
                "ListModelTypesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelTypesRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelTypesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelTypesRequest::new)
    }
}

impl ::protobuf::Clear for ListModelTypesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelTypesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelTypesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelTypeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_type: ::protobuf::SingularPtrField<super::resources::ModelType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelTypeResponse {
    fn default() -> &'a SingleModelTypeResponse {
        <SingleModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelTypeResponse {
    pub fn new() -> SingleModelTypeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ModelType model_type = 2;


    pub fn get_model_type(&self) -> &super::resources::ModelType {
        self.model_type.as_ref().unwrap_or_else(|| <super::resources::ModelType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_type(&mut self) {
        self.model_type.clear();
    }

    pub fn has_model_type(&self) -> bool {
        self.model_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_type(&mut self, v: super::resources::ModelType) {
        self.model_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type(&mut self) -> &mut super::resources::ModelType {
        if self.model_type.is_none() {
            self.model_type.set_default();
        }
        self.model_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_type(&mut self) -> super::resources::ModelType {
        self.model_type.take().unwrap_or_else(|| super::resources::ModelType::new())
    }
}

impl ::protobuf::Message for SingleModelTypeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelTypeResponse {
        SingleModelTypeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelTypeResponse| { &m.status },
                |m: &mut SingleModelTypeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelType>>(
                "model_type",
                |m: &SingleModelTypeResponse| { &m.model_type },
                |m: &mut SingleModelTypeResponse| { &mut m.model_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelTypeResponse>(
                "SingleModelTypeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelTypeResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelTypeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelTypeResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelTypeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelTypeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelTypeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_types: ::protobuf::RepeatedField<super::resources::ModelType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelTypeResponse {
    fn default() -> &'a MultiModelTypeResponse {
        <MultiModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelTypeResponse {
    pub fn new() -> MultiModelTypeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ModelType model_types = 2;


    pub fn get_model_types(&self) -> &[super::resources::ModelType] {
        &self.model_types
    }
    pub fn clear_model_types(&mut self) {
        self.model_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_types(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelType>) {
        self.model_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_types(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelType> {
        &mut self.model_types
    }

    // Take field
    pub fn take_model_types(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelType> {
        ::std::mem::replace(&mut self.model_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelTypeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.model_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.model_types {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelTypeResponse {
        MultiModelTypeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelTypeResponse| { &m.status },
                |m: &mut MultiModelTypeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelType>>(
                "model_types",
                |m: &MultiModelTypeResponse| { &m.model_types },
                |m: &mut MultiModelTypeResponse| { &mut m.model_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelTypeResponse>(
                "MultiModelTypeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelTypeResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelTypeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelTypeResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelTypeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelTypeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiOutputResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub outputs: ::protobuf::RepeatedField<super::resources::Output>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiOutputResponse {
    fn default() -> &'a MultiOutputResponse {
        <MultiOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiOutputResponse {
    pub fn new() -> MultiOutputResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Output outputs = 2;


    pub fn get_outputs(&self) -> &[super::resources::Output] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Output>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Output> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Output> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiOutputResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.outputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiOutputResponse {
        MultiOutputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiOutputResponse| { &m.status },
                |m: &mut MultiOutputResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Output>>(
                "outputs",
                |m: &MultiOutputResponse| { &m.outputs },
                |m: &mut MultiOutputResponse| { &mut m.outputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiOutputResponse>(
                "MultiOutputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiOutputResponse {
        static instance: ::protobuf::rt::LazyV2<MultiOutputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiOutputResponse::new)
    }
}

impl ::protobuf::Clear for MultiOutputResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiOutputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListScopesRequest {
    // message fields
    pub key_type: ::std::string::String,
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListScopesRequest {
    fn default() -> &'a ListScopesRequest {
        <ListScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListScopesRequest {
    pub fn new() -> ListScopesRequest {
        ::std::default::Default::default()
    }

    // string key_type = 1;


    pub fn get_key_type(&self) -> &str {
        &self.key_type
    }
    pub fn clear_key_type(&mut self) {
        self.key_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: ::std::string::String) {
        self.key_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_type(&mut self) -> &mut ::std::string::String {
        &mut self.key_type
    }

    // Take field
    pub fn take_key_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_type, ::std::string::String::new())
    }

    // .clarifai.api.UserAppIDSet user_app_id = 2;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for ListScopesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_type);
        }
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key_type.is_empty() {
            os.write_string(1, &self.key_type)?;
        }
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListScopesRequest {
        ListScopesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_type",
                |m: &ListScopesRequest| { &m.key_type },
                |m: &mut ListScopesRequest| { &mut m.key_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListScopesRequest| { &m.user_app_id },
                |m: &mut ListScopesRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListScopesRequest>(
                "ListScopesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListScopesRequest {
        static instance: ::protobuf::rt::LazyV2<ListScopesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListScopesRequest::new)
    }
}

impl ::protobuf::Clear for ListScopesRequest {
    fn clear(&mut self) {
        self.key_type.clear();
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListScopesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MyScopesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyScopesRequest {
    fn default() -> &'a MyScopesRequest {
        <MyScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRequest {
    pub fn new() -> MyScopesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for MyScopesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyScopesRequest {
        MyScopesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &MyScopesRequest| { &m.user_app_id },
                |m: &mut MyScopesRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MyScopesRequest>(
                "MyScopesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MyScopesRequest {
        static instance: ::protobuf::rt::LazyV2<MyScopesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MyScopesRequest::new)
    }
}

impl ::protobuf::Clear for MyScopesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiScopeDepsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub scope_deps: ::protobuf::RepeatedField<super::resources::ScopeDeps>,
    pub endpoint_deps: ::protobuf::RepeatedField<super::resources::EndpointDeps>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiScopeDepsResponse {
    fn default() -> &'a MultiScopeDepsResponse {
        <MultiScopeDepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeDepsResponse {
    pub fn new() -> MultiScopeDepsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ScopeDeps scope_deps = 2;


    pub fn get_scope_deps(&self) -> &[super::resources::ScopeDeps] {
        &self.scope_deps
    }
    pub fn clear_scope_deps(&mut self) {
        self.scope_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope_deps(&mut self, v: ::protobuf::RepeatedField<super::resources::ScopeDeps>) {
        self.scope_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scope_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ScopeDeps> {
        &mut self.scope_deps
    }

    // Take field
    pub fn take_scope_deps(&mut self) -> ::protobuf::RepeatedField<super::resources::ScopeDeps> {
        ::std::mem::replace(&mut self.scope_deps, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.EndpointDeps endpoint_deps = 3;


    pub fn get_endpoint_deps(&self) -> &[super::resources::EndpointDeps] {
        &self.endpoint_deps
    }
    pub fn clear_endpoint_deps(&mut self) {
        self.endpoint_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint_deps(&mut self, v: ::protobuf::RepeatedField<super::resources::EndpointDeps>) {
        self.endpoint_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoint_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::EndpointDeps> {
        &mut self.endpoint_deps
    }

    // Take field
    pub fn take_endpoint_deps(&mut self) -> ::protobuf::RepeatedField<super::resources::EndpointDeps> {
        ::std::mem::replace(&mut self.endpoint_deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiScopeDepsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scope_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endpoint_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scope_deps)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.endpoint_deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scope_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.endpoint_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scope_deps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.endpoint_deps {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiScopeDepsResponse {
        MultiScopeDepsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiScopeDepsResponse| { &m.status },
                |m: &mut MultiScopeDepsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ScopeDeps>>(
                "scope_deps",
                |m: &MultiScopeDepsResponse| { &m.scope_deps },
                |m: &mut MultiScopeDepsResponse| { &mut m.scope_deps },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::EndpointDeps>>(
                "endpoint_deps",
                |m: &MultiScopeDepsResponse| { &m.endpoint_deps },
                |m: &mut MultiScopeDepsResponse| { &mut m.endpoint_deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiScopeDepsResponse>(
                "MultiScopeDepsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiScopeDepsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiScopeDepsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiScopeDepsResponse::new)
    }
}

impl ::protobuf::Clear for MultiScopeDepsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.scope_deps.clear();
        self.endpoint_deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiScopeDepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeDepsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiScopeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub app: ::protobuf::SingularPtrField<super::resources::App>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiScopeResponse {
    fn default() -> &'a MultiScopeResponse {
        <MultiScopeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeResponse {
    pub fn new() -> MultiScopeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string scopes = 2;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.App app = 3;


    pub fn get_app(&self) -> &super::resources::App {
        self.app.as_ref().unwrap_or_else(|| <super::resources::App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: super::resources::App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut super::resources::App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> super::resources::App {
        self.app.take().unwrap_or_else(|| super::resources::App::new())
    }

    // repeated string endpoints = 4;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiScopeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiScopeResponse {
        MultiScopeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiScopeResponse| { &m.status },
                |m: &mut MultiScopeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &MultiScopeResponse| { &m.scopes },
                |m: &mut MultiScopeResponse| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "app",
                |m: &MultiScopeResponse| { &m.app },
                |m: &mut MultiScopeResponse| { &mut m.app },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &MultiScopeResponse| { &m.endpoints },
                |m: &mut MultiScopeResponse| { &mut m.endpoints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiScopeResponse>(
                "MultiScopeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiScopeResponse {
        static instance: ::protobuf::rt::LazyV2<MultiScopeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiScopeResponse::new)
    }
}

impl ::protobuf::Clear for MultiScopeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.app.clear();
        self.endpoints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiScopeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSearchRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSearchRequest {
    fn default() -> &'a GetSearchRequest {
        <GetSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSearchRequest {
    pub fn new() -> GetSearchRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSearchRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSearchRequest {
        GetSearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetSearchRequest| { &m.user_app_id },
                |m: &mut GetSearchRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetSearchRequest| { &m.id },
                |m: &mut GetSearchRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSearchRequest>(
                "GetSearchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSearchRequest {
        static instance: ::protobuf::rt::LazyV2<GetSearchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSearchRequest::new)
    }
}

impl ::protobuf::Clear for GetSearchRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSearchesRequest {
    fn default() -> &'a ListSearchesRequest {
        <ListSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSearchesRequest {
    pub fn new() -> ListSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSearchesRequest {
        ListSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListSearchesRequest| { &m.user_app_id },
                |m: &mut ListSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListSearchesRequest| { &m.page },
                |m: &mut ListSearchesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListSearchesRequest| { &m.per_page },
                |m: &mut ListSearchesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSearchesRequest>(
                "ListSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<ListSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSearchesRequest::new)
    }
}

impl ::protobuf::Clear for ListSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub query: ::protobuf::SingularPtrField<super::resources::Query>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostSearchesRequest {
    fn default() -> &'a PostSearchesRequest {
        <PostSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesRequest {
    pub fn new() -> PostSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.Query query = 2;


    pub fn get_query(&self) -> &super::resources::Query {
        self.query.as_ref().unwrap_or_else(|| <super::resources::Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::resources::Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut super::resources::Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> super::resources::Query {
        self.query.take().unwrap_or_else(|| super::resources::Query::new())
    }

    // repeated .clarifai.api.Search searches = 3;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Pagination pagination = 4;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostSearchesRequest {
        PostSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostSearchesRequest| { &m.user_app_id },
                |m: &mut PostSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Query>>(
                "query",
                |m: &PostSearchesRequest| { &m.query },
                |m: &mut PostSearchesRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PostSearchesRequest| { &m.searches },
                |m: &mut PostSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostSearchesRequest| { &m.pagination },
                |m: &mut PostSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostSearchesRequest>(
                "PostSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.query.clear();
        self.searches.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostSearchesByIDRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostSearchesByIDRequest {
    fn default() -> &'a PostSearchesByIDRequest {
        <PostSearchesByIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesByIDRequest {
    pub fn new() -> PostSearchesByIDRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostSearchesByIDRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostSearchesByIDRequest {
        PostSearchesByIDRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostSearchesByIDRequest| { &m.user_app_id },
                |m: &mut PostSearchesByIDRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PostSearchesByIDRequest| { &m.id },
                |m: &mut PostSearchesByIDRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostSearchesByIDRequest| { &m.pagination },
                |m: &mut PostSearchesByIDRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostSearchesByIDRequest>(
                "PostSearchesByIDRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostSearchesByIDRequest {
        static instance: ::protobuf::rt::LazyV2<PostSearchesByIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostSearchesByIDRequest::new)
    }
}

impl ::protobuf::Clear for PostSearchesByIDRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostSearchesByIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesByIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSearchRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSearchRequest {
    fn default() -> &'a DeleteSearchRequest {
        <DeleteSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSearchRequest {
    pub fn new() -> DeleteSearchRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSearchRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSearchRequest {
        DeleteSearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteSearchRequest| { &m.user_app_id },
                |m: &mut DeleteSearchRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DeleteSearchRequest| { &m.id },
                |m: &mut DeleteSearchRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSearchRequest>(
                "DeleteSearchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSearchRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSearchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSearchRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSearchRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAnnotationsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsSearchesRequest {
    fn default() -> &'a PostAnnotationsSearchesRequest {
        <PostAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsSearchesRequest {
    pub fn new() -> PostAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostAnnotationsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAnnotationsSearchesRequest {
        PostAnnotationsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAnnotationsSearchesRequest| { &m.user_app_id },
                |m: &mut PostAnnotationsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PostAnnotationsSearchesRequest| { &m.searches },
                |m: &mut PostAnnotationsSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostAnnotationsSearchesRequest| { &m.pagination },
                |m: &mut PostAnnotationsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAnnotationsSearchesRequest>(
                "PostAnnotationsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAnnotationsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostAnnotationsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAnnotationsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostAnnotationsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationSearchMetricsRequest {
    fn default() -> &'a DeleteAnnotationSearchMetricsRequest {
        <DeleteAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationSearchMetricsRequest {
    pub fn new() -> DeleteAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAnnotationSearchMetricsRequest {
        DeleteAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DeleteAnnotationSearchMetricsRequest| { &m.id },
                |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAnnotationSearchMetricsRequest>(
                "DeleteAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostInputsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostInputsSearchesRequest {
    fn default() -> &'a PostInputsSearchesRequest {
        <PostInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsSearchesRequest {
    pub fn new() -> PostInputsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostInputsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostInputsSearchesRequest {
        PostInputsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostInputsSearchesRequest| { &m.user_app_id },
                |m: &mut PostInputsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PostInputsSearchesRequest| { &m.searches },
                |m: &mut PostInputsSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostInputsSearchesRequest| { &m.pagination },
                |m: &mut PostInputsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostInputsSearchesRequest>(
                "PostInputsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostInputsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostInputsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostInputsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostInputsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleSearchResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub search: ::protobuf::SingularPtrField<super::resources::Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleSearchResponse {
    fn default() -> &'a SingleSearchResponse {
        <SingleSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleSearchResponse {
    pub fn new() -> SingleSearchResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Search search = 5;


    pub fn get_search(&self) -> &super::resources::Search {
        self.search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search(&mut self) {
        self.search.clear();
    }

    pub fn has_search(&self) -> bool {
        self.search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: super::resources::Search) {
        self.search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut super::resources::Search {
        if self.search.is_none() {
            self.search.set_default();
        }
        self.search.as_mut().unwrap()
    }

    // Take field
    pub fn take_search(&mut self) -> super::resources::Search {
        self.search.take().unwrap_or_else(|| super::resources::Search::new())
    }
}

impl ::protobuf::Message for SingleSearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleSearchResponse {
        SingleSearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleSearchResponse| { &m.status },
                |m: &mut SingleSearchResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "search",
                |m: &SingleSearchResponse| { &m.search },
                |m: &mut SingleSearchResponse| { &mut m.search },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleSearchResponse>(
                "SingleSearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleSearchResponse {
        static instance: ::protobuf::rt::LazyV2<SingleSearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleSearchResponse::new)
    }
}

impl ::protobuf::Clear for SingleSearchResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.search.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiSearchResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub id: ::std::string::String,
    pub hits: ::protobuf::RepeatedField<super::resources::Hit>,
    pub query: ::protobuf::SingularPtrField<super::resources::Query>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiSearchResponse {
    fn default() -> &'a MultiSearchResponse {
        <MultiSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiSearchResponse {
    pub fn new() -> MultiSearchResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Hit hits = 3;


    pub fn get_hits(&self) -> &[super::resources::Hit] {
        &self.hits
    }
    pub fn clear_hits(&mut self) {
        self.hits.clear();
    }

    // Param is passed by value, moved
    pub fn set_hits(&mut self, v: ::protobuf::RepeatedField<super::resources::Hit>) {
        self.hits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hits(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Hit> {
        &mut self.hits
    }

    // Take field
    pub fn take_hits(&mut self) -> ::protobuf::RepeatedField<super::resources::Hit> {
        ::std::mem::replace(&mut self.hits, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Query query = 4;


    pub fn get_query(&self) -> &super::resources::Query {
        self.query.as_ref().unwrap_or_else(|| <super::resources::Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::resources::Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut super::resources::Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> super::resources::Query {
        self.query.take().unwrap_or_else(|| super::resources::Query::new())
    }

    // repeated .clarifai.api.Search searches = 5;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiSearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hits)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.hits {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiSearchResponse {
        MultiSearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiSearchResponse| { &m.status },
                |m: &mut MultiSearchResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MultiSearchResponse| { &m.id },
                |m: &mut MultiSearchResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Hit>>(
                "hits",
                |m: &MultiSearchResponse| { &m.hits },
                |m: &mut MultiSearchResponse| { &mut m.hits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Query>>(
                "query",
                |m: &MultiSearchResponse| { &m.query },
                |m: &mut MultiSearchResponse| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &MultiSearchResponse| { &m.searches },
                |m: &mut MultiSearchResponse| { &mut m.searches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiSearchResponse>(
                "MultiSearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiSearchResponse {
        static instance: ::protobuf::rt::LazyV2<MultiSearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiSearchResponse::new)
    }
}

impl ::protobuf::Clear for MultiSearchResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.hits.clear();
        self.query.clear();
        self.searches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    pub ground_truth: ::protobuf::SingularPtrField<super::resources::Search>,
    pub search_to_eval: ::protobuf::SingularPtrField<super::resources::Search>,
    pub data: ::protobuf::SingularPtrField<super::resources::Data>,
    pub evaluation_type: super::resources::EvaluationType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAnnotationSearchMetricsRequest {
    fn default() -> &'a PostAnnotationSearchMetricsRequest {
        <PostAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationSearchMetricsRequest {
    pub fn new() -> PostAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Search ground_truth = 3;


    pub fn get_ground_truth(&self) -> &super::resources::Search {
        self.ground_truth.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ground_truth(&mut self) {
        self.ground_truth.clear();
    }

    pub fn has_ground_truth(&self) -> bool {
        self.ground_truth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ground_truth(&mut self, v: super::resources::Search) {
        self.ground_truth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ground_truth(&mut self) -> &mut super::resources::Search {
        if self.ground_truth.is_none() {
            self.ground_truth.set_default();
        }
        self.ground_truth.as_mut().unwrap()
    }

    // Take field
    pub fn take_ground_truth(&mut self) -> super::resources::Search {
        self.ground_truth.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Search search_to_eval = 4;


    pub fn get_search_to_eval(&self) -> &super::resources::Search {
        self.search_to_eval.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search_to_eval(&mut self) {
        self.search_to_eval.clear();
    }

    pub fn has_search_to_eval(&self) -> bool {
        self.search_to_eval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_to_eval(&mut self, v: super::resources::Search) {
        self.search_to_eval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_to_eval(&mut self) -> &mut super::resources::Search {
        if self.search_to_eval.is_none() {
            self.search_to_eval.set_default();
        }
        self.search_to_eval.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_to_eval(&mut self) -> super::resources::Search {
        self.search_to_eval.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Data data = 5;


    pub fn get_data(&self) -> &super::resources::Data {
        self.data.as_ref().unwrap_or_else(|| <super::resources::Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::resources::Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::resources::Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::resources::Data {
        self.data.take().unwrap_or_else(|| super::resources::Data::new())
    }

    // .clarifai.api.EvaluationType evaluation_type = 6;


    pub fn get_evaluation_type(&self) -> super::resources::EvaluationType {
        self.evaluation_type
    }
    pub fn clear_evaluation_type(&mut self) {
        self.evaluation_type = super::resources::EvaluationType::Classification;
    }

    // Param is passed by value, moved
    pub fn set_evaluation_type(&mut self, v: super::resources::EvaluationType) {
        self.evaluation_type = v;
    }
}

impl ::protobuf::Message for PostAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ground_truth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search_to_eval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ground_truth)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search_to_eval)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.evaluation_type, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(ref v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.evaluation_type != super::resources::EvaluationType::Classification {
            my_size += ::protobuf::rt::enum_size(6, self.evaluation_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(ref v) = self.ground_truth.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.search_to_eval.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.evaluation_type != super::resources::EvaluationType::Classification {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.evaluation_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAnnotationSearchMetricsRequest {
        PostAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PostAnnotationSearchMetricsRequest| { &m.id },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "ground_truth",
                |m: &PostAnnotationSearchMetricsRequest| { &m.ground_truth },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.ground_truth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "search_to_eval",
                |m: &PostAnnotationSearchMetricsRequest| { &m.search_to_eval },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.search_to_eval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Data>>(
                "data",
                |m: &PostAnnotationSearchMetricsRequest| { &m.data },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::resources::EvaluationType>>(
                "evaluation_type",
                |m: &PostAnnotationSearchMetricsRequest| { &m.evaluation_type },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.evaluation_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAnnotationSearchMetricsRequest>(
                "PostAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for PostAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.data.clear();
        self.evaluation_type = super::resources::EvaluationType::Classification;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAnnotationSearchMetricsRequest {
    fn default() -> &'a GetAnnotationSearchMetricsRequest {
        <GetAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationSearchMetricsRequest {
    pub fn new() -> GetAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAnnotationSearchMetricsRequest {
        GetAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetAnnotationSearchMetricsRequest| { &m.id },
                |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAnnotationSearchMetricsRequest>(
                "GetAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<GetAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for GetAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAnnotationSearchMetricsRequest {
    fn default() -> &'a ListAnnotationSearchMetricsRequest {
        <ListAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationSearchMetricsRequest {
    pub fn new() -> ListAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for ListAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAnnotationSearchMetricsRequest {
        ListAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut ListAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAnnotationSearchMetricsRequest>(
                "ListAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for ListAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAnnotationSearchMetricsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub annotation_search_metrics: ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationSearchMetricsResponse {
    fn default() -> &'a MultiAnnotationSearchMetricsResponse {
        <MultiAnnotationSearchMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationSearchMetricsResponse {
    pub fn new() -> MultiAnnotationSearchMetricsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.AnnotationSearchMetrics annotation_search_metrics = 2;


    pub fn get_annotation_search_metrics(&self) -> &[super::resources::AnnotationSearchMetrics] {
        &self.annotation_search_metrics
    }
    pub fn clear_annotation_search_metrics(&mut self) {
        self.annotation_search_metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_search_metrics(&mut self, v: ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics>) {
        self.annotation_search_metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_search_metrics(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics> {
        &mut self.annotation_search_metrics
    }

    // Take field
    pub fn take_annotation_search_metrics(&mut self) -> ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics> {
        ::std::mem::replace(&mut self.annotation_search_metrics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAnnotationSearchMetricsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_search_metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_search_metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotation_search_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotation_search_metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAnnotationSearchMetricsResponse {
        MultiAnnotationSearchMetricsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAnnotationSearchMetricsResponse| { &m.status },
                |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AnnotationSearchMetrics>>(
                "annotation_search_metrics",
                |m: &MultiAnnotationSearchMetricsResponse| { &m.annotation_search_metrics },
                |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.annotation_search_metrics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAnnotationSearchMetricsResponse>(
                "MultiAnnotationSearchMetricsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAnnotationSearchMetricsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAnnotationSearchMetricsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAnnotationSearchMetricsResponse::new)
    }
}

impl ::protobuf::Clear for MultiAnnotationSearchMetricsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.annotation_search_metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAnnotationSearchMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationSearchMetricsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostValidatePasswordRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub password: ::protobuf::SingularPtrField<super::resources::Password>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostValidatePasswordRequest {
    fn default() -> &'a PostValidatePasswordRequest {
        <PostValidatePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostValidatePasswordRequest {
    pub fn new() -> PostValidatePasswordRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.Password password = 2;


    pub fn get_password(&self) -> &super::resources::Password {
        self.password.as_ref().unwrap_or_else(|| <super::resources::Password as ::protobuf::Message>::default_instance())
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: super::resources::Password) {
        self.password = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut super::resources::Password {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> super::resources::Password {
        self.password.take().unwrap_or_else(|| super::resources::Password::new())
    }
}

impl ::protobuf::Message for PostValidatePasswordRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.password {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.password.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostValidatePasswordRequest {
        PostValidatePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostValidatePasswordRequest| { &m.user_app_id },
                |m: &mut PostValidatePasswordRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Password>>(
                "password",
                |m: &PostValidatePasswordRequest| { &m.password },
                |m: &mut PostValidatePasswordRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostValidatePasswordRequest>(
                "PostValidatePasswordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostValidatePasswordRequest {
        static instance: ::protobuf::rt::LazyV2<PostValidatePasswordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostValidatePasswordRequest::new)
    }
}

impl ::protobuf::Clear for PostValidatePasswordRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostValidatePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostValidatePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SinglePasswordValidationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub password_violations: ::protobuf::SingularPtrField<super::resources::PasswordViolations>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SinglePasswordValidationResponse {
    fn default() -> &'a SinglePasswordValidationResponse {
        <SinglePasswordValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SinglePasswordValidationResponse {
    pub fn new() -> SinglePasswordValidationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.PasswordViolations password_violations = 2;


    pub fn get_password_violations(&self) -> &super::resources::PasswordViolations {
        self.password_violations.as_ref().unwrap_or_else(|| <super::resources::PasswordViolations as ::protobuf::Message>::default_instance())
    }
    pub fn clear_password_violations(&mut self) {
        self.password_violations.clear();
    }

    pub fn has_password_violations(&self) -> bool {
        self.password_violations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_violations(&mut self, v: super::resources::PasswordViolations) {
        self.password_violations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_violations(&mut self) -> &mut super::resources::PasswordViolations {
        if self.password_violations.is_none() {
            self.password_violations.set_default();
        }
        self.password_violations.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_violations(&mut self) -> super::resources::PasswordViolations {
        self.password_violations.take().unwrap_or_else(|| super::resources::PasswordViolations::new())
    }
}

impl ::protobuf::Message for SinglePasswordValidationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.password_violations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.password_violations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.password_violations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.password_violations.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SinglePasswordValidationResponse {
        SinglePasswordValidationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SinglePasswordValidationResponse| { &m.status },
                |m: &mut SinglePasswordValidationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::PasswordViolations>>(
                "password_violations",
                |m: &SinglePasswordValidationResponse| { &m.password_violations },
                |m: &mut SinglePasswordValidationResponse| { &mut m.password_violations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SinglePasswordValidationResponse>(
                "SinglePasswordValidationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SinglePasswordValidationResponse {
        static instance: ::protobuf::rt::LazyV2<SinglePasswordValidationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SinglePasswordValidationResponse::new)
    }
}

impl ::protobuf::Clear for SinglePasswordValidationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.password_violations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SinglePasswordValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePasswordValidationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWorkflowRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub favor_clarifai_workflows: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWorkflowRequest {
    fn default() -> &'a GetWorkflowRequest {
        <GetWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowRequest {
    pub fn new() -> GetWorkflowRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // bool favor_clarifai_workflows = 3;


    pub fn get_favor_clarifai_workflows(&self) -> bool {
        self.favor_clarifai_workflows
    }
    pub fn clear_favor_clarifai_workflows(&mut self) {
        self.favor_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_favor_clarifai_workflows(&mut self, v: bool) {
        self.favor_clarifai_workflows = v;
    }
}

impl ::protobuf::Message for GetWorkflowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favor_clarifai_workflows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.favor_clarifai_workflows != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(3, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWorkflowRequest {
        GetWorkflowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetWorkflowRequest| { &m.user_app_id },
                |m: &mut GetWorkflowRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &GetWorkflowRequest| { &m.workflow_id },
                |m: &mut GetWorkflowRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favor_clarifai_workflows",
                |m: &GetWorkflowRequest| { &m.favor_clarifai_workflows },
                |m: &mut GetWorkflowRequest| { &mut m.favor_clarifai_workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetWorkflowRequest>(
                "GetWorkflowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetWorkflowRequest {
        static instance: ::protobuf::rt::LazyV2<GetWorkflowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWorkflowRequest::new)
    }
}

impl ::protobuf::Clear for GetWorkflowRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.favor_clarifai_workflows = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWorkflowsRequest {
    fn default() -> &'a ListWorkflowsRequest {
        <ListWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowsRequest {
    pub fn new() -> ListWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWorkflowsRequest {
        ListWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListWorkflowsRequest| { &m.user_app_id },
                |m: &mut ListWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListWorkflowsRequest| { &m.page },
                |m: &mut ListWorkflowsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListWorkflowsRequest| { &m.per_page },
                |m: &mut ListWorkflowsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListWorkflowsRequest>(
                "ListWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<ListWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for ListWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflows: ::protobuf::RepeatedField<super::resources::Workflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowsRequest {
    fn default() -> &'a PostWorkflowsRequest {
        <PostWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowsRequest {
    pub fn new() -> PostWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Workflow workflows = 2;


    pub fn get_workflows(&self) -> &[super::resources::Workflow] {
        &self.workflows
    }
    pub fn clear_workflows(&mut self) {
        self.workflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflows(&mut self, v: ::protobuf::RepeatedField<super::resources::Workflow>) {
        self.workflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflows(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Workflow> {
        &mut self.workflows
    }

    // Take field
    pub fn take_workflows(&mut self) -> ::protobuf::RepeatedField<super::resources::Workflow> {
        ::std::mem::replace(&mut self.workflows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowsRequest {
        PostWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostWorkflowsRequest| { &m.user_app_id },
                |m: &mut PostWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflows",
                |m: &PostWorkflowsRequest| { &m.workflows },
                |m: &mut PostWorkflowsRequest| { &mut m.workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowsRequest>(
                "PostWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for PostWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflows: ::protobuf::RepeatedField<super::resources::Workflow>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowsRequest {
    fn default() -> &'a PatchWorkflowsRequest {
        <PatchWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowsRequest {
    pub fn new() -> PatchWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Workflow workflows = 2;


    pub fn get_workflows(&self) -> &[super::resources::Workflow] {
        &self.workflows
    }
    pub fn clear_workflows(&mut self) {
        self.workflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflows(&mut self, v: ::protobuf::RepeatedField<super::resources::Workflow>) {
        self.workflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflows(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Workflow> {
        &mut self.workflows
    }

    // Take field
    pub fn take_workflows(&mut self) -> ::protobuf::RepeatedField<super::resources::Workflow> {
        ::std::mem::replace(&mut self.workflows, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflows)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchWorkflowsRequest {
        PatchWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchWorkflowsRequest| { &m.user_app_id },
                |m: &mut PatchWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflows",
                |m: &PatchWorkflowsRequest| { &m.workflows },
                |m: &mut PatchWorkflowsRequest| { &mut m.workflows },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchWorkflowsRequest| { &m.action },
                |m: &mut PatchWorkflowsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchWorkflowsRequest>(
                "PatchWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for PatchWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkflowRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowRequest {
    fn default() -> &'a DeleteWorkflowRequest {
        <DeleteWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowRequest {
    pub fn new() -> DeleteWorkflowRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWorkflowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkflowRequest {
        DeleteWorkflowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteWorkflowRequest| { &m.user_app_id },
                |m: &mut DeleteWorkflowRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &DeleteWorkflowRequest| { &m.workflow_id },
                |m: &mut DeleteWorkflowRequest| { &mut m.workflow_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkflowRequest>(
                "DeleteWorkflowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkflowRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkflowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkflowRequest::new)
    }
}

impl ::protobuf::Clear for DeleteWorkflowRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub delete_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowsRequest {
    fn default() -> &'a DeleteWorkflowsRequest {
        <DeleteWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowsRequest {
    pub fn new() -> DeleteWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool delete_all = 3;


    pub fn get_delete_all(&self) -> bool {
        self.delete_all
    }
    pub fn clear_delete_all(&mut self) {
        self.delete_all = false;
    }

    // Param is passed by value, moved
    pub fn set_delete_all(&mut self, v: bool) {
        self.delete_all = v;
    }
}

impl ::protobuf::Message for DeleteWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkflowsRequest {
        DeleteWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteWorkflowsRequest| { &m.user_app_id },
                |m: &mut DeleteWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteWorkflowsRequest| { &m.ids },
                |m: &mut DeleteWorkflowsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_all",
                |m: &DeleteWorkflowsRequest| { &m.delete_all },
                |m: &mut DeleteWorkflowsRequest| { &mut m.delete_all },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkflowsRequest>(
                "DeleteWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleWorkflowResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflow: ::protobuf::SingularPtrField<super::resources::Workflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowResponse {
    fn default() -> &'a SingleWorkflowResponse {
        <SingleWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowResponse {
    pub fn new() -> SingleWorkflowResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Workflow workflow = 2;


    pub fn get_workflow(&self) -> &super::resources::Workflow {
        self.workflow.as_ref().unwrap_or_else(|| <super::resources::Workflow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow(&mut self) {
        self.workflow.clear();
    }

    pub fn has_workflow(&self) -> bool {
        self.workflow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: super::resources::Workflow) {
        self.workflow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow(&mut self) -> &mut super::resources::Workflow {
        if self.workflow.is_none() {
            self.workflow.set_default();
        }
        self.workflow.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow(&mut self) -> super::resources::Workflow {
        self.workflow.take().unwrap_or_else(|| super::resources::Workflow::new())
    }
}

impl ::protobuf::Message for SingleWorkflowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleWorkflowResponse {
        SingleWorkflowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleWorkflowResponse| { &m.status },
                |m: &mut SingleWorkflowResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflow",
                |m: &SingleWorkflowResponse| { &m.workflow },
                |m: &mut SingleWorkflowResponse| { &mut m.workflow },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleWorkflowResponse>(
                "SingleWorkflowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleWorkflowResponse {
        static instance: ::protobuf::rt::LazyV2<SingleWorkflowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleWorkflowResponse::new)
    }
}

impl ::protobuf::Clear for SingleWorkflowResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiWorkflowResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflows: ::protobuf::RepeatedField<super::resources::Workflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowResponse {
    fn default() -> &'a MultiWorkflowResponse {
        <MultiWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowResponse {
    pub fn new() -> MultiWorkflowResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Workflow workflows = 2;


    pub fn get_workflows(&self) -> &[super::resources::Workflow] {
        &self.workflows
    }
    pub fn clear_workflows(&mut self) {
        self.workflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflows(&mut self, v: ::protobuf::RepeatedField<super::resources::Workflow>) {
        self.workflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflows(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Workflow> {
        &mut self.workflows
    }

    // Take field
    pub fn take_workflows(&mut self) -> ::protobuf::RepeatedField<super::resources::Workflow> {
        ::std::mem::replace(&mut self.workflows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiWorkflowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiWorkflowResponse {
        MultiWorkflowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiWorkflowResponse| { &m.status },
                |m: &mut MultiWorkflowResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflows",
                |m: &MultiWorkflowResponse| { &m.workflows },
                |m: &mut MultiWorkflowResponse| { &mut m.workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiWorkflowResponse>(
                "MultiWorkflowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiWorkflowResponse {
        static instance: ::protobuf::rt::LazyV2<MultiWorkflowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiWorkflowResponse::new)
    }
}

impl ::protobuf::Clear for MultiWorkflowResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub output_config: ::protobuf::SingularPtrField<super::resources::OutputConfig>,
    pub favor_clarifai_workflows: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsRequest {
    fn default() -> &'a PostWorkflowResultsRequest {
        <PostWorkflowResultsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsRequest {
    pub fn new() -> PostWorkflowResultsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Input inputs = 3;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.OutputConfig output_config = 4;


    pub fn get_output_config(&self) -> &super::resources::OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <super::resources::OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: super::resources::OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut super::resources::OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> super::resources::OutputConfig {
        self.output_config.take().unwrap_or_else(|| super::resources::OutputConfig::new())
    }

    // bool favor_clarifai_workflows = 5;


    pub fn get_favor_clarifai_workflows(&self) -> bool {
        self.favor_clarifai_workflows
    }
    pub fn clear_favor_clarifai_workflows(&mut self) {
        self.favor_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_favor_clarifai_workflows(&mut self, v: bool) {
        self.favor_clarifai_workflows = v;
    }
}

impl ::protobuf::Message for PostWorkflowResultsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favor_clarifai_workflows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.favor_clarifai_workflows != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(5, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsRequest {
        PostWorkflowResultsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostWorkflowResultsRequest| { &m.user_app_id },
                |m: &mut PostWorkflowResultsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &PostWorkflowResultsRequest| { &m.workflow_id },
                |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PostWorkflowResultsRequest| { &m.inputs },
                |m: &mut PostWorkflowResultsRequest| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::OutputConfig>>(
                "output_config",
                |m: &PostWorkflowResultsRequest| { &m.output_config },
                |m: &mut PostWorkflowResultsRequest| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favor_clarifai_workflows",
                |m: &PostWorkflowResultsRequest| { &m.favor_clarifai_workflows },
                |m: &mut PostWorkflowResultsRequest| { &mut m.favor_clarifai_workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsRequest>(
                "PostWorkflowResultsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsRequest {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsRequest::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.inputs.clear();
        self.output_config.clear();
        self.favor_clarifai_workflows = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflow: ::protobuf::SingularPtrField<super::resources::Workflow>,
    pub results: ::protobuf::RepeatedField<super::resources::WorkflowResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsResponse {
    fn default() -> &'a PostWorkflowResultsResponse {
        <PostWorkflowResultsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsResponse {
    pub fn new() -> PostWorkflowResultsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Workflow workflow = 2;


    pub fn get_workflow(&self) -> &super::resources::Workflow {
        self.workflow.as_ref().unwrap_or_else(|| <super::resources::Workflow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow(&mut self) {
        self.workflow.clear();
    }

    pub fn has_workflow(&self) -> bool {
        self.workflow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: super::resources::Workflow) {
        self.workflow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow(&mut self) -> &mut super::resources::Workflow {
        if self.workflow.is_none() {
            self.workflow.set_default();
        }
        self.workflow.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow(&mut self) -> super::resources::Workflow {
        self.workflow.take().unwrap_or_else(|| super::resources::Workflow::new())
    }

    // repeated .clarifai.api.WorkflowResult results = 3;


    pub fn get_results(&self) -> &[super::resources::WorkflowResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::resources::WorkflowResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::WorkflowResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::resources::WorkflowResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostWorkflowResultsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.results {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsResponse {
        PostWorkflowResultsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &PostWorkflowResultsResponse| { &m.status },
                |m: &mut PostWorkflowResultsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflow",
                |m: &PostWorkflowResultsResponse| { &m.workflow },
                |m: &mut PostWorkflowResultsResponse| { &mut m.workflow },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowResult>>(
                "results",
                |m: &PostWorkflowResultsResponse| { &m.results },
                |m: &mut PostWorkflowResultsResponse| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsResponse>(
                "PostWorkflowResultsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsResponse {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsResponse::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsSimilarityRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub probe_inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub pool_inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub favor_clarifai_workflows: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityRequest {
    fn default() -> &'a PostWorkflowResultsSimilarityRequest {
        <PostWorkflowResultsSimilarityRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityRequest {
    pub fn new() -> PostWorkflowResultsSimilarityRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // string model_version_id = 3;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Input probe_inputs = 4;


    pub fn get_probe_inputs(&self) -> &[super::resources::Input] {
        &self.probe_inputs
    }
    pub fn clear_probe_inputs(&mut self) {
        self.probe_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_probe_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.probe_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_probe_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.probe_inputs
    }

    // Take field
    pub fn take_probe_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.probe_inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Input pool_inputs = 5;


    pub fn get_pool_inputs(&self) -> &[super::resources::Input] {
        &self.pool_inputs
    }
    pub fn clear_pool_inputs(&mut self) {
        self.pool_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pool_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.pool_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pool_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.pool_inputs
    }

    // Take field
    pub fn take_pool_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.pool_inputs, ::protobuf::RepeatedField::new())
    }

    // bool favor_clarifai_workflows = 6;


    pub fn get_favor_clarifai_workflows(&self) -> bool {
        self.favor_clarifai_workflows
    }
    pub fn clear_favor_clarifai_workflows(&mut self) {
        self.favor_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_favor_clarifai_workflows(&mut self, v: bool) {
        self.favor_clarifai_workflows = v;
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.probe_inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pool_inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.probe_inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pool_inputs)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favor_clarifai_workflows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.probe_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pool_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.favor_clarifai_workflows != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.probe_inputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pool_inputs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.favor_clarifai_workflows != false {
            os.write_bool(6, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsSimilarityRequest {
        PostWorkflowResultsSimilarityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.user_app_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.workflow_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.model_version_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "probe_inputs",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.probe_inputs },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.probe_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "pool_inputs",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.pool_inputs },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.pool_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favor_clarifai_workflows",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.favor_clarifai_workflows },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.favor_clarifai_workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsSimilarityRequest>(
                "PostWorkflowResultsSimilarityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityRequest {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsSimilarityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsSimilarityRequest::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsSimilarityRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.model_version_id.clear();
        self.probe_inputs.clear();
        self.pool_inputs.clear();
        self.favor_clarifai_workflows = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsSimilarityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsSimilarityResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub results: ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityResponse {
    fn default() -> &'a PostWorkflowResultsSimilarityResponse {
        <PostWorkflowResultsSimilarityResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityResponse {
    pub fn new() -> PostWorkflowResultsSimilarityResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.WorkflowResultsSimilarity results = 2;


    pub fn get_results(&self) -> &[super::resources::WorkflowResultsSimilarity] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsSimilarityResponse {
        PostWorkflowResultsSimilarityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &PostWorkflowResultsSimilarityResponse| { &m.status },
                |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowResultsSimilarity>>(
                "results",
                |m: &PostWorkflowResultsSimilarityResponse| { &m.results },
                |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsSimilarityResponse>(
                "PostWorkflowResultsSimilarityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityResponse {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsSimilarityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsSimilarityResponse::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsSimilarityResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsSimilarityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAppDuplicationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub app_duplications: ::protobuf::RepeatedField<super::resources::AppDuplication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAppDuplicationsRequest {
    fn default() -> &'a PostAppDuplicationsRequest {
        <PostAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppDuplicationsRequest {
    pub fn new() -> PostAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.AppDuplication app_duplications = 2;


    pub fn get_app_duplications(&self) -> &[super::resources::AppDuplication] {
        &self.app_duplications
    }
    pub fn clear_app_duplications(&mut self) {
        self.app_duplications.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_duplications(&mut self, v: ::protobuf::RepeatedField<super::resources::AppDuplication>) {
        self.app_duplications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_duplications(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::AppDuplication> {
        &mut self.app_duplications
    }

    // Take field
    pub fn take_app_duplications(&mut self) -> ::protobuf::RepeatedField<super::resources::AppDuplication> {
        ::std::mem::replace(&mut self.app_duplications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostAppDuplicationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_duplications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_duplications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.app_duplications {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAppDuplicationsRequest {
        PostAppDuplicationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAppDuplicationsRequest| { &m.user_app_id },
                |m: &mut PostAppDuplicationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppDuplication>>(
                "app_duplications",
                |m: &PostAppDuplicationsRequest| { &m.app_duplications },
                |m: &mut PostAppDuplicationsRequest| { &mut m.app_duplications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAppDuplicationsRequest>(
                "PostAppDuplicationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAppDuplicationsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAppDuplicationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAppDuplicationsRequest::new)
    }
}

impl ::protobuf::Clear for PostAppDuplicationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppDuplicationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAppDuplicationRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub app_duplication_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAppDuplicationRequest {
    fn default() -> &'a GetAppDuplicationRequest {
        <GetAppDuplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppDuplicationRequest {
    pub fn new() -> GetAppDuplicationRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string app_duplication_id = 2;


    pub fn get_app_duplication_id(&self) -> &str {
        &self.app_duplication_id
    }
    pub fn clear_app_duplication_id(&mut self) {
        self.app_duplication_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_duplication_id(&mut self, v: ::std::string::String) {
        self.app_duplication_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_duplication_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_duplication_id
    }

    // Take field
    pub fn take_app_duplication_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_duplication_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAppDuplicationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_duplication_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_duplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_duplication_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_duplication_id.is_empty() {
            os.write_string(2, &self.app_duplication_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAppDuplicationRequest {
        GetAppDuplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAppDuplicationRequest| { &m.user_app_id },
                |m: &mut GetAppDuplicationRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_duplication_id",
                |m: &GetAppDuplicationRequest| { &m.app_duplication_id },
                |m: &mut GetAppDuplicationRequest| { &mut m.app_duplication_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAppDuplicationRequest>(
                "GetAppDuplicationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAppDuplicationRequest {
        static instance: ::protobuf::rt::LazyV2<GetAppDuplicationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAppDuplicationRequest::new)
    }
}

impl ::protobuf::Clear for GetAppDuplicationRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplication_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAppDuplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppDuplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAppDuplicationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAppDuplicationsRequest {
    fn default() -> &'a ListAppDuplicationsRequest {
        <ListAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppDuplicationsRequest {
    pub fn new() -> ListAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListAppDuplicationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAppDuplicationsRequest {
        ListAppDuplicationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAppDuplicationsRequest| { &m.user_app_id },
                |m: &mut ListAppDuplicationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAppDuplicationsRequest| { &m.page },
                |m: &mut ListAppDuplicationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAppDuplicationsRequest| { &m.per_page },
                |m: &mut ListAppDuplicationsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAppDuplicationsRequest>(
                "ListAppDuplicationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAppDuplicationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAppDuplicationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAppDuplicationsRequest::new)
    }
}

impl ::protobuf::Clear for ListAppDuplicationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppDuplicationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAppDuplicationsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app_duplications: ::protobuf::RepeatedField<super::resources::AppDuplication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAppDuplicationsResponse {
    fn default() -> &'a MultiAppDuplicationsResponse {
        <MultiAppDuplicationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppDuplicationsResponse {
    pub fn new() -> MultiAppDuplicationsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.AppDuplication app_duplications = 2;


    pub fn get_app_duplications(&self) -> &[super::resources::AppDuplication] {
        &self.app_duplications
    }
    pub fn clear_app_duplications(&mut self) {
        self.app_duplications.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_duplications(&mut self, v: ::protobuf::RepeatedField<super::resources::AppDuplication>) {
        self.app_duplications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_duplications(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::AppDuplication> {
        &mut self.app_duplications
    }

    // Take field
    pub fn take_app_duplications(&mut self) -> ::protobuf::RepeatedField<super::resources::AppDuplication> {
        ::std::mem::replace(&mut self.app_duplications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAppDuplicationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_duplications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_duplications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.app_duplications {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAppDuplicationsResponse {
        MultiAppDuplicationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAppDuplicationsResponse| { &m.status },
                |m: &mut MultiAppDuplicationsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppDuplication>>(
                "app_duplications",
                |m: &MultiAppDuplicationsResponse| { &m.app_duplications },
                |m: &mut MultiAppDuplicationsResponse| { &mut m.app_duplications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAppDuplicationsResponse>(
                "MultiAppDuplicationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAppDuplicationsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAppDuplicationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAppDuplicationsResponse::new)
    }
}

impl ::protobuf::Clear for MultiAppDuplicationsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app_duplications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAppDuplicationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppDuplicationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleAppDuplicationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app_duplication: ::protobuf::SingularPtrField<super::resources::AppDuplication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleAppDuplicationResponse {
    fn default() -> &'a SingleAppDuplicationResponse {
        <SingleAppDuplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppDuplicationResponse {
    pub fn new() -> SingleAppDuplicationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.AppDuplication app_duplication = 2;


    pub fn get_app_duplication(&self) -> &super::resources::AppDuplication {
        self.app_duplication.as_ref().unwrap_or_else(|| <super::resources::AppDuplication as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app_duplication(&mut self) {
        self.app_duplication.clear();
    }

    pub fn has_app_duplication(&self) -> bool {
        self.app_duplication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_duplication(&mut self, v: super::resources::AppDuplication) {
        self.app_duplication = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_duplication(&mut self) -> &mut super::resources::AppDuplication {
        if self.app_duplication.is_none() {
            self.app_duplication.set_default();
        }
        self.app_duplication.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_duplication(&mut self) -> super::resources::AppDuplication {
        self.app_duplication.take().unwrap_or_else(|| super::resources::AppDuplication::new())
    }
}

impl ::protobuf::Message for SingleAppDuplicationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_duplication {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app_duplication)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app_duplication.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app_duplication.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleAppDuplicationResponse {
        SingleAppDuplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleAppDuplicationResponse| { &m.status },
                |m: &mut SingleAppDuplicationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppDuplication>>(
                "app_duplication",
                |m: &SingleAppDuplicationResponse| { &m.app_duplication },
                |m: &mut SingleAppDuplicationResponse| { &mut m.app_duplication },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleAppDuplicationResponse>(
                "SingleAppDuplicationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleAppDuplicationResponse {
        static instance: ::protobuf::rt::LazyV2<SingleAppDuplicationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleAppDuplicationResponse::new)
    }
}

impl ::protobuf::Clear for SingleAppDuplicationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app_duplication.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleAppDuplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppDuplicationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub tasks: ::protobuf::RepeatedField<super::resources::Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostTasksRequest {
    fn default() -> &'a PostTasksRequest {
        <PostTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTasksRequest {
    pub fn new() -> PostTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Task tasks = 2;


    pub fn get_tasks(&self) -> &[super::resources::Task] {
        &self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<super::resources::Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<super::resources::Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostTasksRequest {
        PostTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostTasksRequest| { &m.user_app_id },
                |m: &mut PostTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "tasks",
                |m: &PostTasksRequest| { &m.tasks },
                |m: &mut PostTasksRequest| { &mut m.tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostTasksRequest>(
                "PostTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostTasksRequest {
        static instance: ::protobuf::rt::LazyV2<PostTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostTasksRequest::new)
    }
}

impl ::protobuf::Clear for PostTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTaskRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub task_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTaskRequest {
    fn default() -> &'a GetTaskRequest {
        <GetTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskRequest {
    pub fn new() -> GetTaskRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTaskRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTaskRequest {
        GetTaskRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetTaskRequest| { &m.user_app_id },
                |m: &mut GetTaskRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &GetTaskRequest| { &m.task_id },
                |m: &mut GetTaskRequest| { &mut m.task_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTaskRequest>(
                "GetTaskRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTaskRequest {
        static instance: ::protobuf::rt::LazyV2<GetTaskRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTaskRequest::new)
    }
}

impl ::protobuf::Clear for GetTaskRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub worker_user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub review_user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub including_label_order_tasks: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTasksRequest {
    fn default() -> &'a ListTasksRequest {
        <ListTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTasksRequest {
    pub fn new() -> ListTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // repeated string worker_user_ids = 4;


    pub fn get_worker_user_ids(&self) -> &[::std::string::String] {
        &self.worker_user_ids
    }
    pub fn clear_worker_user_ids(&mut self) {
        self.worker_user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.worker_user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_worker_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.worker_user_ids
    }

    // Take field
    pub fn take_worker_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.worker_user_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string review_user_ids = 5;


    pub fn get_review_user_ids(&self) -> &[::std::string::String] {
        &self.review_user_ids
    }
    pub fn clear_review_user_ids(&mut self) {
        self.review_user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_review_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.review_user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_review_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.review_user_ids
    }

    // Take field
    pub fn take_review_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.review_user_ids, ::protobuf::RepeatedField::new())
    }

    // bool including_label_order_tasks = 6;


    pub fn get_including_label_order_tasks(&self) -> bool {
        self.including_label_order_tasks
    }
    pub fn clear_including_label_order_tasks(&mut self) {
        self.including_label_order_tasks = false;
    }

    // Param is passed by value, moved
    pub fn set_including_label_order_tasks(&mut self, v: bool) {
        self.including_label_order_tasks = v;
    }
}

impl ::protobuf::Message for ListTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.worker_user_ids)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.review_user_ids)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.including_label_order_tasks = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.worker_user_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.review_user_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.including_label_order_tasks != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.worker_user_ids {
            os.write_string(4, &v)?;
        };
        for v in &self.review_user_ids {
            os.write_string(5, &v)?;
        };
        if self.including_label_order_tasks != false {
            os.write_bool(6, self.including_label_order_tasks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTasksRequest {
        ListTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListTasksRequest| { &m.user_app_id },
                |m: &mut ListTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListTasksRequest| { &m.page },
                |m: &mut ListTasksRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListTasksRequest| { &m.per_page },
                |m: &mut ListTasksRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "worker_user_ids",
                |m: &ListTasksRequest| { &m.worker_user_ids },
                |m: &mut ListTasksRequest| { &mut m.worker_user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "review_user_ids",
                |m: &ListTasksRequest| { &m.review_user_ids },
                |m: &mut ListTasksRequest| { &mut m.review_user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "including_label_order_tasks",
                |m: &ListTasksRequest| { &m.including_label_order_tasks },
                |m: &mut ListTasksRequest| { &mut m.including_label_order_tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTasksRequest>(
                "ListTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTasksRequest {
        static instance: ::protobuf::rt::LazyV2<ListTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTasksRequest::new)
    }
}

impl ::protobuf::Clear for ListTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.worker_user_ids.clear();
        self.review_user_ids.clear();
        self.including_label_order_tasks = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub tasks: ::protobuf::RepeatedField<super::resources::Task>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchTasksRequest {
    fn default() -> &'a PatchTasksRequest {
        <PatchTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchTasksRequest {
    pub fn new() -> PatchTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Task tasks = 2;


    pub fn get_tasks(&self) -> &[super::resources::Task] {
        &self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<super::resources::Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<super::resources::Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchTasksRequest {
        PatchTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchTasksRequest| { &m.user_app_id },
                |m: &mut PatchTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "tasks",
                |m: &PatchTasksRequest| { &m.tasks },
                |m: &mut PatchTasksRequest| { &mut m.tasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchTasksRequest| { &m.action },
                |m: &mut PatchTasksRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchTasksRequest>(
                "PatchTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchTasksRequest {
        static instance: ::protobuf::rt::LazyV2<PatchTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchTasksRequest::new)
    }
}

impl ::protobuf::Clear for PatchTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTasksRequest {
    fn default() -> &'a DeleteTasksRequest {
        <DeleteTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTasksRequest {
    pub fn new() -> DeleteTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTasksRequest {
        DeleteTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteTasksRequest| { &m.user_app_id },
                |m: &mut DeleteTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteTasksRequest| { &m.ids },
                |m: &mut DeleteTasksRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTasksRequest>(
                "DeleteTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTasksRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTasksRequest::new)
    }
}

impl ::protobuf::Clear for DeleteTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiTaskResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub tasks: ::protobuf::RepeatedField<super::resources::Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiTaskResponse {
    fn default() -> &'a MultiTaskResponse {
        <MultiTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTaskResponse {
    pub fn new() -> MultiTaskResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Task tasks = 2;


    pub fn get_tasks(&self) -> &[super::resources::Task] {
        &self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<super::resources::Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<super::resources::Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiTaskResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiTaskResponse {
        MultiTaskResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiTaskResponse| { &m.status },
                |m: &mut MultiTaskResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "tasks",
                |m: &MultiTaskResponse| { &m.tasks },
                |m: &mut MultiTaskResponse| { &mut m.tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiTaskResponse>(
                "MultiTaskResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiTaskResponse {
        static instance: ::protobuf::rt::LazyV2<MultiTaskResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiTaskResponse::new)
    }
}

impl ::protobuf::Clear for MultiTaskResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.tasks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTaskResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleTaskResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub task: ::protobuf::SingularPtrField<super::resources::Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleTaskResponse {
    fn default() -> &'a SingleTaskResponse {
        <SingleTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskResponse {
    pub fn new() -> SingleTaskResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Task task = 2;


    pub fn get_task(&self) -> &super::resources::Task {
        self.task.as_ref().unwrap_or_else(|| <super::resources::Task as ::protobuf::Message>::default_instance())
    }
    pub fn clear_task(&mut self) {
        self.task.clear();
    }

    pub fn has_task(&self) -> bool {
        self.task.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task(&mut self, v: super::resources::Task) {
        self.task = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task(&mut self) -> &mut super::resources::Task {
        if self.task.is_none() {
            self.task.set_default();
        }
        self.task.as_mut().unwrap()
    }

    // Take field
    pub fn take_task(&mut self) -> super::resources::Task {
        self.task.take().unwrap_or_else(|| super::resources::Task::new())
    }
}

impl ::protobuf::Message for SingleTaskResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.task {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.task.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleTaskResponse {
        SingleTaskResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleTaskResponse| { &m.status },
                |m: &mut SingleTaskResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "task",
                |m: &SingleTaskResponse| { &m.task },
                |m: &mut SingleTaskResponse| { &mut m.task },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleTaskResponse>(
                "SingleTaskResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleTaskResponse {
        static instance: ::protobuf::rt::LazyV2<SingleTaskResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleTaskResponse::new)
    }
}

impl ::protobuf::Clear for SingleTaskResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.task.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTaskCountRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub task_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTaskCountRequest {
    fn default() -> &'a GetTaskCountRequest {
        <GetTaskCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskCountRequest {
    pub fn new() -> GetTaskCountRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // repeated string user_ids = 3;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetTaskCountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTaskCountRequest {
        GetTaskCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetTaskCountRequest| { &m.user_app_id },
                |m: &mut GetTaskCountRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &GetTaskCountRequest| { &m.task_id },
                |m: &mut GetTaskCountRequest| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &GetTaskCountRequest| { &m.user_ids },
                |m: &mut GetTaskCountRequest| { &mut m.user_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTaskCountRequest>(
                "GetTaskCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTaskCountRequest {
        static instance: ::protobuf::rt::LazyV2<GetTaskCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTaskCountRequest::new)
    }
}

impl ::protobuf::Clear for GetTaskCountRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTaskCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleTaskCountResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app_id: ::std::string::String,
    pub task_id: ::std::string::String,
    pub counts: ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleTaskCountResponse {
    fn default() -> &'a SingleTaskCountResponse {
        <SingleTaskCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskCountResponse {
    pub fn new() -> SingleTaskCountResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string app_id = 2;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string task_id = 3;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.TaskStatusCountPerUser counts = 4;


    pub fn get_counts(&self) -> &[super::resources::TaskStatusCountPerUser] {
        &self.counts
    }
    pub fn clear_counts(&mut self) {
        self.counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_counts(&mut self, v: ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser>) {
        self.counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser> {
        &mut self.counts
    }

    // Take field
    pub fn take_counts(&mut self) -> ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser> {
        ::std::mem::replace(&mut self.counts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SingleTaskCountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.task_id);
        }
        for value in &self.counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(3, &self.task_id)?;
        }
        for v in &self.counts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleTaskCountResponse {
        SingleTaskCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleTaskCountResponse| { &m.status },
                |m: &mut SingleTaskCountResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &SingleTaskCountResponse| { &m.app_id },
                |m: &mut SingleTaskCountResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &SingleTaskCountResponse| { &m.task_id },
                |m: &mut SingleTaskCountResponse| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::TaskStatusCountPerUser>>(
                "counts",
                |m: &SingleTaskCountResponse| { &m.counts },
                |m: &mut SingleTaskCountResponse| { &mut m.counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleTaskCountResponse>(
                "SingleTaskCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleTaskCountResponse {
        static instance: ::protobuf::rt::LazyV2<SingleTaskCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleTaskCountResponse::new)
    }
}

impl ::protobuf::Clear for SingleTaskCountResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app_id.clear();
        self.task_id.clear();
        self.counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleTaskCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collectors: ::protobuf::RepeatedField<super::resources::Collector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostCollectorsRequest {
    fn default() -> &'a PostCollectorsRequest {
        <PostCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollectorsRequest {
    pub fn new() -> PostCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collector collectors = 2;


    pub fn get_collectors(&self) -> &[super::resources::Collector] {
        &self.collectors
    }
    pub fn clear_collectors(&mut self) {
        self.collectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_collectors(&mut self, v: ::protobuf::RepeatedField<super::resources::Collector>) {
        self.collectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collectors(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collector> {
        &mut self.collectors
    }

    // Take field
    pub fn take_collectors(&mut self) -> ::protobuf::RepeatedField<super::resources::Collector> {
        ::std::mem::replace(&mut self.collectors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collectors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostCollectorsRequest {
        PostCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostCollectorsRequest| { &m.user_app_id },
                |m: &mut PostCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collectors",
                |m: &PostCollectorsRequest| { &m.collectors },
                |m: &mut PostCollectorsRequest| { &mut m.collectors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostCollectorsRequest>(
                "PostCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<PostCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for PostCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collectors: ::protobuf::RepeatedField<super::resources::Collector>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchCollectorsRequest {
    fn default() -> &'a PatchCollectorsRequest {
        <PatchCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollectorsRequest {
    pub fn new() -> PatchCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collector collectors = 2;


    pub fn get_collectors(&self) -> &[super::resources::Collector] {
        &self.collectors
    }
    pub fn clear_collectors(&mut self) {
        self.collectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_collectors(&mut self, v: ::protobuf::RepeatedField<super::resources::Collector>) {
        self.collectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collectors(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collector> {
        &mut self.collectors
    }

    // Take field
    pub fn take_collectors(&mut self) -> ::protobuf::RepeatedField<super::resources::Collector> {
        ::std::mem::replace(&mut self.collectors, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collectors)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchCollectorsRequest {
        PatchCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchCollectorsRequest| { &m.user_app_id },
                |m: &mut PatchCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collectors",
                |m: &PatchCollectorsRequest| { &m.collectors },
                |m: &mut PatchCollectorsRequest| { &mut m.collectors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchCollectorsRequest| { &m.action },
                |m: &mut PatchCollectorsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchCollectorsRequest>(
                "PatchCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for PatchCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub delete_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteCollectorsRequest {
    fn default() -> &'a DeleteCollectorsRequest {
        <DeleteCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectorsRequest {
    pub fn new() -> DeleteCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool delete_all = 3;


    pub fn get_delete_all(&self) -> bool {
        self.delete_all
    }
    pub fn clear_delete_all(&mut self) {
        self.delete_all = false;
    }

    // Param is passed by value, moved
    pub fn set_delete_all(&mut self, v: bool) {
        self.delete_all = v;
    }
}

impl ::protobuf::Message for DeleteCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteCollectorsRequest {
        DeleteCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteCollectorsRequest| { &m.user_app_id },
                |m: &mut DeleteCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteCollectorsRequest| { &m.ids },
                |m: &mut DeleteCollectorsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_all",
                |m: &DeleteCollectorsRequest| { &m.delete_all },
                |m: &mut DeleteCollectorsRequest| { &mut m.delete_all },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteCollectorsRequest>(
                "DeleteCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCollectorRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collector_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCollectorRequest {
    fn default() -> &'a GetCollectorRequest {
        <GetCollectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCollectorRequest {
    pub fn new() -> GetCollectorRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string collector_id = 2;


    pub fn get_collector_id(&self) -> &str {
        &self.collector_id
    }
    pub fn clear_collector_id(&mut self) {
        self.collector_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_collector_id(&mut self, v: ::std::string::String) {
        self.collector_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collector_id(&mut self) -> &mut ::std::string::String {
        &mut self.collector_id
    }

    // Take field
    pub fn take_collector_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collector_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetCollectorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collector_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.collector_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collector_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.collector_id.is_empty() {
            os.write_string(2, &self.collector_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCollectorRequest {
        GetCollectorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetCollectorRequest| { &m.user_app_id },
                |m: &mut GetCollectorRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "collector_id",
                |m: &GetCollectorRequest| { &m.collector_id },
                |m: &mut GetCollectorRequest| { &mut m.collector_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCollectorRequest>(
                "GetCollectorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCollectorRequest {
        static instance: ::protobuf::rt::LazyV2<GetCollectorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCollectorRequest::new)
    }
}

impl ::protobuf::Clear for GetCollectorRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collector_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCollectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCollectorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCollectorsRequest {
    fn default() -> &'a ListCollectorsRequest {
        <ListCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollectorsRequest {
    pub fn new() -> ListCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollectorsRequest {
        ListCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListCollectorsRequest| { &m.user_app_id },
                |m: &mut ListCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListCollectorsRequest| { &m.page },
                |m: &mut ListCollectorsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListCollectorsRequest| { &m.per_page },
                |m: &mut ListCollectorsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCollectorsRequest>(
                "ListCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<ListCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for ListCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiCollectorResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collectors: ::protobuf::RepeatedField<super::resources::Collector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiCollectorResponse {
    fn default() -> &'a MultiCollectorResponse {
        <MultiCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollectorResponse {
    pub fn new() -> MultiCollectorResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Collector collectors = 2;


    pub fn get_collectors(&self) -> &[super::resources::Collector] {
        &self.collectors
    }
    pub fn clear_collectors(&mut self) {
        self.collectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_collectors(&mut self, v: ::protobuf::RepeatedField<super::resources::Collector>) {
        self.collectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collectors(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collector> {
        &mut self.collectors
    }

    // Take field
    pub fn take_collectors(&mut self) -> ::protobuf::RepeatedField<super::resources::Collector> {
        ::std::mem::replace(&mut self.collectors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiCollectorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collectors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiCollectorResponse {
        MultiCollectorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiCollectorResponse| { &m.status },
                |m: &mut MultiCollectorResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collectors",
                |m: &MultiCollectorResponse| { &m.collectors },
                |m: &mut MultiCollectorResponse| { &mut m.collectors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiCollectorResponse>(
                "MultiCollectorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiCollectorResponse {
        static instance: ::protobuf::rt::LazyV2<MultiCollectorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiCollectorResponse::new)
    }
}

impl ::protobuf::Clear for MultiCollectorResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collectors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollectorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleCollectorResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collector: ::protobuf::SingularPtrField<super::resources::Collector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleCollectorResponse {
    fn default() -> &'a SingleCollectorResponse {
        <SingleCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleCollectorResponse {
    pub fn new() -> SingleCollectorResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Collector collector = 2;


    pub fn get_collector(&self) -> &super::resources::Collector {
        self.collector.as_ref().unwrap_or_else(|| <super::resources::Collector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_collector(&mut self) {
        self.collector.clear();
    }

    pub fn has_collector(&self) -> bool {
        self.collector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collector(&mut self, v: super::resources::Collector) {
        self.collector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collector(&mut self) -> &mut super::resources::Collector {
        if self.collector.is_none() {
            self.collector.set_default();
        }
        self.collector.as_mut().unwrap()
    }

    // Take field
    pub fn take_collector(&mut self) -> super::resources::Collector {
        self.collector.take().unwrap_or_else(|| super::resources::Collector::new())
    }
}

impl ::protobuf::Message for SingleCollectorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.collector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.collector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.collector.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleCollectorResponse {
        SingleCollectorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleCollectorResponse| { &m.status },
                |m: &mut SingleCollectorResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collector",
                |m: &SingleCollectorResponse| { &m.collector },
                |m: &mut SingleCollectorResponse| { &mut m.collector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleCollectorResponse>(
                "SingleCollectorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleCollectorResponse {
        static instance: ::protobuf::rt::LazyV2<SingleCollectorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleCollectorResponse::new)
    }
}

impl ::protobuf::Clear for SingleCollectorResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleCollectorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostStatValuesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub stat_values: ::protobuf::RepeatedField<super::resources::StatValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostStatValuesRequest {
    fn default() -> &'a PostStatValuesRequest {
        <PostStatValuesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesRequest {
    pub fn new() -> PostStatValuesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.StatValue stat_values = 2;


    pub fn get_stat_values(&self) -> &[super::resources::StatValue] {
        &self.stat_values
    }
    pub fn clear_stat_values(&mut self) {
        self.stat_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_values(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValue>) {
        self.stat_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_values(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValue> {
        &mut self.stat_values
    }

    // Take field
    pub fn take_stat_values(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValue> {
        ::std::mem::replace(&mut self.stat_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostStatValuesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostStatValuesRequest {
        PostStatValuesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostStatValuesRequest| { &m.user_app_id },
                |m: &mut PostStatValuesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValue>>(
                "stat_values",
                |m: &PostStatValuesRequest| { &m.stat_values },
                |m: &mut PostStatValuesRequest| { &mut m.stat_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostStatValuesRequest>(
                "PostStatValuesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostStatValuesRequest {
        static instance: ::protobuf::rt::LazyV2<PostStatValuesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostStatValuesRequest::new)
    }
}

impl ::protobuf::Clear for PostStatValuesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostStatValuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiStatValueResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub stat_values: ::protobuf::RepeatedField<super::resources::StatValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiStatValueResponse {
    fn default() -> &'a MultiStatValueResponse {
        <MultiStatValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueResponse {
    pub fn new() -> MultiStatValueResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.StatValue stat_values = 2;


    pub fn get_stat_values(&self) -> &[super::resources::StatValue] {
        &self.stat_values
    }
    pub fn clear_stat_values(&mut self) {
        self.stat_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_values(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValue>) {
        self.stat_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_values(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValue> {
        &mut self.stat_values
    }

    // Take field
    pub fn take_stat_values(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValue> {
        ::std::mem::replace(&mut self.stat_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiStatValueResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiStatValueResponse {
        MultiStatValueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiStatValueResponse| { &m.status },
                |m: &mut MultiStatValueResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValue>>(
                "stat_values",
                |m: &MultiStatValueResponse| { &m.stat_values },
                |m: &mut MultiStatValueResponse| { &mut m.stat_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiStatValueResponse>(
                "MultiStatValueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiStatValueResponse {
        static instance: ::protobuf::rt::LazyV2<MultiStatValueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiStatValueResponse::new)
    }
}

impl ::protobuf::Clear for MultiStatValueResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.stat_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiStatValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostStatValuesAggregateRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub stat_value_aggregate_queries: ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostStatValuesAggregateRequest {
    fn default() -> &'a PostStatValuesAggregateRequest {
        <PostStatValuesAggregateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesAggregateRequest {
    pub fn new() -> PostStatValuesAggregateRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.StatValueAggregateQuery stat_value_aggregate_queries = 2;


    pub fn get_stat_value_aggregate_queries(&self) -> &[super::resources::StatValueAggregateQuery] {
        &self.stat_value_aggregate_queries
    }
    pub fn clear_stat_value_aggregate_queries(&mut self) {
        self.stat_value_aggregate_queries.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_value_aggregate_queries(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery>) {
        self.stat_value_aggregate_queries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_value_aggregate_queries(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery> {
        &mut self.stat_value_aggregate_queries
    }

    // Take field
    pub fn take_stat_value_aggregate_queries(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery> {
        ::std::mem::replace(&mut self.stat_value_aggregate_queries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostStatValuesAggregateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_value_aggregate_queries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_value_aggregate_queries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_value_aggregate_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_value_aggregate_queries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostStatValuesAggregateRequest {
        PostStatValuesAggregateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostStatValuesAggregateRequest| { &m.user_app_id },
                |m: &mut PostStatValuesAggregateRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValueAggregateQuery>>(
                "stat_value_aggregate_queries",
                |m: &PostStatValuesAggregateRequest| { &m.stat_value_aggregate_queries },
                |m: &mut PostStatValuesAggregateRequest| { &mut m.stat_value_aggregate_queries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostStatValuesAggregateRequest>(
                "PostStatValuesAggregateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostStatValuesAggregateRequest {
        static instance: ::protobuf::rt::LazyV2<PostStatValuesAggregateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostStatValuesAggregateRequest::new)
    }
}

impl ::protobuf::Clear for PostStatValuesAggregateRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_value_aggregate_queries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostStatValuesAggregateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesAggregateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiStatValueAggregateResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub stat_value_aggregate_results: ::protobuf::RepeatedField<super::resources::StatValueAggregateResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiStatValueAggregateResponse {
    fn default() -> &'a MultiStatValueAggregateResponse {
        <MultiStatValueAggregateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueAggregateResponse {
    pub fn new() -> MultiStatValueAggregateResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.StatValueAggregateResult stat_value_aggregate_results = 2;


    pub fn get_stat_value_aggregate_results(&self) -> &[super::resources::StatValueAggregateResult] {
        &self.stat_value_aggregate_results
    }
    pub fn clear_stat_value_aggregate_results(&mut self) {
        self.stat_value_aggregate_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_value_aggregate_results(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValueAggregateResult>) {
        self.stat_value_aggregate_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_value_aggregate_results(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValueAggregateResult> {
        &mut self.stat_value_aggregate_results
    }

    // Take field
    pub fn take_stat_value_aggregate_results(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValueAggregateResult> {
        ::std::mem::replace(&mut self.stat_value_aggregate_results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiStatValueAggregateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_value_aggregate_results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_value_aggregate_results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_value_aggregate_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_value_aggregate_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiStatValueAggregateResponse {
        MultiStatValueAggregateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiStatValueAggregateResponse| { &m.status },
                |m: &mut MultiStatValueAggregateResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValueAggregateResult>>(
                "stat_value_aggregate_results",
                |m: &MultiStatValueAggregateResponse| { &m.stat_value_aggregate_results },
                |m: &mut MultiStatValueAggregateResponse| { &mut m.stat_value_aggregate_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiStatValueAggregateResponse>(
                "MultiStatValueAggregateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiStatValueAggregateResponse {
        static instance: ::protobuf::rt::LazyV2<MultiStatValueAggregateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiStatValueAggregateResponse::new)
    }
}

impl ::protobuf::Clear for MultiStatValueAggregateResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.stat_value_aggregate_results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiStatValueAggregateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueAggregateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrganizationInvitationStatus {
    NOT_SET = 0,
    PENDING = 1,
    ACCEPTED = 2,
    CANCELLED = 3,
    DECLINED = 4,
    EXPIRED = 5,
}

impl ::protobuf::ProtobufEnum for OrganizationInvitationStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrganizationInvitationStatus> {
        match value {
            0 => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            1 => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            2 => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            3 => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            4 => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            5 => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrganizationInvitationStatus] = &[
            OrganizationInvitationStatus::NOT_SET,
            OrganizationInvitationStatus::PENDING,
            OrganizationInvitationStatus::ACCEPTED,
            OrganizationInvitationStatus::CANCELLED,
            OrganizationInvitationStatus::DECLINED,
            OrganizationInvitationStatus::EXPIRED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OrganizationInvitationStatus>("OrganizationInvitationStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OrganizationInvitationStatus {
}

impl ::std::default::Default for OrganizationInvitationStatus {
    fn default() -> Self {
        OrganizationInvitationStatus::NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for OrganizationInvitationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20proto/clarifai/api/service.proto\x12\x0cclarifai.api\x1a\"proto/cl\
    arifai/api/resources.proto\x1a&proto/clarifai/api/status/status.proto\
    \x1a)proto/clarifai/api/utils/extensions.proto\x1a%proto/clarifai/auth/s\
    cope/scope.proto\x1a(proto/clarifai/auth/util/extension.proto\x1a+proto/\
    clarifai/api/status/status_code.proto\x1a\x1cgoogle/api/annotations.prot\
    o\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.pr\
    oto\x1a\x1fgoogle/protobuf/timestamp.proto\";\n\nPagination\x12\x12\n\
    \x04page\x18\x01\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x02\x20\
    \x01(\rR\x07perPage\"\x92\x01\n\x14GetAnnotationRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12#\n\rannotation_id\x18\x02\x20\x01(\tR\x0cannotationId\x12\x19\n\x08\
    input_id\x18\x03\x20\x01(\tR\x07inputId\"\x83\x03\n\x16ListAnnotationsRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1b\
    \n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\x12\x19\n\x08user_ids\x18\
    \t\x20\x03(\tR\x07userIds\x12*\n\x11model_version_ids\x18\n\x20\x03(\tR\
    \x0fmodelVersionIds\x127\n\x08statuses\x18\x05\x20\x03(\x0b2\x1b.clarifa\
    i.api.status.StatusR\x08statuses\x120\n\x14list_all_annotations\x18\x06\
    \x20\x01(\x08R\x12listAllAnnotations\x12\x12\n\x04page\x18\x07\x20\x01(\
    \rR\x04page\x12\x19\n\x08per_page\x18\x08\x20\x01(\rR\x07perPage\x12\x17\
    \n\x07task_id\x18\x0b\x20\x01(\tR\x06taskIdJ\x04\x08\x04\x10\x05\"\x90\
    \x01\n\x16PostAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotations\
    \x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\"\xa9\
    \x01\n\x17PatchAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotations\
    \x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\xe9\x01\n\x1dPatchAnnot\
    ationsStatusRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12@\n\x0bstatus_code\x18\x02\x20\x01(\
    \x0e2\x1f.clarifai.api.status.StatusCodeR\nstatusCode\x12\x19\n\x08user_\
    ids\x18\x03\x20\x03(\tR\x07userIds\x12\x17\n\x07task_id\x18\x04\x20\x01(\
    \tR\x06taskId\x12\x16\n\x06action\x18\x05\x20\x01(\tR\x06action\"\x95\
    \x01\n\x1ePatchAnnotationsStatusResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x19\n\x08user_i\
    ds\x18\x02\x20\x03(\tR\x07userIds\x12#\n\rupdated_count\x18\x03\x20\x01(\
    \rR\x0cupdatedCount\"\x95\x01\n\x17DeleteAnnotationRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\x12#\n\rannotation\
    _id\x18\x03\x20\x01(\tR\x0cannotationId\"\x85\x01\n\x18DeleteAnnotations\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\
    \x1b\n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\"\x89\x01\n\x18SingleA\
    nnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x128\n\nannotation\x18\x02\x20\x01(\x0b2\x18.\
    clarifai.api.AnnotationR\nannotation\"\x90\x01\n\x17MultiAnnotationRespo\
    nse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Statu\
    sR\x06status\x12@\n\x0bannotations\x18\x02\x20\x03(\x0b2\x18.clarifai.ap\
    i.AnnotationR\x0bannotationsB\x04\x80\xb5\x18\x01\"K\n\rGetAppRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\"|\n\x0fListAppsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\
    \x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\
    \x07perPage\"t\n\x0fPostAppsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04apps\x18\
    \x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\"N\n\x10DeleteAppReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\"\xeb\x01\n\x10PatchAppsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\
    \x04apps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\x12B\n\x0fmetadata_action\x18\
    \x04\x20\x01(\x0b2\x19.clarifai.api.PatchActionR\x0emetadataAction\x12\
    \x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reindex\"\xc4\x01\n\x17PostAp\
    psSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x123\n\tapp_query\x18\x02\x20\x01(\x0b2\
    \x16.clarifai.api.AppQueryR\x08appQuery\x128\n\npagination\x18\x03\x20\
    \x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"m\n\x11SingleAppRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai.api.AppR\
    \x03app\"t\n\x10MultiAppResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04apps\x18\x02\x20\
    \x03(\x0b2\x11.clarifai.api.AppR\x04appsB\x04\x80\xb5\x18\x01\"\x8c\x01\
    \n\x18ListCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\x16list_all_colla\
    borators\x18\x02\x20\x01(\x08R\x14listAllCollaborators\"\x98\x01\n\x18Po\
    stCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\x18\x02\x20\
    \x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\"\xb1\x01\n\x19\
    PatchCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\xa4\x01\n\x1aDeleteCollaborat\
    orsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12)\n\x10collaborator_ids\x18\x02\x20\x03(\tR\
    \x0fcollaboratorIds\x12\x1f\n\x0buser_emails\x18\x03\x20\x03(\tR\nuserEm\
    ails\"\x99\x01\n\x1aMultiCollaboratorsResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12F\n\rcollabo\
    rators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborato\
    rsB\x04\x80\xb5\x18\x01\"\x86\x01\n\x19ListCollaborationsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_p\
    age\x18\x03\x20\x01(\rR\x07perPage\"\x9d\x01\n\x1bMultiCollaborationsRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12I\n\x0ecollaborations\x18\x02\x20\x03(\x0b2\x1b.clarif\
    ai.api.CollaborationR\x0ecollaborationsB\x04\x80\xb5\x18\x01\"<\n\x14Get\
    StatusCodeRequest\x12$\n\x0estatus_code_id\x18\x01\x20\x01(\tR\x0cstatus\
    CodeId\"\x18\n\x16ListStatusCodesRequest\"O\n\x18SingleStatusCodeRespons\
    e\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\"\x87\x01\n\x17MultiStatusCodeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\x08s\
    tatuses\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.status.StatusR\x08statuse\
    s\"n\n\x11GetConceptRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\
    \x20\x01(\tR\tconceptId\"\x80\x01\n\x13ListConceptsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"\xd4\x01\n\x1bPostConceptsSearchesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12?\n\rconcept_query\x18\x02\x20\x01(\x0b2\x1a.clarifai.\
    api.ConceptQueryR\x0cconceptQuery\x128\n\npagination\x18\x03\x20\x01(\
    \x0b2\x18.clarifai.api.PaginationR\npagination\"\x84\x01\n\x13PostConcep\
    tsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.cla\
    rifai.api.ConceptR\x08concepts\"\x9d\x01\n\x14PatchConceptsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.clarifai.api.Conc\
    eptR\x08concepts\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x84\
    \x01\n\x17GetConceptCountsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"}\n\x15SingleConceptResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07concept\x18\
    \x02\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\"\x84\x01\n\x14M\
    ultiConceptResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x127\n\x08concepts\x18\x02\x20\x03(\x0b2\
    \x15.clarifai.api.ConceptR\x08conceptsB\x04\x80\xb5\x18\x01\"\x99\x01\n\
    \x19MultiConceptCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b\
    .clarifai.api.status.StatusR\x06status\x12G\n\x0econcept_counts\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.ConceptCountR\rconceptCountsB\x04\x80\
    \xb5\x18\x01\"\xf3\x01\n\x1bListConceptRelationsRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x1c\n\tpredica\
    te\x18\x03\x20\x01(\tR\tpredicate\x12,\n\x12knowledge_graph_id\x18\x04\
    \x20\x01(\tR\x10knowledgeGraphId\x12\x12\n\x04page\x18\x05\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x06\x20\x01(\rR\x07perPage\"\xc4\x01\
    \n\x1bPostConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_relations\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptRelationR\x10conceptRelations\"\x8c\
    \x01\n\x1dDeleteConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconc\
    ept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x10\n\x03ids\x18\x03\x20\x03(\
    \tR\x03ids\"X\n\x1aListKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xa1\x01\n\
    \x1aPostKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphs\"\xae\x01\n\x1dPostConceptMappingJobsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12Q\n\
    \x14concept_mapping_jobs\x18\x02\x20\x03(\x0b2\x1f.clarifai.api.ConceptM\
    appingJobR\x12conceptMappingJobs\"\xa5\x01\n\x1cMultiConceptRelationResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12P\n\x11concept_relations\x18\x02\x20\x03(\x0b2\x1d.clar\
    ifai.api.ConceptRelationR\x10conceptRelationsB\x04\x80\xb5\x18\x01\"\xa1\
    \x01\n\x1bMultiKnowledgeGraphResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphsB\x04\x80\xb5\x18\x01\"g\n\x1eMultiConceptMappingJobResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x92\x01\n\x19GetConcept\
    LanguageRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\
    \tconceptId\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08language\"\xa7\
    \x01\n\x1bListConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_\
    id\x18\x02\x20\x01(\tR\tconceptId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xdd\x01\
    \n\x1cPatchConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_languages\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguages\x12\x16\
    \n\x06action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x1bPostConceptLan\
    guagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tc\
    onceptId\x12J\n\x11concept_languages\x18\x03\x20\x03(\x0b2\x1d.clarifai.\
    api.ConceptLanguageR\x10conceptLanguages\"\x9e\x01\n\x1dSingleConceptLan\
    guageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12H\n\x10concept_language\x18\x02\x20\x01(\x0b2\
    \x1d.clarifai.api.ConceptLanguageR\x0fconceptLanguage\"\xa5\x01\n\x1cMul\
    tiConceptLanguageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12P\n\x11concept_languages\x18\x02\
    \x20\x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguagesB\
    \x04\x80\xb5\x18\x01\"h\n\x0fGetInputRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08input_id\x18\x02\x20\x01(\tR\x07inputId\"\x88\x01\n\x16GetInputSampl\
    esRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06task\
    Id\x12\x19\n\x08user_ids\x18\x03\x20\x03(\tR\x07userIds\"\xc5\x01\n\x11L\
    istInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04\
    page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x123\n\x06stat\
    us\x18\x05\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x10\n\x03ids\x18\x04\x20\x03(\tR\x03ids\"\xa5\x01\n\x13StreamInputsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x19\n\x08per_page\x18\x02\x20\x01(\rR\x07perPage\
    \x12\x17\n\x07last_id\x18\x03\x20\x01(\tR\x06lastId\x12\x1e\n\ndescendin\
    g\x18\x04\x20\x01(\x08R\ndescending\"|\n\x11PostInputsRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12+\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06in\
    puts\"\x95\x01\n\x12PatchInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x06inputs\
    \x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06inputs\x12\x16\n\x06ac\
    tion\x18\x03\x20\x01(\tR\x06action\"k\n\x12DeleteInputRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\"i\n\x13DeleteI\
    nputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03idsJ\
    \x04\x08\x03\x10\x04\"u\n\x13SingleInputResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12)\n\x05i\
    nput\x18\x02\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\"|\n\x12Mult\
    iInputResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x121\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clari\
    fai.api.InputR\x06inputsB\x04\x80\xb5\x18\x01\"\x80\x01\n\x1cMultiInputA\
    nnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\x11.clar\
    ifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\"\x81\x01\n\x18SingleInputCou\
    ntResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.statu\
    s.StatusR\x06status\x120\n\x06counts\x18\x02\x20\x01(\x0b2\x18.clarifai.\
    api.InputCountR\x06counts\"R\n\x14GetInputCountRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\
    \xe7\x01\n\x17PostModelOutputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\
    \tR\tversionId\x12+\n\x06inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.I\
    nputR\x06inputs\x12)\n\x05model\x18\x05\x20\x01(\x0b2\x13.clarifai.api.M\
    odelR\x05model\"\xbd\x01\n\x16ListModelInputsRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\
    \x18\x03\x20\x01(\tR\tversionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\"b\n\rGetK\
    eyRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\
    \"|\n\x0fListKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01\
    (\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\x7f\
    \n\x12ListAppKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01\
    (\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"t\n\
    \x0fPostKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\
    \x11.clarifai.api.KeyR\x04keys\"e\n\x10DeleteKeyRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\"\x8d\x01\n\x10PatchKe\
    ysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\x11.clarifa\
    i.api.KeyR\x04keys\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"m\
    \n\x11SingleKeyResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12#\n\x03key\x18\x02\x20\x01(\x0b2\x11\
    .clarifai.api.KeyR\x03key\"t\n\x10MultiKeyResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04k\
    eys\x18\x02\x20\x03(\x0b2\x11.clarifai.api.KeyR\x04keysB\x04\x80\xb5\x18\
    \x01\"\xca\x01\n\x0fGetModelRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\
    \tR\tversionId\x12\x1a\n\x08language\x18\x04\x20\x01(\tR\x08language\x12\
    %\n\x0etrained_before\x18\x05\x20\x01(\x08R\rtrainedBefore\"\x90\x01\n\
    \x11ListModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\r\
    R\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12\x10\n\
    \x03ids\x18\x04\x20\x03(\tR\x03ids\"\xab\x01\n\x11PostModelsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12-\n\x05model\x18\x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\
    \x05modelB\x02\x18\x01\x12+\n\x06models\x18\x03\x20\x03(\x0b2\x13.clarif\
    ai.api.ModelR\x06models\"\x95\x01\n\x12PatchModelsRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12+\n\x06models\x18\x02\x20\x03(\x0b2\x13.clarifai.api.ModelR\x06model\
    s\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"k\n\x12DeleteModelR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\"\x82\x01\n\x13DeleteModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\
    \x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\
    \tdeleteAll\"\xcc\x01\n\x19PostModelsSearchesRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x129\
    \n\x0bmodel_query\x18\x02\x20\x01(\x0b2\x18.clarifai.api.ModelQueryR\nmo\
    delQuery\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.Pagin\
    ationR\npagination\"u\n\x13SingleModelResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12)\n\x05model\
    \x18\x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05model\"|\n\x12MultiMod\
    elResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.statu\
    s.StatusR\x06status\x121\n\x06models\x18\x02\x20\x03(\x0b2\x13.clarifai.\
    api.ModelR\x06modelsB\x04\x80\xb5\x18\x01\"\xcd\x01\n\x19PatchModelVersi\
    onsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mo\
    delId\x12A\n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.Mo\
    delVersionR\rmodelVersions\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06ac\
    tion\"\x8e\x01\n\x16GetModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08mo\
    del_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\
    \x01(\tR\tversionId\"\xc1\x01\n\x18ListModelVersionsRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\x04page\
    \x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\
    \x07perPage\x12\x1f\n\x0bconcept_ids\x18\x05\x20\x03(\tR\nconceptIds\"\
    \x91\x01\n\x19DeleteModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08mo\
    del_id\x18\x03\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x04\x20\
    \x01(\tR\tversionId\"\x92\x01\n\x1aSingleModelVersionResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12?\n\rmodel_version\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.ModelVersi\
    onR\x0cmodelVersion\"\x99\x01\n\x19MultiModelVersionResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12G\n\x0emodel_versions\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.ModelVe\
    rsionR\rmodelVersionsB\x04\x80\xb5\x18\x01\"\xb0\x03\n\x18PostModelVersi\
    onsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mo\
    delId\x12A\n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.Mo\
    delVersionR\rmodelVersions\x120\n\x06search\x18\x04\x20\x01(\x0b2\x14.cl\
    arifai.api.SearchR\x06searchB\x02\x18\x01\x127\n\x0ctrain_search\x18\x05\
    \x20\x01(\x0b2\x14.clarifai.api.SearchR\x0btrainSearch\x125\n\x0btest_se\
    arch\x18\x06\x20\x01(\x0b2\x14.clarifai.api.SearchR\ntestSearch\x126\n\
    \x17evaluate_after_training\x18\x07\x20\x01(\x08R\x15evaluateAfterTraini\
    ng\x12\x20\n\x0bdescription\x18\x08\x20\x01(\tR\x0bdescription\"\xf0\x01\
    \n\x1ePostModelVersionMetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\
    \tR\tversionId\x12!\n\x0cmax_examples\x18\x04\x20\x01(\rR\x0bmaxExamples\
    \x125\n\x0btest_search\x18\x05\x20\x01(\x0b2\x14.clarifai.api.SearchR\nt\
    estSearch\"\xc8\x01\n\x1dGetModelVersionMetricsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\
    \x18\x03\x20\x01(\tR\tversionId\x121\n\x06fields\x18\x04\x20\x01(\x0b2\
    \x19.clarifai.api.FieldsValueR\x06fields\"u\n\x13GetModelTypeRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\"\n\rmodel_type_id\x18\x02\x20\x01(\tR\x0bmodelTypeId\"\
    \x82\x01\n\x15ListModelTypesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\
    \x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\
    \x07perPage\"\x8c\x01\n\x17SingleModelTypeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12<\n\nmod\
    el_type\x18\x02\x20\x01(\x0b2\x17.clarifai.api.ModelTypeR\tmodelTypeB\
    \x04\x80\xb5\x18\x01\"\x8d\x01\n\x16MultiModelTypeResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12>\
    \n\x0bmodel_types\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ModelTypeR\nmod\
    elTypesB\x04\x80\xb5\x18\x01\"\x80\x01\n\x13MultiOutputResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x124\n\x07outputs\x18\x02\x20\x03(\x0b2\x14.clarifai.api.OutputR\x07o\
    utputsB\x04\x80\xb5\x18\x01\"j\n\x11ListScopesRequest\x12\x19\n\x08key_t\
    ype\x18\x01\x20\x01(\tR\x07keyType\x12:\n\x0buser_app_id\x18\x02\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"M\n\x0fMyScopesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\"\xc6\x01\n\x16MultiScopeDepsResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x126\n\
    \nscope_deps\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ScopeDepsR\tscopeDep\
    s\x12?\n\rendpoint_deps\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.EndpointD\
    epsR\x0cendpointDeps\"\xa4\x01\n\x12MultiScopeResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x16\
    \n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12#\n\x03app\x18\x03\x20\x01\
    (\x0b2\x11.clarifai.api.AppR\x03app\x12\x1c\n\tendpoints\x18\x04\x20\x03\
    (\tR\tendpoints\"^\n\x10GetSearchRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\
    \x18\x02\x20\x01(\tR\x02id\"\x80\x01\n\x13ListSearchesRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\"\xec\x01\n\x13PostSearchesRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12-\n\x05query\x18\x02\x20\x01(\x0b2\x13.clarifai.api.QueryR\
    \x05queryB\x02\x18\x01\x120\n\x08searches\x18\x03\x20\x03(\x0b2\x14.clar\
    ifai.api.SearchR\x08searches\x128\n\npagination\x18\x04\x20\x01(\x0b2\
    \x18.clarifai.api.PaginationR\npagination\"\x9f\x01\n\x17PostSearchesByI\
    DRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x128\n\
    \npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npaginat\
    ion\"a\n\x13DeleteSearchRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\
    \x20\x01(\tR\x02id\"\xc8\x01\n\x1ePostAnnotationsSearchesRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api.Search\
    R\x08searches\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.\
    PaginationR\npagination\"r\n$DeleteAnnotationSearchMetricsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\xc3\x01\n\x19PostInp\
    utsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clari\
    fai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b\
    2\x14.clarifai.api.SearchR\x08searches\x128\n\npagination\x18\x03\x20\
    \x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"y\n\x14SingleSearch\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x12,\n\x06search\x18\x05\x20\x01(\x0b2\x14.clarifai.ap\
    i.SearchR\x06search\"\xe4\x01\n\x13MultiSearchResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x0e\
    \n\x02id\x18\x02\x20\x01(\tR\x02id\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\
    \x11.clarifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\x12)\n\x05query\x18\
    \x04\x20\x01(\x0b2\x13.clarifai.api.QueryR\x05query\x120\n\x08searches\
    \x18\x05\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\"\xd4\x02\n\
    \"PostAnnotationSearchMetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\tR\x02id\x127\n\x0cground_truth\x18\x03\x20\x01(\x0b2\x14.\
    clarifai.api.SearchR\x0bgroundTruth\x12:\n\x0esearch_to_eval\x18\x04\x20\
    \x01(\x0b2\x14.clarifai.api.SearchR\x0csearchToEval\x12&\n\x04data\x18\
    \x05\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x12E\n\x0fevaluation_t\
    ype\x18\x06\x20\x01(\x0e2\x1c.clarifai.api.EvaluationTypeR\x0eevaluation\
    Type\"o\n!GetAnnotationSearchMetricsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\
    \x02id\x18\x02\x20\x01(\tR\x02id\"`\n\"ListAnnotationSearchMetricsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\"\xbe\x01\n$MultiAnnotationSearchMetricsResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12a\n\x19annotation_search_metrics\x18\x02\x20\x03(\x0b2%.clarifai.a\
    pi.AnnotationSearchMetricsR\x17annotationSearchMetrics\"\x8d\x01\n\x1bPo\
    stValidatePasswordRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x122\n\x08password\x18\x02\
    \x20\x01(\x0b2\x16.clarifai.api.PasswordR\x08password\"\xaa\x01\n\x20Sin\
    glePasswordValidationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b\
    .clarifai.api.status.StatusR\x06status\x12Q\n\x13password_violations\x18\
    \x02\x20\x01(\x0b2\x20.clarifai.api.PasswordViolationsR\x12passwordViola\
    tions\"\xab\x01\n\x12GetWorkflowRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bwo\
    rkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x128\n\x18favor_clarifai_workf\
    lows\x18\x03\x20\x01(\x08R\x16favorClarifaiWorkflows\"\x81\x01\n\x14List\
    WorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04\
    page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\x88\x01\n\
    \x14PostWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflows\x18\x02\x20\x03\
    (\x0b2\x16.clarifai.api.WorkflowR\tworkflows\"\xa1\x01\n\x15PatchWorkflo\
    wsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x124\n\tworkflows\x18\x02\x20\x03(\x0b2\x16.clar\
    ifai.api.WorkflowR\tworkflows\x12\x16\n\x06action\x18\x03\x20\x01(\tR\
    \x06action\"t\n\x15DeleteWorkflowRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bwo\
    rkflow_id\x18\x02\x20\x01(\tR\nworkflowId\"\x85\x01\n\x16DeleteWorkflows\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\
    \x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"\x81\x01\n\x16Singl\
    eWorkflowResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x122\n\x08workflow\x18\x02\x20\x01(\x0b2\x16.\
    clarifai.api.WorkflowR\x08workflow\"\x88\x01\n\x15MultiWorkflowResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12:\n\tworkflows\x18\x02\x20\x03(\x0b2\x16.clarifai.api.Work\
    flowR\tworkflowsB\x04\x80\xb5\x18\x01\"\xa1\x02\n\x1aPostWorkflowResults\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nwork\
    flowId\x12+\n\x06inputs\x18\x03\x20\x03(\x0b2\x13.clarifai.api.InputR\
    \x06inputs\x12?\n\routput_config\x18\x04\x20\x01(\x0b2\x1a.clarifai.api.\
    OutputConfigR\x0coutputConfig\x128\n\x18favor_clarifai_workflows\x18\x05\
    \x20\x01(\x08R\x16favorClarifaiWorkflows\"\xbe\x01\n\x1bPostWorkflowResu\
    ltsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x122\n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarif\
    ai.api.WorkflowR\x08workflow\x126\n\x07results\x18\x03\x20\x03(\x0b2\x1c\
    .clarifai.api.WorkflowResultR\x07results\"\xd5\x02\n$PostWorkflowResults\
    SimilarityRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01\
    (\tR\nworkflowId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodel\
    VersionId\x126\n\x0cprobe_inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.\
    InputR\x0bprobeInputs\x124\n\x0bpool_inputs\x18\x05\x20\x03(\x0b2\x13.cl\
    arifai.api.InputR\npoolInputs\x128\n\x18favor_clarifai_workflows\x18\x06\
    \x20\x01(\x08R\x16favorClarifaiWorkflows\"\x9f\x01\n%PostWorkflowResults\
    SimilarityResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.a\
    pi.status.StatusR\x06status\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.cla\
    rifai.api.WorkflowResultsSimilarityR\x07results\"\xa1\x01\n\x1aPostAppDu\
    plicationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12G\n\x10app_duplications\x18\x02\x20\
    \x03(\x0b2\x1c.clarifai.api.AppDuplicationR\x0fappDuplications\"\x84\x01\
    \n\x18GetAppDuplicationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12,\n\x12app_duplicatio\
    n_id\x18\x02\x20\x01(\tR\x10appDuplicationId\"\x87\x01\n\x1aListAppDupli\
    cationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04pa\
    ge\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\x9c\x01\n\x1cM\
    ultiAppDuplicationsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.c\
    larifai.api.status.StatusR\x06status\x12G\n\x10app_duplications\x18\x02\
    \x20\x03(\x0b2\x1c.clarifai.api.AppDuplicationR\x0fappDuplications\"\x9a\
    \x01\n\x1cSingleAppDuplicationResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12E\n\x0fapp_duplicatio\
    n\x18\x02\x20\x01(\x0b2\x1c.clarifai.api.AppDuplicationR\x0eappDuplicati\
    on\"x\n\x10PostTasksRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12(\n\x05tasks\x18\x02\x20\
    \x03(\x0b2\x12.clarifai.api.TaskR\x05tasks\"e\n\x0eGetTaskRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\"\x8c\x02\n\
    \x10ListTasksRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12&\n\x0f\
    worker_user_ids\x18\x04\x20\x03(\tR\rworkerUserIds\x12&\n\x0freview_user\
    _ids\x18\x05\x20\x03(\tR\rreviewUserIds\x12=\n\x1bincluding_label_order_\
    tasks\x18\x06\x20\x01(\x08R\x18includingLabelOrderTasks\"\x91\x01\n\x11P\
    atchTasksRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12(\n\x05tasks\x18\x02\x20\x03(\x0b2\x12\
    .clarifai.api.TaskR\x05tasks\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06\
    action\"b\n\x12DeleteTasksRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\
    \x20\x03(\tR\x03ids\"x\n\x11MultiTaskResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12.\n\x05tasks\
    \x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05tasksB\x04\x80\xb5\x18\
    \x01\"q\n\x12SingleTaskResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12&\n\x04task\x18\x02\x20\
    \x01(\x0b2\x12.clarifai.api.TaskR\x04task\"\x85\x01\n\x13GetTaskCountReq\
    uest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAp\
    pIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\
    \x12\x19\n\x08user_ids\x18\x03\x20\x03(\tR\x07userIds\"\xbc\x01\n\x17Sin\
    gleTaskCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\
    \x05appId\x12\x17\n\x07task_id\x18\x03\x20\x01(\tR\x06taskId\x12<\n\x06c\
    ounts\x18\x04\x20\x03(\x0b2$.clarifai.api.TaskStatusCountPerUserR\x06cou\
    nts\"\x8c\x01\n\x15PostCollectorsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncollect\
    ors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\"\xa5\
    \x01\n\x16PatchCollectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncollectors\x18\
    \x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\x12\x16\n\x06\
    action\x18\x03\x20\x01(\tR\x06action\"\x86\x01\n\x17DeleteCollectorsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\
    \ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"t\n\x13GetCollectorReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12!\n\x0ccollector_id\x18\x02\x20\x01(\tR\x0bcollectorI\
    d\"\x82\x01\n\x15ListCollectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\
    \x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\
    \x07perPage\"\x86\x01\n\x16MultiCollectorResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\ncol\
    lectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\"\
    \x85\x01\n\x17SingleCollectorResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x125\n\tcollector\x18\
    \x02\x20\x01(\x0b2\x17.clarifai.api.CollectorR\tcollector\"\x8d\x01\n\
    \x15PostStatValuesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x128\n\x0bstat_values\x18\x02\
    \x20\x03(\x0b2\x17.clarifai.api.StatValueR\nstatValues\"\x8d\x01\n\x16Mu\
    ltiStatValueResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12>\n\x0bstat_values\x18\x02\x20\x03(\x0b\
    2\x17.clarifai.api.StatValueR\nstatValuesB\x04\x80\xb5\x18\x01\"\xc4\x01\
    \n\x1ePostStatValuesAggregateRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12f\n\x1cstat_valu\
    e_aggregate_queries\x18\x02\x20\x03(\x0b2%.clarifai.api.StatValueAggrega\
    teQueryR\x19statValueAggregateQueries\"\xbf\x01\n\x1fMultiStatValueAggre\
    gateResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12g\n\x1cstat_value_aggregate_results\x18\x02\x20\
    \x03(\x0b2&.clarifai.api.StatValueAggregateResultR\x19statValueAggregate\
    Results*p\n\x1cOrganizationInvitationStatus\x12\x0b\n\x07NOT_SET\x10\0\
    \x12\x0b\n\x07PENDING\x10\x01\x12\x0c\n\x08ACCEPTED\x10\x02\x12\r\n\tCAN\
    CELLED\x10\x03\x12\x0c\n\x08DECLINED\x10\x04\x12\x0b\n\x07EXPIRED\x10\
    \x052\xaf\xbe\x01\n\x02V2\x12\xaa\x02\n\x14ListConceptRelations\x12).cla\
    rifai.api.ListConceptRelationsRequest\x1a*.clarifai.api.MultiConceptRela\
    tionResponse\"\xba\x01\x90\x9c'\x0b\x98\x9c'\x05\x82\xd3\xe4\x93\x02\xab\
    \x01\x12Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/conce\
    pts/{concept_id}/relationsZN\x12L/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/concepts/relations\x12\xdf\x01\n\x14PostConceptRelati\
    ons\x12).clarifai.api.PostConceptRelationsRequest\x1a*.clarifai.api.Mult\
    iConceptRelationResponse\"p\x82\xd3\xe4\x93\x02^\"Y/v2/users/{user_app_i\
    d.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations:\
    \x01*\x90\x9c'\n\x90\x9c'\x0b\x98\x9c'\x05\x12\xde\x01\n\x16DeleteConcep\
    tRelations\x12+.clarifai.api.DeleteConceptRelationsRequest\x1a!.clarifai\
    .api.status.BaseResponse\"t\x90\x9c'\r\x90\x9c'\n\x90\x9c'\x0b\x98\x9c'\
    \x05\x82\xd3\xe4\x93\x02^*Y/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/concepts/{concept_id}/relations:\x01*\x12\xdc\x01\n\x10GetC\
    onceptCounts\x12%.clarifai.api.GetConceptCountsRequest\x1a'.clarifai.api\
    .MultiConceptCountResponse\"x\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/concepts/statusZ\x15\x12\x13/v2/concepts/status\x12\
    \xd0\x01\n\nGetConcept\x12\x1f.clarifai.api.GetConceptRequest\x1a#.clari\
    fai.api.SingleConceptResponse\"|\x90\x9c'\x0b\x82\xd3\xe4\x93\x02n\x12O/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{conce\
    pt_id}Z\x1b\x12\x19/v2/concepts/{concept_id}\x98\x9c'\x02\x12\xb9\x01\n\
    \x0cListConcepts\x12!.clarifai.api.ListConceptsRequest\x1a\".clarifai.ap\
    i.MultiConceptResponse\"b\x90\x9c'\x0b\x82\xd3\xe4\x93\x02T\x12B/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/conceptsZ\x0e\x12\x0c/\
    v2/concepts\x98\x9c'\x02\x12\xea\x01\n\x14PostConceptsSearches\x12).clar\
    ifai.api.PostConceptsSearchesRequest\x1a\".clarifai.api.MultiConceptResp\
    onse\"\x82\x01\x98\x9c'\x02\x82\xd3\xe4\x93\x02l\"K/v2/users/{user_app_i\
    d.user_id}/apps/{user_app_id.app_id}/concepts/searches:\x01*Z\x1a\"\x15/\
    v2/concepts/searches:\x01*\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x13\x12\
    \xc3\x01\n\x0cPostConcepts\x12!.clarifai.api.PostConceptsRequest\x1a\".c\
    larifai.api.MultiConceptResponse\"l\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\
    \x93\x02Z\"B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/co\
    ncepts:\x01*Z\x11\"\x0c/v2/concepts:\x01*\x98\x9c'\x02\x12\xc5\x01\n\rPa\
    tchConcepts\x12\".clarifai.api.PatchConceptsRequest\x1a\".clarifai.api.M\
    ultiConceptResponse\"l\x82\xd3\xe4\x93\x02Z2B/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/concepts:\x01*Z\x112\x0c/v2/concepts:\x01\
    *\x98\x9c'\x02\x90\x9c'\n\x90\x9c'\x0b\x12\x94\x02\n\x12GetConceptLangua\
    ge\x12'.clarifai.api.GetConceptLanguageRequest\x1a+.clarifai.api.SingleC\
    onceptLanguageResponse\"\xa7\x01\x82\xd3\xe4\x93\x02\x98\x01\x12d/v2/use\
    rs/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}\
    /languages/{language}Z0\x12./v2/concepts/{concept_id}/languages/{languag\
    e}\x90\x9c'\x0b\x98\x9c'\x02\x12\x81\x02\n\x14ListConceptLanguages\x12).\
    clarifai.api.ListConceptLanguagesRequest\x1a*.clarifai.api.MultiConceptL\
    anguageResponse\"\x91\x01\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\x82\x01\x12Y/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{conce\
    pt_id}/languagesZ%\x12#/v2/concepts/{concept_id}/languages\x98\x9c'\x02\
    \x12\x8b\x02\n\x14PostConceptLanguages\x12).clarifai.api.PostConceptLang\
    uagesRequest\x1a*.clarifai.api.MultiConceptLanguageResponse\"\x9b\x01\
    \x82\xd3\xe4\x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/apps/{use\
    r_app_id.app_id}/concepts/{concept_id}/languages:\x01*Z(\"#/v2/concepts/\
    {concept_id}/languages:\x01*\x98\x9c'\x02\x90\x9c'\n\x90\x9c'\x0b\x12\
    \x8d\x02\n\x15PatchConceptLanguages\x12*.clarifai.api.PatchConceptLangua\
    gesRequest\x1a*.clarifai.api.MultiConceptLanguageResponse\"\x9b\x01\x82\
    \xd3\xe4\x93\x02\x88\x012Y/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/concepts/{concept_id}/languages:\x01*Z(2#/v2/concepts/{conce\
    pt_id}/languages:\x01*\x98\x9c'\x02\x90\x9c'\n\x90\x9c'\x0b\x12\xf1\x01\
    \n\x13ListKnowledgeGraphs\x12(.clarifai.api.ListKnowledgeGraphsRequest\
    \x1a).clarifai.api.MultiKnowledgeGraphResponse\"\x84\x01\x82\xd3\xe4\x93\
    \x02v\x12S/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/conc\
    epts/knowledge_graphsZ\x1f\x12\x1d/v2/concepts/knowledge_graphs\x90\x9c'\
    \x0b\x98\x9c'\x02\x12\xfb\x01\n\x13PostKnowledgeGraphs\x12(.clarifai.api\
    .PostKnowledgeGraphsRequest\x1a).clarifai.api.MultiKnowledgeGraphRespons\
    e\"\x8e\x01\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02|\"S/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs:\
    \x01*Z\"\"\x1d/v2/concepts/knowledge_graphs:\x01*\x98\x9c'\x02\x12\xfe\
    \x01\n\x16PostConceptMappingJobs\x12+.clarifai.api.PostConceptMappingJob\
    sRequest\x1a,.clarifai.api.MultiConceptMappingJobResponse\"\x88\x01\x82\
    \xd3\xe4\x93\x02v\"P/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/concepts/mappings/jobs:\x01*Z\x1f\"\x1a/v2/concepts/mappings/jobs:\
    \x01*\x98\x9c'\x02\x90\x9c'\n\x90\x9c'\x0b\x12\x93\x02\n\rGetAnnotation\
    \x12\".clarifai.api.GetAnnotationRequest\x1a&.clarifai.api.SingleAnnotat\
    ionResponse\"\xb5\x01\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02\x9e\x01\x12g/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/inputs/{input_id}/annotations/{annotation_id}Z3\x121/v2/inputs/{i\
    nput_id}/annotations/{annotation_id}\x98\x9c'\x02\x12\xd0\x01\n\x0fListA\
    nnotations\x12$.clarifai.api.ListAnnotationsRequest\x1a%.clarifai.api.Mu\
    ltiAnnotationResponse\"p\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02Z\x12E/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    annotationsZ\x11\x12\x0f/v2/annotations\x98\x9c'\x02\x12\xe3\x01\n\x0fPo\
    stAnnotations\x12$.clarifai.api.PostAnnotationsRequest\x1a%.clarifai.api\
    .MultiAnnotationResponse\"\x82\x01\x98\x9c'\x02\x90\x9c'\x05\x90\x9c'%\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02`\"\
    E/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations:\
    \x01*Z\x14\"\x0f/v2/annotations:\x01*\x12\xe5\x01\n\x10PatchAnnotations\
    \x12%.clarifai.api.PatchAnnotationsRequest\x1a%.clarifai.api.MultiAnnota\
    tionResponse\"\x82\x01\x98\x9c'\x02\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02`2E/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/annotations:\x01*Z\x142\x0f/\
    v2/annotations:\x01*\x12\xf3\x01\n\x16PatchAnnotationsStatus\x12+.clarif\
    ai.api.PatchAnnotationsStatusRequest\x1a,.clarifai.api.PatchAnnotationsS\
    tatusResponse\"~\x82\xd3\xe4\x93\x02`2[/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/task/{task_id}/annotations/status:\x01*\x98\x9c\
    '\x02\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x12\x98\
    \x02\n\x10DeleteAnnotation\x12%.clarifai.api.DeleteAnnotationRequest\x1a\
    !.clarifai.api.status.BaseResponse\"\xb9\x01\x90\x9c'%\x90\x9c'(\x90\x9c\
    '&\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x9e\x01*g/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation\
    _id}Z3*1/v2/inputs/{input_id}/annotations/{annotation_id}\x98\x9c'\x02\
    \x12\xcc\x02\n\x11DeleteAnnotations\x12&.clarifai.api.DeleteAnnotationsR\
    equest\x1a!.clarifai.api.status.BaseResponse\"\xeb\x01\x98\x9c'\x02\x90\
    \x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\x82\xd3\xe4\x93\x02\xd0\x01*L/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/annotation\
    s:\x01*Z\x1b*\x16/v2/inputs/annotations:\x01*ZJ*E/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/annotations:\x01*Z\x14*\x0f/v2/annota\
    tions:\x01*\x12\x81\x02\n\x17PostAnnotationsSearches\x12,.clarifai.api.P\
    ostAnnotationsSearchesRequest\x1a!.clarifai.api.MultiSearchResponse\"\
    \x94\x01\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\x02r\"N/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/annotations/searches:\x01*Z\x1d\"\
    \x18/v2/annotations/searches:\x01*\x12\xd1\x01\n\rGetInputCount\x12\".cl\
    arifai.api.GetInputCountRequest\x1a&.clarifai.api.SingleInputCountRespon\
    se\"t\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.user_id}/apps/{use\
    r_app_id.app_id}/inputs/statusZ\x13\x12\x11/v2/inputs/status\x98\x9c'\
    \x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x12\xc9\x01\n\x0cStreamInputs\
    \x12!.clarifai.api.StreamInputsRequest\x1a\x20.clarifai.api.MultiInputRe\
    sponse\"t\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/inputs/streamZ\x13\x12\x11/v2/inputs/stream\x98\x9c\
    '\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x12\xfd\x01\n\x0fGetInputSampl\
    es\x12$.clarifai.api.GetInputSamplesRequest\x1a*.clarifai.api.MultiInput\
    AnnotationResponse\"\x97\x01\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c\
    '\x05\x82\xd3\xe4\x93\x02\x80\x01\x12X/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/tasks/{task_id}/inputs/samplesZ$\x12\"/v2/tasks/\
    {task_id}/inputs/samples\x12\xca\x01\n\x08GetInput\x12\x1d.clarifai.api.\
    GetInputRequest\x1a!.clarifai.api.SingleInputResponse\"|\x82\xd3\xe4\x93\
    \x02f\x12K/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inpu\
    ts/{input_id}Z\x17\x12\x15/v2/inputs/{input_id}\x98\x9c'\x02\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x12\xb7\x01\n\nListInputs\x12\x1f.clarifai.ap\
    i.ListInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"f\x82\xd3\
    \xe4\x93\x02P\x12@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/inputsZ\x0c\x12\n/v2/inputs\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x98\
    \x9c'\x02\x12\xd2\x01\n\nPostInputs\x12\x1f.clarifai.api.PostInputsReque\
    st\x1a\x20.clarifai.api.MultiInputResponse\"\x80\x01\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02V\"@/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/inputs:\x01*Z\x0f\"\n/v2/inputs:\x01*\x90\x9c'%\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\
    \x12\xcb\x01\n\x0bPatchInputs\x12\x20.clarifai.api.PatchInputsRequest\
    \x1a\x20.clarifai.api.MultiInputResponse\"x\x82\xd3\xe4\x93\x02V2@/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs:\x01*Z\x0f2\n\
    /v2/inputs:\x01*\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\
    \x05\x90\x9c'\x0f\x98\x9c'\x02\x12\xe5\x01\n\x0bDeleteInput\x12\x20.clar\
    ifai.api.DeleteInputRequest\x1a!.clarifai.api.status.BaseResponse\"\x90\
    \x01\x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/inputs/{input_id}Z\x17*\x15/v2/inputs/{input_id}\x98\x9c'\
    \x02\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x04\x90\x9c'\x08\x90\x9c'\
    \x05\x90\x9c'\x0f\x90\x9c'\x13\x12\xd7\x01\n\x0cDeleteInputs\x12!.clarif\
    ai.api.DeleteInputsRequest\x1a!.clarifai.api.status.BaseResponse\"\x80\
    \x01\x82\xd3\xe4\x93\x02V*@/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/inputs:\x01*Z\x0f*\n/v2/inputs:\x01*\x98\x9c'\x02\x90\x9c'%\
    \x90\x9c'(\x90\x9c'&\x90\x9c'\x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x13\x12\xed\x01\n\x12PostInputsSearches\x12'.clarifai.api.Post\
    InputsSearchesRequest\x1a!.clarifai.api.MultiSearchResponse\"\x8a\x01\
    \x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/inputs/searches:\x01*Z\x18\"\x13/v2/inputs/searches:\x01*\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\
    \x98\x9c'\x02\x12\x9c\x03\n\x10PostModelOutputs\x12%.clarifai.api.PostMo\
    delOutputsRequest\x1a!.clarifai.api.MultiOutputResponse\"\xbd\x02\x82\
    \xd3\xe4\x93\x02\xa6\x02\"i/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models/{model_id}/versions/{version_id}/outputs:\x01*Z8\"3/\
    v2/models/{model_id}/versions/{version_id}/outputs:\x01*ZX\"S/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/outputs\
    :\x01*Z\"\"\x1d/v2/models/{model_id}/outputs:\x01*\x90\x9c'\x0b\x90\x9c'\
    \x0f\x90\x9c'\x02\x98\x9c'\x02\x12\xe5\x01\n\x0cGetModelType\x12!.clarif\
    ai.api.GetModelTypeRequest\x1a%.clarifai.api.SingleModelTypeResponse\"\
    \x8a\x01\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{\
    user_app_id.app_id}/models/types/{model_type_id}Z\"\x12\x20/v2/models/ty\
    pes/{model_type_id}\x98\x9c'\x02\x90\x9c'\x0f\x12\xc7\x01\n\x0eListModel\
    Types\x12#.clarifai.api.ListModelTypesRequest\x1a$.clarifai.api.MultiMod\
    elTypeResponse\"j\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\\\x12F/v2/users/{user\
    _app_id.user_id}/apps/{user_app_id.app_id}/models/typesZ\x12\x12\x10/v2/\
    models/types\x98\x9c'\x02\x12\xc6\x01\n\x08GetModel\x12\x1d.clarifai.api\
    .GetModelRequest\x1a!.clarifai.api.SingleModelResponse\"x\x98\x9c'\x02\
    \x82\xd3\xe4\x93\x02f\x12K/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/models/{model_id}Z\x17\x12\x15/v2/models/{model_id}\x90\x9c'\
    \x0b\x90\x9c'\x0f\x12\x96\x03\n\x12GetModelOutputInfo\x12\x1d.clarifai.a\
    pi.GetModelRequest\x1a!.clarifai.api.SingleModelResponse\"\xbd\x02\x82\
    \xd3\xe4\x93\x02\xaa\x02\x12W/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/models/{model_id}/output_infoZ#\x12!/v2/models/{model_id}\
    /output_infoZo\x12m/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/models/{model_id}/versions/{version_id}/output_infoZ9\x127/v2/model\
    s/{model_id}/versions/{version_id}/output_info\x90\x9c'\x0b\x90\x9c'\x0f\
    \x98\x9c'\x02\x12\xb3\x01\n\nListModels\x12\x1f.clarifai.api.ListModelsR\
    equest\x1a\x20.clarifai.api.MultiModelResponse\"b\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02P\x12@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/modelsZ\x0c\x12\n/v2/models\x90\x9c'\x0b\x90\x9c'\x0f\x12\xdb\x01\n\
    \x12PostModelsSearches\x12'.clarifai.api.PostModelsSearchesRequest\x1a\
    \x20.clarifai.api.MultiModelResponse\"z\x90\x9c'\x0b\x90\x9c'\x0f\x98\
    \x9c'\x02\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/models/searches:\x01*Z\x18\"\x13/v2/models/searches:\
    \x01*\x12\xc6\x01\n\nPostModels\x12\x1f.clarifai.api.PostModelsRequest\
    \x1a!.clarifai.api.SingleModelResponse\"t\x98\x9c'\x02\x90\x9c'\x0b\x90\
    \x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x82\xd3\xe4\x93\x02V\"@\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models:\x01*Z\
    \x0f\"\n/v2/models:\x01*\x12\xc3\x01\n\x0bPatchModels\x12\x20.clarifai.a\
    pi.PatchModelsRequest\x1a\x20.clarifai.api.MultiModelResponse\"p\x90\x9c\
    '\x0b\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x82\xd3\xe4\x93\x02V2@/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models:\x01*Z\x0f2\
    \n/v2/models:\x01*\x98\x9c'\x02\x12\xd9\x01\n\x0bDeleteModel\x12\x20.cla\
    rifai.api.DeleteModelRequest\x1a!.clarifai.api.status.BaseResponse\"\x84\
    \x01\x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models/{model_id}Z\x17*\x15/v2/models/{model_id}\x90\x9c'\
    \x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\x98\x9c'\x02\
    \x12\xca\x01\n\x0cDeleteModels\x12!.clarifai.api.DeleteModelsRequest\x1a\
    !.clarifai.api.status.BaseResponse\"t\x82\xd3\xe4\x93\x02V*@/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/models:\x01*Z\x0f*\n/v2/mo\
    dels:\x01*\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\
    \x0f\x90\x9c'\x13\x12\x8d\x03\n\x0fListModelInputs\x12$.clarifai.api.Lis\
    tModelInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"\xb1\x02\
    \x82\xd3\xe4\x93\x02\x96\x02\x12R/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/models/{model_id}/inputsZ\x1e\x12\x1c/v2/models/{mode\
    l_id}/inputsZj\x12h/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/models/{model_id}/versions/{version_id}/inputsZ4\x122/v2/models/{mo\
    del_id}/versions/{version_id}/inputs\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x05\x90\x9c'\x0f\x12\x89\x02\n\x0fGetModelVersion\x12$.clarifa\
    i.api.GetModelVersionRequest\x1a(.clarifai.api.SingleModelVersionRespons\
    e\"\xa5\x01\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\
    \x92\x01\x12a/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/m\
    odels/{model_id}/versions/{version_id}Z-\x12+/v2/models/{model_id}/versi\
    ons/{version_id}\x12\xf1\x01\n\x11ListModelVersions\x12&.clarifai.api.Li\
    stModelVersionsRequest\x1a'.clarifai.api.MultiModelVersionResponse\"\x8a\
    \x01\x90\x9c'\x0b\x90\x9c'\x0f\x98\x9c'\x02\x82\xd3\xe4\x93\x02x\x12T/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}\
    /versionsZ\x20\x12\x1e/v2/models/{model_id}/versions\x12\x8d\x02\n\x11Po\
    stModelVersions\x12&.clarifai.api.PostModelVersionsRequest\x1a!.clarifai\
    .api.SingleModelResponse\"\xac\x01\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\
    \x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\
    \x98\x9c'\x02\x82\xd3\xe4\x93\x02~\"T/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/models/{model_id}/versions:\x01*Z#\"\x1e/v2/model\
    s/{model_id}/versions:\x01*\x12\xdb\x01\n\x12PatchModelVersions\x12'.cla\
    rifai.api.PatchModelVersionsRequest\x1a'.clarifai.api.MultiModelVersionR\
    esponse\"s\x82\xd3\xe4\x93\x02Y2T/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/models/{model_id}/versions:\x01*\x98\x9c'\x02\x90\x9c\
    '\x0b\x90\x9c'\x0f\x90\x9c'\x0e\x90\x9c'\x1a\x12\x94\x02\n\x12DeleteMode\
    lVersion\x12'.clarifai.api.DeleteModelVersionRequest\x1a!.clarifai.api.s\
    tatus.BaseResponse\"\xb1\x01\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0e\x90\
    \x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x92\x01*a/v2/use\
    rs/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/ver\
    sions/{version_id}Z-*+/v2/models/{model_id}/versions/{version_id}\x12\
    \xb3\x02\n\x16GetModelVersionMetrics\x12+.clarifai.api.GetModelVersionMe\
    tricsRequest\x1a(.clarifai.api.SingleModelVersionResponse\"\xc1\x01\x98\
    \x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\
    \xd3\xe4\x93\x02\xa2\x01\x12i/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/models/{model_id}/versions/{version_id}/metricsZ5\x123/v2\
    /models/{model_id}/versions/{version_id}/metrics\x12\xcf\x02\n\x17PostMo\
    delVersionMetrics\x12,.clarifai.api.PostModelVersionMetricsRequest\x1a(.\
    clarifai.api.SingleModelVersionResponse\"\xdb\x01\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02\xa8\x01\"i/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/models/{model_id}/versions/{version_id}/metrics:\x01*Z8\"3/v2/m\
    odels/{model_id}/versions/{version_id}/metrics:\x01*\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x02\
    \x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x12\xdc\x01\n\x0bGetWorkflow\x12\x20.c\
    larifai.api.GetWorkflowRequest\x1a$.clarifai.api.SingleWorkflowResponse\
    \"\x84\x01\x90\x9c'\x0f\x90\x9c'\x13\x98\x9c'\x02\x82\xd3\xe4\x93\x02r\
    \x12Q/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows\
    /{workflow_id}Z\x1d\x12\x1b/v2/workflows/{workflow_id}\x12\xc2\x01\n\rLi\
    stWorkflows\x12\".clarifai.api.ListWorkflowsRequest\x1a#.clarifai.api.Mu\
    ltiWorkflowResponse\"h\x82\xd3\xe4\x93\x02V\x12C/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/workflowsZ\x0f\x12\r/v2/workflows\x98\
    \x9c'\x02\x90\x9c'\x0f\x90\x9c'\x13\x12\xcc\x01\n\rPostWorkflows\x12\".c\
    larifai.api.PostWorkflowsRequest\x1a#.clarifai.api.MultiWorkflowResponse\
    \"r\x82\xd3\xe4\x93\x02\\\"C/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/workflows:\x01*Z\x12\"\r/v2/workflows:\x01*\x98\x9c'\x02\
    \x90\x9c'\x0f\x90\x9c'\x12\x90\x9c'\x13\x12\xce\x01\n\x0ePatchWorkflows\
    \x12#.clarifai.api.PatchWorkflowsRequest\x1a#.clarifai.api.MultiWorkflow\
    Response\"r\x98\x9c'\x02\x82\xd3\xe4\x93\x02\\2C/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/workflows:\x01*Z\x122\r/v2/workflows:\
    \x01*\x90\x9c'\x0f\x90\x9c'\x12\x90\x9c'\x13\x12\xe3\x01\n\x0eDeleteWork\
    flow\x12#.clarifai.api.DeleteWorkflowRequest\x1a!.clarifai.api.status.Ba\
    seResponse\"\x88\x01\x90\x9c'\x12\x90\x9c'\x15\x90\x9c'\x13\x98\x9c'\x02\
    \x82\xd3\xe4\x93\x02r*Q/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/workflows/{workflow_id}Z\x1d*\x1b/v2/workflows/{workflow_id}\
    \x12\xce\x01\n\x0fDeleteWorkflows\x12$.clarifai.api.DeleteWorkflowsReque\
    st\x1a!.clarifai.api.status.BaseResponse\"r\x82\xd3\xe4\x93\x02\\*C/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows:\x01*Z\
    \x12*\r/v2/workflows:\x01*\x90\x9c'\x12\x90\x9c'\x15\x90\x9c'\x13\x98\
    \x9c'\x02\x12\x90\x02\n\x13PostWorkflowResults\x12(.clarifai.api.PostWor\
    kflowResultsRequest\x1a).clarifai.api.PostWorkflowResultsResponse\"\xa3\
    \x01\x82\xd3\xe4\x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/workflows/{workflow_id}/results:\x01*Z(\"#/v2/workf\
    lows/{workflow_id}/results:\x01*\x98\x9c'\x02\x90\x9c'\x0f\x90\x9c'\x0b\
    \x90\x9c'\x02\x90\x9c'\x13\x12\xc4\x02\n\x1dPostWorkflowResultsSimilarit\
    y\x122.clarifai.api.PostWorkflowResultsSimilarityRequest\x1a3.clarifai.a\
    pi.PostWorkflowResultsSimilarityResponse\"\xb9\x01\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02\x9e\x01\"d/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/workflows/{workflow_id}/results/similarity:\x01*Z3\"./v2/workfl\
    ows/{workflow_id}/results/similarity:\x01*\x90\x9c'\x0f\x90\x9c'\x0b\x90\
    \x9c'\x02\x90\x9c'\x13\x12\x85\x01\n\x06GetKey\x12\x1b.clarifai.api.GetK\
    eyRequest\x1a\x1f.clarifai.api.SingleKeyResponse\"=\x90\x9c'0\x82\xd3\
    \xe4\x93\x02/\x12-/v2/users/{user_app_id.user_id}/keys/{key_id}\x98\x9c'\
    \x05\x12\x7f\n\x08ListKeys\x12\x1d.clarifai.api.ListKeysRequest\x1a\x1e.\
    clarifai.api.MultiKeyResponse\"4\x90\x9c'0\x82\xd3\xe4\x93\x02&\x12$/v2/\
    users/{user_app_id.user_id}/keys\x98\x9c'\x05\x12\x9f\x01\n\x0bListAppKe\
    ys\x12\x20.clarifai.api.ListAppKeysRequest\x1a\x1e.clarifai.api.MultiKey\
    Response\"N\x82\xd3\xe4\x93\x02@\x12>/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/keys\x98\x9c'\x05\x90\x9c'0\x12\x95\x01\n\tDelete\
    Key\x12\x1e.clarifai.api.DeleteKeyRequest\x1a!.clarifai.api.status.BaseR\
    esponse\"E\x90\x9c'/\x90\x9c'1\x90\x9c'0\x98\x9c'\x05\x82\xd3\xe4\x93\
    \x02/*-/v2/users/{user_app_id.user_id}/keys/{key_id}\x12\x8a\x01\n\x08Po\
    stKeys\x12\x1d.clarifai.api.PostKeysRequest\x1a\x1e.clarifai.api.MultiKe\
    yResponse\"?\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_id}/keys\
    :\x01*\x98\x9c'\x05\x90\x9c'-\x90\x9c'/\x90\x9c'0\x12\x88\x01\n\tPatchKe\
    ys\x12\x1e.clarifai.api.PatchKeysRequest\x1a\x1e.clarifai.api.MultiKeyRe\
    sponse\";\x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/keys:\
    \x01*\x90\x9c'/\x90\x9c'0\x98\x9c'\x05\x12\xbc\x01\n\x08MyScopes\x12\x1d\
    .clarifai.api.MyScopesRequest\x1a\x20.clarifai.api.MultiScopeResponse\"o\
    \x98\x9c'\x02\x82\xd3\xe4\x93\x02e\x12B/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/myscopesZ\x0e\x12\x0c/v2/myscopesZ\x0f\x12\r/v2\
    /my_scopes\x12\x87\x01\n\nListScopes\x12\x1f.clarifai.api.ListScopesRequ\
    est\x1a$.clarifai.api.MultiScopeDepsResponse\"2\x98\x9c'\x03\x82\xd3\xe4\
    \x93\x02(\x12&/v2/users/{user_app_id.user_id}/scopes\x12\x95\x01\n\x06Ge\
    tApp\x12\x1b.clarifai.api.GetAppRequest\x1a\x1f.clarifai.api.SingleAppRe\
    sponse\"M\x98\x9c'\x05\x82\xd3\xe4\x93\x02;\x129/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}\x90\x9c'-\x90\x9c'\x13\x12\x8f\x01\n\
    \x08ListApps\x12\x1d.clarifai.api.ListAppsRequest\x1a\x1e.clarifai.api.M\
    ultiAppResponse\"D\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x022\x12$/v2/users/{user_app_id.user_id}/appsZ\n\x12\x08/v2/apps\x12\
    \xa5\x01\n\tDeleteApp\x12\x1e.clarifai.api.DeleteAppRequest\x1a!.clarifa\
    i.api.status.BaseResponse\"U\x90\x9c',\x90\x9c'.\x90\x9c'-\x90\x9c'\x13\
    \x82\xd3\xe4\x93\x02;*9/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}\x98\x9c'\x05\x12\x92\x01\n\x08PostApps\x12\x1d.clarifai.api.Pos\
    tAppsRequest\x1a\x1e.clarifai.api.MultiAppResponse\"G\x82\xd3\xe4\x93\
    \x02)\"$/v2/users/{user_app_id.user_id}/apps:\x01*\x90\x9c',\x90\x9c'-\
    \x90\x9c'\x0f\x90\x9c'\x13\x90\x9c'\x12\x98\x9c'\x05\x12\x88\x01\n\tPatc\
    hApps\x12\x1e.clarifai.api.PatchAppsRequest\x1a\x1e.clarifai.api.MultiAp\
    pResponse\";\x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/apps:\
    \x01*\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x12\x9f\x01\n\x10PostAppsSearches\
    \x12%.clarifai.api.PostAppsSearchesRequest\x1a\x1e.clarifai.api.MultiApp\
    Response\"D\x82\xd3\xe4\x93\x022\"-/v2/users/{user_app_id.user_id}/apps/\
    searches:\x01*\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x13\x12\xd3\x01\n\x14Post\
    ValidatePassword\x12).clarifai.api.PostValidatePasswordRequest\x1a..clar\
    ifai.api.SinglePasswordValidationResponse\"`\x90\x9c':\x98\x9c'\x05\x82\
    \xd3\xe4\x93\x02R\"1/v2/users/{user_app_id.user_id}/validate_password:\
    \x01*Z\x1a\"\x15/v2/validate_password:\x01*\x12\xbd\x01\n\tGetSearch\x12\
    \x1e.clarifai.api.GetSearchRequest\x1a\".clarifai.api.SingleSearchRespon\
    se\"l\x90\x9c'\x03\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.user_\
    id}/apps/{user_app_id.app_id}/searches/{id}Z\x13\x12\x11/v2/searches/{id\
    }\x98\x9c'\x02\x12\xb8\x01\n\x0cListSearches\x12!.clarifai.api.ListSearc\
    hesRequest\x1a!.clarifai.api.MultiSearchResponse\"b\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/searchesZ\x0e\x12\x0c/v2/searches\x90\x9c'\x03\x12\xd2\x01\n\x0cPost\
    Searches\x12!.clarifai.api.PostSearchesRequest\x1a!.clarifai.api.MultiSe\
    archResponse\"|\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c\
    '\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\x02Z\"B/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/searches:\x01*Z\x11\"\x0c/v2/se\
    arches:\x01*\x12\xd0\x01\n\x10PostSearchesByID\x12%.clarifai.api.PostSea\
    rchesByIDRequest\x1a!.clarifai.api.MultiSearchResponse\"r\x90\x9c'\x03\
    \x82\xd3\xe4\x93\x02d\"G/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/searches/{id}:\x01*Z\x16\"\x11/v2/searches/{id}:\x01*\x98\x9c'\
    \x02\x12\xaf\x02\n\x1bPostAnnotationSearchMetrics\x120.clarifai.api.Post\
    AnnotationSearchMetricsRequest\x1a2.clarifai.api.MultiAnnotationSearchMe\
    tricsResponse\"\xa9\x01\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\
    \x90\x9c'5\x90\x9c'6\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x82\
    \x01\"V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotat\
    ions/searches/metrics:\x01*Z%\"\x20/v2/annotations/searches/metrics:\x01\
    *\x12\xa5\x02\n\x1aGetAnnotationSearchMetrics\x12/.clarifai.api.GetAnnot\
    ationSearchMetricsRequest\x1a2.clarifai.api.MultiAnnotationSearchMetrics\
    Response\"\xa1\x01\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x82\xd3\
    \xe4\x93\x02\x86\x01\x12[/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/annotations/searches/metrics/{id}Z'\x12%/v2/annotations/searc\
    hes/metrics/{id}\x98\x9c'\x02\x12\x9c\x02\n\x1bListAnnotationSearchMetri\
    cs\x120.clarifai.api.ListAnnotationSearchMetricsRequest\x1a2.clarifai.ap\
    i.MultiAnnotationSearchMetricsResponse\"\x96\x01\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/annotations/searches/metricsZ\"\x12\x20/v2/annotations/searches/metr\
    ics\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x12\x96\x02\n\x1dDelet\
    eAnnotationSearchMetrics\x122.clarifai.api.DeleteAnnotationSearchMetrics\
    Request\x1a!.clarifai.api.status.BaseResponse\"\x9d\x01\x90\x9c'5\x90\
    \x9c'6\x90\x9c'?\x82\xd3\xe4\x93\x02\x86\x01*[/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}Z'*%/v2\
    /annotations/searches/metrics/{id}\x98\x9c'\x02\x12\xc2\x01\n\x0cDeleteS\
    earch\x12!.clarifai.api.DeleteSearchRequest\x1a!.clarifai.api.status.Bas\
    eResponse\"l\x82\xd3\xe4\x93\x02^*G/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/searches/{id}Z\x13*\x11/v2/searches/{id}\x98\x9c'\
    \x02\x90\x9c'\x03\x12|\n\x0fListStatusCodes\x12$.clarifai.api.ListStatus\
    CodesRequest\x1a%.clarifai.api.MultiStatusCodeResponse\"\x1c\x82\xd3\xe4\
    \x93\x02\x12\x12\x10/v2/status_codes\x98\x9c'\x01\x12\x8a\x01\n\rGetStat\
    usCode\x12\".clarifai.api.GetStatusCodeRequest\x1a&.clarifai.api.SingleS\
    tatusCodeResponse\"-\x82\xd3\xe4\x93\x02#\x12!/v2/status_codes/{status_c\
    ode_id}\x98\x9c'\x01\x12\xbe\x01\n\x11ListCollaborators\x12&.clarifai.ap\
    i.ListCollaboratorsRequest\x1a(.clarifai.api.MultiCollaboratorsResponse\
    \"W\x90\x9c'2\x82\xd3\xe4\x93\x02I\x12G/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/collaborators\x98\x9c'\x02\x12\xc5\x01\n\x11Pos\
    tCollaborators\x12&.clarifai.api.PostCollaboratorsRequest\x1a(.clarifai.\
    api.MultiCollaboratorsResponse\"^\x82\xd3\xe4\x93\x02L\"G/v2/users/{user\
    _app_id.user_id}/apps/{user_app_id.app_id}/collaborators:\x01*\x98\x9c'\
    \x02\x90\x9c'3\x90\x9c'2\x12\xcb\x01\n\x12PatchCollaborators\x12'.clarif\
    ai.api.PatchCollaboratorsRequest\x1a(.clarifai.api.MultiCollaboratorsRes\
    ponse\"b\x98\x9c'\x02\x90\x9c'3\x90\x9c'2\x90\x9c'4\x82\xd3\xe4\x93\x02L\
    2G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborator\
    s:\x01*\x12\xce\x01\n\x13DeleteCollaborators\x12(.clarifai.api.DeleteCol\
    laboratorsRequest\x1a!.clarifai.api.status.BaseResponse\"j\x90\x9c'3\x90\
    \x9c'2\x90\x9c'4\x90\x9c'7\x90\x9c'8\x98\x9c'\x02\x82\xd3\xe4\x93\x02L*G\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators:\
    \x01*\x12\xa4\x01\n\x12ListCollaborations\x12'.clarifai.api.ListCollabor\
    ationsRequest\x1a).clarifai.api.MultiCollaborationsResponse\":\x82\xd3\
    \xe4\x93\x020\x12./v2/users/{user_app_id.user_id}/collaborations\x98\x9c\
    '\x03\x12\xef\x01\n\x13PostAppDuplications\x12(.clarifai.api.PostAppDupl\
    icationsRequest\x1a*.clarifai.api.MultiAppDuplicationsResponse\"\x81\x01\
    \x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\n\x90\x9c'\x0b\x90\x9c'\
    \x04\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x12\x90\x9c'\x13\x98\x9c'\
    \x02\x82\xd3\xe4\x93\x02K\"F/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/duplications:\x01*\x12\xa5\x01\n\x13ListAppDuplications\
    \x12(.clarifai.api.ListAppDuplicationsRequest\x1a*.clarifai.api.MultiApp\
    DuplicationsResponse\"8\x98\x9c'\x03\x82\xd3\xe4\x93\x02.\x12,/v2/users/\
    {user_app_id.user_id}/duplications\x12\xb6\x01\n\x11GetAppDuplication\
    \x12&.clarifai.api.GetAppDuplicationRequest\x1a*.clarifai.api.SingleAppD\
    uplicationResponse\"M\x82\xd3\xe4\x93\x02C\x12A/v2/users/{user_app_id.us\
    er_id}/duplications/{app_duplication_id}\x98\x9c'\x03\x12\xd1\x01\n\tPos\
    tTasks\x12\x1e.clarifai.api.PostTasksRequest\x1a\x1f.clarifai.api.MultiT\
    askResponse\"\x82\x01\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'\x03\x90\
    \x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02T\"?/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/tasks:\x01*Z\x0e\"\t/v2/tasks:\x01*\x12\xfa\x01\n\x16GetTaskAnnota\
    tionCount\x12!.clarifai.api.GetTaskCountRequest\x1a%.clarifai.api.Single\
    TaskCountResponse\"\x95\x01\x98\x9c'\x02\x90\x9c'8\x82\xd3\xe4\x93\x02\
    \x86\x01\x12[/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/t\
    asks/{task_id}/annotations/countZ'\x12%/v2/tasks/{task_id}/annotations/c\
    ount\x12\xea\x01\n\x11GetTaskInputCount\x12!.clarifai.api.GetTaskCountRe\
    quest\x1a%.clarifai.api.SingleTaskCountResponse\"\x8a\x01\x82\xd3\xe4\
    \x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    tasks/{task_id}/inputs/countZ\"\x12\x20/v2/tasks/{task_id}/inputs/count\
    \x98\x9c'\x02\x90\x9c'8\x12\xcc\x01\n\x07GetTask\x12\x1c.clarifai.api.Ge\
    tTaskRequest\x1a\x20.clarifai.api.SingleTaskResponse\"\x80\x01\x82\xd3\
    \xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/tasks/{task_id}Z\x15\x12\x13/v2/tasks/{task_id}\x98\x9c'\x02\x90\x9c\
    '8\x90\x9c'\x03\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x12\xba\x01\n\tLi\
    stTasks\x12\x1e.clarifai.api.ListTasksRequest\x1a\x1f.clarifai.api.Multi\
    TaskResponse\"l\x98\x9c'\x02\x82\xd3\xe4\x93\x02N\x12?/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/tasksZ\x0b\x12\t/v2/tasks\x90\
    \x9c'8\x90\x9c'\x03\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x12\xd3\x01\n\
    \nPatchTasks\x12\x1f.clarifai.api.PatchTasksRequest\x1a\x1f.clarifai.api\
    .MultiTaskResponse\"\x82\x01\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'\
    \x03\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x82\xd3\
    \xe4\x93\x02T2?/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /tasks:\x01*Z\x0e2\t/v2/tasks:\x01*\x98\x9c'\x02\x12\xbe\x01\n\x0bDelete\
    Tasks\x12\x20.clarifai.api.DeleteTasksRequest\x1a!.clarifai.api.status.B\
    aseResponse\"j\x82\xd3\xe4\x93\x02T*?/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/tasks:\x01*Z\x0e*\t/v2/tasks:\x01*\x90\x9c'7\x90\
    \x9c'8\x90\x9c'F\x98\x9c'\x02\x12\xee\x01\n\x0ePostCollectors\x12#.clari\
    fai.api.PostCollectorsRequest\x1a$.clarifai.api.MultiCollectorResponse\"\
    \x90\x01\x98\x9c'\x02\x82\xd3\xe4\x93\x02^\"D/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x13\"\x0e/v2/collectors\
    :\x01*\x90\x9c'\x04\x90\x9c'%\x90\x9c'&\x90\x9c')\x90\x9c'\x0b\x90\x9c'\
    \x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x12\xdf\x01\n\
    \x0cGetCollector\x12!.clarifai.api.GetCollectorRequest\x1a%.clarifai.api\
    .SingleCollectorResponse\"\x84\x01\x90\x9c'*\x82\xd3\xe4\x93\x02v\x12S/v\
    2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors/{coll\
    ector_id}Z\x1f\x12\x1d/v2/collectors/{collector_id}\x98\x9c'\x02\x12\xc3\
    \x01\n\x0eListCollectors\x12#.clarifai.api.ListCollectorsRequest\x1a$.cl\
    arifai.api.MultiCollectorResponse\"f\x98\x9c'\x02\x82\xd3\xe4\x93\x02X\
    \x12D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collector\
    sZ\x10\x12\x0e/v2/collectors\x90\x9c'*\x12\xcf\x01\n\x0fPatchCollectors\
    \x12$.clarifai.api.PatchCollectorsRequest\x1a$.clarifai.api.MultiCollect\
    orResponse\"p\x90\x9c')\x90\x9c'*\x82\xd3\xe4\x93\x02^2D/v2/users/{user_\
    app_id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x132\x0e/v2/\
    collectors:\x01*\x98\x9c'\x02\x12\xd2\x01\n\x10DeleteCollectors\x12%.cla\
    rifai.api.DeleteCollectorsRequest\x1a!.clarifai.api.status.BaseResponse\
    \"t\x90\x9c')\x90\x9c'+\x90\x9c'*\x98\x9c'\x02\x82\xd3\xe4\x93\x02^*D/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\
    \x13*\x0e/v2/collectors:\x01*\x12\xc9\x01\n\x0ePostStatValues\x12#.clari\
    fai.api.PostStatValuesRequest\x1a$.clarifai.api.MultiStatValueResponse\"\
    l\x82\xd3\xe4\x93\x02b\"F/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/stats/values:\x01*Z\x15\"\x10/v2/stats/values:\x01*\x98\x9c'\
    \x02\x12\xf9\x01\n\x17PostStatValuesAggregate\x12,.clarifai.api.PostStat\
    ValuesAggregateRequest\x1a-.clarifai.api.MultiStatValueAggregateResponse\
    \"\x80\x01\x98\x9c'\x02\x82\xd3\xe4\x93\x02v\"P/v2/users/{user_app_id.us\
    er_id}/apps/{user_app_id.app_id}/stats/values/aggregate:\x01*Z\x1f\"\x1a\
    /v2/stats/values/aggregate:\x01*B]\n\x15com.clarifai.grpc.apiP\x01Z;gith\
    ub.com/Clarifai/clarifai-go-grpc/proto/clarifai/api/api\xa2\x02\x04CAIPJ\
    \xc4\xea\x05\n\x07\x12\x05\x02\0\xd2\x1d\x01\n\x08\n\x01\x0c\x12\x03\x02\
    \0\x12\n\t\n\x02\x03\0\x12\x03\x04\0,\n\t\n\x02\x03\x01\x12\x03\x05\00\n\
    \t\n\x02\x03\x02\x12\x03\x06\03\n\t\n\x02\x03\x03\x12\x03\x07\0/\n\t\n\
    \x02\x03\x04\x12\x03\x08\02\n\t\n\x02\x03\x05\x12\x03\t\05\n\t\n\x02\x03\
    \x06\x12\x03\x0b\0&\n\t\n\x02\x03\x07\x12\x03\x0c\0(\n\t\n\x02\x03\x08\
    \x12\x03\r\0&\n\t\n\x02\x03\t\x12\x03\x0e\0)\n\x08\n\x01\x02\x12\x03\x11\
    \0\x15\n\x08\n\x01\x08\x12\x03\x13\0R\n\t\n\x02\x08\x0b\x12\x03\x13\0R\n\
    \x08\n\x01\x08\x12\x03\x14\0\"\n\t\n\x02\x08\n\x12\x03\x14\0\"\n\x08\n\
    \x01\x08\x12\x03\x15\0.\n\t\n\x02\x08\x01\x12\x03\x15\0.\n\x08\n\x01\x08\
    \x12\x03\x16\0\"\n\t\n\x02\x08$\x12\x03\x16\0\"\n\xfa\x01\n\x02\x06\0\
    \x12\x05!\0\x99\x0f\x012\xec\x01\nNote:\x20this\x20is\x20based\x20on\x20\
    the\x20google\x20api\x20format\x20defined\x20here.\x20Please\nread\x20th\
    is\x20before\x20contributing\x20to\x20this\x20file\x20and\x20other\x20*.\
    proto\x20files\nfor\x20the\x20API.\nhttps://cloud.google.com/service-man\
    agement/reference/rpc/google.api#google.api.HttpRule\n\n\n\n\x03\x06\0\
    \x01\x12\x03!\x08\n\n\xc4\x02\n\x04\x06\0\x02\0\x12\x04/\x028\x03\x1a\
    \xce\x01\x20List\x20concept\x20relations\x20between\x20concepts\x20in\
    \x20the\x20platform.\n\x20MUST\x20be\x20above\x20ListConcepts\x20so\x20t\
    hat\x20if\x20concept_id\x20is\x20empty\x20this\x20will\x20still\x20match\
    \n\x20/concepts/relations\x20to\x20list\x20all\x20the\x20concept\x20rela\
    tions\x20in\x20the\x20app.\n2e//////////////////////////////////////\n\
    \x20Concept\x20Relationships\n//////////////////////////////////////\n\n\
    \x0c\n\x05\x06\0\x02\0\x01\x12\x03/\x06\x1a\n\x0c\n\x05\x06\0\x02\0\x02\
    \x12\x03/\x1c7\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03/B^\n\r\n\x05\x06\0\
    \x02\0\x04\x12\x040\x045\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\
    \x040\x045\x06\n\x0c\n\x05\x06\0\x02\0\x04\x12\x036\x047\n\x0f\n\x08\x06\
    \0\x02\0\x04\xc3\xf3\x04\x12\x036\x047\n\x0c\n\x05\x06\0\x02\0\x04\x12\
    \x037\x04C\n\x10\n\t\x06\0\x02\0\x04\xc2\xf3\x04\0\x12\x037\x04C\n\\\n\
    \x04\x06\0\x02\x01\x12\x04=\x02E\x03\x1aN\x20Post\x20concept\x20relation\
    s\x20to\x20create\x20relations\x20between\x20concepts\x20in\x20the\x20pl\
    atform.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03=\x06\x1a\n\x0c\n\x05\x06\
    \0\x02\x01\x02\x12\x03=\x1c7\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03=B^\n\
    \r\n\x05\x06\0\x02\x01\x04\x12\x04>\x04A\x06\n\x11\n\t\x06\0\x02\x01\x04\
    \xb0\xca\xbc\"\x12\x04>\x04A\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03B\
    \x047\n\x0f\n\x08\x06\0\x02\x01\x04\xc3\xf3\x04\x12\x03B\x047\n\x0c\n\
    \x05\x06\0\x02\x01\x04\x12\x03C\x04C\n\x10\n\t\x06\0\x02\x01\x04\xc2\xf3\
    \x04\0\x12\x03C\x04C\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03D\x04C\n\x10\n\
    \t\x06\0\x02\x01\x04\xc2\xf3\x04\x01\x12\x03D\x04C\n\\\n\x04\x06\0\x02\
    \x02\x12\x04H\x02Q\x03\x1aN\x20Post\x20concept\x20relations\x20to\x20cre\
    ate\x20relations\x20between\x20concepts\x20in\x20the\x20platform.\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x03H\x06\x1c\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03H\x1e;\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03HFf\n\r\n\x05\
    \x06\0\x02\x02\x04\x12\x04I\x04L\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\
    \xbc\"\x12\x04I\x04L\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03M\x047\n\
    \x0f\n\x08\x06\0\x02\x02\x04\xc3\xf3\x04\x12\x03M\x047\n\x0c\n\x05\x06\0\
    \x02\x02\x04\x12\x03N\x04F\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\0\x12\
    \x03N\x04F\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03O\x04C\n\x10\n\t\x06\0\
    \x02\x02\x04\xc2\xf3\x04\x01\x12\x03O\x04C\n\x0c\n\x05\x06\0\x02\x02\x04\
    \x12\x03P\x04C\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x02\x12\x03P\x04C\
    \n\xa7\x01\n\x04\x06\0\x02\x03\x12\x04[\x02f\x03\x1a?\x20List\x20all\x20\
    the\x20concepts\x20with\x20their\x20positive\x20and\x20negative\x20count\
    s\n2X//////////////////////////////////////\n\x20Concepts\n/////////////\
    /////////////////////////\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03[\x06\
    \x16\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03[\x18/\n\x0c\n\x05\x06\0\x02\
    \x03\x03\x12\x03[:S\n\r\n\x05\x06\0\x02\x03\x04\x12\x04\\\x04a\x06\n\x11\
    \n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04\\\x04a\x06\n\x0c\n\x05\x06\
    \0\x02\x03\x04\x12\x03b\x047\n\x0f\n\x08\x06\0\x02\x03\x04\xc3\xf3\x04\
    \x12\x03b\x047\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03c\x04F\n\x10\n\t\x06\
    \0\x02\x03\x04\xc2\xf3\x04\0\x12\x03c\x04F\n\x0c\n\x05\x06\0\x02\x03\x04\
    \x12\x03d\x04C\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x01\x12\x03d\x04C\
    \n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03e\x04A\n\x10\n\t\x06\0\x02\x03\x04\
    \xc2\xf3\x04\x02\x12\x03e\x04A\n3\n\x04\x06\0\x02\x04\x12\x04i\x02r\x03\
    \x1a%\x20Get\x20a\x20specific\x20concept\x20from\x20an\x20app.\n\n\x0c\n\
    \x05\x06\0\x02\x04\x01\x12\x03i\x06\x10\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03i\x12#\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03i.C\n\r\n\x05\x06\0\
    \x02\x04\x04\x12\x04j\x04o\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x12\x04j\x04o\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03p\x047\n\x0f\n\
    \x08\x06\0\x02\x04\x04\xc3\xf3\x04\x12\x03p\x047\n\x0c\n\x05\x06\0\x02\
    \x04\x04\x12\x03q\x04C\n\x10\n\t\x06\0\x02\x04\x04\xc2\xf3\x04\0\x12\x03\
    q\x04C\n&\n\x04\x06\0\x02\x05\x12\x04u\x02~\x03\x1a\x18\x20List\x20all\
    \x20the\x20concepts.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03u\x06\x12\n\
    \x0c\n\x05\x06\0\x02\x05\x02\x12\x03u\x14'\n\x0c\n\x05\x06\0\x02\x05\x03\
    \x12\x03u2F\n\r\n\x05\x06\0\x02\x05\x04\x12\x04v\x04{\x06\n\x11\n\t\x06\
    \0\x02\x05\x04\xb0\xca\xbc\"\x12\x04v\x04{\x06\n\x0c\n\x05\x06\0\x02\x05\
    \x04\x12\x03|\x047\n\x0f\n\x08\x06\0\x02\x05\x04\xc3\xf3\x04\x12\x03|\
    \x047\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03}\x04C\n\x10\n\t\x06\0\x02\
    \x05\x04\xc2\xf3\x04\0\x12\x03}\x04C\n\xcd\x01\n\x04\x06\0\x02\x06\x12\
    \x06\x83\x01\x02\x90\x01\x03\x1a\xbc\x01\x20Search\x20over\x20the\x20con\
    cepts\x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\
    \x20This\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\
    \x20also\x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20p\
    aram\x20variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02\x06\
    \x01\x12\x04\x83\x01\x06\x1a\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x83\x01\
    \x1c7\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x83\x01BV\n\x0f\n\x05\x06\0\
    \x02\x06\x04\x12\x06\x84\x01\x04\x8b\x01\x06\n\x13\n\t\x06\0\x02\x06\x04\
    \xb0\xca\xbc\"\x12\x06\x84\x01\x04\x8b\x01\x06\n\r\n\x05\x06\0\x02\x06\
    \x04\x12\x04\x8c\x01\x047\n\x10\n\x08\x06\0\x02\x06\x04\xc3\xf3\x04\x12\
    \x04\x8c\x01\x047\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x8d\x01\x04C\n\x11\
    \n\t\x06\0\x02\x06\x04\xc2\xf3\x04\0\x12\x04\x8d\x01\x04C\n\r\n\x05\x06\
    \0\x02\x06\x04\x12\x04\x8e\x01\x04A\n\x11\n\t\x06\0\x02\x06\x04\xc2\xf3\
    \x04\x01\x12\x04\x8e\x01\x04A\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x8f\
    \x01\x04D\nP\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\x02\x12\x04\x8f\x01\x04D\
    \"=\x20as\x20it\x20needs\x20to\x20know\x20the\x20concepts\x20in\x20your\
    \x20workflow's\x20models.\n\n*\n\x04\x06\0\x02\x07\x12\x06\x93\x01\x02\
    \x9f\x01\x03\x1a\x1a\x20Add\x20a\x20concept\x20to\x20an\x20app.\n\n\r\n\
    \x05\x06\0\x02\x07\x01\x12\x04\x93\x01\x06\x12\n\r\n\x05\x06\0\x02\x07\
    \x02\x12\x04\x93\x01\x14'\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\x93\x012F\
    \n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x94\x01\x04\x9b\x01\x06\n\x13\n\t\
    \x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\x94\x01\x04\x9b\x01\x06\n\r\n\
    \x05\x06\0\x02\x07\x04\x12\x04\x9c\x01\x047\n\x10\n\x08\x06\0\x02\x07\
    \x04\xc3\xf3\x04\x12\x04\x9c\x01\x047\n\r\n\x05\x06\0\x02\x07\x04\x12\
    \x04\x9d\x01\x04C\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\0\x12\x04\x9d\
    \x01\x04C\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\x9e\x01\x04C\n\x11\n\t\x06\
    \0\x02\x07\x04\xc2\xf3\x04\x01\x12\x04\x9e\x01\x04C\n-\n\x04\x06\0\x02\
    \x08\x12\x06\xa2\x01\x02\xae\x01\x03\x1a\x1d\x20Patch\x20one\x20or\x20mo\
    re\x20concepts.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xa2\x01\x06\x13\n\
    \r\n\x05\x06\0\x02\x08\x02\x12\x04\xa2\x01\x15)\n\r\n\x05\x06\0\x02\x08\
    \x03\x12\x04\xa2\x014H\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xa3\x01\x04\
    \xaa\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xa3\x01\
    \x04\xaa\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xab\x01\x047\n\x10\
    \n\x08\x06\0\x02\x08\x04\xc3\xf3\x04\x12\x04\xab\x01\x047\n\r\n\x05\x06\
    \0\x02\x08\x04\x12\x04\xac\x01\x04C\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\
    \x04\0\x12\x04\xac\x01\x04C\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xad\x01\
    \x04C\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\x04\x01\x12\x04\xad\x01\x04C\n\
    \xc1\x01\n\x04\x06\0\x02\t\x12\x06\xc4\x01\x02\xcd\x01\x03\x1a%\x20Get\
    \x20a\x20specific\x20concept\x20from\x20an\x20app.\n2'//////////////////\
    ////////////////////\n2a//////////////////////////////////////\n\x20Conc\
    ept\x20Languages\n//////////////////////////////////////\n\n\r\n\x05\x06\
    \0\x02\t\x01\x12\x04\xc4\x01\x06\x18\n\r\n\x05\x06\0\x02\t\x02\x12\x04\
    \xc4\x01\x1a3\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xc4\x01>[\n\x0f\n\x05\
    \x06\0\x02\t\x04\x12\x06\xc5\x01\x04\xca\x01\x06\n\x13\n\t\x06\0\x02\t\
    \x04\xb0\xca\xbc\"\x12\x06\xc5\x01\x04\xca\x01\x06\n\r\n\x05\x06\0\x02\t\
    \x04\x12\x04\xcb\x01\x047\n\x10\n\x08\x06\0\x02\t\x04\xc3\xf3\x04\x12\
    \x04\xcb\x01\x047\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xcc\x01\x04C\n\x11\n\
    \t\x06\0\x02\t\x04\xc2\xf3\x04\0\x12\x04\xcc\x01\x04C\nC\n\x04\x06\0\x02\
    \n\x12\x06\xd0\x01\x02\xd9\x01\x03\x1a3\x20List\x20the\x20concept\x20in\
    \x20all\x20the\x20translated\x20languages.\n\n\r\n\x05\x06\0\x02\n\x01\
    \x12\x04\xd0\x01\x06\x1a\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xd0\x01\x1c7\
    \n\r\n\x05\x06\0\x02\n\x03\x12\x04\xd0\x01B^\n\x0f\n\x05\x06\0\x02\n\x04\
    \x12\x06\xd1\x01\x04\xd6\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\
    \x12\x06\xd1\x01\x04\xd6\x01\x06\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xd7\
    \x01\x047\n\x10\n\x08\x06\0\x02\n\x04\xc3\xf3\x04\x12\x04\xd7\x01\x047\n\
    \r\n\x05\x06\0\x02\n\x04\x12\x04\xd8\x01\x04C\n\x11\n\t\x06\0\x02\n\x04\
    \xc2\xf3\x04\0\x12\x04\xd8\x01\x04C\n9\n\x04\x06\0\x02\x0b\x12\x06\xdc\
    \x01\x02\xe8\x01\x03\x1a)\x20Add\x20a\x20new\x20tranlsation\x20for\x20th\
    is\x20concept.\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xdc\x01\x06\x1a\n\r\
    \n\x05\x06\0\x02\x0b\x02\x12\x04\xdc\x01\x1c7\n\r\n\x05\x06\0\x02\x0b\
    \x03\x12\x04\xdc\x01B^\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xdd\x01\x04\
    \xe4\x01\x06\n\x13\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xdd\x01\
    \x04\xe4\x01\x06\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xe5\x01\x047\n\x10\
    \n\x08\x06\0\x02\x0b\x04\xc3\xf3\x04\x12\x04\xe5\x01\x047\n\r\n\x05\x06\
    \0\x02\x0b\x04\x12\x04\xe6\x01\x04C\n\x11\n\t\x06\0\x02\x0b\x04\xc2\xf3\
    \x04\0\x12\x04\xe6\x01\x04C\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xe7\x01\
    \x04C\n\x11\n\t\x06\0\x02\x0b\x04\xc2\xf3\x04\x01\x12\x04\xe7\x01\x04C\n\
    \x83\x01\n\x04\x06\0\x02\x0c\x12\x06\xec\x01\x02\xf8\x01\x03\x1as\x20Pat\
    ch\x20the\x20name\x20for\x20a\x20given\x20language\x20names\x20by\x20pas\
    sing\x20in\x20a\x20list\x20of\x20concepts\x20with\x20the\x20new\x20names\
    \n\x20for\x20the\x20languages.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xec\
    \x01\x06\x1b\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xec\x01\x1d9\n\r\n\x05\
    \x06\0\x02\x0c\x03\x12\x04\xec\x01D`\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\
    \x06\xed\x01\x04\xf4\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\
    \x12\x06\xed\x01\x04\xf4\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf5\
    \x01\x047\n\x10\n\x08\x06\0\x02\x0c\x04\xc3\xf3\x04\x12\x04\xf5\x01\x047\
    \n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf6\x01\x04C\n\x11\n\t\x06\0\x02\
    \x0c\x04\xc2\xf3\x04\0\x12\x04\xf6\x01\x04C\n\r\n\x05\x06\0\x02\x0c\x04\
    \x12\x04\xf7\x01\x04C\n\x11\n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\x01\x12\
    \x04\xf7\x01\x04C\n\x8a\x01\n\x04\x06\0\x02\r\x12\x06\x88\x02\x02\x91\
    \x02\x03\x1a\x19\x20List\x20all\x20domain\x20graphs.\n2_////////////////\
    //////////////////////\n\x20Knowledge\x20Graph\n////////////////////////\
    //////////////\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\x88\x02\x06\x19\n\r\n\
    \x05\x06\0\x02\r\x02\x12\x04\x88\x02\x1b5\n\r\n\x05\x06\0\x02\r\x03\x12\
    \x04\x88\x02@[\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\x89\x02\x04\x8e\x02\
    \x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\x89\x02\x04\x8e\x02\
    \x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x8f\x02\x047\n\x10\n\x08\x06\0\
    \x02\r\x04\xc3\xf3\x04\x12\x04\x8f\x02\x047\n\r\n\x05\x06\0\x02\r\x04\
    \x12\x04\x90\x02\x04C\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\0\x12\x04\
    \x90\x02\x04C\n%\n\x04\x06\0\x02\x0e\x12\x06\x94\x02\x02\xa0\x02\x03\x1a\
    \x15\x20Post\x20domain\x20graphs.\n\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\
    \x94\x02\x06\x19\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\x94\x02\x1b5\n\r\n\
    \x05\x06\0\x02\x0e\x03\x12\x04\x94\x02@[\n\x0f\n\x05\x06\0\x02\x0e\x04\
    \x12\x06\x95\x02\x04\x9c\x02\x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\
    \"\x12\x06\x95\x02\x04\x9c\x02\x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\
    \x9d\x02\x047\n\x10\n\x08\x06\0\x02\x0e\x04\xc3\xf3\x04\x12\x04\x9d\x02\
    \x047\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x9e\x02\x04C\n\x11\n\t\x06\0\
    \x02\x0e\x04\xc2\xf3\x04\0\x12\x04\x9e\x02\x04C\n\r\n\x05\x06\0\x02\x0e\
    \x04\x12\x04\x9f\x02\x04C\n\x11\n\t\x06\0\x02\x0e\x04\xc2\xf3\x04\x01\
    \x12\x04\x9f\x02\x04C\n-\n\x04\x06\0\x02\x0f\x12\x06\xa3\x02\x02\xaf\x02\
    \x03\x1a\x1d\x20Start\x20concept\x20mapping\x20jobs.\n\n\r\n\x05\x06\0\
    \x02\x0f\x01\x12\x04\xa3\x02\x06\x1c\n\r\n\x05\x06\0\x02\x0f\x02\x12\x04\
    \xa3\x02\x1e;\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\xa3\x02Fd\n\x0f\n\x05\
    \x06\0\x02\x0f\x04\x12\x06\xa4\x02\x04\xab\x02\x06\n\x13\n\t\x06\0\x02\
    \x0f\x04\xb0\xca\xbc\"\x12\x06\xa4\x02\x04\xab\x02\x06\n\r\n\x05\x06\0\
    \x02\x0f\x04\x12\x04\xac\x02\x047\n\x10\n\x08\x06\0\x02\x0f\x04\xc3\xf3\
    \x04\x12\x04\xac\x02\x047\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xad\x02\
    \x04C\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\0\x12\x04\xad\x02\x04C\n\r\
    \n\x05\x06\0\x02\x0f\x04\x12\x04\xae\x02\x04C\n\x11\n\t\x06\0\x02\x0f\
    \x04\xc2\xf3\x04\x01\x12\x04\xae\x02\x04C\n\x95\x01\n\x04\x06\0\x02\x10\
    \x12\x06\xb9\x02\x02\xc4\x02\x03\x1a(\x20Get\x20a\x20specific\x20annotat\
    ion\x20from\x20an\x20app.\n2[//////////////////////////////////////\n\
    \x20annotations\n//////////////////////////////////////\n\n\r\n\x05\x06\
    \0\x02\x10\x01\x12\x04\xb9\x02\x06\x13\n\r\n\x05\x06\0\x02\x10\x02\x12\
    \x04\xb9\x02\x15)\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xb9\x024L\n\x0f\n\
    \x05\x06\0\x02\x10\x04\x12\x06\xba\x02\x04\xbf\x02\x06\n\x13\n\t\x06\0\
    \x02\x10\x04\xb0\xca\xbc\"\x12\x06\xba\x02\x04\xbf\x02\x06\n\r\n\x05\x06\
    \0\x02\x10\x04\x12\x04\xc0\x02\x047\n\x10\n\x08\x06\0\x02\x10\x04\xc3\
    \xf3\x04\x12\x04\xc0\x02\x047\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xc1\
    \x02\x04F\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\0\x12\x04\xc1\x02\x04F\
    \n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xc2\x02\x04C\n\x11\n\t\x06\0\x02\
    \x10\x04\xc2\xf3\x04\x01\x12\x04\xc2\x02\x04C\n\r\n\x05\x06\0\x02\x10\
    \x04\x12\x04\xc3\x02\x04A\n5\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\x02\x12\
    \x04\xc3\x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20work\
    er.\n\n*\n\x04\x06\0\x02\x11\x12\x06\xc7\x02\x02\xd2\x02\x03\x1a\x1a\x20\
    List\x20all\x20the\x20annotation.\n\n\r\n\x05\x06\0\x02\x11\x01\x12\x04\
    \xc7\x02\x06\x15\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\xc7\x02\x17-\n\r\n\
    \x05\x06\0\x02\x11\x03\x12\x04\xc7\x028O\n\x0f\n\x05\x06\0\x02\x11\x04\
    \x12\x06\xc8\x02\x04\xcd\x02\x06\n\x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\
    \"\x12\x06\xc8\x02\x04\xcd\x02\x06\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\
    \xce\x02\x047\n\x10\n\x08\x06\0\x02\x11\x04\xc3\xf3\x04\x12\x04\xce\x02\
    \x047\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xcf\x02\x04F\n\x11\n\t\x06\0\
    \x02\x11\x04\xc2\xf3\x04\0\x12\x04\xcf\x02\x04F\n\r\n\x05\x06\0\x02\x11\
    \x04\x12\x04\xd0\x02\x04C\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\x01\
    \x12\x04\xd0\x02\x04C\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xd1\x02\x04A\n\
    5\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\x02\x12\x04\xd1\x02\x04A\"\"\x20to\
    \x20get\x20the\x20model\x20for\x20the\x20worker.\n\n#\n\x04\x06\0\x02\
    \x12\x12\x06\xd5\x02\x02\xe5\x02\x03\x1a\x13\x20Post\x20annotations.\n\n\
    \r\n\x05\x06\0\x02\x12\x01\x12\x04\xd5\x02\x06\x15\n\r\n\x05\x06\0\x02\
    \x12\x02\x12\x04\xd5\x02\x17-\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\xd5\
    \x028O\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xd6\x02\x04\xdd\x02\x06\n\
    \x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\xd6\x02\x04\xdd\x02\x06\
    \n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xde\x02\x047\n\x10\n\x08\x06\0\x02\
    \x12\x04\xc3\xf3\x04\x12\x04\xde\x02\x047\n\r\n\x05\x06\0\x02\x12\x04\
    \x12\x04\xdf\x02\x04A\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\0\x12\x04\
    \xdf\x02\x04A\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xe0\x02\x04F\n\x11\n\t\
    \x06\0\x02\x12\x04\xc2\xf3\x04\x01\x12\x04\xe0\x02\x04F\n\r\n\x05\x06\0\
    \x02\x12\x04\x12\x04\xe1\x02\x04F\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\
    \x04\x02\x12\x04\xe1\x02\x04F\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xe2\
    \x02\x04C\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x03\x12\x04\xe2\x02\
    \x04C\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xe3\x02\x04A\n\x11\n\t\x06\0\
    \x02\x12\x04\xc2\xf3\x04\x04\x12\x04\xe3\x02\x04A\n\r\n\x05\x06\0\x02\
    \x12\x04\x12\x04\xe4\x02\x04D\nA\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x05\
    \x12\x04\xe4\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n0\n\x04\x06\0\x02\x13\x12\x06\xe8\x02\x02\
    \xf8\x02\x03\x1a\x20\x20Patch\x20one\x20or\x20more\x20annotations.\n\n\r\
    \n\x05\x06\0\x02\x13\x01\x12\x04\xe8\x02\x06\x16\n\r\n\x05\x06\0\x02\x13\
    \x02\x12\x04\xe8\x02\x18/\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\xe8\x02:Q\
    \n\x0f\n\x05\x06\0\x02\x13\x04\x12\x06\xe9\x02\x04\xf0\x02\x06\n\x13\n\t\
    \x06\0\x02\x13\x04\xb0\xca\xbc\"\x12\x06\xe9\x02\x04\xf0\x02\x06\n\r\n\
    \x05\x06\0\x02\x13\x04\x12\x04\xf1\x02\x047\n\x10\n\x08\x06\0\x02\x13\
    \x04\xc3\xf3\x04\x12\x04\xf1\x02\x047\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xf2\x02\x04A\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\0\x12\x04\xf2\
    \x02\x04A\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xf3\x02\x04F\n\x11\n\t\x06\
    \0\x02\x13\x04\xc2\xf3\x04\x01\x12\x04\xf3\x02\x04F\n\r\n\x05\x06\0\x02\
    \x13\x04\x12\x04\xf4\x02\x04F\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\
    \x02\x12\x04\xf4\x02\x04F\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xf5\x02\
    \x04C\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x03\x12\x04\xf5\x02\x04C\n\
    \r\n\x05\x06\0\x02\x13\x04\x12\x04\xf6\x02\x04D\nA\n\t\x06\0\x02\x13\x04\
    \xc2\xf3\x04\x04\x12\x04\xf6\x02\x04D\".\x20to\x20know\x20the\x20models\
    \x20in\x20your\x20default\x20workflow.\n\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xf7\x02\x04A\n5\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x05\x12\x04\xf7\
    \x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20worker.\n\nD\
    \n\x04\x06\0\x02\x14\x12\x06\xfb\x02\x02\x86\x03\x03\x1a4\x20Patch\x20an\
    notations\x20status\x20by\x20worker\x20id\x20and\x20task\x20id.\n\n\r\n\
    \x05\x06\0\x02\x14\x01\x12\x04\xfb\x02\x06\x1c\n\r\n\x05\x06\0\x02\x14\
    \x02\x12\x04\xfb\x02\x1e;\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xfb\x02Fd\
    \n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\xfc\x02\x04\xff\x02\x06\n\x13\n\t\
    \x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\xfc\x02\x04\xff\x02\x06\n\r\n\
    \x05\x06\0\x02\x14\x04\x12\x04\x80\x03\x047\n\x10\n\x08\x06\0\x02\x14\
    \x04\xc3\xf3\x04\x12\x04\x80\x03\x047\n\r\n\x05\x06\0\x02\x14\x04\x12\
    \x04\x81\x03\x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\0\x12\x04\x81\
    \x03\x04F\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\x82\x03\x04F\n\x11\n\t\x06\
    \0\x02\x14\x04\xc2\xf3\x04\x01\x12\x04\x82\x03\x04F\n\r\n\x05\x06\0\x02\
    \x14\x04\x12\x04\x83\x03\x04C\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\
    \x02\x12\x04\x83\x03\x04C\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\x84\x03\
    \x04D\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x03\x12\x04\x84\x03\x04D\n\
    \r\n\x05\x06\0\x02\x14\x04\x12\x04\x85\x03\x04A\n\x11\n\t\x06\0\x02\x14\
    \x04\xc2\xf3\x04\x04\x12\x04\x85\x03\x04A\n-\n\x04\x06\0\x02\x15\x12\x06\
    \x89\x03\x02\x95\x03\x03\x1a\x1d\x20Delete\x20a\x20single\x20annotation.\
    \n\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\x89\x03\x06\x16\n\r\n\x05\x06\0\
    \x02\x15\x02\x12\x04\x89\x03\x18/\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\
    \x89\x03:Z\n\x0f\n\x05\x06\0\x02\x15\x04\x12\x06\x8a\x03\x04\x8f\x03\x06\
    \n\x13\n\t\x06\0\x02\x15\x04\xb0\xca\xbc\"\x12\x06\x8a\x03\x04\x8f\x03\
    \x06\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x90\x03\x047\n\x10\n\x08\x06\0\
    \x02\x15\x04\xc3\xf3\x04\x12\x04\x90\x03\x047\n\r\n\x05\x06\0\x02\x15\
    \x04\x12\x04\x91\x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\0\x12\
    \x04\x91\x03\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x92\x03\x04I\n\x11\
    \n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x01\x12\x04\x92\x03\x04I\n\r\n\x05\
    \x06\0\x02\x15\x04\x12\x04\x93\x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\
    \xf3\x04\x02\x12\x04\x93\x03\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\
    \x94\x03\x04D\n\\\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x03\x12\x04\x94\x03\
    \x04D\"I\x20for\x20cleaning\x20up\x20some\x20optimizations\x20we\x20have\
    \x20in\x20DB\x20layer\x20for\x20annotations.\n\n=\n\x04\x06\0\x02\x16\
    \x12\x06\x98\x03\x02\xae\x03\x03\x1a-\x20Delete\x20multiple\x20annotatio\
    ns\x20in\x20one\x20request.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\x98\
    \x03\x06\x17\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\x98\x03\x191\n\r\n\x05\
    \x06\0\x02\x16\x03\x12\x04\x98\x03<\\\n\x0f\n\x05\x06\0\x02\x16\x04\x12\
    \x06\x99\x03\x04\xa8\x03\x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\
    \x12\x06\x99\x03\x04\xa8\x03\x06\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xa9\
    \x03\x047\n\x10\n\x08\x06\0\x02\x16\x04\xc3\xf3\x04\x12\x04\xa9\x03\x047\
    \n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xaa\x03\x04F\n\x11\n\t\x06\0\x02\
    \x16\x04\xc2\xf3\x04\0\x12\x04\xaa\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\
    \x12\x04\xab\x03\x04I\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x01\x12\
    \x04\xab\x03\x04I\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xac\x03\x04F\n\x11\
    \n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x02\x12\x04\xac\x03\x04F\n\r\n\x05\
    \x06\0\x02\x16\x04\x12\x04\xad\x03\x04D\n\\\n\t\x06\0\x02\x16\x04\xc2\
    \xf3\x04\x03\x12\x04\xad\x03\x04D\"I\x20for\x20cleaning\x20up\x20some\
    \x20optimizations\x20we\x20have\x20in\x20DB\x20layer\x20for\x20annotatio\
    ns.\n\n2\n\x04\x06\0\x02\x17\x12\x06\xb1\x03\x02\xc2\x03\x03\x1a\"\x20Ex\
    ecute\x20a\x20search\x20over\x20annotation\n\n\r\n\x05\x06\0\x02\x17\x01\
    \x12\x04\xb1\x03\x06\x1d\n\r\n\x05\x06\0\x02\x17\x02\x12\x04\xb1\x03\x1e\
    <\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\xb1\x03GZ\n\x0f\n\x05\x06\0\x02\
    \x17\x04\x12\x06\xb2\x03\x04\xb9\x03\x06\n\x13\n\t\x06\0\x02\x17\x04\xb0\
    \xca\xbc\"\x12\x06\xb2\x03\x04\xb9\x03\x06\n\r\n\x05\x06\0\x02\x17\x04\
    \x12\x04\xba\x03\x047\n\x10\n\x08\x06\0\x02\x17\x04\xc3\xf3\x04\x12\x04\
    \xba\x03\x047\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xbb\x03\x04F\n\x11\n\t\
    \x06\0\x02\x17\x04\xc2\xf3\x04\0\x12\x04\xbb\x03\x04F\n\r\n\x05\x06\0\
    \x02\x17\x04\x12\x04\xbc\x03\x04C\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\
    \x04\x01\x12\x04\xbc\x03\x04C\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xbd\
    \x03\x04A\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x02\x12\x04\xbd\x03\
    \x04A\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xbe\x03\x04A\n\x11\n\t\x06\0\
    \x02\x17\x04\xc2\xf3\x04\x03\x12\x04\xbe\x03\x04A\n\r\n\x05\x06\0\x02\
    \x17\x04\x12\x04\xbf\x03\x04=\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\
    \x04\x12\x04\xbf\x03\x04=\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xc0\x03\
    \x04D\nN\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x05\x12\x04\xc0\x03\x04D\";\
    \x20to\x20know\x20the\x20concepts\x20and\x20models\x20in\x20your\x20defa\
    ult\x20workflow.\n\n\x85\x01\n\x04\x06\0\x02\x18\x12\x06\xca\x03\x02\xd5\
    \x03\x03\x1a\x1d\x20Get\x20input\x20count\x20per\x20status.\n2V/////////\
    /////////////////////////////\n\x20Inputs\n/////////////////////////////\
    /////////\n\n\r\n\x05\x06\0\x02\x18\x01\x12\x04\xca\x03\x06\x13\n\r\n\
    \x05\x06\0\x02\x18\x02\x12\x04\xca\x03\x15)\n\r\n\x05\x06\0\x02\x18\x03\
    \x12\x04\xca\x034L\n\x0f\n\x05\x06\0\x02\x18\x04\x12\x06\xcb\x03\x04\xd0\
    \x03\x06\n\x13\n\t\x06\0\x02\x18\x04\xb0\xca\xbc\"\x12\x06\xcb\x03\x04\
    \xd0\x03\x06\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xd1\x03\x047\n\x10\n\
    \x08\x06\0\x02\x18\x04\xc3\xf3\x04\x12\x04\xd1\x03\x047\n\r\n\x05\x06\0\
    \x02\x18\x04\x12\x04\xd2\x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\
    \x04\0\x12\x04\xd2\x03\x04F\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xd3\x03\
    \x04C\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\x04\x01\x12\x04\xd3\x03\x04C\n\
    \r\n\x05\x06\0\x02\x18\x04\x12\x04\xd4\x03\x04A\n\x11\n\t\x06\0\x02\x18\
    \x04\xc2\xf3\x04\x02\x12\x04\xd4\x03\x04A\nE\n\x04\x06\0\x02\x19\x12\x06\
    \xd8\x03\x02\xe3\x03\x03\x1a5\x20Streams\x20all\x20the\x20inputs\x20star\
    ting\x20from\x20oldest\x20assets.\n\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\
    \xd8\x03\x06\x12\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xd8\x03\x14'\n\r\n\
    \x05\x06\0\x02\x19\x03\x12\x04\xd8\x032D\n\x0f\n\x05\x06\0\x02\x19\x04\
    \x12\x06\xd9\x03\x04\xde\x03\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\xca\xbc\
    \"\x12\x06\xd9\x03\x04\xde\x03\x06\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\
    \xdf\x03\x047\n\x10\n\x08\x06\0\x02\x19\x04\xc3\xf3\x04\x12\x04\xdf\x03\
    \x047\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xe0\x03\x04F\n\x11\n\t\x06\0\
    \x02\x19\x04\xc2\xf3\x04\0\x12\x04\xe0\x03\x04F\n\r\n\x05\x06\0\x02\x19\
    \x04\x12\x04\xe1\x03\x04C\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x01\
    \x12\x04\xe1\x03\x04C\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xe2\x03\x04A\n\
    \x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x02\x12\x04\xe2\x03\x04A\n3\n\x04\
    \x06\0\x02\x1a\x12\x06\xe6\x03\x02\xf1\x03\x03\x1a#\x20Get\x20a\x20speci\
    fic\x20input\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\x1a\x01\x12\x04\
    \xe6\x03\x06\x15\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xe6\x03\x17-\n\r\n\
    \x05\x06\0\x02\x1a\x03\x12\x04\xe6\x038T\n\x0f\n\x05\x06\0\x02\x1a\x04\
    \x12\x06\xe7\x03\x04\xec\x03\x06\n\x13\n\t\x06\0\x02\x1a\x04\xb0\xca\xbc\
    \"\x12\x06\xe7\x03\x04\xec\x03\x06\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\
    \xed\x03\x047\n\x10\n\x08\x06\0\x02\x1a\x04\xc3\xf3\x04\x12\x04\xed\x03\
    \x047\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xee\x03\x04F\n\x11\n\t\x06\0\
    \x02\x1a\x04\xc2\xf3\x04\0\x12\x04\xee\x03\x04F\n\r\n\x05\x06\0\x02\x1a\
    \x04\x12\x04\xef\x03\x04C\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\x01\
    \x12\x04\xef\x03\x04C\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xf0\x03\x04A\n\
    \x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\x02\x12\x04\xf0\x03\x04A\n3\n\x04\
    \x06\0\x02\x1b\x12\x06\xf4\x03\x02\xff\x03\x03\x1a#\x20Get\x20a\x20speci\
    fic\x20input\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\x1b\x01\x12\x04\
    \xf4\x03\x06\x0e\n\r\n\x05\x06\0\x02\x1b\x02\x12\x04\xf4\x03\x10\x1f\n\r\
    \n\x05\x06\0\x02\x1b\x03\x12\x04\xf4\x03*=\n\x0f\n\x05\x06\0\x02\x1b\x04\
    \x12\x06\xf5\x03\x04\xfa\x03\x06\n\x13\n\t\x06\0\x02\x1b\x04\xb0\xca\xbc\
    \"\x12\x06\xf5\x03\x04\xfa\x03\x06\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\
    \xfb\x03\x047\n\x10\n\x08\x06\0\x02\x1b\x04\xc3\xf3\x04\x12\x04\xfb\x03\
    \x047\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xfc\x03\x04F\n\x11\n\t\x06\0\
    \x02\x1b\x04\xc2\xf3\x04\0\x12\x04\xfc\x03\x04F\n\r\n\x05\x06\0\x02\x1b\
    \x04\x12\x04\xfd\x03\x04C\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\x01\
    \x12\x04\xfd\x03\x04C\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xfe\x03\x04A\n\
    \x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\x02\x12\x04\xfe\x03\x04A\n&\n\x04\
    \x06\0\x02\x1c\x12\x06\x82\x04\x02\x8d\x04\x03\x1a\x16\x20List\x20all\
    \x20the\x20inputs.\n\n\r\n\x05\x06\0\x02\x1c\x01\x12\x04\x82\x04\x06\x10\
    \n\r\n\x05\x06\0\x02\x1c\x02\x12\x04\x82\x04\x12#\n\r\n\x05\x06\0\x02\
    \x1c\x03\x12\x04\x82\x04.@\n\x0f\n\x05\x06\0\x02\x1c\x04\x12\x06\x83\x04\
    \x04\x88\x04\x06\n\x13\n\t\x06\0\x02\x1c\x04\xb0\xca\xbc\"\x12\x06\x83\
    \x04\x04\x88\x04\x06\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x89\x04\x047\n\
    \x10\n\x08\x06\0\x02\x1c\x04\xc3\xf3\x04\x12\x04\x89\x04\x047\n\r\n\x05\
    \x06\0\x02\x1c\x04\x12\x04\x8a\x04\x04F\n\x11\n\t\x06\0\x02\x1c\x04\xc2\
    \xf3\x04\0\x12\x04\x8a\x04\x04F\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x8b\
    \x04\x04C\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\x01\x12\x04\x8b\x04\
    \x04C\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x8c\x04\x04A\n\x11\n\t\x06\0\
    \x02\x1c\x04\xc2\xf3\x04\x02\x12\x04\x8c\x04\x04A\n\xb2\x01\n\x04\x06\0\
    \x02\x1d\x12\x06\x92\x04\x02\xa4\x04\x03\x1a\xa1\x01\x20Add\x20an\x20inp\
    ut\x20(or\x20set\x20of\x20inputs)\x20to\x20an\x20app.\n\x20This\x20call\
    \x20is\x20synchronous\x20if\x20the\x20PostInputsRequest\x20contains\x20e\
    xactly\x20one\x20image\x20input.\x20Otherwise,\n\x20it\x20is\x20asynchro\
    nous.\n\n\r\n\x05\x06\0\x02\x1d\x01\x12\x04\x92\x04\x06\x10\n\r\n\x05\
    \x06\0\x02\x1d\x02\x12\x04\x92\x04\x12#\n\r\n\x05\x06\0\x02\x1d\x03\x12\
    \x04\x92\x04.@\n\x0f\n\x05\x06\0\x02\x1d\x04\x12\x06\x93\x04\x04\x9a\x04\
    \x06\n\x13\n\t\x06\0\x02\x1d\x04\xb0\xca\xbc\"\x12\x06\x93\x04\x04\x9a\
    \x04\x06\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x9b\x04\x047\n\x10\n\x08\
    \x06\0\x02\x1d\x04\xc3\xf3\x04\x12\x04\x9b\x04\x047\n\r\n\x05\x06\0\x02\
    \x1d\x04\x12\x04\x9c\x04\x04F\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\0\
    \x12\x04\x9c\x04\x04F\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x9d\x04\x04F\n\
    \x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x01\x12\x04\x9d\x04\x04F\n\r\n\
    \x05\x06\0\x02\x1d\x04\x12\x04\x9e\x04\x04C\n\x11\n\t\x06\0\x02\x1d\x04\
    \xc2\xf3\x04\x02\x12\x04\x9e\x04\x04C\n\r\n\x05\x06\0\x02\x1d\x04\x12\
    \x04\x9f\x04\x04A\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x03\x12\x04\
    \x9f\x04\x04A\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa0\x04\x04A\n\x11\n\t\
    \x06\0\x02\x1d\x04\xc2\xf3\x04\x04\x12\x04\xa0\x04\x04A\n\r\n\x05\x06\0\
    \x02\x1d\x04\x12\x04\xa1\x04\x04A\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\
    \x04\x05\x12\x04\xa1\x04\x04A\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa2\
    \x04\x04>\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x06\x12\x04\xa2\x04\
    \x04>\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa3\x04\x04D\n\x11\n\t\x06\0\
    \x02\x1d\x04\xc2\xf3\x04\x07\x12\x04\xa3\x04\x04D\n+\n\x04\x06\0\x02\x1e\
    \x12\x06\xaa\x04\x02\xba\x04\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\
    \x20inputs.\n\n\r\n\x05\x06\0\x02\x1e\x01\x12\x04\xaa\x04\x06\x11\n\r\n\
    \x05\x06\0\x02\x1e\x02\x12\x04\xaa\x04\x13%\n\r\n\x05\x06\0\x02\x1e\x03\
    \x12\x04\xaa\x040B\n\x0f\n\x05\x06\0\x02\x1e\x04\x12\x06\xab\x04\x04\xb2\
    \x04\x06\n\x13\n\t\x06\0\x02\x1e\x04\xb0\xca\xbc\"\x12\x06\xab\x04\x04\
    \xb2\x04\x06\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xb3\x04\x047\n\x10\n\
    \x08\x06\0\x02\x1e\x04\xc3\xf3\x04\x12\x04\xb3\x04\x047\n\r\n\x05\x06\0\
    \x02\x1e\x04\x12\x04\xb4\x04\x04F\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\
    \x04\0\x12\x04\xb4\x04\x04F\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xb5\x04\
    \x04F\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x01\x12\x04\xb5\x04\x04F\n\
    \r\n\x05\x06\0\x02\x1e\x04\x12\x04\xb6\x04\x04C\n\x11\n\t\x06\0\x02\x1e\
    \x04\xc2\xf3\x04\x02\x12\x04\xb6\x04\x04C\n\r\n\x05\x06\0\x02\x1e\x04\
    \x12\x04\xb7\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x03\x12\
    \x04\xb7\x04\x04A\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xb8\x04\x04A\n\x11\
    \n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x04\x12\x04\xb8\x04\x04A\n\r\n\x05\
    \x06\0\x02\x1e\x04\x12\x04\xb9\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\xc2\
    \xf3\x04\x05\x12\x04\xb9\x04\x04A\n7\n\x04\x06\0\x02\x1f\x12\x06\xbd\x04\
    \x02\xcd\x04\x03\x1a'\x20Delete\x20a\x20single\x20input\x20asynchronousl\
    y.\n\n\r\n\x05\x06\0\x02\x1f\x01\x12\x04\xbd\x04\x06\x11\n\r\n\x05\x06\0\
    \x02\x1f\x02\x12\x04\xbd\x04\x13%\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\
    \xbd\x040P\n\x0f\n\x05\x06\0\x02\x1f\x04\x12\x06\xbe\x04\x04\xc3\x04\x06\
    \n\x13\n\t\x06\0\x02\x1f\x04\xb0\xca\xbc\"\x12\x06\xbe\x04\x04\xc3\x04\
    \x06\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xc4\x04\x047\n\x10\n\x08\x06\0\
    \x02\x1f\x04\xc3\xf3\x04\x12\x04\xc4\x04\x047\n\r\n\x05\x06\0\x02\x1f\
    \x04\x12\x04\xc5\x04\x04F\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\0\x12\
    \x04\xc5\x04\x04F\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xc6\x04\x04I\n\x11\
    \n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x01\x12\x04\xc6\x04\x04I\n\r\n\x05\
    \x06\0\x02\x1f\x04\x12\x04\xc7\x04\x04F\n\x11\n\t\x06\0\x02\x1f\x04\xc2\
    \xf3\x04\x02\x12\x04\xc7\x04\x04F\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\
    \xc8\x04\x04A\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x03\x12\x04\xc8\
    \x04\x04A\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xc9\x04\x04D\n\x11\n\t\x06\
    \0\x02\x1f\x04\xc2\xf3\x04\x04\x12\x04\xc9\x04\x04D\n\r\n\x05\x06\0\x02\
    \x1f\x04\x12\x04\xca\x04\x04A\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\
    \x05\x12\x04\xca\x04\x04A\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xcb\x04\
    \x04A\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x06\x12\x04\xcb\x04\x04A\n\
    \r\n\x05\x06\0\x02\x1f\x04\x12\x04\xcc\x04\x04D\n\x11\n\t\x06\0\x02\x1f\
    \x04\xc2\xf3\x04\x07\x12\x04\xcc\x04\x04D\nT\n\x04\x06\0\x02\x20\x12\x06\
    \xd1\x04\x02\xe3\x04\x03\x1aD\x20Delete\x20multiple\x20inputs\x20in\x20o\
    ne\x20request.\n\x20This\x20call\x20is\x20asynchronous.\n\n\r\n\x05\x06\
    \0\x02\x20\x01\x12\x04\xd1\x04\x06\x12\n\r\n\x05\x06\0\x02\x20\x02\x12\
    \x04\xd1\x04\x14'\n\r\n\x05\x06\0\x02\x20\x03\x12\x04\xd1\x042R\n\x0f\n\
    \x05\x06\0\x02\x20\x04\x12\x06\xd2\x04\x04\xd9\x04\x06\n\x13\n\t\x06\0\
    \x02\x20\x04\xb0\xca\xbc\"\x12\x06\xd2\x04\x04\xd9\x04\x06\n\r\n\x05\x06\
    \0\x02\x20\x04\x12\x04\xda\x04\x047\n\x10\n\x08\x06\0\x02\x20\x04\xc3\
    \xf3\x04\x12\x04\xda\x04\x047\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xdb\
    \x04\x04F\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\0\x12\x04\xdb\x04\x04F\
    \n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xdc\x04\x04I\n\x11\n\t\x06\0\x02\
    \x20\x04\xc2\xf3\x04\x01\x12\x04\xdc\x04\x04I\n\r\n\x05\x06\0\x02\x20\
    \x04\x12\x04\xdd\x04\x04F\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x02\
    \x12\x04\xdd\x04\x04F\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xde\x04\x04A\n\
    \x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x03\x12\x04\xde\x04\x04A\n\r\n\
    \x05\x06\0\x02\x20\x04\x12\x04\xdf\x04\x04D\n\x11\n\t\x06\0\x02\x20\x04\
    \xc2\xf3\x04\x04\x12\x04\xdf\x04\x04D\n\r\n\x05\x06\0\x02\x20\x04\x12\
    \x04\xe0\x04\x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x05\x12\x04\
    \xe0\x04\x04A\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xe1\x04\x04A\n\x11\n\t\
    \x06\0\x02\x20\x04\xc2\xf3\x04\x06\x12\x04\xe1\x04\x04A\n\r\n\x05\x06\0\
    \x02\x20\x04\x12\x04\xe2\x04\x04D\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\
    \x04\x07\x12\x04\xe2\x04\x04D\n-\n\x04\x06\0\x02!\x12\x06\xe6\x04\x02\
    \xf6\x04\x03\x1a\x1d\x20Execute\x20a\x20search\x20over\x20input\n\n\r\n\
    \x05\x06\0\x02!\x01\x12\x04\xe6\x04\x06\x18\n\r\n\x05\x06\0\x02!\x02\x12\
    \x04\xe6\x04\x192\n\r\n\x05\x06\0\x02!\x03\x12\x04\xe6\x04=P\n\x0f\n\x05\
    \x06\0\x02!\x04\x12\x06\xe7\x04\x04\xee\x04\x06\n\x13\n\t\x06\0\x02!\x04\
    \xb0\xca\xbc\"\x12\x06\xe7\x04\x04\xee\x04\x06\n\r\n\x05\x06\0\x02!\x04\
    \x12\x04\xef\x04\x047\n\x10\n\x08\x06\0\x02!\x04\xc3\xf3\x04\x12\x04\xef\
    \x04\x047\n\r\n\x05\x06\0\x02!\x04\x12\x04\xf0\x04\x04F\n\x11\n\t\x06\0\
    \x02!\x04\xc2\xf3\x04\0\x12\x04\xf0\x04\x04F\n\r\n\x05\x06\0\x02!\x04\
    \x12\x04\xf1\x04\x04C\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x01\x12\x04\
    \xf1\x04\x04C\n\r\n\x05\x06\0\x02!\x04\x12\x04\xf2\x04\x04A\n\x11\n\t\
    \x06\0\x02!\x04\xc2\xf3\x04\x02\x12\x04\xf2\x04\x04A\n\r\n\x05\x06\0\x02\
    !\x04\x12\x04\xf3\x04\x04A\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x03\x12\
    \x04\xf3\x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\x04\xf4\x04\x04=\n\x11\n\
    \t\x06\0\x02!\x04\xc2\xf3\x04\x04\x12\x04\xf4\x04\x04=\n\r\n\x05\x06\0\
    \x02!\x04\x12\x04\xf5\x04\x04D\nN\n\t\x06\0\x02!\x04\xc2\xf3\x04\x05\x12\
    \x04\xf5\x04\x04D\";\x20to\x20know\x20the\x20concepts\x20and\x20models\
    \x20in\x20your\x20default\x20workflow.\n\n7\n\x04\x06\0\x02\"\x12\x06\
    \xf9\x04\x02\x8e\x05\x03\x1a'\x20Get\x20predicted\x20outputs\x20from\x20\
    the\x20model.\n\n\r\n\x05\x06\0\x02\"\x01\x12\x04\xf9\x04\x06\x16\n\r\n\
    \x05\x06\0\x02\"\x02\x12\x04\xf9\x04\x18/\n\r\n\x05\x06\0\x02\"\x03\x12\
    \x04\xf9\x04:M\n\x0f\n\x05\x06\0\x02\"\x04\x12\x06\xfa\x04\x04\x89\x05\
    \x06\n\x13\n\t\x06\0\x02\"\x04\xb0\xca\xbc\"\x12\x06\xfa\x04\x04\x89\x05\
    \x06\n\r\n\x05\x06\0\x02\"\x04\x12\x04\x8a\x05\x047\n\x10\n\x08\x06\0\
    \x02\"\x04\xc3\xf3\x04\x12\x04\x8a\x05\x047\n\r\n\x05\x06\0\x02\"\x04\
    \x12\x04\x8b\x05\x04C\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\0\x12\x04\
    \x8b\x05\x04C\n\r\n\x05\x06\0\x02\"\x04\x12\x04\x8c\x05\x04A\n\x11\n\t\
    \x06\0\x02\"\x04\xc2\xf3\x04\x01\x12\x04\x8c\x05\x04A\n\r\n\x05\x06\0\
    \x02\"\x04\x12\x04\x8d\x05\x04>\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\
    \x02\x12\x04\x8d\x05\x04>\n\xad\x01\n\x04\x06\0\x02#\x12\x06\x99\x05\x02\
    \xa2\x05\x03\x1a\x1c\x20Get\x20a\x20specific\x20model\x20type.\n2'//////\
    ////////////////////////////////\n2V////////////////////////////////////\
    //\n\x20Models\n//////////////////////////////////////\n\n\r\n\x05\x06\0\
    \x02#\x01\x12\x04\x99\x05\x06\x12\n\r\n\x05\x06\0\x02#\x02\x12\x04\x99\
    \x05\x14'\n\r\n\x05\x06\0\x02#\x03\x12\x04\x99\x052I\n\x0f\n\x05\x06\0\
    \x02#\x04\x12\x06\x9a\x05\x04\x9f\x05\x06\n\x13\n\t\x06\0\x02#\x04\xb0\
    \xca\xbc\"\x12\x06\x9a\x05\x04\x9f\x05\x06\n\r\n\x05\x06\0\x02#\x04\x12\
    \x04\xa0\x05\x047\n\x10\n\x08\x06\0\x02#\x04\xc3\xf3\x04\x12\x04\xa0\x05\
    \x047\n\r\n\x05\x06\0\x02#\x04\x12\x04\xa1\x05\x04A\n\x11\n\t\x06\0\x02#\
    \x04\xc2\xf3\x04\0\x12\x04\xa1\x05\x04A\n\x9a\x01\n\x04\x06\0\x02$\x12\
    \x06\xa6\x05\x02\xaf\x05\x03\x1a\x89\x01\x20List\x20all\x20the\x20model\
    \x20types\x20available\x20in\x20the\x20platform.\n\x20This\x20MUST\x20be\
    \x20above\x20ListModels\x20so\x20that\x20the\x20/models/types\x20endpoin\
    t\x20takes\x20precedence.\n\n\r\n\x05\x06\0\x02$\x01\x12\x04\xa6\x05\x06\
    \x14\n\r\n\x05\x06\0\x02$\x02\x12\x04\xa6\x05\x16+\n\r\n\x05\x06\0\x02$\
    \x03\x12\x04\xa6\x056L\n\x0f\n\x05\x06\0\x02$\x04\x12\x06\xa7\x05\x04\
    \xac\x05\x06\n\x13\n\t\x06\0\x02$\x04\xb0\xca\xbc\"\x12\x06\xa7\x05\x04\
    \xac\x05\x06\n\r\n\x05\x06\0\x02$\x04\x12\x04\xad\x05\x047\n\x10\n\x08\
    \x06\0\x02$\x04\xc3\xf3\x04\x12\x04\xad\x05\x047\n\r\n\x05\x06\0\x02$\
    \x04\x12\x04\xae\x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\0\x12\x04\
    \xae\x05\x04A\n3\n\x04\x06\0\x02%\x12\x06\xb2\x05\x02\xbc\x05\x03\x1a#\
    \x20Get\x20a\x20specific\x20model\x20from\x20an\x20app.\n\n\r\n\x05\x06\
    \0\x02%\x01\x12\x04\xb2\x05\x06\x0e\n\r\n\x05\x06\0\x02%\x02\x12\x04\xb2\
    \x05\x10\x1f\n\r\n\x05\x06\0\x02%\x03\x12\x04\xb2\x05*=\n\x0f\n\x05\x06\
    \0\x02%\x04\x12\x06\xb3\x05\x04\xb8\x05\x06\n\x13\n\t\x06\0\x02%\x04\xb0\
    \xca\xbc\"\x12\x06\xb3\x05\x04\xb8\x05\x06\n\r\n\x05\x06\0\x02%\x04\x12\
    \x04\xb9\x05\x047\n\x10\n\x08\x06\0\x02%\x04\xc3\xf3\x04\x12\x04\xb9\x05\
    \x047\n\r\n\x05\x06\0\x02%\x04\x12\x04\xba\x05\x04C\n\x11\n\t\x06\0\x02%\
    \x04\xc2\xf3\x04\0\x12\x04\xba\x05\x04C\n\r\n\x05\x06\0\x02%\x04\x12\x04\
    \xbb\x05\x04A\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\x01\x12\x04\xbb\x05\
    \x04A\n[\n\x04\x06\0\x02&\x12\x06\xc0\x05\x02\xd0\x05\x03\x1aK\x20Get\
    \x20a\x20the\x20output\x20info\x20for\x20a\x20given\x20model_id\x20or\
    \x20model_id/version_id\n\x20combo.\n\n\r\n\x05\x06\0\x02&\x01\x12\x04\
    \xc0\x05\x06\x18\n\r\n\x05\x06\0\x02&\x02\x12\x04\xc0\x05\x1a)\n\r\n\x05\
    \x06\0\x02&\x03\x12\x04\xc0\x054G\n\x0f\n\x05\x06\0\x02&\x04\x12\x06\xc1\
    \x05\x04\xcc\x05\x06\n\x13\n\t\x06\0\x02&\x04\xb0\xca\xbc\"\x12\x06\xc1\
    \x05\x04\xcc\x05\x06\n\r\n\x05\x06\0\x02&\x04\x12\x04\xcd\x05\x047\n\x10\
    \n\x08\x06\0\x02&\x04\xc3\xf3\x04\x12\x04\xcd\x05\x047\n\r\n\x05\x06\0\
    \x02&\x04\x12\x04\xce\x05\x04C\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\0\
    \x12\x04\xce\x05\x04C\n\r\n\x05\x06\0\x02&\x04\x12\x04\xcf\x05\x04A\n\
    \x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x01\x12\x04\xcf\x05\x04A\n&\n\x04\
    \x06\0\x02'\x12\x06\xd3\x05\x02\xdd\x05\x03\x1a\x16\x20List\x20all\x20th\
    e\x20models.\n\n\r\n\x05\x06\0\x02'\x01\x12\x04\xd3\x05\x06\x10\n\r\n\
    \x05\x06\0\x02'\x02\x12\x04\xd3\x05\x12#\n\r\n\x05\x06\0\x02'\x03\x12\
    \x04\xd3\x05.@\n\x0f\n\x05\x06\0\x02'\x04\x12\x06\xd4\x05\x04\xd9\x05\
    \x06\n\x13\n\t\x06\0\x02'\x04\xb0\xca\xbc\"\x12\x06\xd4\x05\x04\xd9\x05\
    \x06\n\r\n\x05\x06\0\x02'\x04\x12\x04\xda\x05\x047\n\x10\n\x08\x06\0\x02\
    '\x04\xc3\xf3\x04\x12\x04\xda\x05\x047\n\r\n\x05\x06\0\x02'\x04\x12\x04\
    \xdb\x05\x04C\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\0\x12\x04\xdb\x05\x04\
    C\n\r\n\x05\x06\0\x02'\x04\x12\x04\xdc\x05\x04A\n\x11\n\t\x06\0\x02'\x04\
    \xc2\xf3\x04\x01\x12\x04\xdc\x05\x04A\n\xcb\x01\n\x04\x06\0\x02(\x12\x06\
    \xe4\x05\x02\xf0\x05\x03\x1a\xba\x01\x20Search\x20over\x20the\x20models\
    \x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20Th\
    is\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\
    \x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20\
    variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02(\x01\x12\x04\
    \xe4\x05\x06\x18\n\r\n\x05\x06\0\x02(\x02\x12\x04\xe4\x05\x1a3\n\r\n\x05\
    \x06\0\x02(\x03\x12\x04\xe4\x05>P\n\x0f\n\x05\x06\0\x02(\x04\x12\x06\xe5\
    \x05\x04\xec\x05\x06\n\x13\n\t\x06\0\x02(\x04\xb0\xca\xbc\"\x12\x06\xe5\
    \x05\x04\xec\x05\x06\n\r\n\x05\x06\0\x02(\x04\x12\x04\xed\x05\x047\n\x10\
    \n\x08\x06\0\x02(\x04\xc3\xf3\x04\x12\x04\xed\x05\x047\n\r\n\x05\x06\0\
    \x02(\x04\x12\x04\xee\x05\x04C\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\0\
    \x12\x04\xee\x05\x04C\n\r\n\x05\x06\0\x02(\x04\x12\x04\xef\x05\x04A\n\
    \x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\x01\x12\x04\xef\x05\x04A\nb\n\x04\
    \x06\0\x02)\x12\x06\xf4\x05\x02\x83\x06\x03\x1aR\x20Add\x20a\x20models\
    \x20to\x20an\x20app.\n\x20FIXME(zeiler):\x20this\x20should\x20have\x20be\
    en\x20a\x20plural\x20response.\n\n\r\n\x05\x06\0\x02)\x01\x12\x04\xf4\
    \x05\x06\x10\n\r\n\x05\x06\0\x02)\x02\x12\x04\xf4\x05\x12#\n\r\n\x05\x06\
    \0\x02)\x03\x12\x04\xf4\x05.A\n\x0f\n\x05\x06\0\x02)\x04\x12\x06\xf5\x05\
    \x04\xfc\x05\x06\n\x13\n\t\x06\0\x02)\x04\xb0\xca\xbc\"\x12\x06\xf5\x05\
    \x04\xfc\x05\x06\n\r\n\x05\x06\0\x02)\x04\x12\x04\xfd\x05\x047\n\x10\n\
    \x08\x06\0\x02)\x04\xc3\xf3\x04\x12\x04\xfd\x05\x047\n\r\n\x05\x06\0\x02\
    )\x04\x12\x04\xfe\x05\x04C\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\0\x12\
    \x04\xfe\x05\x04C\n\r\n\x05\x06\0\x02)\x04\x12\x04\xff\x05\x04A\n\x11\n\
    \t\x06\0\x02)\x04\xc2\xf3\x04\x01\x12\x04\xff\x05\x04A\n\r\n\x05\x06\0\
    \x02)\x04\x12\x04\x80\x06\x04A\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\x02\
    \x12\x04\x80\x06\x04A\n\r\n\x05\x06\0\x02)\x04\x12\x04\x81\x06\x04C\nF\n\
    \t\x06\0\x02)\x04\xc2\xf3\x04\x03\x12\x04\x81\x06\x04C\"3\x20Train\x20is\
    \x20needed\x20because\x20it\x20creates\x20a\x20new\x20version.\n\n\r\n\
    \x05\x06\0\x02)\x04\x12\x04\x82\x06\x04D\nF\n\t\x06\0\x02)\x04\xc2\xf3\
    \x04\x04\x12\x04\x82\x06\x04D\"3\x20Needs\x20to\x20check\x20the\x20base\
    \x20workflow\x20to\x20build\x20off\x20of.\n\n+\n\x04\x06\0\x02*\x12\x06\
    \x86\x06\x02\x94\x06\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\x20models\
    .\n\n\r\n\x05\x06\0\x02*\x01\x12\x04\x86\x06\x06\x11\n\r\n\x05\x06\0\x02\
    *\x02\x12\x04\x86\x06\x13%\n\r\n\x05\x06\0\x02*\x03\x12\x04\x86\x060B\n\
    \x0f\n\x05\x06\0\x02*\x04\x12\x06\x87\x06\x04\x8e\x06\x06\n\x13\n\t\x06\
    \0\x02*\x04\xb0\xca\xbc\"\x12\x06\x87\x06\x04\x8e\x06\x06\n\r\n\x05\x06\
    \0\x02*\x04\x12\x04\x8f\x06\x047\n\x10\n\x08\x06\0\x02*\x04\xc3\xf3\x04\
    \x12\x04\x8f\x06\x047\n\r\n\x05\x06\0\x02*\x04\x12\x04\x90\x06\x04C\n\
    \x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\0\x12\x04\x90\x06\x04C\n\r\n\x05\x06\
    \0\x02*\x04\x12\x04\x91\x06\x04A\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\
    \x01\x12\x04\x91\x06\x04A\n\r\n\x05\x06\0\x02*\x04\x12\x04\x92\x06\x04A\
    \n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x02\x12\x04\x92\x06\x04A\n\r\n\x05\
    \x06\0\x02*\x04\x12\x04\x93\x06\x04C\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\
    \x04\x03\x12\x04\x93\x06\x04C\n(\n\x04\x06\0\x02+\x12\x06\x97\x06\x02\
    \xa4\x06\x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\x05\x06\
    \0\x02+\x01\x12\x04\x97\x06\x06\x11\n\r\n\x05\x06\0\x02+\x02\x12\x04\x97\
    \x06\x13%\n\r\n\x05\x06\0\x02+\x03\x12\x04\x97\x060P\n\x0f\n\x05\x06\0\
    \x02+\x04\x12\x06\x98\x06\x04\x9d\x06\x06\n\x13\n\t\x06\0\x02+\x04\xb0\
    \xca\xbc\"\x12\x06\x98\x06\x04\x9d\x06\x06\n\r\n\x05\x06\0\x02+\x04\x12\
    \x04\x9e\x06\x047\n\x10\n\x08\x06\0\x02+\x04\xc3\xf3\x04\x12\x04\x9e\x06\
    \x047\n\r\n\x05\x06\0\x02+\x04\x12\x04\x9f\x06\x04C\n\x11\n\t\x06\0\x02+\
    \x04\xc2\xf3\x04\0\x12\x04\x9f\x06\x04C\n\r\n\x05\x06\0\x02+\x04\x12\x04\
    \xa0\x06\x04A\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x01\x12\x04\xa0\x06\
    \x04A\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa1\x06\x04D\n\x11\n\t\x06\0\x02+\
    \x04\xc2\xf3\x04\x02\x12\x04\xa1\x06\x04D\n\r\n\x05\x06\0\x02+\x04\x12\
    \x04\xa2\x06\x04A\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x03\x12\x04\xa2\
    \x06\x04A\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa3\x06\x04D\n\x11\n\t\x06\0\
    \x02+\x04\xc2\xf3\x04\x04\x12\x04\xa3\x06\x04D\n8\n\x04\x06\0\x02,\x12\
    \x06\xa7\x06\x02\xb6\x06\x03\x1a(\x20Delete\x20multiple\x20models\x20in\
    \x20one\x20request.\n\n\r\n\x05\x06\0\x02,\x01\x12\x04\xa7\x06\x06\x12\n\
    \r\n\x05\x06\0\x02,\x02\x12\x04\xa7\x06\x14'\n\r\n\x05\x06\0\x02,\x03\
    \x12\x04\xa7\x062R\n\x0f\n\x05\x06\0\x02,\x04\x12\x06\xa8\x06\x04\xaf\
    \x06\x06\n\x13\n\t\x06\0\x02,\x04\xb0\xca\xbc\"\x12\x06\xa8\x06\x04\xaf\
    \x06\x06\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb0\x06\x047\n\x10\n\x08\x06\0\
    \x02,\x04\xc3\xf3\x04\x12\x04\xb0\x06\x047\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xb1\x06\x04C\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\0\x12\x04\xb1\x06\
    \x04C\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb2\x06\x04A\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\x01\x12\x04\xb2\x06\x04A\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xb3\x06\x04D\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x02\x12\x04\xb3\
    \x06\x04D\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb4\x06\x04A\n\x11\n\t\x06\0\
    \x02,\x04\xc2\xf3\x04\x03\x12\x04\xb4\x06\x04A\n\r\n\x05\x06\0\x02,\x04\
    \x12\x04\xb5\x06\x04D\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x04\x12\x04\
    \xb5\x06\x04D\n&\n\x04\x06\0\x02-\x12\x06\xb9\x06\x02\xcb\x06\x03\x1a\
    \x16\x20List\x20all\x20the\x20inputs.\n\n\r\n\x05\x06\0\x02-\x01\x12\x04\
    \xb9\x06\x06\x15\n\r\n\x05\x06\0\x02-\x02\x12\x04\xb9\x06\x17-\n\r\n\x05\
    \x06\0\x02-\x03\x12\x04\xb9\x068J\n\x0f\n\x05\x06\0\x02-\x04\x12\x06\xba\
    \x06\x04\xc5\x06\x06\n\x13\n\t\x06\0\x02-\x04\xb0\xca\xbc\"\x12\x06\xba\
    \x06\x04\xc5\x06\x06\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc6\x06\x047\n\x10\
    \n\x08\x06\0\x02-\x04\xc3\xf3\x04\x12\x04\xc6\x06\x047\n\r\n\x05\x06\0\
    \x02-\x04\x12\x04\xc7\x06\x04F\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\0\
    \x12\x04\xc7\x06\x04F\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc8\x06\x04C\n\
    \x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x01\x12\x04\xc8\x06\x04C\n\r\n\x05\
    \x06\0\x02-\x04\x12\x04\xc9\x06\x04A\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\
    \x04\x02\x12\x04\xc9\x06\x04A\n\r\n\x05\x06\0\x02-\x04\x12\x04\xca\x06\
    \x04A\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x03\x12\x04\xca\x06\x04A\n\
    \xbc\x01\n\x04\x06\0\x02.\x12\x06\xd4\x06\x02\xde\x06\x03\x1a#\x20Get\
    \x20a\x20specific\x20model\x20from\x20an\x20app.\n2'////////////////////\
    //////////////////\n2^//////////////////////////////////////\n\x20Model\
    \x20versions\n//////////////////////////////////////\n\n\r\n\x05\x06\0\
    \x02.\x01\x12\x04\xd4\x06\x06\x15\n\r\n\x05\x06\0\x02.\x02\x12\x04\xd4\
    \x06\x17-\n\r\n\x05\x06\0\x02.\x03\x12\x04\xd4\x068R\n\x0f\n\x05\x06\0\
    \x02.\x04\x12\x06\xd5\x06\x04\xda\x06\x06\n\x13\n\t\x06\0\x02.\x04\xb0\
    \xca\xbc\"\x12\x06\xd5\x06\x04\xda\x06\x06\n\r\n\x05\x06\0\x02.\x04\x12\
    \x04\xdb\x06\x047\n\x10\n\x08\x06\0\x02.\x04\xc3\xf3\x04\x12\x04\xdb\x06\
    \x047\n\r\n\x05\x06\0\x02.\x04\x12\x04\xdc\x06\x04C\n\x11\n\t\x06\0\x02.\
    \x04\xc2\xf3\x04\0\x12\x04\xdc\x06\x04C\n\r\n\x05\x06\0\x02.\x04\x12\x04\
    \xdd\x06\x04A\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x01\x12\x04\xdd\x06\
    \x04A\n&\n\x04\x06\0\x02/\x12\x06\xe1\x06\x02\xeb\x06\x03\x1a\x16\x20Lis\
    t\x20all\x20the\x20models.\n\n\r\n\x05\x06\0\x02/\x01\x12\x04\xe1\x06\
    \x06\x17\n\r\n\x05\x06\0\x02/\x02\x12\x04\xe1\x06\x191\n\r\n\x05\x06\0\
    \x02/\x03\x12\x04\xe1\x06<U\n\x0f\n\x05\x06\0\x02/\x04\x12\x06\xe2\x06\
    \x04\xe7\x06\x06\n\x13\n\t\x06\0\x02/\x04\xb0\xca\xbc\"\x12\x06\xe2\x06\
    \x04\xe7\x06\x06\n\r\n\x05\x06\0\x02/\x04\x12\x04\xe8\x06\x047\n\x10\n\
    \x08\x06\0\x02/\x04\xc3\xf3\x04\x12\x04\xe8\x06\x047\n\r\n\x05\x06\0\x02\
    /\x04\x12\x04\xe9\x06\x04C\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\0\x12\
    \x04\xe9\x06\x04C\n\r\n\x05\x06\0\x02/\x04\x12\x04\xea\x06\x04A\n\x11\n\
    \t\x06\0\x02/\x04\xc2\xf3\x04\x01\x12\x04\xea\x06\x04A\n\xd0\x01\n\x04\
    \x06\0\x020\x12\x06\xf2\x06\x02\x85\x07\x03\x1aw\x20Create\x20a\x20new\
    \x20model\x20version\x20to\x20trigger\x20training\x20of\x20the\x20model.\
    \n\x20FIXME(zeiler):\x20this\x20should\x20have\x20been\x20a\x20plural\
    \x20response.\n2G\x20NOTE:\x20inconsistency:\x20do\x20we\x20want\x20this\
    \x20to\x20return\x20a\x20SingleModelResponse?\n\n\r\n\x05\x06\0\x020\x01\
    \x12\x04\xf2\x06\x06\x17\n\r\n\x05\x06\0\x020\x02\x12\x04\xf2\x06\x191\n\
    \r\n\x05\x06\0\x020\x03\x12\x04\xf2\x06<O\n\x0f\n\x05\x06\0\x020\x04\x12\
    \x06\xf3\x06\x04\xfa\x06\x06\n\x13\n\t\x06\0\x020\x04\xb0\xca\xbc\"\x12\
    \x06\xf3\x06\x04\xfa\x06\x06\n\r\n\x05\x06\0\x020\x04\x12\x04\xfb\x06\
    \x047\n\x10\n\x08\x06\0\x020\x04\xc3\xf3\x04\x12\x04\xfb\x06\x047\n\r\n\
    \x05\x06\0\x020\x04\x12\x04\xfc\x06\x04F\n\x11\n\t\x06\0\x020\x04\xc2\
    \xf3\x04\0\x12\x04\xfc\x06\x04F\n\r\n\x05\x06\0\x020\x04\x12\x04\xfd\x06\
    \x04C\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x01\x12\x04\xfd\x06\x04C\n\r\
    \n\x05\x06\0\x020\x04\x12\x04\xfe\x06\x04A\n\x11\n\t\x06\0\x020\x04\xc2\
    \xf3\x04\x02\x12\x04\xfe\x06\x04A\n\r\n\x05\x06\0\x020\x04\x12\x04\xff\
    \x06\x04A\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x03\x12\x04\xff\x06\x04A\
    \n\r\n\x05\x06\0\x020\x04\x12\x04\x80\x07\x04A\n\x11\n\t\x06\0\x020\x04\
    \xc2\xf3\x04\x04\x12\x04\x80\x07\x04A\n\r\n\x05\x06\0\x020\x04\x12\x04\
    \x81\x07\x04C\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x05\x12\x04\x81\x07\
    \x04C\n\r\n\x05\x06\0\x020\x04\x12\x04\x82\x07\x04D\nF\n\t\x06\0\x020\
    \x04\xc2\xf3\x04\x06\x12\x04\x82\x07\x04D\"3\x20Needs\x20to\x20check\x20\
    the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n\r\n\x05\x06\0\
    \x020\x04\x12\x04\x83\x07\x04B\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x07\
    \x12\x04\x83\x07\x04B\n\r\n\x05\x06\0\x020\x04\x12\x04\x84\x07\x04B\n\
    \x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x08\x12\x04\x84\x07\x04B\n\x0e\n\x04\
    \x06\0\x021\x12\x06\x87\x07\x02\x91\x07\x03\n\r\n\x05\x06\0\x021\x01\x12\
    \x04\x87\x07\x06\x18\n\r\n\x05\x06\0\x021\x02\x12\x04\x87\x07\x1a3\n\r\n\
    \x05\x06\0\x021\x03\x12\x04\x87\x07>W\n\x0f\n\x05\x06\0\x021\x04\x12\x06\
    \x88\x07\x04\x8b\x07\x06\n\x13\n\t\x06\0\x021\x04\xb0\xca\xbc\"\x12\x06\
    \x88\x07\x04\x8b\x07\x06\n\r\n\x05\x06\0\x021\x04\x12\x04\x8c\x07\x047\n\
    \x10\n\x08\x06\0\x021\x04\xc3\xf3\x04\x12\x04\x8c\x07\x047\n\r\n\x05\x06\
    \0\x021\x04\x12\x04\x8d\x07\x04C\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\0\
    \x12\x04\x8d\x07\x04C\n\r\n\x05\x06\0\x021\x04\x12\x04\x8e\x07\x04A\n\
    \x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x01\x12\x04\x8e\x07\x04A\n\r\n\x05\
    \x06\0\x021\x04\x12\x04\x8f\x07\x04A\n\x11\n\t\x06\0\x021\x04\xc2\xf3\
    \x04\x02\x12\x04\x8f\x07\x04A\n\r\n\x05\x06\0\x021\x04\x12\x04\x90\x07\
    \x04C\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x03\x12\x04\x90\x07\x04C\n(\n\
    \x04\x06\0\x022\x12\x06\x94\x07\x02\xa1\x07\x03\x1a\x18\x20Delete\x20a\
    \x20single\x20model.\n\n\r\n\x05\x06\0\x022\x01\x12\x04\x94\x07\x06\x18\
    \n\r\n\x05\x06\0\x022\x02\x12\x04\x94\x07\x1a3\n\r\n\x05\x06\0\x022\x03\
    \x12\x04\x94\x07>^\n\x0f\n\x05\x06\0\x022\x04\x12\x06\x95\x07\x04\x9a\
    \x07\x06\n\x13\n\t\x06\0\x022\x04\xb0\xca\xbc\"\x12\x06\x95\x07\x04\x9a\
    \x07\x06\n\r\n\x05\x06\0\x022\x04\x12\x04\x9b\x07\x047\n\x10\n\x08\x06\0\
    \x022\x04\xc3\xf3\x04\x12\x04\x9b\x07\x047\n\r\n\x05\x06\0\x022\x04\x12\
    \x04\x9c\x07\x04C\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\0\x12\x04\x9c\x07\
    \x04C\n\r\n\x05\x06\0\x022\x04\x12\x04\x9d\x07\x04A\n\x11\n\t\x06\0\x022\
    \x04\xc2\xf3\x04\x01\x12\x04\x9d\x07\x04A\n\r\n\x05\x06\0\x022\x04\x12\
    \x04\x9e\x07\x04D\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x02\x12\x04\x9e\
    \x07\x04D\n\r\n\x05\x06\0\x022\x04\x12\x04\x9f\x07\x04A\n\x11\n\t\x06\0\
    \x022\x04\xc2\xf3\x04\x03\x12\x04\x9f\x07\x04A\n\r\n\x05\x06\0\x022\x04\
    \x12\x04\xa0\x07\x04D\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x04\x12\x04\
    \xa0\x07\x04D\nA\n\x04\x06\0\x023\x12\x06\xa4\x07\x02\xb1\x07\x03\x1a1\
    \x20Get\x20the\x20evaluation\x20metrics\x20for\x20a\x20model\x20version.\
    \n\n\r\n\x05\x06\0\x023\x01\x12\x04\xa4\x07\x06\x1c\n\r\n\x05\x06\0\x023\
    \x02\x12\x04\xa4\x07\x1e;\n\r\n\x05\x06\0\x023\x03\x12\x04\xa4\x07F`\n\
    \x0f\n\x05\x06\0\x023\x04\x12\x06\xa5\x07\x04\xaa\x07\x06\n\x13\n\t\x06\
    \0\x023\x04\xb0\xca\xbc\"\x12\x06\xa5\x07\x04\xaa\x07\x06\n\r\n\x05\x06\
    \0\x023\x04\x12\x04\xab\x07\x047\n\x10\n\x08\x06\0\x023\x04\xc3\xf3\x04\
    \x12\x04\xab\x07\x047\n\r\n\x05\x06\0\x023\x04\x12\x04\xac\x07\x04F\n\
    \x11\n\t\x06\0\x023\x04\xc2\xf3\x04\0\x12\x04\xac\x07\x04F\n\r\n\x05\x06\
    \0\x023\x04\x12\x04\xad\x07\x04C\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\
    \x01\x12\x04\xad\x07\x04C\n\r\n\x05\x06\0\x023\x04\x12\x04\xae\x07\x04A\
    \n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x02\x12\x04\xae\x07\x04A\n\r\n\x05\
    \x06\0\x023\x04\x12\x04\xaf\x07\x04A\n\x11\n\t\x06\0\x023\x04\xc2\xf3\
    \x04\x03\x12\x04\xaf\x07\x04A\n\r\n\x05\x06\0\x023\x04\x12\x04\xb0\x07\
    \x04B\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x04\x12\x04\xb0\x07\x04B\nA\n\
    \x04\x06\0\x024\x12\x06\xb4\x07\x02\xc8\x07\x03\x1a1\x20Run\x20the\x20ev\
    aluation\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\
    \x024\x01\x12\x04\xb4\x07\x06\x1d\n\r\n\x05\x06\0\x024\x02\x12\x04\xb4\
    \x07\x1f=\n\r\n\x05\x06\0\x024\x03\x12\x04\xb4\x07Hb\n\x0f\n\x05\x06\0\
    \x024\x04\x12\x06\xb5\x07\x04\xbc\x07\x06\n\x13\n\t\x06\0\x024\x04\xb0\
    \xca\xbc\"\x12\x06\xb5\x07\x04\xbc\x07\x06\n\r\n\x05\x06\0\x024\x04\x12\
    \x04\xbd\x07\x047\n\x10\n\x08\x06\0\x024\x04\xc3\xf3\x04\x12\x04\xbd\x07\
    \x047\n\r\n\x05\x06\0\x024\x04\x12\x04\xbe\x07\x04F\n\x11\n\t\x06\0\x024\
    \x04\xc2\xf3\x04\0\x12\x04\xbe\x07\x04F\n\r\n\x05\x06\0\x024\x04\x12\x04\
    \xbf\x07\x04C\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x01\x12\x04\xbf\x07\
    \x04C\n\r\n\x05\x06\0\x024\x04\x12\x04\xc0\x07\x04A\n\x11\n\t\x06\0\x024\
    \x04\xc2\xf3\x04\x02\x12\x04\xc0\x07\x04A\n\r\n\x05\x06\0\x024\x04\x12\
    \x04\xc1\x07\x04A\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x03\x12\x04\xc1\
    \x07\x04A\n\r\n\x05\x06\0\x024\x04\x12\x04\xc2\x07\x04A\n\x11\n\t\x06\0\
    \x024\x04\xc2\xf3\x04\x04\x12\x04\xc2\x07\x04A\n\r\n\x05\x06\0\x024\x04\
    \x12\x04\xc3\x07\x04C\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x05\x12\x04\
    \xc3\x07\x04C\n\r\n\x05\x06\0\x024\x04\x12\x04\xc4\x07\x04>\n\x11\n\t\
    \x06\0\x024\x04\xc2\xf3\x04\x06\x12\x04\xc4\x07\x04>\n\r\n\x05\x06\0\x02\
    4\x04\x12\x04\xc5\x07\x04D\nF\n\t\x06\0\x024\x04\xc2\xf3\x04\x07\x12\x04\
    \xc5\x07\x04D\"3\x20Needs\x20to\x20check\x20the\x20base\x20workflow\x20t\
    o\x20build\x20off\x20of.\n\n\r\n\x05\x06\0\x024\x04\x12\x04\xc6\x07\x04B\
    \n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x08\x12\x04\xc6\x07\x04B\n\r\n\x05\
    \x06\0\x024\x04\x12\x04\xc7\x07\x04B\n\x11\n\t\x06\0\x024\x04\xc2\xf3\
    \x04\t\x12\x04\xc7\x07\x04B\n\xba\x01\n\x04\x06\0\x025\x12\x06\xd5\x07\
    \x02\xdf\x07\x03\x1a&\x20Get\x20a\x20specific\x20workflow\x20from\x20an\
    \x20app.\n2'//////////////////////////////////////\n2Y//////////////////\
    ////////////////////\n\x20Workflows\n///////////////////////////////////\
    ///\n\n\r\n\x05\x06\0\x025\x01\x12\x04\xd5\x07\x06\x11\n\r\n\x05\x06\0\
    \x025\x02\x12\x04\xd5\x07\x13%\n\r\n\x05\x06\0\x025\x03\x12\x04\xd5\x070\
    F\n\x0f\n\x05\x06\0\x025\x04\x12\x06\xd6\x07\x04\xdb\x07\x06\n\x13\n\t\
    \x06\0\x025\x04\xb0\xca\xbc\"\x12\x06\xd6\x07\x04\xdb\x07\x06\n\r\n\x05\
    \x06\0\x025\x04\x12\x04\xdc\x07\x047\n\x10\n\x08\x06\0\x025\x04\xc3\xf3\
    \x04\x12\x04\xdc\x07\x047\n\r\n\x05\x06\0\x025\x04\x12\x04\xdd\x07\x04A\
    \n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\0\x12\x04\xdd\x07\x04A\n\r\n\x05\
    \x06\0\x025\x04\x12\x04\xde\x07\x04D\n\x11\n\t\x06\0\x025\x04\xc2\xf3\
    \x04\x01\x12\x04\xde\x07\x04D\n)\n\x04\x06\0\x026\x12\x06\xe2\x07\x02\
    \xec\x07\x03\x1a\x19\x20List\x20all\x20the\x20workflows.\n\n\r\n\x05\x06\
    \0\x026\x01\x12\x04\xe2\x07\x06\x13\n\r\n\x05\x06\0\x026\x02\x12\x04\xe2\
    \x07\x15)\n\r\n\x05\x06\0\x026\x03\x12\x04\xe2\x074I\n\x0f\n\x05\x06\0\
    \x026\x04\x12\x06\xe3\x07\x04\xe8\x07\x06\n\x13\n\t\x06\0\x026\x04\xb0\
    \xca\xbc\"\x12\x06\xe3\x07\x04\xe8\x07\x06\n\r\n\x05\x06\0\x026\x04\x12\
    \x04\xe9\x07\x047\n\x10\n\x08\x06\0\x026\x04\xc3\xf3\x04\x12\x04\xe9\x07\
    \x047\n\r\n\x05\x06\0\x026\x04\x12\x04\xea\x07\x04A\n\x11\n\t\x06\0\x026\
    \x04\xc2\xf3\x04\0\x12\x04\xea\x07\x04A\n\r\n\x05\x06\0\x026\x04\x12\x04\
    \xeb\x07\x04D\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x01\x12\x04\xeb\x07\
    \x04D\n+\n\x04\x06\0\x027\x12\x06\xf0\x07\x02\xfd\x07\x03\x1a\x1b\x20Add\
    \x20a\x20workflow\x20to\x20an\x20app.\n\n\r\n\x05\x06\0\x027\x01\x12\x04\
    \xf0\x07\x06\x13\n\r\n\x05\x06\0\x027\x02\x12\x04\xf0\x07\x15)\n\r\n\x05\
    \x06\0\x027\x03\x12\x04\xf0\x074I\n\x0f\n\x05\x06\0\x027\x04\x12\x06\xf1\
    \x07\x04\xf8\x07\x06\n\x13\n\t\x06\0\x027\x04\xb0\xca\xbc\"\x12\x06\xf1\
    \x07\x04\xf8\x07\x06\n\r\n\x05\x06\0\x027\x04\x12\x04\xf9\x07\x047\n\x10\
    \n\x08\x06\0\x027\x04\xc3\xf3\x04\x12\x04\xf9\x07\x047\n\r\n\x05\x06\0\
    \x027\x04\x12\x04\xfa\x07\x04A\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\0\
    \x12\x04\xfa\x07\x04A\n\r\n\x05\x06\0\x027\x04\x12\x04\xfb\x07\x04D\n\
    \x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x01\x12\x04\xfb\x07\x04D\n\r\n\x05\
    \x06\0\x027\x04\x12\x04\xfc\x07\x04D\n\x11\n\t\x06\0\x027\x04\xc2\xf3\
    \x04\x02\x12\x04\xfc\x07\x04D\n.\n\x04\x06\0\x028\x12\x06\x80\x08\x02\
    \x8d\x08\x03\x1a\x1e\x20Patch\x20one\x20or\x20more\x20workflows.\n\n\r\n\
    \x05\x06\0\x028\x01\x12\x04\x80\x08\x06\x14\n\r\n\x05\x06\0\x028\x02\x12\
    \x04\x80\x08\x16+\n\r\n\x05\x06\0\x028\x03\x12\x04\x80\x086K\n\x0f\n\x05\
    \x06\0\x028\x04\x12\x06\x81\x08\x04\x88\x08\x06\n\x13\n\t\x06\0\x028\x04\
    \xb0\xca\xbc\"\x12\x06\x81\x08\x04\x88\x08\x06\n\r\n\x05\x06\0\x028\x04\
    \x12\x04\x89\x08\x047\n\x10\n\x08\x06\0\x028\x04\xc3\xf3\x04\x12\x04\x89\
    \x08\x047\n\r\n\x05\x06\0\x028\x04\x12\x04\x8a\x08\x04A\n\x11\n\t\x06\0\
    \x028\x04\xc2\xf3\x04\0\x12\x04\x8a\x08\x04A\n\r\n\x05\x06\0\x028\x04\
    \x12\x04\x8b\x08\x04D\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x01\x12\x04\
    \x8b\x08\x04D\n\r\n\x05\x06\0\x028\x04\x12\x04\x8c\x08\x04D\n\x11\n\t\
    \x06\0\x028\x04\xc2\xf3\x04\x02\x12\x04\x8c\x08\x04D\n+\n\x04\x06\0\x029\
    \x12\x06\x90\x08\x02\x9b\x08\x03\x1a\x1b\x20Delete\x20a\x20single\x20wor\
    kflow.\n\n\r\n\x05\x06\0\x029\x01\x12\x04\x90\x08\x06\x14\n\r\n\x05\x06\
    \0\x029\x02\x12\x04\x90\x08\x16+\n\r\n\x05\x06\0\x029\x03\x12\x04\x90\
    \x086V\n\x0f\n\x05\x06\0\x029\x04\x12\x06\x91\x08\x04\x96\x08\x06\n\x13\
    \n\t\x06\0\x029\x04\xb0\xca\xbc\"\x12\x06\x91\x08\x04\x96\x08\x06\n\r\n\
    \x05\x06\0\x029\x04\x12\x04\x97\x08\x047\n\x10\n\x08\x06\0\x029\x04\xc3\
    \xf3\x04\x12\x04\x97\x08\x047\n\r\n\x05\x06\0\x029\x04\x12\x04\x98\x08\
    \x04D\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\0\x12\x04\x98\x08\x04D\n\r\n\
    \x05\x06\0\x029\x04\x12\x04\x99\x08\x04G\n\x11\n\t\x06\0\x029\x04\xc2\
    \xf3\x04\x01\x12\x04\x99\x08\x04G\n\r\n\x05\x06\0\x029\x04\x12\x04\x9a\
    \x08\x04D\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\x02\x12\x04\x9a\x08\x04D\
    \n;\n\x04\x06\0\x02:\x12\x06\x9e\x08\x02\xab\x08\x03\x1a+\x20Delete\x20m\
    ultiple\x20workflows\x20in\x20one\x20request.\n\n\r\n\x05\x06\0\x02:\x01\
    \x12\x04\x9e\x08\x06\x15\n\r\n\x05\x06\0\x02:\x02\x12\x04\x9e\x08\x17-\n\
    \r\n\x05\x06\0\x02:\x03\x12\x04\x9e\x088X\n\x0f\n\x05\x06\0\x02:\x04\x12\
    \x06\x9f\x08\x04\xa6\x08\x06\n\x13\n\t\x06\0\x02:\x04\xb0\xca\xbc\"\x12\
    \x06\x9f\x08\x04\xa6\x08\x06\n\r\n\x05\x06\0\x02:\x04\x12\x04\xa7\x08\
    \x047\n\x10\n\x08\x06\0\x02:\x04\xc3\xf3\x04\x12\x04\xa7\x08\x047\n\r\n\
    \x05\x06\0\x02:\x04\x12\x04\xa8\x08\x04D\n\x11\n\t\x06\0\x02:\x04\xc2\
    \xf3\x04\0\x12\x04\xa8\x08\x04D\n\r\n\x05\x06\0\x02:\x04\x12\x04\xa9\x08\
    \x04G\n\x11\n\t\x06\0\x02:\x04\xc2\xf3\x04\x01\x12\x04\xa9\x08\x04G\n\r\
    \n\x05\x06\0\x02:\x04\x12\x04\xaa\x08\x04D\n\x11\n\t\x06\0\x02:\x04\xc2\
    \xf3\x04\x02\x12\x04\xaa\x08\x04D\n+\n\x04\x06\0\x02;\x12\x06\xae\x08\
    \x02\xbc\x08\x03\x1a\x1b\x20Predict\x20using\x20a\x20workflow.\n\n\r\n\
    \x05\x06\0\x02;\x01\x12\x04\xae\x08\x06\x19\n\r\n\x05\x06\0\x02;\x02\x12\
    \x04\xae\x08\x1b5\n\r\n\x05\x06\0\x02;\x03\x12\x04\xae\x08@[\n\x0f\n\x05\
    \x06\0\x02;\x04\x12\x06\xaf\x08\x04\xb6\x08\x06\n\x13\n\t\x06\0\x02;\x04\
    \xb0\xca\xbc\"\x12\x06\xaf\x08\x04\xb6\x08\x06\n\r\n\x05\x06\0\x02;\x04\
    \x12\x04\xb7\x08\x047\n\x10\n\x08\x06\0\x02;\x04\xc3\xf3\x04\x12\x04\xb7\
    \x08\x047\n\r\n\x05\x06\0\x02;\x04\x12\x04\xb8\x08\x04A\n\x11\n\t\x06\0\
    \x02;\x04\xc2\xf3\x04\0\x12\x04\xb8\x08\x04A\n\r\n\x05\x06\0\x02;\x04\
    \x12\x04\xb9\x08\x04C\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\x01\x12\x04\
    \xb9\x08\x04C\n\r\n\x05\x06\0\x02;\x04\x12\x04\xba\x08\x04>\n\x11\n\t\
    \x06\0\x02;\x04\xc2\xf3\x04\x02\x12\x04\xba\x08\x04>\n\r\n\x05\x06\0\x02\
    ;\x04\x12\x04\xbb\x08\x04D\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\x03\x12\
    \x04\xbb\x08\x04D\n?\n\x04\x06\0\x02<\x12\x06\xc1\x08\x02\xcf\x08\x032/\
    \x20Compare\x20embeddings\x20distances\x20using\x20a\x20workflow\n\n\r\n\
    \x05\x06\0\x02<\x01\x12\x04\xc1\x08\x06#\n\r\n\x05\x06\0\x02<\x02\x12\
    \x04\xc1\x08$H\n\r\n\x05\x06\0\x02<\x03\x12\x04\xc1\x08Sx\n\x0f\n\x05\
    \x06\0\x02<\x04\x12\x06\xc2\x08\x04\xc9\x08\x06\n\x13\n\t\x06\0\x02<\x04\
    \xb0\xca\xbc\"\x12\x06\xc2\x08\x04\xc9\x08\x06\n\r\n\x05\x06\0\x02<\x04\
    \x12\x04\xca\x08\x047\n\x10\n\x08\x06\0\x02<\x04\xc3\xf3\x04\x12\x04\xca\
    \x08\x047\n\r\n\x05\x06\0\x02<\x04\x12\x04\xcb\x08\x04A\n\x11\n\t\x06\0\
    \x02<\x04\xc2\xf3\x04\0\x12\x04\xcb\x08\x04A\n\r\n\x05\x06\0\x02<\x04\
    \x12\x04\xcc\x08\x04C\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x01\x12\x04\
    \xcc\x08\x04C\n\r\n\x05\x06\0\x02<\x04\x12\x04\xcd\x08\x04>\n\x11\n\t\
    \x06\0\x02<\x04\xc2\xf3\x04\x02\x12\x04\xcd\x08\x04>\n\r\n\x05\x06\0\x02\
    <\x04\x12\x04\xce\x08\x04D\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x03\x12\
    \x04\xce\x08\x04D\n\x8b\x01\n\x04\x06\0\x02=\x12\x06\xe1\x08\x02\xe7\x08\
    \x03\x1a!\x20Get\x20a\x20specific\x20key\x20from\x20an\x20app.\n2X//////\
    ////////////////////////////////\n\x20API\x20Keys\n/////////////////////\
    /////////////////\n\n\r\n\x05\x06\0\x02=\x01\x12\x04\xe1\x08\x06\x0c\n\r\
    \n\x05\x06\0\x02=\x02\x12\x04\xe1\x08\x0e\x1b\n\r\n\x05\x06\0\x02=\x03\
    \x12\x04\xe1\x08&7\n\x0f\n\x05\x06\0\x02=\x04\x12\x06\xe2\x08\x04\xe4\
    \x08\x06\n\x13\n\t\x06\0\x02=\x04\xb0\xca\xbc\"\x12\x06\xe2\x08\x04\xe4\
    \x08\x06\n\r\n\x05\x06\0\x02=\x04\x12\x04\xe5\x08\x047\n\x10\n\x08\x06\0\
    \x02=\x04\xc3\xf3\x04\x12\x04\xe5\x08\x047\n\r\n\x05\x06\0\x02=\x04\x12\
    \x04\xe6\x08\x04?\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\0\x12\x04\xe6\x08\
    \x04?\n$\n\x04\x06\0\x02>\x12\x06\xea\x08\x02\xf0\x08\x03\x1a\x14\x20Lis\
    t\x20all\x20the\x20keys.\n\n\r\n\x05\x06\0\x02>\x01\x12\x04\xea\x08\x06\
    \x0e\n\r\n\x05\x06\0\x02>\x02\x12\x04\xea\x08\x10\x1f\n\r\n\x05\x06\0\
    \x02>\x03\x12\x04\xea\x08*:\n\x0f\n\x05\x06\0\x02>\x04\x12\x06\xeb\x08\
    \x04\xed\x08\x06\n\x13\n\t\x06\0\x02>\x04\xb0\xca\xbc\"\x12\x06\xeb\x08\
    \x04\xed\x08\x06\n\r\n\x05\x06\0\x02>\x04\x12\x04\xee\x08\x047\n\x10\n\
    \x08\x06\0\x02>\x04\xc3\xf3\x04\x12\x04\xee\x08\x047\n\r\n\x05\x06\0\x02\
    >\x04\x12\x04\xef\x08\x04?\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\0\x12\
    \x04\xef\x08\x04?\n%\n\x04\x06\0\x02?\x12\x06\xf3\x08\x02\xf9\x08\x03\
    \x1a\x15\x20List\x20keys\x20by\x20app_id\n\n\r\n\x05\x06\0\x02?\x01\x12\
    \x04\xf3\x08\x06\x11\n\r\n\x05\x06\0\x02?\x02\x12\x04\xf3\x08\x13%\n\r\n\
    \x05\x06\0\x02?\x03\x12\x04\xf3\x080@\n\x0f\n\x05\x06\0\x02?\x04\x12\x06\
    \xf4\x08\x04\xf6\x08\x06\n\x13\n\t\x06\0\x02?\x04\xb0\xca\xbc\"\x12\x06\
    \xf4\x08\x04\xf6\x08\x06\n\r\n\x05\x06\0\x02?\x04\x12\x04\xf7\x08\x047\n\
    \x10\n\x08\x06\0\x02?\x04\xc3\xf3\x04\x12\x04\xf7\x08\x047\n\r\n\x05\x06\
    \0\x02?\x04\x12\x04\xf8\x08\x04?\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\0\
    \x12\x04\xf8\x08\x04?\n\xc9\x01\n\x04\x06\0\x02@\x12\x06\xfe\x08\x02\x86\
    \t\x03\x1a\xb8\x01\x20Search\x20over\x20the\x20keys\x20to\x20find\x20one\
    \x20or\x20more\x20you're\x20looking\x20for.\n\x20This\x20leverage\x20the\
    \x20\"body\"\x20parameter\x20because\x20we\x20also\x20have\x20page\x20an\
    d\n\x20per_page\x20as\x20url\x20query\x20param\x20variables\x20in\x20thi\
    s\x20request.\n\n\r\n\x05\x06\0\x02@\x01\x12\x04\xfe\x08\x06\x0f\n\r\n\
    \x05\x06\0\x02@\x02\x12\x04\xfe\x08\x11!\n\r\n\x05\x06\0\x02@\x03\x12\
    \x04\xfe\x08,L\n\x0f\n\x05\x06\0\x02@\x04\x12\x06\xff\x08\x04\x81\t\x06\
    \n\x13\n\t\x06\0\x02@\x04\xb0\xca\xbc\"\x12\x06\xff\x08\x04\x81\t\x06\n\
    \r\n\x05\x06\0\x02@\x04\x12\x04\x82\t\x047\n\x10\n\x08\x06\0\x02@\x04\
    \xc3\xf3\x04\x12\x04\x82\t\x047\n\r\n\x05\x06\0\x02@\x04\x12\x04\x83\t\
    \x04?\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\0\x12\x04\x83\t\x04?\n\r\n\
    \x05\x06\0\x02@\x04\x12\x04\x84\t\x04B\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\
    \x04\x01\x12\x04\x84\t\x04B\n\r\n\x05\x06\0\x02@\x04\x12\x04\x85\t\x04?\
    \n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\x02\x12\x04\x85\t\x04?\n&\n\x04\
    \x06\0\x02A\x12\x06\x89\t\x02\x92\t\x03\x1a\x16\x20Add\x20a\x20key\x20to\
    \x20an\x20app.\n\n\r\n\x05\x06\0\x02A\x01\x12\x04\x89\t\x06\x0e\n\r\n\
    \x05\x06\0\x02A\x02\x12\x04\x89\t\x10\x1f\n\r\n\x05\x06\0\x02A\x03\x12\
    \x04\x89\t*:\n\x0f\n\x05\x06\0\x02A\x04\x12\x06\x8a\t\x04\x8d\t\x06\n\
    \x13\n\t\x06\0\x02A\x04\xb0\xca\xbc\"\x12\x06\x8a\t\x04\x8d\t\x06\n\r\n\
    \x05\x06\0\x02A\x04\x12\x04\x8e\t\x047\n\x10\n\x08\x06\0\x02A\x04\xc3\
    \xf3\x04\x12\x04\x8e\t\x047\n\r\n\x05\x06\0\x02A\x04\x12\x04\x8f\t\x04?\
    \n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\0\x12\x04\x8f\t\x04?\n\r\n\x05\x06\
    \0\x02A\x04\x12\x04\x90\t\x04?\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\x01\
    \x12\x04\x90\t\x04?\n\r\n\x05\x06\0\x02A\x04\x12\x04\x91\t\x04?\n\x11\n\
    \t\x06\0\x02A\x04\xc2\xf3\x04\x02\x12\x04\x91\t\x04?\n)\n\x04\x06\0\x02B\
    \x12\x06\x95\t\x02\x9d\t\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20ke\
    ys.\n\n\r\n\x05\x06\0\x02B\x01\x12\x04\x95\t\x06\x0f\n\r\n\x05\x06\0\x02\
    B\x02\x12\x04\x95\t\x11!\n\r\n\x05\x06\0\x02B\x03\x12\x04\x95\t,<\n\x0f\
    \n\x05\x06\0\x02B\x04\x12\x06\x96\t\x04\x99\t\x06\n\x13\n\t\x06\0\x02B\
    \x04\xb0\xca\xbc\"\x12\x06\x96\t\x04\x99\t\x06\n\r\n\x05\x06\0\x02B\x04\
    \x12\x04\x9a\t\x047\n\x10\n\x08\x06\0\x02B\x04\xc3\xf3\x04\x12\x04\x9a\t\
    \x047\n\r\n\x05\x06\0\x02B\x04\x12\x04\x9b\t\x04?\n\x11\n\t\x06\0\x02B\
    \x04\xc2\xf3\x04\0\x12\x04\x9b\t\x04?\n\r\n\x05\x06\0\x02B\x04\x12\x04\
    \x9c\t\x04?\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\x01\x12\x04\x9c\t\x04?\
    \n\xc5\x01\n\x04\x06\0\x02C\x12\x06\xa2\t\x02\xad\t\x03\x1a\xb4\x01\x20A\
    PI\x20Keys\x20in\x20the\x20public\x20API\x20--\x20request\x20is\x20itsel\
    f\x20Key\x20authorized,\x20and\x20will\x20tell\n\x20the\x20user\x20the\
    \x20scopes/access\x20of\x20the\x20key/credential\x20they're\x20providing\
    ,\x20as\x20computed\x20by\n\x20our\x20authorizer:\n\n\r\n\x05\x06\0\x02C\
    \x01\x12\x04\xa2\t\x06\x0e\n\r\n\x05\x06\0\x02C\x02\x12\x04\xa2\t\x10\
    \x1f\n\r\n\x05\x06\0\x02C\x03\x12\x04\xa2\t*<\n\x0f\n\x05\x06\0\x02C\x04\
    \x12\x06\xa3\t\x04\xab\t\x06\n\x13\n\t\x06\0\x02C\x04\xb0\xca\xbc\"\x12\
    \x06\xa3\t\x04\xab\t\x06\n\r\n\x05\x06\0\x02C\x04\x12\x04\xac\t\x047\n\
    \x10\n\x08\x06\0\x02C\x04\xc3\xf3\x04\x12\x04\xac\t\x047\nA\n\x04\x06\0\
    \x02D\x12\x06\xb0\t\x02\xb5\t\x03\x1a1\x20List\x20all\x20auth\x20scopes\
    \x20available\x20to\x20me\x20as\x20a\x20user.\n\n\r\n\x05\x06\0\x02D\x01\
    \x12\x04\xb0\t\x06\x10\n\r\n\x05\x06\0\x02D\x02\x12\x04\xb0\t\x12#\n\r\n\
    \x05\x06\0\x02D\x03\x12\x04\xb0\t.D\n\x0f\n\x05\x06\0\x02D\x04\x12\x06\
    \xb1\t\x04\xb3\t\x06\n\x13\n\t\x06\0\x02D\x04\xb0\xca\xbc\"\x12\x06\xb1\
    \t\x04\xb3\t\x06\n\r\n\x05\x06\0\x02D\x04\x12\x04\xb4\t\x04@\n\x10\n\x08\
    \x06\0\x02D\x04\xc3\xf3\x04\x12\x04\xb4\t\x04@\n\x87\x01\n\x04\x06\0\x02\
    E\x12\x06\xbd\t\x02\xc4\t\x03\x1a!\x20Get\x20a\x20specific\x20app\x20fro\
    m\x20an\x20app.\n2T//////////////////////////////////////\n\x20Apps\n///\
    ///////////////////////////////////\n\n\r\n\x05\x06\0\x02E\x01\x12\x04\
    \xbd\t\x06\x0c\n\r\n\x05\x06\0\x02E\x02\x12\x04\xbd\t\x0e\x1b\n\r\n\x05\
    \x06\0\x02E\x03\x12\x04\xbd\t&7\n\x0f\n\x05\x06\0\x02E\x04\x12\x06\xbe\t\
    \x04\xc0\t\x06\n\x13\n\t\x06\0\x02E\x04\xb0\xca\xbc\"\x12\x06\xbe\t\x04\
    \xc0\t\x06\n\r\n\x05\x06\0\x02E\x04\x12\x04\xc1\t\x047\n\x10\n\x08\x06\0\
    \x02E\x04\xc3\xf3\x04\x12\x04\xc1\t\x047\n\r\n\x05\x06\0\x02E\x04\x12\
    \x04\xc2\t\x04?\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\0\x12\x04\xc2\t\x04\
    ?\n\r\n\x05\x06\0\x02E\x04\x12\x04\xc3\t\x04D\n\x11\n\t\x06\0\x02E\x04\
    \xc2\xf3\x04\x01\x12\x04\xc3\t\x04D\n$\n\x04\x06\0\x02F\x12\x06\xc7\t\
    \x02\xd1\t\x03\x1a\x14\x20List\x20all\x20the\x20apps.\n\n\r\n\x05\x06\0\
    \x02F\x01\x12\x04\xc7\t\x06\x0e\n\r\n\x05\x06\0\x02F\x02\x12\x04\xc7\t\
    \x10\x1f\n\r\n\x05\x06\0\x02F\x03\x12\x04\xc7\t*:\n\x0f\n\x05\x06\0\x02F\
    \x04\x12\x06\xc8\t\x04\xcd\t\x06\n\x13\n\t\x06\0\x02F\x04\xb0\xca\xbc\"\
    \x12\x06\xc8\t\x04\xcd\t\x06\n\r\n\x05\x06\0\x02F\x04\x12\x04\xce\t\x047\
    \n\x10\n\x08\x06\0\x02F\x04\xc3\xf3\x04\x12\x04\xce\t\x047\n\r\n\x05\x06\
    \0\x02F\x04\x12\x04\xcf\t\x04?\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\0\
    \x12\x04\xcf\t\x04?\n\r\n\x05\x06\0\x02F\x04\x12\x04\xd0\t\x04D\n\x11\n\
    \t\x06\0\x02F\x04\xc2\xf3\x04\x01\x12\x04\xd0\t\x04D\n\xc9\x01\n\x04\x06\
    \0\x02G\x12\x06\xd6\t\x02\xdf\t\x03\x1a\xb8\x01\x20Search\x20over\x20the\
    \x20apps\x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\
    \n\x20This\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\
    \x20also\x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20p\
    aram\x20variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02G\x01\
    \x12\x04\xd6\t\x06\x0f\n\r\n\x05\x06\0\x02G\x02\x12\x04\xd6\t\x11!\n\r\n\
    \x05\x06\0\x02G\x03\x12\x04\xd6\t,L\n\x0f\n\x05\x06\0\x02G\x04\x12\x06\
    \xd7\t\x04\xd9\t\x06\n\x13\n\t\x06\0\x02G\x04\xb0\xca\xbc\"\x12\x06\xd7\
    \t\x04\xd9\t\x06\n\r\n\x05\x06\0\x02G\x04\x12\x04\xda\t\x047\n\x10\n\x08\
    \x06\0\x02G\x04\xc3\xf3\x04\x12\x04\xda\t\x047\n\r\n\x05\x06\0\x02G\x04\
    \x12\x04\xdb\t\x04?\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\0\x12\x04\xdb\t\
    \x04?\n\r\n\x05\x06\0\x02G\x04\x12\x04\xdc\t\x04B\n\x11\n\t\x06\0\x02G\
    \x04\xc2\xf3\x04\x01\x12\x04\xdc\t\x04B\n\r\n\x05\x06\0\x02G\x04\x12\x04\
    \xdd\t\x04?\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\x02\x12\x04\xdd\t\x04?\
    \n\r\n\x05\x06\0\x02G\x04\x12\x04\xde\t\x04D\n\x11\n\t\x06\0\x02G\x04\
    \xc2\xf3\x04\x03\x12\x04\xde\t\x04D\n\xba\x01\n\x04\x06\0\x02H\x12\x06\
    \xe4\t\x02\xef\t\x03\x1a\xa9\x01\x20Add\x20a\x20app\x20to\x20an\x20app.\
    \n\x20This\x20needs\x20to\x20load\x20the\x20default\x20workflow\x20to\
    \x20make\x20a\x20copy,\x20validating\x20all\x20the\x20models\x20in\x20it\
    ,\x20and\n\x20then\x20writing\x20the\x20new\x20workflow\x20back\x20to\
    \x20this\x20new\x20app.\n\n\r\n\x05\x06\0\x02H\x01\x12\x04\xe4\t\x06\x0e\
    \n\r\n\x05\x06\0\x02H\x02\x12\x04\xe4\t\x10\x1f\n\r\n\x05\x06\0\x02H\x03\
    \x12\x04\xe4\t*:\n\x0f\n\x05\x06\0\x02H\x04\x12\x06\xe5\t\x04\xe8\t\x06\
    \n\x13\n\t\x06\0\x02H\x04\xb0\xca\xbc\"\x12\x06\xe5\t\x04\xe8\t\x06\n\r\
    \n\x05\x06\0\x02H\x04\x12\x04\xe9\t\x047\n\x10\n\x08\x06\0\x02H\x04\xc3\
    \xf3\x04\x12\x04\xe9\t\x047\n\r\n\x05\x06\0\x02H\x04\x12\x04\xea\t\x04?\
    \n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\0\x12\x04\xea\t\x04?\n\r\n\x05\x06\
    \0\x02H\x04\x12\x04\xeb\t\x04?\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x01\
    \x12\x04\xeb\t\x04?\n\r\n\x05\x06\0\x02H\x04\x12\x04\xec\t\x04A\n\x11\n\
    \t\x06\0\x02H\x04\xc2\xf3\x04\x02\x12\x04\xec\t\x04A\n\r\n\x05\x06\0\x02\
    H\x04\x12\x04\xed\t\x04D\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x03\x12\
    \x04\xed\t\x04D\n\r\n\x05\x06\0\x02H\x04\x12\x04\xee\t\x04D\n\x11\n\t\
    \x06\0\x02H\x04\xc2\xf3\x04\x04\x12\x04\xee\t\x04D\n)\n\x04\x06\0\x02I\
    \x12\x06\xf2\t\x02\xfc\t\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20ap\
    ps.\n\n\r\n\x05\x06\0\x02I\x01\x12\x04\xf2\t\x06\x0f\n\r\n\x05\x06\0\x02\
    I\x02\x12\x04\xf2\t\x11!\n\r\n\x05\x06\0\x02I\x03\x12\x04\xf2\t,<\n\x0f\
    \n\x05\x06\0\x02I\x04\x12\x06\xf3\t\x04\xf6\t\x06\n\x13\n\t\x06\0\x02I\
    \x04\xb0\xca\xbc\"\x12\x06\xf3\t\x04\xf6\t\x06\n\r\n\x05\x06\0\x02I\x04\
    \x12\x04\xf7\t\x047\n\x10\n\x08\x06\0\x02I\x04\xc3\xf3\x04\x12\x04\xf7\t\
    \x047\n\r\n\x05\x06\0\x02I\x04\x12\x04\xf8\t\x04?\n\x11\n\t\x06\0\x02I\
    \x04\xc2\xf3\x04\0\x12\x04\xf8\t\x04?\n\r\n\x05\x06\0\x02I\x04\x12\x04\
    \xf9\t\x04?\n\x95\x01\n\t\x06\0\x02I\x04\xc2\xf3\x04\x01\x12\x04\xf9\t\
    \x04?\"\x81\x01\x20option\x20(clarifai.auth.util.cl_depending_scopes)\
    \x20=\x20Models_Get;\n\x20option\x20(clarifai.auth.util.cl_depending_sco\
    pes)\x20=\x20Workflows_Get;\n\nV\n\x04\x06\0\x02J\x12\x06\xff\t\x02\x87\
    \n\x03\x1aF\x20Search\x20over\x20the\x20applications\x20to\x20find\x20on\
    e\x20or\x20more\x20you're\x20looking\x20for.\n\n\r\n\x05\x06\0\x02J\x01\
    \x12\x04\xff\t\x06\x16\n\r\n\x05\x06\0\x02J\x02\x12\x04\xff\t\x18/\n\r\n\
    \x05\x06\0\x02J\x03\x12\x04\xff\t:J\n\x0f\n\x05\x06\0\x02J\x04\x12\x06\
    \x80\n\x04\x83\n\x06\n\x13\n\t\x06\0\x02J\x04\xb0\xca\xbc\"\x12\x06\x80\
    \n\x04\x83\n\x06\n\r\n\x05\x06\0\x02J\x04\x12\x04\x84\n\x047\n\x10\n\x08\
    \x06\0\x02J\x04\xc3\xf3\x04\x12\x04\x84\n\x047\n\r\n\x05\x06\0\x02J\x04\
    \x12\x04\x85\n\x04?\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\0\x12\x04\x85\n\
    \x04?\n\r\n\x05\x06\0\x02J\x04\x12\x04\x86\n\x04D\n\x11\n\t\x06\0\x02J\
    \x04\xc2\xf3\x04\x01\x12\x04\x86\n\x04D\n\xc2\x01\n\x04\x06\0\x02K\x12\
    \x06\x9e\n\x02\xa9\n\x03\x1a/\x20Validate\x20new\x20password\x20in\x20re\
    al-time\x20for\x20a\x20user\n2'//////////////////////////////////////\n2\
    X//////////////////////////////////////\n\x20Password\n/////////////////\
    /////////////////////\n\n\r\n\x05\x06\0\x02K\x01\x12\x04\x9e\n\x06\x1a\n\
    \r\n\x05\x06\0\x02K\x02\x12\x04\x9e\n\x1c7\n\r\n\x05\x06\0\x02K\x03\x12\
    \x04\x9e\nBb\n\x0f\n\x05\x06\0\x02K\x04\x12\x06\x9f\n\x04\xa6\n\x06\n\
    \x13\n\t\x06\0\x02K\x04\xb0\xca\xbc\"\x12\x06\x9f\n\x04\xa6\n\x06\n\r\n\
    \x05\x06\0\x02K\x04\x12\x04\xa7\n\x047\n\x10\n\x08\x06\0\x02K\x04\xc3\
    \xf3\x04\x12\x04\xa7\n\x047\n\r\n\x05\x06\0\x02K\x04\x12\x04\xa8\n\x04K\
    \n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\0\x12\x04\xa8\n\x04K\n\x7f\n\x04\
    \x06\0\x02L\x12\x06\xe7\n\x02\xf0\n\x03\x1a\x15\x20Get\x20a\x20saved\x20\
    search.\n2X//////////////////////////////////////\n\x20Searches\n///////\
    ///////////////////////////////\n\n\r\n\x05\x06\0\x02L\x01\x12\x04\xe7\n\
    \x06\x0f\n\r\n\x05\x06\0\x02L\x02\x12\x04\xe7\n\x11!\n\r\n\x05\x06\0\x02\
    L\x03\x12\x04\xe7\n,@\n\x0f\n\x05\x06\0\x02L\x04\x12\x06\xe8\n\x04\xed\n\
    \x06\n\x13\n\t\x06\0\x02L\x04\xb0\xca\xbc\"\x12\x06\xe8\n\x04\xed\n\x06\
    \n\r\n\x05\x06\0\x02L\x04\x12\x04\xee\n\x047\n\x10\n\x08\x06\0\x02L\x04\
    \xc3\xf3\x04\x12\x04\xee\n\x047\n\r\n\x05\x06\0\x02L\x04\x12\x04\xef\n\
    \x04=\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\0\x12\x04\xef\n\x04=\n*\n\x04\
    \x06\0\x02M\x12\x06\xf3\n\x02\xfc\n\x03\x1a\x1a\x20List\x20all\x20saved\
    \x20searches.\n\n\r\n\x05\x06\0\x02M\x01\x12\x04\xf3\n\x06\x12\n\r\n\x05\
    \x06\0\x02M\x02\x12\x04\xf3\n\x14'\n\r\n\x05\x06\0\x02M\x03\x12\x04\xf3\
    \n2E\n\x0f\n\x05\x06\0\x02M\x04\x12\x06\xf4\n\x04\xf9\n\x06\n\x13\n\t\
    \x06\0\x02M\x04\xb0\xca\xbc\"\x12\x06\xf4\n\x04\xf9\n\x06\n\r\n\x05\x06\
    \0\x02M\x04\x12\x04\xfa\n\x047\n\x10\n\x08\x06\0\x02M\x04\xc3\xf3\x04\
    \x12\x04\xfa\n\x047\n\r\n\x05\x06\0\x02M\x04\x12\x04\xfb\n\x04=\n\x11\n\
    \t\x06\0\x02M\x04\xc2\xf3\x04\0\x12\x04\xfb\n\x04=\n>\n\x04\x06\0\x02N\
    \x12\x06\xff\n\x02\x90\x0b\x03\x1a.\x20Execute\x20a\x20new\x20search\x20\
    and\x20optionally\x20save\x20it.\n\n\r\n\x05\x06\0\x02N\x01\x12\x04\xff\
    \n\x06\x12\n\r\n\x05\x06\0\x02N\x02\x12\x04\xff\n\x14'\n\r\n\x05\x06\0\
    \x02N\x03\x12\x04\xff\n2E\n\x0f\n\x05\x06\0\x02N\x04\x12\x06\x80\x0b\x04\
    \x87\x0b\x06\n\x13\n\t\x06\0\x02N\x04\xb0\xca\xbc\"\x12\x06\x80\x0b\x04\
    \x87\x0b\x06\n\r\n\x05\x06\0\x02N\x04\x12\x04\x88\x0b\x047\n\x10\n\x08\
    \x06\0\x02N\x04\xc3\xf3\x04\x12\x04\x88\x0b\x047\n\r\n\x05\x06\0\x02N\
    \x04\x12\x04\x89\x0b\x04F\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\0\x12\x04\
    \x89\x0b\x04F\n\r\n\x05\x06\0\x02N\x04\x12\x04\x8a\x0b\x04C\n\x11\n\t\
    \x06\0\x02N\x04\xc2\xf3\x04\x01\x12\x04\x8a\x0b\x04C\n\r\n\x05\x06\0\x02\
    N\x04\x12\x04\x8b\x0b\x04A\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x02\x12\
    \x04\x8b\x0b\x04A\n\r\n\x05\x06\0\x02N\x04\x12\x04\x8c\x0b\x04A\n\x11\n\
    \t\x06\0\x02N\x04\xc2\xf3\x04\x03\x12\x04\x8c\x0b\x04A\n\r\n\x05\x06\0\
    \x02N\x04\x12\x04\x8e\x0b\x04=\n[\n\t\x06\0\x02N\x04\xc2\xf3\x04\x04\x12\
    \x04\x8e\x0b\x04=\x1aH\x20option\x20(clarifai.auth.util.cl_depending_sco\
    pes)\x20=\x20Predict;\x20//\x20optional\n\n\r\n\x05\x06\0\x02N\x04\x12\
    \x04\x8f\x0b\x04D\nN\n\t\x06\0\x02N\x04\xc2\xf3\x04\x05\x12\x04\x8f\x0b\
    \x04D\";\x20to\x20know\x20the\x20concepts\x20and\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n4\n\x04\x06\0\x02O\x12\x06\x93\x0b\x02\x9e\
    \x0b\x03\x1a$\x20Execute\x20a\x20previously\x20saved\x20search.\n\n\r\n\
    \x05\x06\0\x02O\x01\x12\x04\x93\x0b\x06\x16\n\r\n\x05\x06\0\x02O\x02\x12\
    \x04\x93\x0b\x18/\n\r\n\x05\x06\0\x02O\x03\x12\x04\x93\x0b:M\n\x0f\n\x05\
    \x06\0\x02O\x04\x12\x06\x94\x0b\x04\x9b\x0b\x06\n\x13\n\t\x06\0\x02O\x04\
    \xb0\xca\xbc\"\x12\x06\x94\x0b\x04\x9b\x0b\x06\n\r\n\x05\x06\0\x02O\x04\
    \x12\x04\x9c\x0b\x047\n\x10\n\x08\x06\0\x02O\x04\xc3\xf3\x04\x12\x04\x9c\
    \x0b\x047\n\r\n\x05\x06\0\x02O\x04\x12\x04\x9d\x0b\x04=\n\x11\n\t\x06\0\
    \x02O\x04\xc2\xf3\x04\0\x12\x04\x9d\x0b\x04=\n=\n\x04\x06\0\x02P\x12\x06\
    \xa1\x0b\x02\xb2\x0b\x03\x1a-\x20Evaluate\x20the\x20results\x20of\x20two\
    \x20search\x20requests\n\n\r\n\x05\x06\0\x02P\x01\x12\x04\xa1\x0b\x06!\n\
    \r\n\x05\x06\0\x02P\x02\x12\x04\xa1\x0b\"D\n\r\n\x05\x06\0\x02P\x03\x12\
    \x04\xa1\x0bOs\n\x0f\n\x05\x06\0\x02P\x04\x12\x06\xa2\x0b\x04\xa9\x0b\
    \x06\n\x13\n\t\x06\0\x02P\x04\xb0\xca\xbc\"\x12\x06\xa2\x0b\x04\xa9\x0b\
    \x06\n\r\n\x05\x06\0\x02P\x04\x12\x04\xaa\x0b\x047\n\x10\n\x08\x06\0\x02\
    P\x04\xc3\xf3\x04\x12\x04\xaa\x0b\x047\n\r\n\x05\x06\0\x02P\x04\x12\x04\
    \xab\x0b\x04F\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\0\x12\x04\xab\x0b\x04\
    F\n\r\n\x05\x06\0\x02P\x04\x12\x04\xac\x0b\x04C\n\x11\n\t\x06\0\x02P\x04\
    \xc2\xf3\x04\x01\x12\x04\xac\x0b\x04C\n\r\n\x05\x06\0\x02P\x04\x12\x04\
    \xad\x0b\x04A\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x02\x12\x04\xad\x0b\
    \x04A\n\r\n\x05\x06\0\x02P\x04\x12\x04\xae\x0b\x04B\n\x11\n\t\x06\0\x02P\
    \x04\xc2\xf3\x04\x03\x12\x04\xae\x0b\x04B\n\r\n\x05\x06\0\x02P\x04\x12\
    \x04\xaf\x0b\x04B\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x04\x12\x04\xaf\
    \x0b\x04B\n\r\n\x05\x06\0\x02P\x04\x12\x04\xb0\x0b\x04A\n\x11\n\t\x06\0\
    \x02P\x04\xc2\xf3\x04\x05\x12\x04\xb0\x0b\x04A\n\r\n\x05\x06\0\x02P\x04\
    \x12\x04\xb1\x0b\x04D\nP\n\t\x06\0\x02P\x04\xc2\xf3\x04\x06\x12\x04\xb1\
    \x0b\x04D\"=\x20as\x20it\x20needs\x20to\x20know\x20the\x20concepts\x20in\
    \x20your\x20workflow's\x20models.\n\nH\n\x04\x06\0\x02Q\x12\x06\xb5\x0b\
    \x02\xc1\x0b\x03\x1a8\x20Get\x20the\x20evaluation\x20results\x20between\
    \x20two\x20search\x20requests\n\n\r\n\x05\x06\0\x02Q\x01\x12\x04\xb5\x0b\
    \x06\x20\n\r\n\x05\x06\0\x02Q\x02\x12\x04\xb5\x0b!B\n\r\n\x05\x06\0\x02Q\
    \x03\x12\x04\xb5\x0bMq\n\x0f\n\x05\x06\0\x02Q\x04\x12\x06\xb6\x0b\x04\
    \xbb\x0b\x06\n\x13\n\t\x06\0\x02Q\x04\xb0\xca\xbc\"\x12\x06\xb6\x0b\x04\
    \xbb\x0b\x06\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xbc\x0b\x047\n\x10\n\x08\
    \x06\0\x02Q\x04\xc3\xf3\x04\x12\x04\xbc\x0b\x047\n\r\n\x05\x06\0\x02Q\
    \x04\x12\x04\xbd\x0b\x04F\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\0\x12\x04\
    \xbd\x0b\x04F\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xbe\x0b\x04C\n\x11\n\t\
    \x06\0\x02Q\x04\xc2\xf3\x04\x01\x12\x04\xbe\x0b\x04C\n\r\n\x05\x06\0\x02\
    Q\x04\x12\x04\xbf\x0b\x04A\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x02\x12\
    \x04\xbf\x0b\x04A\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xc0\x0b\x04B\n\x11\n\
    \t\x06\0\x02Q\x04\xc2\xf3\x04\x03\x12\x04\xc0\x0b\x04B\nI\n\x04\x06\0\
    \x02R\x12\x06\xc6\x0b\x02\xd2\x0b\x03\x1a9\x20List\x20the\x20evaluation\
    \x20results\x20between\x20two\x20search\x20requests\n\n\r\n\x05\x06\0\
    \x02R\x01\x12\x04\xc6\x0b\x06!\n\r\n\x05\x06\0\x02R\x02\x12\x04\xc6\x0b\
    \"D\n\r\n\x05\x06\0\x02R\x03\x12\x04\xc6\x0bOs\n\x0f\n\x05\x06\0\x02R\
    \x04\x12\x06\xc7\x0b\x04\xcc\x0b\x06\n\x13\n\t\x06\0\x02R\x04\xb0\xca\
    \xbc\"\x12\x06\xc7\x0b\x04\xcc\x0b\x06\n\r\n\x05\x06\0\x02R\x04\x12\x04\
    \xcd\x0b\x047\n\x10\n\x08\x06\0\x02R\x04\xc3\xf3\x04\x12\x04\xcd\x0b\x04\
    7\n\r\n\x05\x06\0\x02R\x04\x12\x04\xce\x0b\x04F\n\x11\n\t\x06\0\x02R\x04\
    \xc2\xf3\x04\0\x12\x04\xce\x0b\x04F\n\r\n\x05\x06\0\x02R\x04\x12\x04\xcf\
    \x0b\x04C\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x01\x12\x04\xcf\x0b\x04C\
    \n\r\n\x05\x06\0\x02R\x04\x12\x04\xd0\x0b\x04A\n\x11\n\t\x06\0\x02R\x04\
    \xc2\xf3\x04\x02\x12\x04\xd0\x0b\x04A\n\r\n\x05\x06\0\x02R\x04\x12\x04\
    \xd1\x0b\x04B\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x03\x12\x04\xd1\x0b\
    \x04B\n\x0e\n\x04\x06\0\x02S\x12\x06\xd4\x0b\x02\xdf\x0b\x03\n\r\n\x05\
    \x06\0\x02S\x01\x12\x04\xd4\x0b\x06#\n\r\n\x05\x06\0\x02S\x02\x12\x04\
    \xd4\x0b%I\n\r\n\x05\x06\0\x02S\x03\x12\x04\xd4\x0bTt\n\x0f\n\x05\x06\0\
    \x02S\x04\x12\x06\xd5\x0b\x04\xda\x0b\x06\n\x13\n\t\x06\0\x02S\x04\xb0\
    \xca\xbc\"\x12\x06\xd5\x0b\x04\xda\x0b\x06\n\r\n\x05\x06\0\x02S\x04\x12\
    \x04\xdb\x0b\x047\n\x10\n\x08\x06\0\x02S\x04\xc3\xf3\x04\x12\x04\xdb\x0b\
    \x047\n\r\n\x05\x06\0\x02S\x04\x12\x04\xdc\x0b\x04B\n\x11\n\t\x06\0\x02S\
    \x04\xc2\xf3\x04\0\x12\x04\xdc\x0b\x04B\n\r\n\x05\x06\0\x02S\x04\x12\x04\
    \xdd\x0b\x04B\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x01\x12\x04\xdd\x0b\
    \x04B\n\r\n\x05\x06\0\x02S\x04\x12\x04\xde\x0b\x04E\n\x11\n\t\x06\0\x02S\
    \x04\xc2\xf3\x04\x02\x12\x04\xde\x0b\x04E\n(\n\x04\x06\0\x02T\x12\x06\
    \xe2\x0b\x02\xeb\x0b\x03\x1a\x18\x20Delete\x20a\x20saved\x20search.\n\n\
    \r\n\x05\x06\0\x02T\x01\x12\x04\xe2\x0b\x06\x12\n\r\n\x05\x06\0\x02T\x02\
    \x12\x04\xe2\x0b\x14'\n\r\n\x05\x06\0\x02T\x03\x12\x04\xe2\x0b2R\n\x0f\n\
    \x05\x06\0\x02T\x04\x12\x06\xe3\x0b\x04\xe8\x0b\x06\n\x13\n\t\x06\0\x02T\
    \x04\xb0\xca\xbc\"\x12\x06\xe3\x0b\x04\xe8\x0b\x06\n\r\n\x05\x06\0\x02T\
    \x04\x12\x04\xe9\x0b\x047\n\x10\n\x08\x06\0\x02T\x04\xc3\xf3\x04\x12\x04\
    \xe9\x0b\x047\n\r\n\x05\x06\0\x02T\x04\x12\x04\xea\x0b\x04=\n\x11\n\t\
    \x06\0\x02T\x04\xc2\xf3\x04\0\x12\x04\xea\x0b\x04=\n\xaf\x01\n\x04\x06\0\
    \x02U\x12\x06\x95\x0c\x02\x9a\x0c\x03\x1a\x18\x20List\x20all\x20status\
    \x20codes.\n2'//////////////////////////////////////\n2\\///////////////\
    ///////////////////////\n\x20Status\x20Codes\n//////////////////////////\
    ////////////\n\n\r\n\x05\x06\0\x02U\x01\x12\x04\x95\x0c\x06\x15\n\r\n\
    \x05\x06\0\x02U\x02\x12\x04\x95\x0c\x17-\n\r\n\x05\x06\0\x02U\x03\x12\
    \x04\x95\x0c8O\n\x0f\n\x05\x06\0\x02U\x04\x12\x06\x96\x0c\x04\x98\x0c\
    \x06\n\x13\n\t\x06\0\x02U\x04\xb0\xca\xbc\"\x12\x06\x96\x0c\x04\x98\x0c\
    \x06\n\r\n\x05\x06\0\x02U\x04\x12\x04\x99\x0c\x046\n\x10\n\x08\x06\0\x02\
    U\x04\xc3\xf3\x04\x12\x04\x99\x0c\x046\n5\n\x04\x06\0\x02V\x12\x06\x9d\
    \x0c\x02\xa2\x0c\x03\x1a%\x20Get\x20more\x20details\x20for\x20a\x20statu\
    s\x20code.\n\n\r\n\x05\x06\0\x02V\x01\x12\x04\x9d\x0c\x06\x13\n\r\n\x05\
    \x06\0\x02V\x02\x12\x04\x9d\x0c\x15)\n\r\n\x05\x06\0\x02V\x03\x12\x04\
    \x9d\x0c4L\n\x0f\n\x05\x06\0\x02V\x04\x12\x06\x9e\x0c\x04\xa0\x0c\x06\n\
    \x13\n\t\x06\0\x02V\x04\xb0\xca\xbc\"\x12\x06\x9e\x0c\x04\xa0\x0c\x06\n\
    \r\n\x05\x06\0\x02V\x04\x12\x04\xa1\x0c\x046\n\x10\n\x08\x06\0\x02V\x04\
    \xc3\xf3\x04\x12\x04\xa1\x0c\x046\n\x9a\x01\n\x04\x06\0\x02W\x12\x06\xb3\
    \x0c\x02\xb9\x0c\x03\x1a-\x20owner\x20list\x20users\x20who\x20the\x20app\
    \x20is\x20shared\x20with\n2[//////////////////////////////////////\n\x20\
    App\x20Sharing\n//////////////////////////////////////\n\n\r\n\x05\x06\0\
    \x02W\x01\x12\x04\xb3\x0c\x06\x17\n\r\n\x05\x06\0\x02W\x02\x12\x04\xb3\
    \x0c\x191\n\r\n\x05\x06\0\x02W\x03\x12\x04\xb3\x0c<V\n\x0f\n\x05\x06\0\
    \x02W\x04\x12\x06\xb4\x0c\x04\xb6\x0c\x06\n\x13\n\t\x06\0\x02W\x04\xb0\
    \xca\xbc\"\x12\x06\xb4\x0c\x04\xb6\x0c\x06\n\r\n\x05\x06\0\x02W\x04\x12\
    \x04\xb7\x0c\x047\n\x10\n\x08\x06\0\x02W\x04\xc3\xf3\x04\x12\x04\xb7\x0c\
    \x047\n\r\n\x05\x06\0\x02W\x04\x12\x04\xb8\x0c\x04H\n\x11\n\t\x06\0\x02W\
    \x04\xc2\xf3\x04\0\x12\x04\xb8\x0c\x04H\n.\n\x04\x06\0\x02X\x12\x06\xbc\
    \x0c\x02\xc4\x0c\x03\x1a\x1e\x20add\x20collaborators\x20to\x20an\x20app.\
    \n\n\r\n\x05\x06\0\x02X\x01\x12\x04\xbc\x0c\x06\x17\n\r\n\x05\x06\0\x02X\
    \x02\x12\x04\xbc\x0c\x191\n\r\n\x05\x06\0\x02X\x03\x12\x04\xbc\x0c<V\n\
    \x0f\n\x05\x06\0\x02X\x04\x12\x06\xbd\x0c\x04\xc0\x0c\x06\n\x13\n\t\x06\
    \0\x02X\x04\xb0\xca\xbc\"\x12\x06\xbd\x0c\x04\xc0\x0c\x06\n\r\n\x05\x06\
    \0\x02X\x04\x12\x04\xc1\x0c\x047\n\x10\n\x08\x06\0\x02X\x04\xc3\xf3\x04\
    \x12\x04\xc1\x0c\x047\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc2\x0c\x04H\n\
    \x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\0\x12\x04\xc2\x0c\x04H\n\r\n\x05\x06\
    \0\x02X\x04\x12\x04\xc3\x0c\x04H\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\
    \x01\x12\x04\xc3\x0c\x04H\n/\n\x04\x06\0\x02Y\x12\x06\xc7\x0c\x02\xd0\
    \x0c\x03\x1a\x1f\x20Patch\x20existing\x20collaborators.\n\n\r\n\x05\x06\
    \0\x02Y\x01\x12\x04\xc7\x0c\x06\x18\n\r\n\x05\x06\0\x02Y\x02\x12\x04\xc7\
    \x0c\x1a3\n\r\n\x05\x06\0\x02Y\x03\x12\x04\xc7\x0c>X\n\x0f\n\x05\x06\0\
    \x02Y\x04\x12\x06\xc8\x0c\x04\xcb\x0c\x06\n\x13\n\t\x06\0\x02Y\x04\xb0\
    \xca\xbc\"\x12\x06\xc8\x0c\x04\xcb\x0c\x06\n\r\n\x05\x06\0\x02Y\x04\x12\
    \x04\xcc\x0c\x047\n\x10\n\x08\x06\0\x02Y\x04\xc3\xf3\x04\x12\x04\xcc\x0c\
    \x047\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xcd\x0c\x04H\n\x11\n\t\x06\0\x02Y\
    \x04\xc2\xf3\x04\0\x12\x04\xcd\x0c\x04H\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xce\x0c\x04H\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x01\x12\x04\xce\x0c\
    \x04H\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xcf\x0c\x04K\n\x11\n\t\x06\0\x02Y\
    \x04\xc2\xf3\x04\x02\x12\x04\xcf\x0c\x04K\n0\n\x04\x06\0\x02Z\x12\x06\
    \xd3\x0c\x02\xde\x0c\x03\x1a\x20\x20Delete\x20existing\x20collaborators.\
    \n\n\r\n\x05\x06\0\x02Z\x01\x12\x04\xd3\x0c\x06\x19\n\r\n\x05\x06\0\x02Z\
    \x02\x12\x04\xd3\x0c\x1b5\n\r\n\x05\x06\0\x02Z\x03\x12\x04\xd3\x0c@`\n\
    \x0f\n\x05\x06\0\x02Z\x04\x12\x06\xd4\x0c\x04\xd7\x0c\x06\n\x13\n\t\x06\
    \0\x02Z\x04\xb0\xca\xbc\"\x12\x06\xd4\x0c\x04\xd7\x0c\x06\n\r\n\x05\x06\
    \0\x02Z\x04\x12\x04\xd8\x0c\x047\n\x10\n\x08\x06\0\x02Z\x04\xc3\xf3\x04\
    \x12\x04\xd8\x0c\x047\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xd9\x0c\x04H\n\
    \x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\0\x12\x04\xd9\x0c\x04H\n\r\n\x05\x06\
    \0\x02Z\x04\x12\x04\xda\x0c\x04H\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\
    \x01\x12\x04\xda\x0c\x04H\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xdb\x0c\x04K\
    \n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x02\x12\x04\xdb\x0c\x04K\n\r\n\x05\
    \x06\0\x02Z\x04\x12\x04\xdc\x0c\x04@\nn\n\t\x06\0\x02Z\x04\xc2\xf3\x04\
    \x03\x12\x04\xdc\x0c\x04@\"[\x20when\x20deleting\x20a\x20collaborator,\
    \x20we\x20also\x20delete\x20task\x20workers\x20associated\x20to\x20this\
    \x20collaborator\n\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xdd\x0c\x04@\n\x11\n\
    \t\x06\0\x02Z\x04\xc2\xf3\x04\x04\x12\x04\xdd\x0c\x04@\nM\n\x04\x06\0\
    \x02[\x12\x06\xe1\x0c\x02\xe6\x0c\x03\x1a=\x20Collaboration\x20includes\
    \x20the\x20app\x20user\x20are\x20invitied\x20to\x20work\x20on\n\n\r\n\
    \x05\x06\0\x02[\x01\x12\x04\xe1\x0c\x06\x18\n\r\n\x05\x06\0\x02[\x02\x12\
    \x04\xe1\x0c\x1a3\n\r\n\x05\x06\0\x02[\x03\x12\x04\xe1\x0c>Y\n\x0f\n\x05\
    \x06\0\x02[\x04\x12\x06\xe2\x0c\x04\xe4\x0c\x06\n\x13\n\t\x06\0\x02[\x04\
    \xb0\xca\xbc\"\x12\x06\xe2\x0c\x04\xe4\x0c\x06\n\r\n\x05\x06\0\x02[\x04\
    \x12\x04\xe5\x0c\x04@\n\x10\n\x08\x06\0\x02[\x04\xc3\xf3\x04\x12\x04\xe5\
    \x0c\x04@\n\xc3\x02\n\x04\x06\0\x02\\\x12\x06\xf4\x0c\x02\x85\r\x03\x1a\
    \xd1\x01\x20start\x20to\x20duplicate\x20an\x20app\x20which\x20copies\x20\
    all\x20the\x20inputs,\x20annotations,\x20models,\x20concepts\x20etc.\x20\
    to\x20a\x20new\x20app.\n\x20this\x20is\x20an\x20async\x20process,\x20you\
    \x20should\x20use\x20ListAppDuplications\x20or\x20GetAppDuplication\x20t\
    o\x20check\x20the\x20status.\n2_//////////////////////////////////////\n\
    \x20App\x20duplication\n//////////////////////////////////////\n\n\r\n\
    \x05\x06\0\x02\\\x01\x12\x04\xf4\x0c\x06\x19\n\r\n\x05\x06\0\x02\\\x02\
    \x12\x04\xf4\x0c\x1b5\n\r\n\x05\x06\0\x02\\\x03\x12\x04\xf4\x0c@\\\n\x0f\
    \n\x05\x06\0\x02\\\x04\x12\x06\xf5\x0c\x04\xf8\x0c\x06\n\x13\n\t\x06\0\
    \x02\\\x04\xb0\xca\xbc\"\x12\x06\xf5\x0c\x04\xf8\x0c\x06\n\r\n\x05\x06\0\
    \x02\\\x04\x12\x04\xf9\x0c\x047\n\x10\n\x08\x06\0\x02\\\x04\xc3\xf3\x04\
    \x12\x04\xf9\x0c\x047\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xfa\x0c\x04A\n\
    \x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\0\x12\x04\xfa\x0c\x04A\n\r\n\x05\
    \x06\0\x02\\\x04\x12\x04\xfb\x0c\x04A\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\
    \x04\x01\x12\x04\xfb\x0c\x04A\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xfc\x0c\
    \x04C\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x02\x12\x04\xfc\x0c\x04C\n\r\
    \n\x05\x06\0\x02\\\x04\x12\x04\xfd\x0c\x04C\n\x11\n\t\x06\0\x02\\\x04\
    \xc2\xf3\x04\x03\x12\x04\xfd\x0c\x04C\n\r\n\x05\x06\0\x02\\\x04\x12\x04\
    \xfe\x0c\x04C\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x04\x12\x04\xfe\x0c\
    \x04C\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xff\x0c\x04A\n\x11\n\t\x06\0\x02\
    \\\x04\xc2\xf3\x04\x05\x12\x04\xff\x0c\x04A\n\r\n\x05\x06\0\x02\\\x04\
    \x12\x04\x80\r\x04A\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x06\x12\x04\
    \x80\r\x04A\n\r\n\x05\x06\0\x02\\\x04\x12\x04\x81\r\x04F\n\x11\n\t\x06\0\
    \x02\\\x04\xc2\xf3\x04\x07\x12\x04\x81\r\x04F\n\r\n\x05\x06\0\x02\\\x04\
    \x12\x04\x82\r\x04F\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x08\x12\x04\
    \x82\r\x04F\n\r\n\x05\x06\0\x02\\\x04\x12\x04\x83\r\x04D\n\x11\n\t\x06\0\
    \x02\\\x04\xc2\xf3\x04\t\x12\x04\x83\r\x04D\n\r\n\x05\x06\0\x02\\\x04\
    \x12\x04\x84\r\x04D\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\n\x12\x04\x84\
    \r\x04D\n=\n\x04\x06\0\x02]\x12\x06\x88\r\x02\x8d\r\x03\x1a-\x20list\x20\
    all\x20the\x20app\x20duplications\x20user\x20triggers\n\n\r\n\x05\x06\0\
    \x02]\x01\x12\x04\x88\r\x06\x19\n\r\n\x05\x06\0\x02]\x02\x12\x04\x88\r\
    \x1b5\n\r\n\x05\x06\0\x02]\x03\x12\x04\x88\r@\\\n\x0f\n\x05\x06\0\x02]\
    \x04\x12\x06\x89\r\x04\x8b\r\x06\n\x13\n\t\x06\0\x02]\x04\xb0\xca\xbc\"\
    \x12\x06\x89\r\x04\x8b\r\x06\n\r\n\x05\x06\0\x02]\x04\x12\x04\x8c\r\x04@\
    \n\x10\n\x08\x06\0\x02]\x04\xc3\xf3\x04\x12\x04\x8c\r\x04@\n0\n\x04\x06\
    \0\x02^\x12\x06\x90\r\x02\x95\r\x03\x1a\x20\x20get\x20the\x20app\x20dupl\
    ication\x20status\n\n\r\n\x05\x06\0\x02^\x01\x12\x04\x90\r\x06\x17\n\r\n\
    \x05\x06\0\x02^\x02\x12\x04\x90\r\x191\n\r\n\x05\x06\0\x02^\x03\x12\x04\
    \x90\r<X\n\x0f\n\x05\x06\0\x02^\x04\x12\x06\x91\r\x04\x93\r\x06\n\x13\n\
    \t\x06\0\x02^\x04\xb0\xca\xbc\"\x12\x06\x91\r\x04\x93\r\x06\n\r\n\x05\
    \x06\0\x02^\x04\x12\x04\x94\r\x04@\n\x10\n\x08\x06\0\x02^\x04\xc3\xf3\
    \x04\x12\x04\x94\r\x04@\n}\n\x04\x06\0\x02_\x12\x06\x9d\r\x02\xb1\r\x03\
    \x1a\x16\x20Add\x20tasks\x20to\x20an\x20app.\n2U////////////////////////\
    //////////////\n\x20Tasks\n//////////////////////////////////////\n\n\r\
    \n\x05\x06\0\x02_\x01\x12\x04\x9d\r\x06\x0f\n\r\n\x05\x06\0\x02_\x02\x12\
    \x04\x9d\r\x11!\n\r\n\x05\x06\0\x02_\x03\x12\x04\x9d\r,=\n\x0f\n\x05\x06\
    \0\x02_\x04\x12\x06\x9e\r\x04\xa5\r\x06\n\x13\n\t\x06\0\x02_\x04\xb0\xca\
    \xbc\"\x12\x06\x9e\r\x04\xa5\r\x06\n\r\n\x05\x06\0\x02_\x04\x12\x04\xa6\
    \r\x047\n\x10\n\x08\x06\0\x02_\x04\xc3\xf3\x04\x12\x04\xa6\r\x047\n\r\n\
    \x05\x06\0\x02_\x04\x12\x04\xa7\r\x04@\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\
    \x04\0\x12\x04\xa7\r\x04@\n\r\n\x05\x06\0\x02_\x04\x12\x04\xa8\r\x04@\n\
    \x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x01\x12\x04\xa8\r\x04@\n\r\n\x05\x06\
    \0\x02_\x04\x12\x04\xa9\r\x04A\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x02\
    \x12\x04\xa9\r\x04A\n\r\n\x05\x06\0\x02_\x04\x12\x04\xaa\r\x04=\n\x11\n\
    \t\x06\0\x02_\x04\xc2\xf3\x04\x03\x12\x04\xaa\r\x04=\n\r\n\x05\x06\0\x02\
    _\x04\x12\x04\xab\r\x04C\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x04\x12\
    \x04\xab\r\x04C\n\r\n\x05\x06\0\x02_\x04\x12\x04\xac\r\x04D\n\x11\n\t\
    \x06\0\x02_\x04\xc2\xf3\x04\x05\x12\x04\xac\r\x04D\n\r\n\x05\x06\0\x02_\
    \x04\x12\x04\xad\r\x04A\nO\n\t\x06\0\x02_\x04\xc2\xf3\x04\x06\x12\x04\
    \xad\r\x04A\"<\x20needed\x20for\x20converting\x20workers\x20internal\x20\
    ids\x20to\x20external\x20ids\n\n\r\n\x05\x06\0\x02_\x04\x12\x04\xaf\r\
    \x04F\n\xcb\x01\n\t\x06\0\x02_\x04\xc2\xf3\x04\x07\x12\x04\xaf\r\x04F\
    \x1a\x91\x01\x20option\x20(clarifai.auth.util.cl_depending_scopes)\x20=\
    \x20Predict;\x20//\x20optional,\x20needed\x20for\x20add_task_annotations\
    .go\x20when\x20saved\x20search\x20uses\x20visual\x20search\n\"$\x20neede\
    d\x20for\x20add_task_annotations.go\n\n\r\n\x05\x06\0\x02_\x04\x12\x04\
    \xb0\r\x04F\n7\n\t\x06\0\x02_\x04\xc2\xf3\x04\x08\x12\x04\xb0\r\x04F\"$\
    \x20needed\x20for\x20add_task_annotations.go\n\n'\n\x04\x06\0\x02`\x12\
    \x06\xb4\r\x02\xbd\r\x03\x1a\x17\x20Task\x20annotation\x20count\n\n\r\n\
    \x05\x06\0\x02`\x01\x12\x04\xb4\r\x06\x1c\n\r\n\x05\x06\0\x02`\x02\x12\
    \x04\xb4\r\x1e1\n\r\n\x05\x06\0\x02`\x03\x12\x04\xb4\r<S\n\x0f\n\x05\x06\
    \0\x02`\x04\x12\x06\xb5\r\x04\xba\r\x06\n\x13\n\t\x06\0\x02`\x04\xb0\xca\
    \xbc\"\x12\x06\xb5\r\x04\xba\r\x06\n\r\n\x05\x06\0\x02`\x04\x12\x04\xbb\
    \r\x047\n\x10\n\x08\x06\0\x02`\x04\xc3\xf3\x04\x12\x04\xbb\r\x047\n\r\n\
    \x05\x06\0\x02`\x04\x12\x04\xbc\r\x04@\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\
    \x04\0\x12\x04\xbc\r\x04@\n\"\n\x04\x06\0\x02a\x12\x06\xc0\r\x02\xc9\r\
    \x03\x1a\x12\x20Task\x20Input\x20count\n\n\r\n\x05\x06\0\x02a\x01\x12\
    \x04\xc0\r\x06\x17\n\r\n\x05\x06\0\x02a\x02\x12\x04\xc0\r\x19,\n\r\n\x05\
    \x06\0\x02a\x03\x12\x04\xc0\r7N\n\x0f\n\x05\x06\0\x02a\x04\x12\x06\xc1\r\
    \x04\xc6\r\x06\n\x13\n\t\x06\0\x02a\x04\xb0\xca\xbc\"\x12\x06\xc1\r\x04\
    \xc6\r\x06\n\r\n\x05\x06\0\x02a\x04\x12\x04\xc7\r\x047\n\x10\n\x08\x06\0\
    \x02a\x04\xc3\xf3\x04\x12\x04\xc7\r\x047\n\r\n\x05\x06\0\x02a\x04\x12\
    \x04\xc8\r\x04@\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\0\x12\x04\xc8\r\x04\
    @\n2\n\x04\x06\0\x02b\x12\x06\xcc\r\x02\xd9\r\x03\x1a\"\x20Get\x20a\x20s\
    pecific\x20task\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02b\x01\x12\x04\
    \xcc\r\x06\r\n\r\n\x05\x06\0\x02b\x02\x12\x04\xcc\r\x0f\x1d\n\r\n\x05\
    \x06\0\x02b\x03\x12\x04\xcc\r(:\n\x0f\n\x05\x06\0\x02b\x04\x12\x06\xcd\r\
    \x04\xd2\r\x06\n\x13\n\t\x06\0\x02b\x04\xb0\xca\xbc\"\x12\x06\xcd\r\x04\
    \xd2\r\x06\n\r\n\x05\x06\0\x02b\x04\x12\x04\xd3\r\x047\n\x10\n\x08\x06\0\
    \x02b\x04\xc3\xf3\x04\x12\x04\xd3\r\x047\n\r\n\x05\x06\0\x02b\x04\x12\
    \x04\xd4\r\x04@\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\0\x12\x04\xd4\r\x04\
    @\n\r\n\x05\x06\0\x02b\x04\x12\x04\xd5\r\x04=\n\x11\n\t\x06\0\x02b\x04\
    \xc2\xf3\x04\x01\x12\x04\xd5\r\x04=\n\r\n\x05\x06\0\x02b\x04\x12\x04\xd6\
    \r\x04C\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\x02\x12\x04\xd6\r\x04C\n\r\
    \n\x05\x06\0\x02b\x04\x12\x04\xd7\r\x04D\n\x11\n\t\x06\0\x02b\x04\xc2\
    \xf3\x04\x03\x12\x04\xd7\r\x04D\n\r\n\x05\x06\0\x02b\x04\x12\x04\xd8\r\
    \x04A\nO\n\t\x06\0\x02b\x04\xc2\xf3\x04\x04\x12\x04\xd8\r\x04A\"<\x20nee\
    ded\x20for\x20converting\x20workers\x20internal\x20ids\x20to\x20external\
    \x20ids\n\n)\n\x04\x06\0\x02c\x12\x06\xdc\r\x02\xe9\r\x03\x1a\x19\x20Lis\
    t\x20tasks\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02c\x01\x12\x04\xdc\
    \r\x06\x0f\n\r\n\x05\x06\0\x02c\x02\x12\x04\xdc\r\x11!\n\r\n\x05\x06\0\
    \x02c\x03\x12\x04\xdc\r,=\n\x0f\n\x05\x06\0\x02c\x04\x12\x06\xdd\r\x04\
    \xe2\r\x06\n\x13\n\t\x06\0\x02c\x04\xb0\xca\xbc\"\x12\x06\xdd\r\x04\xe2\
    \r\x06\n\r\n\x05\x06\0\x02c\x04\x12\x04\xe3\r\x047\n\x10\n\x08\x06\0\x02\
    c\x04\xc3\xf3\x04\x12\x04\xe3\r\x047\n\r\n\x05\x06\0\x02c\x04\x12\x04\
    \xe4\r\x04@\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\0\x12\x04\xe4\r\x04@\n\
    \r\n\x05\x06\0\x02c\x04\x12\x04\xe5\r\x04=\n\x11\n\t\x06\0\x02c\x04\xc2\
    \xf3\x04\x01\x12\x04\xe5\r\x04=\n\r\n\x05\x06\0\x02c\x04\x12\x04\xe6\r\
    \x04C\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x02\x12\x04\xe6\r\x04C\n\r\n\
    \x05\x06\0\x02c\x04\x12\x04\xe7\r\x04D\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\
    \x04\x03\x12\x04\xe7\r\x04D\n\r\n\x05\x06\0\x02c\x04\x12\x04\xe8\r\x04A\
    \nO\n\t\x06\0\x02c\x04\xc2\xf3\x04\x04\x12\x04\xe8\r\x04A\"<\x20needed\
    \x20for\x20converting\x20workers\x20internal\x20ids\x20to\x20external\
    \x20ids\n\n*\n\x04\x06\0\x02d\x12\x06\xec\r\x02\x80\x0e\x03\x1a\x1a\x20P\
    atch\x20one\x20or\x20more\x20tasks.\n\n\r\n\x05\x06\0\x02d\x01\x12\x04\
    \xec\r\x06\x10\n\r\n\x05\x06\0\x02d\x02\x12\x04\xec\r\x12#\n\r\n\x05\x06\
    \0\x02d\x03\x12\x04\xec\r.?\n\x0f\n\x05\x06\0\x02d\x04\x12\x06\xed\r\x04\
    \xf4\r\x06\n\x13\n\t\x06\0\x02d\x04\xb0\xca\xbc\"\x12\x06\xed\r\x04\xf4\
    \r\x06\n\r\n\x05\x06\0\x02d\x04\x12\x04\xf5\r\x047\n\x10\n\x08\x06\0\x02\
    d\x04\xc3\xf3\x04\x12\x04\xf5\r\x047\n\r\n\x05\x06\0\x02d\x04\x12\x04\
    \xf6\r\x04@\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\0\x12\x04\xf6\r\x04@\n\
    \r\n\x05\x06\0\x02d\x04\x12\x04\xf7\r\x04@\n\x11\n\t\x06\0\x02d\x04\xc2\
    \xf3\x04\x01\x12\x04\xf7\r\x04@\n\r\n\x05\x06\0\x02d\x04\x12\x04\xf8\r\
    \x04A\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x02\x12\x04\xf8\r\x04A\n\r\n\
    \x05\x06\0\x02d\x04\x12\x04\xf9\r\x04=\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\
    \x04\x03\x12\x04\xf9\r\x04=\n\r\n\x05\x06\0\x02d\x04\x12\x04\xfa\r\x04C\
    \n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x04\x12\x04\xfa\r\x04C\n\r\n\x05\
    \x06\0\x02d\x04\x12\x04\xfb\r\x04D\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\
    \x05\x12\x04\xfb\r\x04D\n\r\n\x05\x06\0\x02d\x04\x12\x04\xfc\r\x04A\nO\n\
    \t\x06\0\x02d\x04\xc2\xf3\x04\x06\x12\x04\xfc\r\x04A\"<\x20needed\x20for\
    \x20converting\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\
    \n\r\n\x05\x06\0\x02d\x04\x12\x04\xfe\r\x04F\n\xcb\x01\n\t\x06\0\x02d\
    \x04\xc2\xf3\x04\x07\x12\x04\xfe\r\x04F\x1a\x91\x01\x20option\x20(clarif\
    ai.auth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20optional,\
    \x20needed\x20for\x20add_task_annotations.go\x20when\x20saved\x20search\
    \x20uses\x20visual\x20search\n\"$\x20needed\x20for\x20add_task_annotatio\
    ns.go\n\n\r\n\x05\x06\0\x02d\x04\x12\x04\xff\r\x04F\n7\n\t\x06\0\x02d\
    \x04\xc2\xf3\x04\x08\x12\x04\xff\r\x04F\"$\x20needed\x20for\x20add_task_\
    annotations.go\n\n7\n\x04\x06\0\x02e\x12\x06\x83\x0e\x02\x90\x0e\x03\x1a\
    '\x20Delete\x20multiple\x20tasks\x20in\x20one\x20request.\n\n\r\n\x05\
    \x06\0\x02e\x01\x12\x04\x83\x0e\x06\x11\n\r\n\x05\x06\0\x02e\x02\x12\x04\
    \x83\x0e\x13%\n\r\n\x05\x06\0\x02e\x03\x12\x04\x83\x0e0P\n\x0f\n\x05\x06\
    \0\x02e\x04\x12\x06\x84\x0e\x04\x8b\x0e\x06\n\x13\n\t\x06\0\x02e\x04\xb0\
    \xca\xbc\"\x12\x06\x84\x0e\x04\x8b\x0e\x06\n\r\n\x05\x06\0\x02e\x04\x12\
    \x04\x8c\x0e\x047\n\x10\n\x08\x06\0\x02e\x04\xc3\xf3\x04\x12\x04\x8c\x0e\
    \x047\n\r\n\x05\x06\0\x02e\x04\x12\x04\x8d\x0e\x04@\n\x11\n\t\x06\0\x02e\
    \x04\xc2\xf3\x04\0\x12\x04\x8d\x0e\x04@\n\r\n\x05\x06\0\x02e\x04\x12\x04\
    \x8e\x0e\x04@\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x01\x12\x04\x8e\x0e\
    \x04@\n\r\n\x05\x06\0\x02e\x04\x12\x04\x8f\x0e\x04C\n\x11\n\t\x06\0\x02e\
    \x04\xc2\xf3\x04\x02\x12\x04\x8f\x0e\x04C\n\xce\x03\n\x04\x06\0\x02f\x12\
    \x06\xa4\x0e\x02\xb8\x0e\x03\x1a\xe1\x02\x20Add\x20a\x20list\x20of\x20Co\
    llectors\x20to\x20an\x20app.\n\x20In\x20the\x20handler\x20of\x20this\x20\
    endpoint\x20we\x20also\x20check\x20for\x20all\x20the\x20scopes\x20of\x20\
    the\x20\x20POST\x20/inputs\n\x20endpoint.\n\x20Those\x20current\x20scope\
    s\x20are\x20listed\x20here\x20as\x20a\x20hard\x20requirement.\n\x20They\
    \x20are\x20needed\x20when\x20adding\x20the\x20collectors\x20just\x20so\
    \x20we\x20now\x20that\x20you\x20have\x20permission\x20with\n\x20that\x20\
    key\x20at\x20least\x20to\x20do\x20the\x20writing\x20to\x20this\x20app\
    \x20with\x20POST\x20/inputs.\n2Z//////////////////////////////////////\n\
    \x20Collectors\n//////////////////////////////////////\n\n\r\n\x05\x06\0\
    \x02f\x01\x12\x04\xa4\x0e\x06\x14\n\r\n\x05\x06\0\x02f\x02\x12\x04\xa4\
    \x0e\x16+\n\r\n\x05\x06\0\x02f\x03\x12\x04\xa4\x0e6L\n\x0f\n\x05\x06\0\
    \x02f\x04\x12\x06\xa5\x0e\x04\xac\x0e\x06\n\x13\n\t\x06\0\x02f\x04\xb0\
    \xca\xbc\"\x12\x06\xa5\x0e\x04\xac\x0e\x06\n\r\n\x05\x06\0\x02f\x04\x12\
    \x04\xad\x0e\x047\n\x10\n\x08\x06\0\x02f\x04\xc3\xf3\x04\x12\x04\xad\x0e\
    \x047\n\r\n\x05\x06\0\x02f\x04\x12\x04\xae\x0e\x04A\n\x11\n\t\x06\0\x02f\
    \x04\xc2\xf3\x04\0\x12\x04\xae\x0e\x04A\n\r\n\x05\x06\0\x02f\x04\x12\x04\
    \xaf\x0e\x04F\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x01\x12\x04\xaf\x0e\
    \x04F\n\r\n\x05\x06\0\x02f\x04\x12\x04\xb0\x0e\x04F\n\x11\n\t\x06\0\x02f\
    \x04\xc2\xf3\x04\x02\x12\x04\xb0\x0e\x04F\n\r\n\x05\x06\0\x02f\x04\x12\
    \x04\xb1\x0e\x04E\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x03\x12\x04\xb1\
    \x0e\x04E\n\r\n\x05\x06\0\x02f\x04\x12\x04\xb2\x0e\x04C\n\x11\n\t\x06\0\
    \x02f\x04\xc2\xf3\x04\x04\x12\x04\xb2\x0e\x04C\n\r\n\x05\x06\0\x02f\x04\
    \x12\x04\xb3\x0e\x04A\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x05\x12\x04\
    \xb3\x0e\x04A\n\r\n\x05\x06\0\x02f\x04\x12\x04\xb4\x0e\x04A\n\x11\n\t\
    \x06\0\x02f\x04\xc2\xf3\x04\x06\x12\x04\xb4\x0e\x04A\n\r\n\x05\x06\0\x02\
    f\x04\x12\x04\xb5\x0e\x04A\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x07\x12\
    \x04\xb5\x0e\x04A\n\r\n\x05\x06\0\x02f\x04\x12\x04\xb6\x0e\x04>\n\x11\n\
    \t\x06\0\x02f\x04\xc2\xf3\x04\x08\x12\x04\xb6\x0e\x04>\n\r\n\x05\x06\0\
    \x02f\x04\x12\x04\xb7\x0e\x04D\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\t\
    \x12\x04\xb7\x0e\x04D\n7\n\x04\x06\0\x02g\x12\x06\xbb\x0e\x02\xc4\x0e\
    \x03\x1a'\x20Get\x20a\x20specific\x20collector\x20from\x20an\x20app.\n\n\
    \r\n\x05\x06\0\x02g\x01\x12\x04\xbb\x0e\x06\x12\n\r\n\x05\x06\0\x02g\x02\
    \x12\x04\xbb\x0e\x14'\n\r\n\x05\x06\0\x02g\x03\x12\x04\xbb\x0e2I\n\x0f\n\
    \x05\x06\0\x02g\x04\x12\x06\xbc\x0e\x04\xc1\x0e\x06\n\x13\n\t\x06\0\x02g\
    \x04\xb0\xca\xbc\"\x12\x06\xbc\x0e\x04\xc1\x0e\x06\n\r\n\x05\x06\0\x02g\
    \x04\x12\x04\xc2\x0e\x047\n\x10\n\x08\x06\0\x02g\x04\xc3\xf3\x04\x12\x04\
    \xc2\x0e\x047\n\r\n\x05\x06\0\x02g\x04\x12\x04\xc3\x0e\x04E\n\x11\n\t\
    \x06\0\x02g\x04\xc2\xf3\x04\0\x12\x04\xc3\x0e\x04E\n*\n\x04\x06\0\x02h\
    \x12\x06\xc7\x0e\x02\xd0\x0e\x03\x1a\x1a\x20List\x20all\x20the\x20collec\
    tors.\n\n\r\n\x05\x06\0\x02h\x01\x12\x04\xc7\x0e\x06\x14\n\r\n\x05\x06\0\
    \x02h\x02\x12\x04\xc7\x0e\x16+\n\r\n\x05\x06\0\x02h\x03\x12\x04\xc7\x0e6\
    L\n\x0f\n\x05\x06\0\x02h\x04\x12\x06\xc8\x0e\x04\xcd\x0e\x06\n\x13\n\t\
    \x06\0\x02h\x04\xb0\xca\xbc\"\x12\x06\xc8\x0e\x04\xcd\x0e\x06\n\r\n\x05\
    \x06\0\x02h\x04\x12\x04\xce\x0e\x047\n\x10\n\x08\x06\0\x02h\x04\xc3\xf3\
    \x04\x12\x04\xce\x0e\x047\n\r\n\x05\x06\0\x02h\x04\x12\x04\xcf\x0e\x04E\
    \n\x11\n\t\x06\0\x02h\x04\xc2\xf3\x04\0\x12\x04\xcf\x0e\x04E\n/\n\x04\
    \x06\0\x02i\x12\x06\xd3\x0e\x02\xdf\x0e\x03\x1a\x1f\x20Patch\x20one\x20o\
    r\x20more\x20collectors.\n\n\r\n\x05\x06\0\x02i\x01\x12\x04\xd3\x0e\x06\
    \x15\n\r\n\x05\x06\0\x02i\x02\x12\x04\xd3\x0e\x17-\n\r\n\x05\x06\0\x02i\
    \x03\x12\x04\xd3\x0e8N\n\x0f\n\x05\x06\0\x02i\x04\x12\x06\xd4\x0e\x04\
    \xdb\x0e\x06\n\x13\n\t\x06\0\x02i\x04\xb0\xca\xbc\"\x12\x06\xd4\x0e\x04\
    \xdb\x0e\x06\n\r\n\x05\x06\0\x02i\x04\x12\x04\xdc\x0e\x047\n\x10\n\x08\
    \x06\0\x02i\x04\xc3\xf3\x04\x12\x04\xdc\x0e\x047\n\r\n\x05\x06\0\x02i\
    \x04\x12\x04\xdd\x0e\x04E\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\0\x12\x04\
    \xdd\x0e\x04E\n\r\n\x05\x06\0\x02i\x04\x12\x04\xde\x0e\x04E\n\x11\n\t\
    \x06\0\x02i\x04\xc2\xf3\x04\x01\x12\x04\xde\x0e\x04E\n\x8f\x01\n\x04\x06\
    \0\x02j\x12\x06\xe5\x0e\x02\xf2\x0e\x03\x1a\x7f\x20Delete\x20multiple\
    \x20collectors\x20in\x20one\x20request.\n\x20This\x20call\x20is\x20async\
    hronous.\x20Use\x20DeleteCollector\x20if\x20you\x20want\x20a\x20synchron\
    ous\x20version.\n\n\r\n\x05\x06\0\x02j\x01\x12\x04\xe5\x0e\x06\x16\n\r\n\
    \x05\x06\0\x02j\x02\x12\x04\xe5\x0e\x18/\n\r\n\x05\x06\0\x02j\x03\x12\
    \x04\xe5\x0e:Z\n\x0f\n\x05\x06\0\x02j\x04\x12\x06\xe6\x0e\x04\xed\x0e\
    \x06\n\x13\n\t\x06\0\x02j\x04\xb0\xca\xbc\"\x12\x06\xe6\x0e\x04\xed\x0e\
    \x06\n\r\n\x05\x06\0\x02j\x04\x12\x04\xee\x0e\x047\n\x10\n\x08\x06\0\x02\
    j\x04\xc3\xf3\x04\x12\x04\xee\x0e\x047\n\r\n\x05\x06\0\x02j\x04\x12\x04\
    \xef\x0e\x04E\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\0\x12\x04\xef\x0e\x04\
    E\n\r\n\x05\x06\0\x02j\x04\x12\x04\xf0\x0e\x04H\n\x11\n\t\x06\0\x02j\x04\
    \xc2\xf3\x04\x01\x12\x04\xf0\x0e\x04H\n\r\n\x05\x06\0\x02j\x04\x12\x04\
    \xf1\x0e\x04E\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\x02\x12\x04\xf1\x0e\
    \x04E\n\xcc\x01\n\x04\x06\0\x02k\x12\x06\xf9\x0e\x02\x83\x0f\x032\xbb\
    \x01////////////////////////////////////////////////////////////////////\
    //////////\n\x20Stats\x20Collection\x20Endpoints.\n/////////////////////\
    /////////////////////////////////////////////////////////\n\n\r\n\x05\
    \x06\0\x02k\x01\x12\x04\xf9\x0e\x06\x14\n\r\n\x05\x06\0\x02k\x02\x12\x04\
    \xf9\x0e\x16+\n\r\n\x05\x06\0\x02k\x03\x12\x04\xf9\x0e6L\n\x0f\n\x05\x06\
    \0\x02k\x04\x12\x06\xfa\x0e\x04\x81\x0f\x06\n\x13\n\t\x06\0\x02k\x04\xb0\
    \xca\xbc\"\x12\x06\xfa\x0e\x04\x81\x0f\x06\n\r\n\x05\x06\0\x02k\x04\x12\
    \x04\x82\x0f\x047\n\x10\n\x08\x06\0\x02k\x04\xc3\xf3\x04\x12\x04\x82\x0f\
    \x047\n\x0e\n\x04\x06\0\x02l\x12\x06\x87\x0f\x02\x91\x0f\x03\n\r\n\x05\
    \x06\0\x02l\x01\x12\x04\x87\x0f\x06\x1d\n\r\n\x05\x06\0\x02l\x02\x12\x04\
    \x87\x0f\x1f=\n\r\n\x05\x06\0\x02l\x03\x12\x04\x87\x0fHg\n\x0f\n\x05\x06\
    \0\x02l\x04\x12\x06\x88\x0f\x04\x8f\x0f\x06\n\x13\n\t\x06\0\x02l\x04\xb0\
    \xca\xbc\"\x12\x06\x88\x0f\x04\x8f\x0f\x06\n\r\n\x05\x06\0\x02l\x04\x12\
    \x04\x90\x0f\x047\n\x10\n\x08\x06\0\x02l\x04\xc3\xf3\x04\x12\x04\x90\x0f\
    \x047\n-\n\x02\x04\0\x12\x06\xa3\x0f\0\xa8\x0f\x01\x1a\x1f\x20Split\x20t\
    he\x20results\x20into\x20pages.\n\n\x0b\n\x03\x04\0\x01\x12\x04\xa3\x0f\
    \x08\x12\n}\n\x04\x04\0\x02\0\x12\x04\xa5\x0f\x02\x12\x1ao\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\x20Defaults\x20t\
    o\x201.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xa5\x0f\x02\x08\n\r\n\x05\
    \x04\0\x02\0\x01\x12\x04\xa5\x0f\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\
    \xa5\x0f\x10\x11\nt\n\x04\x04\0\x02\x01\x12\x04\xa7\x0f\x02\x16\x1af\x20\
    (optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\x20to\x20\
    128.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\xa7\x0f\x02\x08\n\r\n\x05\x04\
    \0\x02\x01\x01\x12\x04\xa7\x0f\t\x11\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\
    \xa7\x0f\x14\x15\n\xed\x01\n\x02\x04\x01\x12\x06\xaf\x0f\0\xb3\x0f\x01\
    \x1a\xde\x01////////////////////////////////////////////////////////////\
    //////////////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/cla\
    rifai/api/annotation.proto\n////////////////////////////////////////////\
    //////////////////////////////////\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xaf\
    \x0f\x08\x1c\n\x0c\n\x04\x04\x01\x02\0\x12\x04\xb0\x0f\x02,\n\r\n\x05\
    \x04\x01\x02\0\x06\x12\x04\xb0\x0f\x02\x1b\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xb0\x0f\x1c'\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xb0\x0f*+\n\
    \x0c\n\x04\x04\x01\x02\x01\x12\x04\xb1\x0f\x02\x1b\n\r\n\x05\x04\x01\x02\
    \x01\x05\x12\x04\xb1\x0f\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\
    \xb1\x0f\t\x16\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xb1\x0f\x19\x1a\n\
    \x0c\n\x04\x04\x01\x02\x02\x12\x04\xb2\x0f\x02\x16\n\r\n\x05\x04\x01\x02\
    \x02\x05\x12\x04\xb2\x0f\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\
    \xb2\x0f\t\x11\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xb2\x0f\x14\x15\n\
    \x0c\n\x02\x04\x02\x12\x06\xb5\x0f\0\xe3\x0f\x01\n\x0b\n\x03\x04\x02\x01\
    \x12\x04\xb5\x0f\x08\x1e\n\x0b\n\x03\x04\x02\t\x12\x04\xb6\x0f\x02\r\n\
    \x0c\n\x04\x04\x02\t\0\x12\x04\xb6\x0f\x0b\x0c\n\r\n\x05\x04\x02\t\0\x01\
    \x12\x04\xb6\x0f\x0b\x0c\n\r\n\x05\x04\x02\t\0\x02\x12\x04\xb6\x0f\x0b\
    \x0c\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xb8\x0f\x02,\n\r\n\x05\x04\x02\
    \x02\0\x06\x12\x04\xb8\x0f\x02\x1b\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\
    \xb8\x0f\x1c'\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xb8\x0f*+\n.\n\x04\x04\
    \x02\x02\x01\x12\x04\xbb\x0f\x02\x1a\x1a\x20\x20List\x20annotations\x20f\
    or\x20these\x20IDs\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\xbb\x0f\x02\n\
    \n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xbb\x0f\x0b\x11\n\r\n\x05\x04\x02\
    \x02\x01\x01\x12\x04\xbb\x0f\x12\x15\n\r\n\x05\x04\x02\x02\x01\x03\x12\
    \x04\xbb\x0f\x18\x19\n\xd5\x02\n\x04\x04\x02\x02\x02\x12\x04\xc2\x0f\x02\
    \x20\x1a\xc6\x02\x20List\x20annotations\x20for\x20these\x20Input\x20IDs\
    \n\x20Note\x20that\x20'ids'\x20are\x20optional\x20but\x20if\x20the\x20ar\
    e\x20provided\x20the\x20number\x20and\x20order\x20in\n\x20'ids'\x20and\
    \x20'input_ids'\x20should\x20match\n\x20If\x20you\x20do\x20not\x20specif\
    y\x20'ids'\x20all\x20the\x20annotations\x20for\x20'input_ids'\x20are\x20\
    returned\n\x20If\x20a\x20you\x20do\x20not\x20specify\x20both\x20'input_i\
    ds'\x20and\x20'ids'\x20all\x20the\x20annotations\x20in\x20the\x20app\x20\
    are\x20returned\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\xc2\x0f\x02\n\n\
    \r\n\x05\x04\x02\x02\x02\x05\x12\x04\xc2\x0f\x0b\x11\n\r\n\x05\x04\x02\
    \x02\x02\x01\x12\x04\xc2\x0f\x12\x1b\n\r\n\x05\x04\x02\x02\x02\x03\x12\
    \x04\xc2\x0f\x1e\x1f\n\xe6\x03\n\x04\x04\x02\x02\x03\x12\x04\xca\x0f\x02\
    \x1f\x1a\xd7\x03\x20Only\x20return\x20the\x20annotations\x20that\x20has\
    \x20one\x20of\x20these\x20user\x20IDs,\x20effectively\x20operating\x20as\
    \x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20the\x20result\
    s.\n\x20If\x20model_version_ids\x20are\x20also\x20provided\x20these\x20u\
    ser_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20since\n\x20annot\
    ations\x20are\x20either\x20provided\x20by\x20users\x20or\x20model\x20ver\
    sions\x20and\x20we\x20want\x20the\x20union\x20of\x20any\n\x20provided\
    \x20user\x20or\x20model\x20version\x20annotations\x20in\x20the\x20result\
    s\x20of\x20ListAnnotations\x20request.\n\x20If\x20no\x20user_ids\x20are\
    \x20provided\x20then\x20annotations\x20from\x20all\x20users\x20are\x20re\
    turned.\n\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\xca\x0f\x02\n\n\r\n\x05\
    \x04\x02\x02\x03\x05\x12\x04\xca\x0f\x0b\x11\n\r\n\x05\x04\x02\x02\x03\
    \x01\x12\x04\xca\x0f\x12\x1a\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xca\
    \x0f\x1d\x1e\n\x82\x04\n\x04\x04\x02\x02\x04\x12\x04\xd2\x0f\x02)\x1a\
    \xf3\x03\x20Only\x20return\x20the\x20annotations\x20that\x20has\x20one\
    \x20of\x20these\x20model\x20version\x20IDs,\x20effectively\x20operating\
    \x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20the\x20\
    results.\n\x20If\x20user_ids\x20are\x20also\x20provided\x20these\x20mode\
    l_versions_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20since\n\
    \x20annotations\x20are\x20either\x20provided\x20by\x20users\x20or\x20mod\
    el\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\x20any\n\x20pr\
    ovided\x20user\x20or\x20model\x20version\x20annotations\x20in\x20the\x20\
    results\x20of\x20ListAnnotations\x20request.\n\x20If\x20no\x20model_vers\
    ion_ids\x20are\x20provided\x20then\x20annotations\x20from\x20all\x20mode\
    l\x20versions\x20are\x20returned.\n\n\r\n\x05\x04\x02\x02\x04\x04\x12\
    \x04\xd2\x0f\x02\n\n\r\n\x05\x04\x02\x02\x04\x05\x12\x04\xd2\x0f\x0b\x11\
    \n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xd2\x0f\x12#\n\r\n\x05\x04\x02\
    \x02\x04\x03\x12\x04\xd2\x0f&(\n\x8b\x01\n\x04\x04\x02\x02\x05\x12\x04\
    \xd6\x0f\x023\x1a}\x20Set\x20status\x20to\x20filter\x20by\x20a\x20list\
    \x20of\x20statuses\n\x20If\x20not\x20statuses\x20are\x20provided\x20then\
    \x20annotations\x20with\x20any\x20status\x20will\x20be\x20returned.\n\n\
    \r\n\x05\x04\x02\x02\x05\x04\x12\x04\xd6\x0f\x02\n\n\r\n\x05\x04\x02\x02\
    \x05\x06\x12\x04\xd6\x0f\x0b%\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\xd6\
    \x0f&.\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xd6\x0f12\n\x80\x01\n\x04\
    \x04\x02\x02\x06\x12\x04\xda\x0f\x02\x20\x1ar\x20Set\x20this\x20flag\x20\
    to\x20list\x20both\x20trusted\x20and\x20not\x20trusted\x20annotations\n\
    \x20by\x20default\x20it's\x20listing\x20only\x20trusted\x20annotations\n\
    \n\r\n\x05\x04\x02\x02\x06\x05\x12\x04\xda\x0f\x02\x06\n\r\n\x05\x04\x02\
    \x02\x06\x01\x12\x04\xda\x0f\x07\x1b\n\r\n\x05\x04\x02\x02\x06\x03\x12\
    \x04\xda\x0f\x1e\x1f\n~\n\x04\x04\x02\x02\x07\x12\x04\xdd\x0f\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x02\x02\x07\x05\x12\x04\xdd\
    \x0f\x02\x08\n\r\n\x05\x04\x02\x02\x07\x01\x12\x04\xdd\x0f\t\r\n\r\n\x05\
    \x04\x02\x02\x07\x03\x12\x04\xdd\x0f\x10\x11\nu\n\x04\x04\x02\x02\x08\
    \x12\x04\xe0\x0f\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x02\x02\x08\
    \x05\x12\x04\xe0\x0f\x02\x08\n\r\n\x05\x04\x02\x02\x08\x01\x12\x04\xe0\
    \x0f\t\x11\n\r\n\x05\x04\x02\x02\x08\x03\x12\x04\xe0\x0f\x14\x15\n5\n\
    \x04\x04\x02\x02\t\x12\x04\xe2\x0f\x02\x16\x1a'\x20Flag\x20to\x20filter\
    \x20annotations\x20by\x20task_id\n\n\r\n\x05\x04\x02\x02\t\x05\x12\x04\
    \xe2\x0f\x02\x08\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\xe2\x0f\t\x10\n\r\n\
    \x05\x04\x02\x02\t\x03\x12\x04\xe2\x0f\x13\x15\n\x0c\n\x02\x04\x03\x12\
    \x06\xe5\x0f\0\xea\x0f\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xe5\x0f\x08\
    \x1e\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xe7\x0f\x02,\n\r\n\x05\x04\x03\
    \x02\0\x06\x12\x04\xe7\x0f\x02\x1b\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\
    \xe7\x0f\x1c'\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xe7\x0f*+\n\x0c\n\x04\
    \x04\x03\x02\x01\x12\x04\xe9\x0f\x02&\n\r\n\x05\x04\x03\x02\x01\x04\x12\
    \x04\xe9\x0f\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xe9\x0f\x0b\x15\
    \n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xe9\x0f\x16!\n\r\n\x05\x04\x03\
    \x02\x01\x03\x12\x04\xe9\x0f$%\n\x0c\n\x02\x04\x04\x12\x06\xec\x0f\0\xf4\
    \x0f\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xec\x0f\x08\x1f\n\x0c\n\x04\x04\
    \x04\x02\0\x12\x04\xed\x0f\x02,\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xed\
    \x0f\x02\x1b\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xed\x0f\x1c'\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\xed\x0f*+\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\
    \xef\x0f\x02&\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xef\x0f\x02\n\n\r\n\
    \x05\x04\x04\x02\x01\x06\x12\x04\xef\x0f\x0b\x15\n\r\n\x05\x04\x04\x02\
    \x01\x01\x12\x04\xef\x0f\x16!\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xef\
    \x0f$%\n~\n\x04\x04\x04\x02\x02\x12\x04\xf3\x0f\x02\x14\x1ap\x20The\x20a\
    ction\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20no\
    w\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20su\
    pported\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xf3\x0f\x02\x08\n\r\n\
    \x05\x04\x04\x02\x02\x01\x12\x04\xf3\x0f\t\x0f\n\r\n\x05\x04\x04\x02\x02\
    \x03\x12\x04\xf3\x0f\x12\x13\n\x0c\n\x02\x04\x05\x12\x06\xf6\x0f\0\xff\
    \x0f\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xf6\x0f\x08%\n\x0c\n\x04\x04\
    \x05\x02\0\x12\x04\xf7\x0f\x02,\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xf7\
    \x0f\x02\x1b\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xf7\x0f\x1c'\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xf7\x0f*+\n&\n\x04\x04\x05\x02\x01\x12\x04\
    \xf9\x0f\x021\x1a\x18\x20Annotation\x20Status\x20code\n\n\r\n\x05\x04\
    \x05\x02\x01\x06\x12\x04\xf9\x0f\x02\x20\n\r\n\x05\x04\x05\x02\x01\x01\
    \x12\x04\xf9\x0f!,\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xf9\x0f/0\n\x0c\
    \n\x04\x04\x05\x02\x02\x12\x04\xfa\x0f\x02\x1f\n\r\n\x05\x04\x05\x02\x02\
    \x04\x12\x04\xfa\x0f\x02\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xfa\x0f\
    \x0b\x11\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xfa\x0f\x12\x1a\n\r\n\x05\
    \x04\x05\x02\x02\x03\x12\x04\xfa\x0f\x1d\x1e\n\x0c\n\x04\x04\x05\x02\x03\
    \x12\x04\xfb\x0f\x02\x15\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\xfb\x0f\
    \x02\x08\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xfb\x0f\t\x10\n\r\n\x05\
    \x04\x05\x02\x03\x03\x12\x04\xfb\x0f\x13\x14\n(\n\x04\x04\x05\x02\x04\
    \x12\x04\xfd\x0f\x02\x14\x1a\x1a\x20'overwrite'\x20is\x20supported\n\n\r\
    \n\x05\x04\x05\x02\x04\x05\x12\x04\xfd\x0f\x02\x08\n\r\n\x05\x04\x05\x02\
    \x04\x01\x12\x04\xfd\x0f\t\x0f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\xfd\
    \x0f\x12\x13\n\x0c\n\x02\x04\x06\x12\x06\x81\x10\0\x85\x10\x01\n\x0b\n\
    \x03\x04\x06\x01\x12\x04\x81\x10\x08&\n\x0c\n\x04\x04\x06\x02\0\x12\x04\
    \x82\x10\x02(\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\x82\x10\x02\x1c\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\x82\x10\x1d#\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\x82\x10&'\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x83\x10\x02\x1f\n\
    \r\n\x05\x04\x06\x02\x01\x04\x12\x04\x83\x10\x02\n\n\r\n\x05\x04\x06\x02\
    \x01\x05\x12\x04\x83\x10\x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\
    \x83\x10\x12\x1a\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x83\x10\x1d\x1e\n\
    \x0c\n\x04\x04\x06\x02\x02\x12\x04\x84\x10\x02\x1b\n\r\n\x05\x04\x06\x02\
    \x02\x05\x12\x04\x84\x10\x02\x08\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \x84\x10\t\x16\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x84\x10\x19\x1a\n\
    \x0c\n\x02\x04\x07\x12\x06\x87\x10\0\x8d\x10\x01\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\x87\x10\x08\x1f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x88\x10\x02,\
    \n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x88\x10\x02\x1b\n\r\n\x05\x04\x07\
    \x02\0\x01\x12\x04\x88\x10\x1c'\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x88\
    \x10*+\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\x8a\x10\x02\x16\n\r\n\x05\x04\
    \x07\x02\x01\x05\x12\x04\x8a\x10\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\
    \x12\x04\x8a\x10\t\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x8a\x10\x14\
    \x15\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\x8c\x10\x02\x1b\n\r\n\x05\x04\
    \x07\x02\x02\x05\x12\x04\x8c\x10\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\
    \x12\x04\x8c\x10\t\x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x8c\x10\x19\
    \x1a\nD\n\x02\x04\x08\x12\x06\x90\x10\0\x9d\x10\x01\x1a6\x20Request\x20t\
    o\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\x90\x10\x08\x20\n\x0c\n\x04\x04\x08\x02\0\
    \x12\x04\x91\x10\x02,\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\x91\x10\x02\
    \x1b\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x91\x10\x1c'\n\r\n\x05\x04\x08\
    \x02\0\x03\x12\x04\x91\x10*+\n+\n\x04\x04\x08\x02\x01\x12\x04\x94\x10\
    \x02\x1a\x1a\x1d\x20Delete\x20annotations\x20with\x20IDs\n\n\r\n\x05\x04\
    \x08\x02\x01\x04\x12\x04\x94\x10\x02\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\
    \x04\x94\x10\x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x94\x10\x12\
    \x15\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x94\x10\x18\x19\n\xf0\x02\n\
    \x04\x04\x08\x02\x02\x12\x04\x9c\x10\x02\x20\x1a\xe1\x02\x20Delete\x20an\
    notations\x20for\x20these\x20Input\x20IDs\n\x20Note\x20that\x20'ids'\x20\
    are\x20optional\x20but\x20if\x20the\x20are\x20provided\x20the\x20number\
    \x20and\x20order\x20in\n\x20'ids'\x20and\x20'input_ids'\x20should\x20mat\
    ch\n\x20If\x20you\x20do\x20not\x20specifiy\x20'ids'\x20all\x20the\x20ann\
    otations\x20for\x20'input_ids'\x20are\x20deleted\n\x20However\x20you\x20\
    need\x20to\x20specify\x20at\x20least\x20one\x20value\x20for\x20'input_id\
    s'\n\x20i.e.\x20this\x20API\x20does\x20not\x20support\x20deleting\x20all\
    \x20annotations\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x9c\x10\x02\n\n\
    \r\n\x05\x04\x08\x02\x02\x05\x12\x04\x9c\x10\x0b\x11\n\r\n\x05\x04\x08\
    \x02\x02\x01\x12\x04\x9c\x10\x12\x1b\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\x9c\x10\x1e\x1f\n\x0c\n\x02\x04\t\x12\x06\x9f\x10\0\xa2\x10\x01\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x9f\x10\x08\x20\n\x0c\n\x04\x04\t\x02\0\x12\
    \x04\xa0\x10\x02(\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xa0\x10\x02\x1c\n\r\
    \n\x05\x04\t\x02\0\x01\x12\x04\xa0\x10\x1d#\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xa0\x10&'\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xa1\x10\x02\x1c\n\r\
    \n\x05\x04\t\x02\x01\x06\x12\x04\xa1\x10\x02\x0c\n\r\n\x05\x04\t\x02\x01\
    \x01\x12\x04\xa1\x10\r\x17\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xa1\x10\
    \x1a\x1b\n\x0c\n\x02\x04\n\x12\x06\xa4\x10\0\xa8\x10\x01\n\x0b\n\x03\x04\
    \n\x01\x12\x04\xa4\x10\x08\x1f\n\x0c\n\x04\x04\n\x02\0\x12\x04\xa5\x10\
    \x02(\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xa5\x10\x02\x1c\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\xa5\x10\x1d#\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xa5\
    \x10&'\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xa7\x10\x02U\n\r\n\x05\x04\n\
    \x02\x01\x04\x12\x04\xa7\x10\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\
    \xa7\x10\x0b\x15\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xa7\x10\x16!\n\r\n\
    \x05\x04\n\x02\x01\x03\x12\x04\xa7\x10$%\n\r\n\x05\x04\n\x02\x01\x08\x12\
    \x04\xa7\x10&T\n\x10\n\x08\x04\n\x02\x01\x08\xd0\x86\x03\x12\x04\xa7\x10\
    'S\n\xb7\x02\n\x02\x04\x0b\x12\x06\xb0\x10\0\xb2\x10\x01\x1a\xd7\x01////\
    ////////////////////////////////////////////////////////////////////////\
    //\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clarifai/api/app.pr\
    oto\n///////////////////////////////////////////////////////////////////\
    ///////////\n2O/////////////////////////////////////////////////////////\
    /////////////////////\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb0\x10\x08\x15\
    \n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xb1\x10\x02,\n\r\n\x05\x04\x0b\x02\0\
    \x06\x12\x04\xb1\x10\x02\x1b\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xb1\x10\
    \x1c'\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb1\x10*+\n\x0c\n\x02\x04\x0c\
    \x12\x06\xb4\x10\0\xbc\x10\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xb4\x10\
    \x08\x17\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xb5\x10\x02,\n\r\n\x05\x04\
    \x0c\x02\0\x06\x12\x04\xb5\x10\x02\x1b\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\xb5\x10\x1c'\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xb5\x10*+\n~\n\x04\
    \x04\x0c\x02\x01\x12\x04\xb8\x10\x02\x12\x1ap\x20(optional\x20URL\x20par\
    ameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20s\
    plit\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xb8\x10\x02\x08\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\xb8\x10\t\r\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \xb8\x10\x10\x11\nu\n\x04\x04\x0c\x02\x02\x12\x04\xbb\x10\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xbb\x10\x02\x08\n\r\n\
    \x05\x04\x0c\x02\x02\x01\x12\x04\xbb\x10\t\x11\n\r\n\x05\x04\x0c\x02\x02\
    \x03\x12\x04\xbb\x10\x14\x15\n\x0c\n\x02\x04\r\x12\x06\xbe\x10\0\xc1\x10\
    \x01\n\x0b\n\x03\x04\r\x01\x12\x04\xbe\x10\x08\x17\n\x0c\n\x04\x04\r\x02\
    \0\x12\x04\xbf\x10\x02,\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xbf\x10\x02\
    \x1b\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xbf\x10\x1c'\n\r\n\x05\x04\r\x02\
    \0\x03\x12\x04\xbf\x10*+\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc0\x10\x02\
    \x18\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xc0\x10\x02\n\n\r\n\x05\x04\r\
    \x02\x01\x06\x12\x04\xc0\x10\x0b\x0e\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \xc0\x10\x0f\x13\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc0\x10\x16\x17\n\
    \x0c\n\x02\x04\x0e\x12\x06\xc3\x10\0\xc5\x10\x01\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xc3\x10\x08\x18\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xc4\x10\x02,\
    \n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xc4\x10\x02\x1b\n\r\n\x05\x04\x0e\
    \x02\0\x01\x12\x04\xc4\x10\x1c'\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xc4\
    \x10*+\n\x0c\n\x02\x04\x0f\x12\x06\xc7\x10\0\xd4\x10\x01\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xc7\x10\x08\x18\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xc8\
    \x10\x02,\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xc8\x10\x02\x1b\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\xc8\x10\x1c'\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xc8\x10*+\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xc9\x10\x02\x18\n\r\n\
    \x05\x04\x0f\x02\x01\x04\x12\x04\xc9\x10\x02\n\n\r\n\x05\x04\x0f\x02\x01\
    \x06\x12\x04\xc9\x10\x0b\x0e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xc9\
    \x10\x0f\x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xc9\x10\x16\x17\n\x82\
    \x01\n\x04\x04\x0f\x02\x02\x12\x04\xcd\x10\x02\x14\x1at\x20The\x20action\
    \x20to\x20perform\x20on\x20the\x20patched\x20App\x20objects\x20except\
    \x20App.Metadata\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\
    \x20supported\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xcd\x10\x02\x08\n\
    \r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xcd\x10\t\x0f\n\r\n\x05\x04\x0f\x02\
    \x02\x03\x12\x04\xcd\x10\x12\x13\nA\n\x04\x04\x0f\x02\x03\x12\x04\xd0\
    \x10\x02/\x1a3\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\
    \x20App.Metadata\n\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\xd0\x10\x02\x1a\
    \n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xd0\x10\x1b*\n\r\n\x05\x04\x0f\
    \x02\x03\x03\x12\x04\xd0\x10-.\na\n\x04\x04\x0f\x02\x04\x12\x04\xd3\x10\
    \x02\x13\x1aS\x20If\x20set,\x20the\x20app\x20will\x20be\x20automatically\
    \x20reindexed\x20upon\x20change\x20of\x20its\x20base\x20workflow.\n\n\r\
    \n\x05\x04\x0f\x02\x04\x05\x12\x04\xd3\x10\x02\x06\n\r\n\x05\x04\x0f\x02\
    \x04\x01\x12\x04\xd3\x10\x07\x0e\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\
    \xd3\x10\x11\x12\n7\n\x02\x04\x10\x12\x06\xd7\x10\0\xde\x10\x01\x1a)\x20\
    Search\x20over\x20the\x20available\x20applications.\n\n\x0b\n\x03\x04\
    \x10\x01\x12\x04\xd7\x10\x08\x1f\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xd8\
    \x10\x02,\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xd8\x10\x02\x1b\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xd8\x10\x1c'\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xd8\x10*+\n(\n\x04\x04\x10\x02\x01\x12\x04\xda\x10\x02\x19\x1a\x1a\
    \x20The\x20body\x20of\x20the\x20request.\n\n\r\n\x05\x04\x10\x02\x01\x06\
    \x12\x04\xda\x10\x02\n\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xda\x10\x0b\
    \x14\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xda\x10\x17\x18\n]\n\x04\x04\
    \x10\x02\x02\x12\x04\xdd\x10\x02\x1c\x1aO\x20Pagination\x20parameters\
    \x20here\x20since\x20there\x20are\x20no\x20url\x20args\x20in\x20this\n\
    \x20POST\x20request.\n\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xdd\x10\x02\
    \x0c\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xdd\x10\r\x17\n\r\n\x05\x04\
    \x10\x02\x02\x03\x12\x04\xdd\x10\x1a\x1b\n\x0c\n\x02\x04\x11\x12\x06\xe0\
    \x10\0\xe3\x10\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xe0\x10\x08\x19\n\x0c\
    \n\x04\x04\x11\x02\0\x12\x04\xe1\x10\x02(\n\r\n\x05\x04\x11\x02\0\x06\
    \x12\x04\xe1\x10\x02\x1c\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe1\x10\x1d\
    #\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xe1\x10&'\n\x0c\n\x04\x04\x11\x02\
    \x01\x12\x04\xe2\x10\x02\x0e\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xe2\
    \x10\x02\x05\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe2\x10\x06\t\n\r\n\
    \x05\x04\x11\x02\x01\x03\x12\x04\xe2\x10\x0c\r\n\x0c\n\x02\x04\x12\x12\
    \x06\xe5\x10\0\xe8\x10\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xe5\x10\x08\
    \x18\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xe6\x10\x02(\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xe6\x10\x02\x1c\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xe6\x10\x1d#\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe6\x10&'\n\x0c\n\x04\
    \x04\x12\x02\x01\x12\x04\xe7\x10\x02G\n\r\n\x05\x04\x12\x02\x01\x04\x12\
    \x04\xe7\x10\x02\n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xe7\x10\x0b\x0e\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xe7\x10\x0f\x13\n\r\n\x05\x04\x12\
    \x02\x01\x03\x12\x04\xe7\x10\x16\x17\n\r\n\x05\x04\x12\x02\x01\x08\x12\
    \x04\xe7\x10\x18F\n\x10\n\x08\x04\x12\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xe7\x10\x19E\n\xbf\x02\n\x02\x04\x13\x12\x06\xf4\x10\0\xf9\x10\x01\x1a\
    \xdf\x01////////////////////////////////////////////////////////////////\
    //////////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clarifa\
    i/api/app_sharing.proto\n///////////////////////////////////////////////\
    ///////////////////////////////\n2O/////////////////////////////////////\
    /////////////////////////////////////////\n\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xf4\x10\x08\x20\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xf5\x10\x02,\n\r\
    \n\x05\x04\x13\x02\0\x06\x12\x04\xf5\x10\x02\x1b\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xf5\x10\x1c'\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf5\x10*+\
    \n\x88\x01\n\x04\x04\x13\x02\x01\x12\x04\xf8\x10\x02\"\x1az\x20Set\x20th\
    is\x20flag\x20to\x20list\x20both\x20deleted\x20and\x20not\x20deleted\x20\
    collaborators\n\x20by\x20default\x20it's\x20listing\x20only\x20not\x20de\
    leted\x20collaborators\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xf8\x10\
    \x02\x06\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xf8\x10\x07\x1d\n\r\n\x05\
    \x04\x13\x02\x01\x03\x12\x04\xf8\x10\x20!\n\x0c\n\x02\x04\x14\x12\x06\
    \xfb\x10\0\xfe\x10\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xfb\x10\x08\x20\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\xfc\x10\x02,\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\xfc\x10\x02\x1b\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xfc\x10\
    \x1c'\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xfc\x10*+\n\x0c\n\x04\x04\x14\
    \x02\x01\x12\x04\xfd\x10\x02*\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xfd\
    \x10\x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xfd\x10\x0b\x17\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\xfd\x10\x18%\n\r\n\x05\x04\x14\x02\x01\
    \x03\x12\x04\xfd\x10()\n\x0c\n\x02\x04\x15\x12\x06\x80\x11\0\x87\x11\x01\
    \n\x0b\n\x03\x04\x15\x01\x12\x04\x80\x11\x08!\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\x81\x11\x02,\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x81\x11\x02\
    \x1b\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x81\x11\x1c'\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\x81\x11*+\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x82\x11\
    \x02*\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\x82\x11\x02\n\n\r\n\x05\x04\
    \x15\x02\x01\x06\x12\x04\x82\x11\x0b\x17\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\x82\x11\x18%\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x82\x11()\nj\
    \n\x04\x04\x15\x02\x02\x12\x04\x86\x11\x02\x14\x1a\\\x20The\x20action\
    \x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20\
    only\x20action\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\x15\x02\
    \x02\x05\x12\x04\x86\x11\x02\x08\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\
    \x86\x11\t\x0f\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\x86\x11\x12\x13\n\
    \x0c\n\x02\x04\x16\x12\x06\x89\x11\0\x8d\x11\x01\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\x89\x11\x08\"\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x8a\x11\x02,\n\
    \r\n\x05\x04\x16\x02\0\x06\x12\x04\x8a\x11\x02\x1b\n\r\n\x05\x04\x16\x02\
    \0\x01\x12\x04\x8a\x11\x1c'\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x8a\x11*\
    +\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x8b\x11\x02'\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\x8b\x11\x02\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\x8b\
    \x11\x0b\x11\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x8b\x11\x12\"\n\r\n\
    \x05\x04\x16\x02\x01\x03\x12\x04\x8b\x11%&\n\x0c\n\x04\x04\x16\x02\x02\
    \x12\x04\x8c\x11\x02\"\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\x8c\x11\x02\
    \n\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\x8c\x11\x0b\x11\n\r\n\x05\x04\
    \x16\x02\x02\x01\x12\x04\x8c\x11\x12\x1d\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\x8c\x11\x20!\n\x0c\n\x02\x04\x17\x12\x06\x8f\x11\0\x92\x11\x01\
    \n\x0b\n\x03\x04\x17\x01\x12\x04\x8f\x11\x08\"\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\x90\x11\x02(\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\x90\x11\x02\
    \x1c\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x90\x11\x1d#\n\r\n\x05\x04\x17\
    \x02\0\x03\x12\x04\x90\x11&'\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x91\x11\
    \x02Y\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\x91\x11\x02\n\n\r\n\x05\x04\
    \x17\x02\x01\x06\x12\x04\x91\x11\x0b\x17\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\x91\x11\x18%\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x91\x11()\n\
    \r\n\x05\x04\x17\x02\x01\x08\x12\x04\x91\x11*X\n\x10\n\x08\x04\x17\x02\
    \x01\x08\xd0\x86\x03\x12\x04\x91\x11+W\n\x0c\n\x02\x04\x18\x12\x06\x94\
    \x11\0\x9c\x11\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x94\x11\x08!\n\x0c\n\
    \x04\x04\x18\x02\0\x12\x04\x95\x11\x02,\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\x95\x11\x02\x1b\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x95\x11\x1c'\n\
    \r\n\x05\x04\x18\x02\0\x03\x12\x04\x95\x11*+\n~\n\x04\x04\x18\x02\x01\
    \x12\x04\x98\x11\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    \x18\x02\x01\x05\x12\x04\x98\x11\x02\x08\n\r\n\x05\x04\x18\x02\x01\x01\
    \x12\x04\x98\x11\t\r\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x98\x11\x10\
    \x11\nu\n\x04\x04\x18\x02\x02\x12\x04\x9b\x11\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\x9b\x11\x02\x08\n\r\n\x05\x04\x18\
    \x02\x02\x01\x12\x04\x9b\x11\t\x11\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\
    \x9b\x11\x14\x15\n\x0c\n\x02\x04\x19\x12\x06\x9e\x11\0\xa1\x11\x01\n\x0b\
    \n\x03\x04\x19\x01\x12\x04\x9e\x11\x08#\n\x0c\n\x04\x04\x19\x02\0\x12\
    \x04\x9f\x11\x02(\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\x9f\x11\x02\x1c\n\
    \r\n\x05\x04\x19\x02\0\x01\x12\x04\x9f\x11\x1d#\n\r\n\x05\x04\x19\x02\0\
    \x03\x12\x04\x9f\x11&'\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xa0\x11\x02[\
    \n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xa0\x11\x02\n\n\r\n\x05\x04\x19\
    \x02\x01\x06\x12\x04\xa0\x11\x0b\x18\n\r\n\x05\x04\x19\x02\x01\x01\x12\
    \x04\xa0\x11\x19'\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xa0\x11*+\n\r\n\
    \x05\x04\x19\x02\x01\x08\x12\x04\xa0\x11,Z\n\x10\n\x08\x04\x19\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xa0\x11-Y\n\xe5\x04\n\x02\x04\x1a\x12\x06\xd6\
    \x11\0\xd8\x11\x01\x1a\xd8\x01//////////////////////////////////////////\
    ////////////////////////////////////\n\x20Requests\x20/\x20Responses\x20\
    from\x20/proto/clarifai/api/code.proto\n////////////////////////////////\
    //////////////////////////////////////////////\n2O//////////////////////\
    ////////////////////////////////////////////////////////\n2\xaa\x02/////\
    ////////////////////////////////////////////////////////////////////////\
    /\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clarifai/api/cluster\
    .proto\n////////////////////////////////////////////////////////////////\
    //////////////\n////////////////////////////////////////////////////////\
    //////////////////////\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd6\x11\x08\x1c\
    \n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xd7\x11\x02\x1c\n\r\n\x05\x04\x1a\x02\
    \0\x05\x12\x04\xd7\x11\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd7\
    \x11\t\x17\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd7\x11\x1a\x1b\n\x0c\n\
    \x02\x04\x1b\x12\x06\xda\x11\0\xdb\x11\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xda\x11\x08\x1e\n\x0c\n\x02\x04\x1c\x12\x06\xdd\x11\0\xe0\x11\x01\n\
    \x0b\n\x03\x04\x1c\x01\x12\x04\xdd\x11\x08\x20\n'\n\x04\x04\x1c\x02\0\
    \x12\x04\xdf\x11\x02(\x1a\x19\x20Status\x20of\x20this\x20request.\n\n\r\
    \n\x05\x04\x1c\x02\0\x06\x12\x04\xdf\x11\x02\x1c\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xdf\x11\x1d#\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xdf\x11&'\
    \n\x0c\n\x02\x04\x1d\x12\x06\xe2\x11\0\xe5\x11\x01\n\x0b\n\x03\x04\x1d\
    \x01\x12\x04\xe2\x11\x08\x1f\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xe3\x11\
    \x02(\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xe3\x11\x02\x1c\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\xe3\x11\x1d#\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\
    \xe3\x11&'\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xe4\x11\x023\n\r\n\x05\
    \x04\x1d\x02\x01\x04\x12\x04\xe4\x11\x02\n\n\r\n\x05\x04\x1d\x02\x01\x06\
    \x12\x04\xe4\x11\x0b%\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xe4\x11&.\n\
    \r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xe4\x1112\n\x92\x07\n\x02\x04\x1e\
    \x12\x06\x85\x12\0\x89\x12\x01\x1a\xdb\x01//////////////////////////////\
    ////////////////////////////////////////////////\n\x20Requests\x20/\x20R\
    esponses\x20from\x20/proto/clarifai/api/concept.proto\n/////////////////\
    /////////////////////////////////////////////////////////////\n2O///////\
    ///////////////////////////////////////////////////////////////////////\
    \n2\xa8\x02/////////////////////////////////////////////////////////////\
    /////////////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clar\
    ifai/api/color.proto\n//////////////////////////////////////////////////\
    ////////////////////////////\n//////////////////////////////////////////\
    ////////////////////////////////////\n2\xa9\x02/////////////////////////\
    /////////////////////////////////////////////////////\n\x20Requests\x20/\
    \x20Responses\x20from\x20/proto/clarifai/api/common.proto\n/////////////\
    /////////////////////////////////////////////////////////////////\n/////\
    ////////////////////////////////////////////////////////////////////////\
    /\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\x85\x12\x08\x19\n\x0c\n\x04\x04\x1e\
    \x02\0\x12\x04\x86\x12\x02,\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\x86\x12\
    \x02\x1b\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x86\x12\x1c'\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\x86\x12*+\n!\n\x04\x04\x1e\x02\x01\x12\x04\x88\
    \x12\x02\x18\x1a\x13\x20The\x20concept's\x20id.\n\n\r\n\x05\x04\x1e\x02\
    \x01\x05\x12\x04\x88\x12\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\
    \x88\x12\t\x13\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\x88\x12\x16\x17\n\
    \x0c\n\x02\x04\x1f\x12\x06\x8b\x12\0\x93\x12\x01\n\x0b\n\x03\x04\x1f\x01\
    \x12\x04\x8b\x12\x08\x1b\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x8c\x12\x02,\
    \n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\x8c\x12\x02\x1b\n\r\n\x05\x04\x1f\
    \x02\0\x01\x12\x04\x8c\x12\x1c'\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x8c\
    \x12*+\n~\n\x04\x04\x1f\x02\x01\x12\x04\x8f\x12\x02\x12\x1ap\x20(optiona\
    l\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20\
    used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\x8f\x12\x02\x08\n\r\
    \n\x05\x04\x1f\x02\x01\x01\x12\x04\x8f\x12\t\r\n\r\n\x05\x04\x1f\x02\x01\
    \x03\x12\x04\x8f\x12\x10\x11\nu\n\x04\x04\x1f\x02\x02\x12\x04\x92\x12\
    \x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\x92\
    \x12\x02\x08\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\x92\x12\t\x11\n\r\n\
    \x05\x04\x1f\x02\x02\x03\x12\x04\x92\x12\x14\x15\n\x0c\n\x02\x04\x20\x12\
    \x06\x95\x12\0\x9d\x12\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x95\x12\x08#\
    \n6\n\x04\x04\x20\x02\0\x12\x04\x97\x12\x02,\x1a(\x20Ids\x20present\x20i\
    n\x20the\x20url\x20of\x20the\x20request.\n\n\r\n\x05\x04\x20\x02\0\x06\
    \x12\x04\x97\x12\x02\x1b\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x97\x12\x1c\
    '\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x97\x12*+\n(\n\x04\x04\x20\x02\x01\
    \x12\x04\x99\x12\x02!\x1a\x1a\x20The\x20body\x20of\x20the\x20request.\n\
    \n\r\n\x05\x04\x20\x02\x01\x06\x12\x04\x99\x12\x02\x0e\n\r\n\x05\x04\x20\
    \x02\x01\x01\x12\x04\x99\x12\x0f\x1c\n\r\n\x05\x04\x20\x02\x01\x03\x12\
    \x04\x99\x12\x1f\x20\n]\n\x04\x04\x20\x02\x02\x12\x04\x9c\x12\x02\x1c\
    \x1aO\x20Pagination\x20parameters\x20here\x20since\x20there\x20are\x20no\
    \x20url\x20args\x20in\x20this\n\x20POST\x20request.\n\n\r\n\x05\x04\x20\
    \x02\x02\x06\x12\x04\x9c\x12\x02\x0c\n\r\n\x05\x04\x20\x02\x02\x01\x12\
    \x04\x9c\x12\r\x17\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x9c\x12\x1a\x1b\
    \n\x0c\n\x02\x04!\x12\x06\x9f\x12\0\xa3\x12\x01\n\x0b\n\x03\x04!\x01\x12\
    \x04\x9f\x12\x08\x1b\n\x0c\n\x04\x04!\x02\0\x12\x04\xa0\x12\x02,\n\r\n\
    \x05\x04!\x02\0\x06\x12\x04\xa0\x12\x02\x1b\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\xa0\x12\x1c'\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa0\x12*+\n$\n\x04\
    \x04!\x02\x01\x12\x04\xa2\x12\x02\x20\x1a\x16\x20The\x20concepts\x20to\
    \x20add.\n\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xa2\x12\x02\n\n\r\n\x05\
    \x04!\x02\x01\x06\x12\x04\xa2\x12\x0b\x12\n\r\n\x05\x04!\x02\x01\x01\x12\
    \x04\xa2\x12\x13\x1b\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xa2\x12\x1e\x1f\
    \n\x0c\n\x02\x04\"\x12\x06\xa5\x12\0\xad\x12\x01\n\x0b\n\x03\x04\"\x01\
    \x12\x04\xa5\x12\x08\x1c\n\x0c\n\x04\x04\"\x02\0\x12\x04\xa6\x12\x02,\n\
    \r\n\x05\x04\"\x02\0\x06\x12\x04\xa6\x12\x02\x1b\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\xa6\x12\x1c'\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xa6\x12*+\n&\
    \n\x04\x04\"\x02\x01\x12\x04\xa8\x12\x02\x20\x1a\x18\x20The\x20concepts\
    \x20to\x20patch.\n\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xa8\x12\x02\n\n\r\
    \n\x05\x04\"\x02\x01\x06\x12\x04\xa8\x12\x0b\x12\n\r\n\x05\x04\"\x02\x01\
    \x01\x12\x04\xa8\x12\x13\x1b\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xa8\x12\
    \x1e\x1f\ni\n\x04\x04\"\x02\x02\x12\x04\xac\x12\x02\x14\x1a[\x20The\x20a\
    ction\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20no\
    w\x20ony\x20action\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\"\
    \x02\x02\x05\x12\x04\xac\x12\x02\x08\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\
    \xac\x12\t\x0f\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xac\x12\x12\x13\n\x0c\
    \n\x02\x04#\x12\x06\xaf\x12\0\xb7\x12\x01\n\x0b\n\x03\x04#\x01\x12\x04\
    \xaf\x12\x08\x1f\n\x0c\n\x04\x04#\x02\0\x12\x04\xb0\x12\x02,\n\r\n\x05\
    \x04#\x02\0\x06\x12\x04\xb0\x12\x02\x1b\n\r\n\x05\x04#\x02\0\x01\x12\x04\
    \xb0\x12\x1c'\n\r\n\x05\x04#\x02\0\x03\x12\x04\xb0\x12*+\n~\n\x04\x04#\
    \x02\x01\x12\x04\xb3\x12\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\
    \x05\x04#\x02\x01\x05\x12\x04\xb3\x12\x02\x08\n\r\n\x05\x04#\x02\x01\x01\
    \x12\x04\xb3\x12\t\r\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xb3\x12\x10\x11\
    \nu\n\x04\x04#\x02\x02\x12\x04\xb6\x12\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04#\x02\x02\x05\x12\x04\xb6\x12\x02\x08\n\r\n\x05\x04#\x02\x02\x01\
    \x12\x04\xb6\x12\t\x11\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xb6\x12\x14\
    \x15\n\x0c\n\x02\x04$\x12\x06\xb9\x12\0\xbe\x12\x01\n\x0b\n\x03\x04$\x01\
    \x12\x04\xb9\x12\x08\x1d\n$\n\x04\x04$\x02\0\x12\x04\xbb\x12\x02(\x1a\
    \x16\x20The\x20response\x20status.\n\n\r\n\x05\x04$\x02\0\x06\x12\x04\
    \xbb\x12\x02\x1c\n\r\n\x05\x04$\x02\0\x01\x12\x04\xbb\x12\x1d#\n\r\n\x05\
    \x04$\x02\0\x03\x12\x04\xbb\x12&'\n%\n\x04\x04$\x02\x01\x12\x04\xbd\x12\
    \x02\x16\x1a\x17\x20The\x20returned\x20concept.\n\n\r\n\x05\x04$\x02\x01\
    \x06\x12\x04\xbd\x12\x02\t\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xbd\x12\n\
    \x11\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xbd\x12\x14\x15\n\x0c\n\x02\x04%\
    \x12\x06\xc0\x12\0\xc5\x12\x01\n\x0b\n\x03\x04%\x01\x12\x04\xc0\x12\x08\
    \x1c\n$\n\x04\x04%\x02\0\x12\x04\xc2\x12\x02(\x1a\x16\x20The\x20response\
    \x20status.\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\xc2\x12\x02\x1c\n\r\n\x05\
    \x04%\x02\0\x01\x12\x04\xc2\x12\x1d#\n\r\n\x05\x04%\x02\0\x03\x12\x04\
    \xc2\x12&'\n&\n\x04\x04%\x02\x01\x12\x04\xc4\x12\x02O\x1a\x18\x20The\x20\
    returned\x20concepts.\n\n\r\n\x05\x04%\x02\x01\x04\x12\x04\xc4\x12\x02\n\
    \n\r\n\x05\x04%\x02\x01\x06\x12\x04\xc4\x12\x0b\x12\n\r\n\x05\x04%\x02\
    \x01\x01\x12\x04\xc4\x12\x13\x1b\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xc4\
    \x12\x1e\x1f\n\r\n\x05\x04%\x02\x01\x08\x12\x04\xc4\x12\x20N\n\x10\n\x08\
    \x04%\x02\x01\x08\xd0\x86\x03\x12\x04\xc4\x12!M\n\x0c\n\x02\x04&\x12\x06\
    \xc7\x12\0\xcc\x12\x01\n\x0b\n\x03\x04&\x01\x12\x04\xc7\x12\x08!\n$\n\
    \x04\x04&\x02\0\x12\x04\xc9\x12\x02(\x1a\x16\x20The\x20response\x20statu\
    s.\n\n\r\n\x05\x04&\x02\0\x06\x12\x04\xc9\x12\x02\x1c\n\r\n\x05\x04&\x02\
    \0\x01\x12\x04\xc9\x12\x1d#\n\r\n\x05\x04&\x02\0\x03\x12\x04\xc9\x12&'\n\
    ,\n\x04\x04&\x02\x01\x12\x04\xcb\x12\x02Z\x1a\x1e\x20The\x20returned\x20\
    concept\x20counts.\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xcb\x12\x02\n\n\
    \r\n\x05\x04&\x02\x01\x06\x12\x04\xcb\x12\x0b\x17\n\r\n\x05\x04&\x02\x01\
    \x01\x12\x04\xcb\x12\x18&\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xcb\x12)*\n\
    \r\n\x05\x04&\x02\x01\x08\x12\x04\xcb\x12+Y\n\x10\n\x08\x04&\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xcb\x12,X\n\xe7\x03\n\x02\x04'\x12\x06\xde\x12\0\
    \x80\x13\x01\x1a\x87\x03////////////////////////////////////////////////\
    //////////////////////////////\n\x20Requests\x20/\x20Responses\x20from\
    \x20/proto/clarifai/api/concept_graph.proto\n///////////////////////////\
    ///////////////////////////////////////////////////\n///////////////////\
    /\n\x20Responses\n////////////////////\n\x20Requests\n//////////////////\
    //\n\x20GET\x20all\x20relations\x20such\x20that\x20the\x20concept_id\x20\
    refers\x20to\x20the\x20subject\x20of\x20the\x20relation\n2O/////////////\
    /////////////////////////////////////////////////////////////////\n\n\
    \x0b\n\x03\x04'\x01\x12\x04\xde\x12\x08#\n3\n\x04\x04'\x02\0\x12\x04\xe0\
    \x12\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20information.\n\n\r\
    \n\x05\x04'\x02\0\x06\x12\x04\xe0\x12\x02\x1b\n\r\n\x05\x04'\x02\0\x01\
    \x12\x04\xe0\x12\x1c'\n\r\n\x05\x04'\x02\0\x03\x12\x04\xe0\x12*+\n\xb4\
    \x07\n\x04\x04'\x02\x01\x12\x04\xf0\x12\x02\x18\x1a\xa5\x07\x20The\x20su\
    bject\x20concept\x20id\x20in\x20your\x20app\x20to\x20get\x20all\x20the\
    \x20relationships\x20for.\n\x20Leave\x20as\x20an\x20empty\x20string\x20(\
    GET\x20/concepts/relations)\x20to\x20list\x20ALL\x20the\x20relations\x20\
    in\x20the\x20app.\n\n\x20When\x20listing\x20all\x20the\x20relations\x20i\
    t\x20will\x20only\x20return\x20one\x20direction\x20of\x20the\x20relation\
    ship\n\x20with\x20the\x20predicate\x20acting\x20on\x20the\x20subject\x20\
    and\x20not\x20the\x20inverse\x20like\x20is\x20done\x20when\x20providing\
    \x20a\n\x20concept_id\x20so\x20that\x20we\x20can\x20return\x20a\x20relia\
    ble\x20page\x20size\x20always.\n\n\x20When\x20providing\x20a\x20concept_\
    id,\x20if\x20a\x20hyponym\x20is\x20present\x20in\x20the\x20DB\x20such\
    \x20as:\n\x20'honey'\x20(subject),\x20'hyponym'\x20(predict\x20for\x20\"\
    is\x20a\x20kind\x20of\"),\x20'food'\x20(object)\n\x20then\x20you\x20can\
    \x20list\x20the\x20concept\x20relations\x20for\x20'honey'\x20and\x20get\
    \x20hyponym\x20predicate\x20with\x20'food'\n\x20object.\n\x20But\x20you\
    \x20can\x20also\x20list\x20the\x20concept\x20relations\x20for\x20'food'\
    \x20and\x20it\x20will\x20return\x20the\x20same\x20hyponym\n\x20relations\
    hip\x20with\x20'honey'\x20as\x20subject\x20and\x20'food'\x20as\x20predic\
    ate.\n\x20Synonyms\x20by\x20nature\x20are\x20symmetrical\x20relationship\
    s\x20so\x20either\x20side\x20can\x20be\x20the\x20concept_id\x20(subject)\
    \n\x20when\x20listing\x20the\x20relations.\n\n\r\n\x05\x04'\x02\x01\x05\
    \x12\x04\xf0\x12\x02\x08\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xf0\x12\t\
    \x13\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xf0\x12\x16\x17\n\x8f\x01\n\x04\
    \x04'\x02\x02\x12\x04\xf5\x12\x02\x17\x1a\x80\x01\x20This\x20is\x20part\
    \x20of\x20the\x20url\x20so\x20we\x20can\x20extend\x20to\x20multiple\x20l\
    ink\x20types\x20in\x20the\x20future.\n\x20Valid\x20predicates\x20are:\n\
    \x20'hypernyms'\n\x20'hyponyms'\n\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xf5\
    \x12\x02\x08\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xf5\x12\t\x12\n\r\n\x05\
    \x04'\x02\x02\x03\x12\x04\xf5\x12\x15\x16\n\x8b\x02\n\x04\x04'\x02\x03\
    \x12\x04\xf9\x12\x02\x20\x1a\xfc\x01\x20If\x20knowledge_graph_id\x20is\
    \x20provided\x20then\x20just\x20list\x20relations\x20from\x20that\x20kno\
    wledge\x20graph.\n\x20If\x20not\x20provided\x20then\x20list\x20relations\
    \x20from\x20all\x20knowledge\x20graphs\x20including\x20the\x20global\x20\
    one\x20for\x20this\n\x20app\x20one\x20(ie.\x20knowledge_graph\x20\"\")\
    \x20and\x20any\x20specific\x20ones\x20in\x20the\x20app.\n\n\r\n\x05\x04'\
    \x02\x03\x05\x12\x04\xf9\x12\x02\x08\n\r\n\x05\x04'\x02\x03\x01\x12\x04\
    \xf9\x12\t\x1b\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xf9\x12\x1e\x1f\n~\n\
    \x04\x04'\x02\x04\x12\x04\xfc\x12\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04'\x02\x04\x05\x12\x04\xfc\x12\x02\x08\n\r\n\x05\x04'\x02\x04\
    \x01\x12\x04\xfc\x12\t\r\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xfc\x12\x10\
    \x11\nu\n\x04\x04'\x02\x05\x12\x04\xff\x12\x02\x16\x1ag\x20(optional\x20\
    URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20b\
    e\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\
    \n\x05\x04'\x02\x05\x05\x12\x04\xff\x12\x02\x08\n\r\n\x05\x04'\x02\x05\
    \x01\x12\x04\xff\x12\t\x11\n\r\n\x05\x04'\x02\x05\x03\x12\x04\xff\x12\
    \x14\x15\n*\n\x02\x04(\x12\x06\x83\x13\0\x8a\x13\x01\x1a\x1c\x20POST\x20\
    new\x20concept\x20relations\n\n\x0b\n\x03\x04(\x01\x12\x04\x83\x13\x08#\
    \n3\n\x04\x04(\x02\0\x12\x04\x85\x13\x02,\x1a%\x20The\x20user_id\x20and\
    \x20app_id\x20information.\n\n\r\n\x05\x04(\x02\0\x06\x12\x04\x85\x13\
    \x02\x1b\n\r\n\x05\x04(\x02\0\x01\x12\x04\x85\x13\x1c'\n\r\n\x05\x04(\
    \x02\0\x03\x12\x04\x85\x13*+\nI\n\x04\x04(\x02\x01\x12\x04\x87\x13\x02\
    \x18\x1a;\x20The\x20subject\x20concept\x20id\x20you're\x20going\x20to\
    \x20add\x20relations\x20for.\n\n\r\n\x05\x04(\x02\x01\x05\x12\x04\x87\
    \x13\x02\x08\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x87\x13\t\x13\n\r\n\x05\
    \x04(\x02\x01\x03\x12\x04\x87\x13\x16\x17\n6\n\x04\x04(\x02\x02\x12\x04\
    \x89\x13\x021\x1a(\x20The\x20relationships\x20you're\x20going\x20to\x20a\
    dd.\n\n\r\n\x05\x04(\x02\x02\x04\x12\x04\x89\x13\x02\n\n\r\n\x05\x04(\
    \x02\x02\x06\x12\x04\x89\x13\x0b\x1a\n\r\n\x05\x04(\x02\x02\x01\x12\x04\
    \x89\x13\x1b,\n\r\n\x05\x04(\x02\x02\x03\x12\x04\x89\x13/0\n(\n\x02\x04)\
    \x12\x06\x8d\x13\0\x94\x13\x01\x1a\x1a\x20DELETE\x20concept\x20relations\
    \n\n\x0b\n\x03\x04)\x01\x12\x04\x8d\x13\x08%\n3\n\x04\x04)\x02\0\x12\x04\
    \x8f\x13\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20information.\n\
    \n\r\n\x05\x04)\x02\0\x06\x12\x04\x8f\x13\x02\x1b\n\r\n\x05\x04)\x02\0\
    \x01\x12\x04\x8f\x13\x1c'\n\r\n\x05\x04)\x02\0\x03\x12\x04\x8f\x13*+\n7\
    \n\x04\x04)\x02\x01\x12\x04\x91\x13\x02\x18\x1a)\x20The\x20concept\x20to\
    \x20delete\x20relationship\x20for.\n\n\r\n\x05\x04)\x02\x01\x05\x12\x04\
    \x91\x13\x02\x08\n\r\n\x05\x04)\x02\x01\x01\x12\x04\x91\x13\t\x13\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\x91\x13\x16\x17\n7\n\x04\x04)\x02\x02\x12\
    \x04\x93\x13\x02\x1a\x1a)\x20The\x20concept\x20relationship\x20ids\x20to\
    \x20delete.\n\n\r\n\x05\x04)\x02\x02\x04\x12\x04\x93\x13\x02\n\n\r\n\x05\
    \x04)\x02\x02\x05\x12\x04\x93\x13\x0b\x11\n\r\n\x05\x04)\x02\x02\x01\x12\
    \x04\x93\x13\x12\x15\n\r\n\x05\x04)\x02\x02\x03\x12\x04\x93\x13\x18\x19\
    \n(\n\x02\x04*\x12\x06\x97\x13\0\x9a\x13\x01\x1a\x1a\x20GET\x20all\x20kn\
    owledge\x20graphs\n\n\x0b\n\x03\x04*\x01\x12\x04\x97\x13\x08\"\n3\n\x04\
    \x04*\x02\0\x12\x04\x99\x13\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\
    \x20information.\n\n\r\n\x05\x04*\x02\0\x06\x12\x04\x99\x13\x02\x1b\n\r\
    \n\x05\x04*\x02\0\x01\x12\x04\x99\x13\x1c'\n\r\n\x05\x04*\x02\0\x03\x12\
    \x04\x99\x13*+\n)\n\x02\x04+\x12\x06\x9d\x13\0\xa1\x13\x01\x1a\x1b\x20PO\
    ST\x20new\x20knowledge\x20graphs\n\n\x0b\n\x03\x04+\x01\x12\x04\x9d\x13\
    \x08\"\n3\n\x04\x04+\x02\0\x12\x04\x9f\x13\x02,\x1a%\x20The\x20user_id\
    \x20and\x20app_id\x20information.\n\n\r\n\x05\x04+\x02\0\x06\x12\x04\x9f\
    \x13\x02\x1b\n\r\n\x05\x04+\x02\0\x01\x12\x04\x9f\x13\x1c'\n\r\n\x05\x04\
    +\x02\0\x03\x12\x04\x9f\x13*+\n\x0c\n\x04\x04+\x02\x01\x12\x04\xa0\x13\
    \x02/\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xa0\x13\x02\n\n\r\n\x05\x04+\
    \x02\x01\x06\x12\x04\xa0\x13\x0b\x19\n\r\n\x05\x04+\x02\x01\x01\x12\x04\
    \xa0\x13\x1a*\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xa0\x13-.\n*\n\x02\x04,\
    \x12\x06\xa6\x13\0\xab\x13\x01\x1a\x1c\x20Start\x20concept\x20mapping\
    \x20jobs\n\n\x0b\n\x03\x04,\x01\x12\x04\xa6\x13\x08%\n3\n\x04\x04,\x02\0\
    \x12\x04\xa8\x13\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20informa\
    tion.\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xa8\x13\x02\x1b\n\r\n\x05\x04,\
    \x02\0\x01\x12\x04\xa8\x13\x1c'\n\r\n\x05\x04,\x02\0\x03\x12\x04\xa8\x13\
    *+\n?\n\x04\x04,\x02\x01\x12\x04\xaa\x13\x026\x1a1\x20The\x20concept\x20\
    mapping\x20jobs\x20that\x20are\x20being\x20started\n\n\r\n\x05\x04,\x02\
    \x01\x04\x12\x04\xaa\x13\x02\n\n\r\n\x05\x04,\x02\x01\x06\x12\x04\xaa\
    \x13\x0b\x1c\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xaa\x13\x1d1\n\r\n\x05\
    \x04,\x02\x01\x03\x12\x04\xaa\x1345\n\x0c\n\x02\x04-\x12\x06\xae\x13\0\
    \xb3\x13\x01\n\x0b\n\x03\x04-\x01\x12\x04\xae\x13\x08$\n$\n\x04\x04-\x02\
    \0\x12\x04\xb0\x13\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\
    \x05\x04-\x02\0\x06\x12\x04\xb0\x13\x02\x1c\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\xb0\x13\x1d#\n\r\n\x05\x04-\x02\0\x03\x12\x04\xb0\x13&'\n/\n\x04\
    \x04-\x02\x01\x12\x04\xb2\x13\x02`\x1a!\x20The\x20returned\x20concept\
    \x20relations.\n\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xb2\x13\x02\n\n\r\n\
    \x05\x04-\x02\x01\x06\x12\x04\xb2\x13\x0b\x1a\n\r\n\x05\x04-\x02\x01\x01\
    \x12\x04\xb2\x13\x1b,\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xb2\x13/0\n\r\n\
    \x05\x04-\x02\x01\x08\x12\x04\xb2\x131_\n\x10\n\x08\x04-\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xb2\x132^\n\x0c\n\x02\x04.\x12\x06\xb6\x13\0\xbb\x13\
    \x01\n\x0b\n\x03\x04.\x01\x12\x04\xb6\x13\x08#\n$\n\x04\x04.\x02\0\x12\
    \x04\xb8\x13\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x04.\
    \x02\0\x06\x12\x04\xb8\x13\x02\x1c\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb8\
    \x13\x1d#\n\r\n\x05\x04.\x02\0\x03\x12\x04\xb8\x13&'\n.\n\x04\x04.\x02\
    \x01\x12\x04\xba\x13\x02^\x1a\x20\x20The\x20returned\x20knowledge\x20gra\
    phs.\n\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xba\x13\x02\n\n\r\n\x05\x04.\
    \x02\x01\x06\x12\x04\xba\x13\x0b\x19\n\r\n\x05\x04.\x02\x01\x01\x12\x04\
    \xba\x13\x1a*\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xba\x13-.\n\r\n\x05\x04\
    .\x02\x01\x08\x12\x04\xba\x13/]\n\x10\n\x08\x04.\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xba\x130\\\n\x0c\n\x02\x04/\x12\x06\xc0\x13\0\xc5\x13\x01\n\x0b\
    \n\x03\x04/\x01\x12\x04\xc0\x13\x08&\n$\n\x04\x04/\x02\0\x12\x04\xc2\x13\
    \x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x04/\x02\0\x06\
    \x12\x04\xc2\x13\x02\x1c\n\r\n\x05\x04/\x02\0\x01\x12\x04\xc2\x13\x1d#\n\
    \r\n\x05\x04/\x02\0\x03\x12\x04\xc2\x13&'\n=\n\x04\x04/\x02\x01\x12\x04\
    \xc4\x13\x02\x1a\x1a/\x20The\x20ids\x20of\x20the\x20concept\x20mapping\
    \x20jobs\x20underway.\n\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xc4\x13\x02\n\
    \n\r\n\x05\x04/\x02\x01\x05\x12\x04\xc4\x13\x0b\x11\n\r\n\x05\x04/\x02\
    \x01\x01\x12\x04\xc4\x13\x12\x15\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xc4\
    \x13\x18\x19\n\xf8\x02\n\x02\x040\x12\x06\xd2\x13\0\xd7\x13\x01\x1a\x98\
    \x02////////////////////////////////////////////////////////////////////\
    //////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clarifai/ap\
    i/concept_language.proto\n//////////////////////////////////////////////\
    ////////////////////////////////\n\x20GET\x20single\x20concept\x20langua\
    ge\x20for\x20the\x20given\x20concept.\n2O///////////////////////////////\
    ///////////////////////////////////////////////\n\n\x0b\n\x03\x040\x01\
    \x12\x04\xd2\x13\x08!\n\x0c\n\x04\x040\x02\0\x12\x04\xd3\x13\x02,\n\r\n\
    \x05\x040\x02\0\x06\x12\x04\xd3\x13\x02\x1b\n\r\n\x05\x040\x02\0\x01\x12\
    \x04\xd3\x13\x1c'\n\r\n\x05\x040\x02\0\x03\x12\x04\xd3\x13*+\n\x0c\n\x04\
    \x040\x02\x01\x12\x04\xd4\x13\x02\x18\n\r\n\x05\x040\x02\x01\x05\x12\x04\
    \xd4\x13\x02\x08\n\r\n\x05\x040\x02\x01\x01\x12\x04\xd4\x13\t\x13\n\r\n\
    \x05\x040\x02\x01\x03\x12\x04\xd4\x13\x16\x17\n0\n\x04\x040\x02\x02\x12\
    \x04\xd6\x13\x02\x16\x1a\"\x20This\x20is\x20the\x20language\x20identifie\
    r.\n\n\r\n\x05\x040\x02\x02\x05\x12\x04\xd6\x13\x02\x08\n\r\n\x05\x040\
    \x02\x02\x01\x12\x04\xd6\x13\t\x11\n\r\n\x05\x040\x02\x02\x03\x12\x04\
    \xd6\x13\x14\x15\nF\n\x02\x041\x12\x06\xda\x13\0\xe3\x13\x01\x1a8\x20Lis\
    t\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\
    \n\n\x0b\n\x03\x041\x01\x12\x04\xda\x13\x08#\n\x0c\n\x04\x041\x02\0\x12\
    \x04\xdb\x13\x02,\n\r\n\x05\x041\x02\0\x06\x12\x04\xdb\x13\x02\x1b\n\r\n\
    \x05\x041\x02\0\x01\x12\x04\xdb\x13\x1c'\n\r\n\x05\x041\x02\0\x03\x12\
    \x04\xdb\x13*+\n\x0c\n\x04\x041\x02\x01\x12\x04\xdc\x13\x02\x18\n\r\n\
    \x05\x041\x02\x01\x05\x12\x04\xdc\x13\x02\x08\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xdc\x13\t\x13\n\r\n\x05\x041\x02\x01\x03\x12\x04\xdc\x13\x16\
    \x17\n~\n\x04\x041\x02\x02\x12\x04\xdf\x13\x02\x12\x1ap\x20(optional\x20\
    URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\r\n\x05\x041\x02\x02\x05\x12\x04\xdf\x13\x02\x08\n\r\n\x05\
    \x041\x02\x02\x01\x12\x04\xdf\x13\t\r\n\r\n\x05\x041\x02\x02\x03\x12\x04\
    \xdf\x13\x10\x11\nu\n\x04\x041\x02\x03\x12\x04\xe2\x13\x02\x16\x1ag\x20(\
    optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x041\x02\x03\x05\x12\x04\xe2\x13\x02\x08\n\r\n\x05\
    \x041\x02\x03\x01\x12\x04\xe2\x13\t\x11\n\r\n\x05\x041\x02\x03\x03\x12\
    \x04\xe2\x13\x14\x15\nG\n\x02\x042\x12\x06\xe6\x13\0\xec\x13\x01\x1a9\
    \x20PATCH\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20\
    concept.\n\n\x0b\n\x03\x042\x01\x12\x04\xe6\x13\x08$\n\x0c\n\x04\x042\
    \x02\0\x12\x04\xe7\x13\x02,\n\r\n\x05\x042\x02\0\x06\x12\x04\xe7\x13\x02\
    \x1b\n\r\n\x05\x042\x02\0\x01\x12\x04\xe7\x13\x1c'\n\r\n\x05\x042\x02\0\
    \x03\x12\x04\xe7\x13*+\n\x0c\n\x04\x042\x02\x01\x12\x04\xe8\x13\x02\x18\
    \n\r\n\x05\x042\x02\x01\x05\x12\x04\xe8\x13\x02\x08\n\r\n\x05\x042\x02\
    \x01\x01\x12\x04\xe8\x13\t\x13\n\r\n\x05\x042\x02\x01\x03\x12\x04\xe8\
    \x13\x16\x17\n\x0c\n\x04\x042\x02\x02\x12\x04\xe9\x13\x021\n\r\n\x05\x04\
    2\x02\x02\x04\x12\x04\xe9\x13\x02\n\n\r\n\x05\x042\x02\x02\x06\x12\x04\
    \xe9\x13\x0b\x1a\n\r\n\x05\x042\x02\x02\x01\x12\x04\xe9\x13\x1b,\n\r\n\
    \x05\x042\x02\x02\x03\x12\x04\xe9\x13/0\nD\n\x04\x042\x02\x03\x12\x04\
    \xeb\x13\x02\x14\x1a6\x20The\x20action\x20to\x20perform\x20with\x20the\
    \x20objects\x20in\x20the\x20PATCH.\n\n\r\n\x05\x042\x02\x03\x05\x12\x04\
    \xeb\x13\x02\x08\n\r\n\x05\x042\x02\x03\x01\x12\x04\xeb\x13\t\x0f\n\r\n\
    \x05\x042\x02\x03\x03\x12\x04\xeb\x13\x12\x13\n\xb9\x04\n\x02\x043\x12\
    \x06\x82\x14\0\x86\x14\x01\x1a8\x20POST\x20multiple\x20concept\x20langua\
    ges\x20for\x20the\x20given\x20concept.\n2\xeb\x01\x20//\x20DELETE\x20mul\
    tiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\n\x20me\
    ssage\x20DeleteConceptLanguageRequest\x20{\n\x20\x20\x20clarifai.api.Use\
    rAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20concept_id\
    \x20=\x202;\n\x20\x20\x20//\x20The\x20language\x20code\x20to\x20delete.\
    \n\x20\x20\x20string\x20language\x20=\x203;\n\x20}\n2\x82\x02\x20//\x20D\
    ELETE\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20conc\
    ept.\n\x20message\x20DeleteConceptLanguagesRequest\x20{\n\x20\x20\x20cla\
    rifai.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20\
    concept_id\x20=\x202;\n\x20\x20\x20//\x20The\x20language\x20code(s)\x20t\
    o\x20delete.\n\x20\x20\x20string\x20ids\x20=\x203;\n\x20\x20\x20bool\x20\
    delete_all\x20=\x204;\n\x20}\n\n\x0b\n\x03\x043\x01\x12\x04\x82\x14\x08#\
    \n\x0c\n\x04\x043\x02\0\x12\x04\x83\x14\x02,\n\r\n\x05\x043\x02\0\x06\
    \x12\x04\x83\x14\x02\x1b\n\r\n\x05\x043\x02\0\x01\x12\x04\x83\x14\x1c'\n\
    \r\n\x05\x043\x02\0\x03\x12\x04\x83\x14*+\n\x0c\n\x04\x043\x02\x01\x12\
    \x04\x84\x14\x02\x18\n\r\n\x05\x043\x02\x01\x05\x12\x04\x84\x14\x02\x08\
    \n\r\n\x05\x043\x02\x01\x01\x12\x04\x84\x14\t\x13\n\r\n\x05\x043\x02\x01\
    \x03\x12\x04\x84\x14\x16\x17\n\x0c\n\x04\x043\x02\x02\x12\x04\x85\x14\
    \x021\n\r\n\x05\x043\x02\x02\x04\x12\x04\x85\x14\x02\n\n\r\n\x05\x043\
    \x02\x02\x06\x12\x04\x85\x14\x0b\x1a\n\r\n\x05\x043\x02\x02\x01\x12\x04\
    \x85\x14\x1b,\n\r\n\x05\x043\x02\x02\x03\x12\x04\x85\x14/0\n\x0c\n\x02\
    \x044\x12\x06\x88\x14\0\x8b\x14\x01\n\x0b\n\x03\x044\x01\x12\x04\x88\x14\
    \x08%\n\x0c\n\x04\x044\x02\0\x12\x04\x89\x14\x02(\n\r\n\x05\x044\x02\0\
    \x06\x12\x04\x89\x14\x02\x1c\n\r\n\x05\x044\x02\0\x01\x12\x04\x89\x14\
    \x1d#\n\r\n\x05\x044\x02\0\x03\x12\x04\x89\x14&'\n\x0c\n\x04\x044\x02\
    \x01\x12\x04\x8a\x14\x02'\n\r\n\x05\x044\x02\x01\x06\x12\x04\x8a\x14\x02\
    \x11\n\r\n\x05\x044\x02\x01\x01\x12\x04\x8a\x14\x12\"\n\r\n\x05\x044\x02\
    \x01\x03\x12\x04\x8a\x14%&\n\x0c\n\x02\x045\x12\x06\x8d\x14\0\x90\x14\
    \x01\n\x0b\n\x03\x045\x01\x12\x04\x8d\x14\x08$\n\x0c\n\x04\x045\x02\0\
    \x12\x04\x8e\x14\x02(\n\r\n\x05\x045\x02\0\x06\x12\x04\x8e\x14\x02\x1c\n\
    \r\n\x05\x045\x02\0\x01\x12\x04\x8e\x14\x1d#\n\r\n\x05\x045\x02\0\x03\
    \x12\x04\x8e\x14&'\n\x0c\n\x04\x045\x02\x01\x12\x04\x8f\x14\x02`\n\r\n\
    \x05\x045\x02\x01\x04\x12\x04\x8f\x14\x02\n\n\r\n\x05\x045\x02\x01\x06\
    \x12\x04\x8f\x14\x0b\x1a\n\r\n\x05\x045\x02\x01\x01\x12\x04\x8f\x14\x1b,\
    \n\r\n\x05\x045\x02\x01\x03\x12\x04\x8f\x14/0\n\r\n\x05\x045\x02\x01\x08\
    \x12\x04\x8f\x141_\n\x10\n\x08\x045\x02\x01\x08\xd0\x86\x03\x12\x04\x8f\
    \x142^\n\xe4\x04\n\x02\x046\x12\x06\xc0\x14\0\xc3\x14\x01\x1a\xd9\x01///\
    ////////////////////////////////////////////////////////////////////////\
    ///\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clarifai/api/input\
    .proto\n////////////////////////////////////////////////////////////////\
    //////////////\n2O//////////////////////////////////////////////////////\
    ////////////////////////\n2\xa8\x02/////////////////////////////////////\
    /////////////////////////////////////////\n\x20Requests\x20/\x20Response\
    s\x20from\x20/proto/clarifai/api/image.proto\n//////////////////////////\
    ////////////////////////////////////////////////////\n//////////////////\
    ////////////////////////////////////////////////////////////\n\n\x0b\n\
    \x03\x046\x01\x12\x04\xc0\x14\x08\x17\n\x0c\n\x04\x046\x02\0\x12\x04\xc1\
    \x14\x02,\n\r\n\x05\x046\x02\0\x06\x12\x04\xc1\x14\x02\x1b\n\r\n\x05\x04\
    6\x02\0\x01\x12\x04\xc1\x14\x1c'\n\r\n\x05\x046\x02\0\x03\x12\x04\xc1\
    \x14*+\n\x0c\n\x04\x046\x02\x01\x12\x04\xc2\x14\x02\x16\n\r\n\x05\x046\
    \x02\x01\x05\x12\x04\xc2\x14\x02\x08\n\r\n\x05\x046\x02\x01\x01\x12\x04\
    \xc2\x14\t\x11\n\r\n\x05\x046\x02\x01\x03\x12\x04\xc2\x14\x14\x15\n\x0c\
    \n\x02\x047\x12\x06\xc5\x14\0\xca\x14\x01\n\x0b\n\x03\x047\x01\x12\x04\
    \xc5\x14\x08\x1e\n\x0c\n\x04\x047\x02\0\x12\x04\xc6\x14\x02,\n\r\n\x05\
    \x047\x02\0\x06\x12\x04\xc6\x14\x02\x1b\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \xc6\x14\x1c'\n\r\n\x05\x047\x02\0\x03\x12\x04\xc6\x14*+\n\x0c\n\x04\x04\
    7\x02\x01\x12\x04\xc7\x14\x02\x15\n\r\n\x05\x047\x02\x01\x05\x12\x04\xc7\
    \x14\x02\x08\n\r\n\x05\x047\x02\x01\x01\x12\x04\xc7\x14\t\x10\n\r\n\x05\
    \x047\x02\x01\x03\x12\x04\xc7\x14\x13\x14\nN\n\x04\x047\x02\x02\x12\x04\
    \xc9\x14\x02\x1f\x1a@\x20URL\x20param.\x20If\x20zero\x20ids\x20provided,\
    \x20returns\x20for\x20all\x20task\x20labelers\n\n\r\n\x05\x047\x02\x02\
    \x04\x12\x04\xc9\x14\x02\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xc9\x14\
    \x0b\x11\n\r\n\x05\x047\x02\x02\x01\x12\x04\xc9\x14\x12\x1a\n\r\n\x05\
    \x047\x02\x02\x03\x12\x04\xc9\x14\x1d\x1e\n\x0c\n\x02\x048\x12\x06\xcc\
    \x14\0\xd9\x14\x01\n\x0b\n\x03\x048\x01\x12\x04\xcc\x14\x08\x19\n\x0c\n\
    \x04\x048\x02\0\x12\x04\xcd\x14\x02,\n\r\n\x05\x048\x02\0\x06\x12\x04\
    \xcd\x14\x02\x1b\n\r\n\x05\x048\x02\0\x01\x12\x04\xcd\x14\x1c'\n\r\n\x05\
    \x048\x02\0\x03\x12\x04\xcd\x14*+\n~\n\x04\x048\x02\x01\x12\x04\xd0\x14\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x048\x02\x01\x05\x12\
    \x04\xd0\x14\x02\x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\xd0\x14\t\r\n\r\
    \n\x05\x048\x02\x01\x03\x12\x04\xd0\x14\x10\x11\nu\n\x04\x048\x02\x02\
    \x12\x04\xd3\x14\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x048\x02\x02\x05\
    \x12\x04\xd3\x14\x02\x08\n\r\n\x05\x048\x02\x02\x01\x12\x04\xd3\x14\t\
    \x11\n\r\n\x05\x048\x02\x02\x03\x12\x04\xd3\x14\x14\x15\n.\n\x04\x048\
    \x02\x03\x12\x04\xd6\x14\x02(\x1a\x20\x20Set\x20status\x20to\x20filter\
    \x20by\x20status\n\n\r\n\x05\x048\x02\x03\x06\x12\x04\xd6\x14\x02\x1c\n\
    \r\n\x05\x048\x02\x03\x01\x12\x04\xd6\x14\x1d#\n\r\n\x05\x048\x02\x03\
    \x03\x12\x04\xd6\x14&'\n\x0c\n\x04\x048\x02\x04\x12\x04\xd8\x14\x02\x1a\
    \n\r\n\x05\x048\x02\x04\x04\x12\x04\xd8\x14\x02\n\n\r\n\x05\x048\x02\x04\
    \x05\x12\x04\xd8\x14\x0b\x11\n\r\n\x05\x048\x02\x04\x01\x12\x04\xd8\x14\
    \x12\x15\n\r\n\x05\x048\x02\x04\x03\x12\x04\xd8\x14\x18\x19\n\x0c\n\x02\
    \x049\x12\x06\xdb\x14\0\xe4\x14\x01\n\x0b\n\x03\x049\x01\x12\x04\xdb\x14\
    \x08\x1b\n\x0c\n\x04\x049\x02\0\x12\x04\xdc\x14\x02,\n\r\n\x05\x049\x02\
    \0\x06\x12\x04\xdc\x14\x02\x1b\n\r\n\x05\x049\x02\0\x01\x12\x04\xdc\x14\
    \x1c'\n\r\n\x05\x049\x02\0\x03\x12\x04\xdc\x14*+\nt\n\x04\x049\x02\x01\
    \x12\x04\xdf\x14\x02\x16\x1af\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x2020.\n\n\r\n\x05\x049\x02\x01\x05\
    \x12\x04\xdf\x14\x02\x08\n\r\n\x05\x049\x02\x01\x01\x12\x04\xdf\x14\t\
    \x11\n\r\n\x05\x049\x02\x01\x03\x12\x04\xdf\x14\x14\x15\n\x0c\n\x04\x049\
    \x02\x02\x12\x04\xe0\x14\x02\x15\n\r\n\x05\x049\x02\x02\x05\x12\x04\xe0\
    \x14\x02\x08\n\r\n\x05\x049\x02\x02\x01\x12\x04\xe0\x14\t\x10\n\r\n\x05\
    \x049\x02\x02\x03\x12\x04\xe0\x14\x13\x14\n\x0c\n\x04\x049\x02\x03\x12\
    \x04\xe3\x14\x02\x16\n\r\n\x05\x049\x02\x03\x05\x12\x04\xe3\x14\x02\x06\
    \n\r\n\x05\x049\x02\x03\x01\x12\x04\xe3\x14\x07\x11\n\r\n\x05\x049\x02\
    \x03\x03\x12\x04\xe3\x14\x14\x15\n\x0c\n\x02\x04:\x12\x06\xe6\x14\0\xea\
    \x14\x01\n\x0b\n\x03\x04:\x01\x12\x04\xe6\x14\x08\x19\n\x0c\n\x04\x04:\
    \x02\0\x12\x04\xe7\x14\x02,\n\r\n\x05\x04:\x02\0\x06\x12\x04\xe7\x14\x02\
    \x1b\n\r\n\x05\x04:\x02\0\x01\x12\x04\xe7\x14\x1c'\n\r\n\x05\x04:\x02\0\
    \x03\x12\x04\xe7\x14*+\n\x0c\n\x04\x04:\x02\x01\x12\x04\xe9\x14\x02\x1c\
    \n\r\n\x05\x04:\x02\x01\x04\x12\x04\xe9\x14\x02\n\n\r\n\x05\x04:\x02\x01\
    \x06\x12\x04\xe9\x14\x0b\x10\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xe9\x14\
    \x11\x17\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xe9\x14\x1a\x1b\n\x0c\n\x02\
    \x04;\x12\x06\xf0\x14\0\xf8\x14\x01\n\x0b\n\x03\x04;\x01\x12\x04\xf0\x14\
    \x08\x1a\n\x0c\n\x04\x04;\x02\0\x12\x04\xf1\x14\x02,\n\r\n\x05\x04;\x02\
    \0\x06\x12\x04\xf1\x14\x02\x1b\n\r\n\x05\x04;\x02\0\x01\x12\x04\xf1\x14\
    \x1c'\n\r\n\x05\x04;\x02\0\x03\x12\x04\xf1\x14*+\n\x0c\n\x04\x04;\x02\
    \x01\x12\x04\xf3\x14\x02\x1c\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xf3\x14\
    \x02\n\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xf3\x14\x0b\x10\n\r\n\x05\x04;\
    \x02\x01\x01\x12\x04\xf3\x14\x11\x17\n\r\n\x05\x04;\x02\x01\x03\x12\x04\
    \xf3\x14\x1a\x1b\n~\n\x04\x04;\x02\x02\x12\x04\xf7\x14\x02\x14\x1ap\x20T\
    he\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20Fo\
    r\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20ar\
    e\x20supported\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xf7\x14\x02\x08\n\r\
    \n\x05\x04;\x02\x02\x01\x12\x04\xf7\x14\t\x0f\n\r\n\x05\x04;\x02\x02\x03\
    \x12\x04\xf7\x14\x12\x13\n\x0c\n\x02\x04<\x12\x06\xfa\x14\0\xfd\x14\x01\
    \n\x0b\n\x03\x04<\x01\x12\x04\xfa\x14\x08\x1a\n\x0c\n\x04\x04<\x02\0\x12\
    \x04\xfb\x14\x02,\n\r\n\x05\x04<\x02\0\x06\x12\x04\xfb\x14\x02\x1b\n\r\n\
    \x05\x04<\x02\0\x01\x12\x04\xfb\x14\x1c'\n\r\n\x05\x04<\x02\0\x03\x12\
    \x04\xfb\x14*+\n\x0c\n\x04\x04<\x02\x01\x12\x04\xfc\x14\x02\x16\n\r\n\
    \x05\x04<\x02\x01\x05\x12\x04\xfc\x14\x02\x08\n\r\n\x05\x04<\x02\x01\x01\
    \x12\x04\xfc\x14\t\x11\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xfc\x14\x14\
    \x15\nD\n\x02\x04=\x12\x06\x80\x15\0\x85\x15\x01\x1a6\x20Request\x20to\
    \x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\
    \x0b\n\x03\x04=\x01\x12\x04\x80\x15\x08\x1b\n\x0b\n\x03\x04=\t\x12\x04\
    \x81\x15\x02\r\n\x0c\n\x04\x04=\t\0\x12\x04\x81\x15\x0b\x0c\n\r\n\x05\
    \x04=\t\0\x01\x12\x04\x81\x15\x0b\x0c\n\r\n\x05\x04=\t\0\x02\x12\x04\x81\
    \x15\x0b\x0c\n\x0c\n\x04\x04=\x02\0\x12\x04\x83\x15\x02,\n\r\n\x05\x04=\
    \x02\0\x06\x12\x04\x83\x15\x02\x1b\n\r\n\x05\x04=\x02\0\x01\x12\x04\x83\
    \x15\x1c'\n\r\n\x05\x04=\x02\0\x03\x12\x04\x83\x15*+\n\x0c\n\x04\x04=\
    \x02\x01\x12\x04\x84\x15\x02\x1a\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x84\
    \x15\x02\n\n\r\n\x05\x04=\x02\x01\x05\x12\x04\x84\x15\x0b\x11\n\r\n\x05\
    \x04=\x02\x01\x01\x12\x04\x84\x15\x12\x15\n\r\n\x05\x04=\x02\x01\x03\x12\
    \x04\x84\x15\x18\x19\n\x0c\n\x02\x04>\x12\x06\x87\x15\0\x8a\x15\x01\n\
    \x0b\n\x03\x04>\x01\x12\x04\x87\x15\x08\x1b\n\x0c\n\x04\x04>\x02\0\x12\
    \x04\x88\x15\x02(\n\r\n\x05\x04>\x02\0\x06\x12\x04\x88\x15\x02\x1c\n\r\n\
    \x05\x04>\x02\0\x01\x12\x04\x88\x15\x1d#\n\r\n\x05\x04>\x02\0\x03\x12\
    \x04\x88\x15&'\n\x0c\n\x04\x04>\x02\x01\x12\x04\x89\x15\x02\x12\n\r\n\
    \x05\x04>\x02\x01\x06\x12\x04\x89\x15\x02\x07\n\r\n\x05\x04>\x02\x01\x01\
    \x12\x04\x89\x15\x08\r\n\r\n\x05\x04>\x02\x01\x03\x12\x04\x89\x15\x10\
    \x11\n\x0c\n\x02\x04?\x12\x06\x8c\x15\0\x90\x15\x01\n\x0b\n\x03\x04?\x01\
    \x12\x04\x8c\x15\x08\x1a\n\x0c\n\x04\x04?\x02\0\x12\x04\x8e\x15\x02(\n\r\
    \n\x05\x04?\x02\0\x06\x12\x04\x8e\x15\x02\x1c\n\r\n\x05\x04?\x02\0\x01\
    \x12\x04\x8e\x15\x1d#\n\r\n\x05\x04?\x02\0\x03\x12\x04\x8e\x15&'\n\x0c\n\
    \x04\x04?\x02\x01\x12\x04\x8f\x15\x02K\n\r\n\x05\x04?\x02\x01\x04\x12\
    \x04\x8f\x15\x02\n\n\r\n\x05\x04?\x02\x01\x06\x12\x04\x8f\x15\x0b\x10\n\
    \r\n\x05\x04?\x02\x01\x01\x12\x04\x8f\x15\x11\x17\n\r\n\x05\x04?\x02\x01\
    \x03\x12\x04\x8f\x15\x1a\x1b\n\r\n\x05\x04?\x02\x01\x08\x12\x04\x8f\x15\
    \x1cJ\n\x10\n\x08\x04?\x02\x01\x08\xd0\x86\x03\x12\x04\x8f\x15\x1dI\n\
    \x0c\n\x02\x04@\x12\x06\x92\x15\0\x96\x15\x01\n\x0b\n\x03\x04@\x01\x12\
    \x04\x92\x15\x08$\n\x0c\n\x04\x04@\x02\0\x12\x04\x94\x15\x02(\n\r\n\x05\
    \x04@\x02\0\x06\x12\x04\x94\x15\x02\x1c\n\r\n\x05\x04@\x02\0\x01\x12\x04\
    \x94\x15\x1d#\n\r\n\x05\x04@\x02\0\x03\x12\x04\x94\x15&'\n\x0c\n\x04\x04\
    @\x02\x01\x12\x04\x95\x15\x02G\n\r\n\x05\x04@\x02\x01\x04\x12\x04\x95\
    \x15\x02\n\n\r\n\x05\x04@\x02\x01\x06\x12\x04\x95\x15\x0b\x0e\n\r\n\x05\
    \x04@\x02\x01\x01\x12\x04\x95\x15\x0f\x13\n\r\n\x05\x04@\x02\x01\x03\x12\
    \x04\x95\x15\x16\x17\n\r\n\x05\x04@\x02\x01\x08\x12\x04\x95\x15\x18F\n\
    \x10\n\x08\x04@\x02\x01\x08\xd0\x86\x03\x12\x04\x95\x15\x19E\n\x0c\n\x02\
    \x04A\x12\x06\x98\x15\0\x9d\x15\x01\n\x0b\n\x03\x04A\x01\x12\x04\x98\x15\
    \x08\x20\n\x0c\n\x04\x04A\x02\0\x12\x04\x99\x15\x02(\n\r\n\x05\x04A\x02\
    \0\x06\x12\x04\x99\x15\x02\x1c\n\r\n\x05\x04A\x02\0\x01\x12\x04\x99\x15\
    \x1d#\n\r\n\x05\x04A\x02\0\x03\x12\x04\x99\x15&'\nE\n\x04\x04A\x02\x01\
    \x12\x04\x9c\x15\x02\x18\x1a7\x20NOTE:\x20inconsistency:\x20not\x20named\
    \x20after\x20the\x20object\x20name.\n\n\r\n\x05\x04A\x02\x01\x06\x12\x04\
    \x9c\x15\x02\x0c\n\r\n\x05\x04A\x02\x01\x01\x12\x04\x9c\x15\r\x13\n\r\n\
    \x05\x04A\x02\x01\x03\x12\x04\x9c\x15\x16\x17\n\x0c\n\x02\x04B\x12\x06\
    \x9f\x15\0\xa1\x15\x01\n\x0b\n\x03\x04B\x01\x12\x04\x9f\x15\x08\x1c\n\
    \x0c\n\x04\x04B\x02\0\x12\x04\xa0\x15\x02,\n\r\n\x05\x04B\x02\0\x06\x12\
    \x04\xa0\x15\x02\x1b\n\r\n\x05\x04B\x02\0\x01\x12\x04\xa0\x15\x1c'\n\r\n\
    \x05\x04B\x02\0\x03\x12\x04\xa0\x15*+\n\xcb\x01\n\x02\x04C\x12\x06\xa7\
    \x15\0\xaf\x15\x01\x1a\xbc\x01//////////////////////////////////////////\
    ////////\n\x20Model\x20prediction\x20related\x20stuff\x20needs\x20inputs\
    \x20and\x20produces\x20outputs.\n///////////////////////////////////////\
    ///////////\n\x20Model\x20prediction.\n\n\x0b\n\x03\x04C\x01\x12\x04\xa7\
    \x15\x08\x1f\n\x0c\n\x04\x04C\x02\0\x12\x04\xa8\x15\x02,\n\r\n\x05\x04C\
    \x02\0\x06\x12\x04\xa8\x15\x02\x1b\n\r\n\x05\x04C\x02\0\x01\x12\x04\xa8\
    \x15\x1c'\n\r\n\x05\x04C\x02\0\x03\x12\x04\xa8\x15*+\n\x0c\n\x04\x04C\
    \x02\x01\x12\x04\xa9\x15\x02\x16\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xa9\
    \x15\x02\x08\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xa9\x15\t\x11\n\r\n\x05\
    \x04C\x02\x01\x03\x12\x04\xa9\x15\x14\x15\n\x0c\n\x04\x04C\x02\x02\x12\
    \x04\xaa\x15\x02\x18\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xaa\x15\x02\x08\
    \n\r\n\x05\x04C\x02\x02\x01\x12\x04\xaa\x15\t\x13\n\r\n\x05\x04C\x02\x02\
    \x03\x12\x04\xaa\x15\x16\x17\n\x0c\n\x04\x04C\x02\x03\x12\x04\xab\x15\
    \x02\x1c\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xab\x15\x02\n\n\r\n\x05\x04C\
    \x02\x03\x06\x12\x04\xab\x15\x0b\x10\n\r\n\x05\x04C\x02\x03\x01\x12\x04\
    \xab\x15\x11\x17\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xab\x15\x1a\x1b\n\
    \x88\x01\n\x04\x04C\x02\x04\x12\x04\xae\x15\x02\x12\x1az\x20This\x20allo\
    ws\x20you\x20to\x20specify\x20config\x20options\x20for\x20the\x20model\
    \x20such\x20as\n\x20the\x20language\x20which\x20appear's\x20in\x20the\
    \x20model's\x20output_info.\n\n\r\n\x05\x04C\x02\x04\x06\x12\x04\xae\x15\
    \x02\x07\n\r\n\x05\x04C\x02\x04\x01\x12\x04\xae\x15\x08\r\n\r\n\x05\x04C\
    \x02\x04\x03\x12\x04\xae\x15\x10\x11\nF\n\x02\x04D\x12\x06\xb2\x15\0\xbc\
    \x15\x01\x1a8\x20Listing\x20the\x20inputs\x20that\x20went\x20into\x20tra\
    ining\x20this\x20model.\n\n\x0b\n\x03\x04D\x01\x12\x04\xb2\x15\x08\x1e\n\
    \x0c\n\x04\x04D\x02\0\x12\x04\xb3\x15\x02,\n\r\n\x05\x04D\x02\0\x06\x12\
    \x04\xb3\x15\x02\x1b\n\r\n\x05\x04D\x02\0\x01\x12\x04\xb3\x15\x1c'\n\r\n\
    \x05\x04D\x02\0\x03\x12\x04\xb3\x15*+\n\x0c\n\x04\x04D\x02\x01\x12\x04\
    \xb4\x15\x02\x16\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xb4\x15\x02\x08\n\r\
    \n\x05\x04D\x02\x01\x01\x12\x04\xb4\x15\t\x11\n\r\n\x05\x04D\x02\x01\x03\
    \x12\x04\xb4\x15\x14\x15\n\x0c\n\x04\x04D\x02\x02\x12\x04\xb5\x15\x02\
    \x18\n\r\n\x05\x04D\x02\x02\x05\x12\x04\xb5\x15\x02\x08\n\r\n\x05\x04D\
    \x02\x02\x01\x12\x04\xb5\x15\t\x13\n\r\n\x05\x04D\x02\x02\x03\x12\x04\
    \xb5\x15\x16\x17\n~\n\x04\x04D\x02\x03\x12\x04\xb8\x15\x02\x12\x1ap\x20(\
    optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\
    \x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20\
    Defaults\x20to\x201.\n\n\r\n\x05\x04D\x02\x03\x05\x12\x04\xb8\x15\x02\
    \x08\n\r\n\x05\x04D\x02\x03\x01\x12\x04\xb8\x15\t\r\n\r\n\x05\x04D\x02\
    \x03\x03\x12\x04\xb8\x15\x10\x11\nu\n\x04\x04D\x02\x04\x12\x04\xbb\x15\
    \x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04D\x02\x04\x05\x12\x04\xbb\
    \x15\x02\x08\n\r\n\x05\x04D\x02\x04\x01\x12\x04\xbb\x15\t\x11\n\r\n\x05\
    \x04D\x02\x04\x03\x12\x04\xbb\x15\x14\x15\n\xb7\x02\n\x02\x04E\x12\x06\
    \xc8\x15\0\xcb\x15\x01\x1a\xd7\x01//////////////////////////////////////\
    ////////////////////////////////////////\n\x20Requests\x20/\x20Responses\
    \x20from\x20/proto/clarifai/api/key.proto\n/////////////////////////////\
    /////////////////////////////////////////////////\n2O///////////////////\
    ///////////////////////////////////////////////////////////\n\n\x0b\n\
    \x03\x04E\x01\x12\x04\xc8\x15\x08\x15\n\x0c\n\x04\x04E\x02\0\x12\x04\xc9\
    \x15\x02,\n\r\n\x05\x04E\x02\0\x06\x12\x04\xc9\x15\x02\x1b\n\r\n\x05\x04\
    E\x02\0\x01\x12\x04\xc9\x15\x1c'\n\r\n\x05\x04E\x02\0\x03\x12\x04\xc9\
    \x15*+\n\x0c\n\x04\x04E\x02\x01\x12\x04\xca\x15\x02\x14\n\r\n\x05\x04E\
    \x02\x01\x05\x12\x04\xca\x15\x02\x08\n\r\n\x05\x04E\x02\x01\x01\x12\x04\
    \xca\x15\t\x0f\n\r\n\x05\x04E\x02\x01\x03\x12\x04\xca\x15\x12\x13\n\x0c\
    \n\x02\x04F\x12\x06\xcd\x15\0\xd5\x15\x01\n\x0b\n\x03\x04F\x01\x12\x04\
    \xcd\x15\x08\x17\n\x0c\n\x04\x04F\x02\0\x12\x04\xce\x15\x02,\n\r\n\x05\
    \x04F\x02\0\x06\x12\x04\xce\x15\x02\x1b\n\r\n\x05\x04F\x02\0\x01\x12\x04\
    \xce\x15\x1c'\n\r\n\x05\x04F\x02\0\x03\x12\x04\xce\x15*+\n~\n\x04\x04F\
    \x02\x01\x12\x04\xd1\x15\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\
    \x05\x04F\x02\x01\x05\x12\x04\xd1\x15\x02\x08\n\r\n\x05\x04F\x02\x01\x01\
    \x12\x04\xd1\x15\t\r\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xd1\x15\x10\x11\
    \nu\n\x04\x04F\x02\x02\x12\x04\xd4\x15\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04F\x02\x02\x05\x12\x04\xd4\x15\x02\x08\n\r\n\x05\x04F\x02\x02\x01\
    \x12\x04\xd4\x15\t\x11\n\r\n\x05\x04F\x02\x02\x03\x12\x04\xd4\x15\x14\
    \x15\n\x0c\n\x02\x04G\x12\x06\xd7\x15\0\xdf\x15\x01\n\x0b\n\x03\x04G\x01\
    \x12\x04\xd7\x15\x08\x1a\n\x0c\n\x04\x04G\x02\0\x12\x04\xd8\x15\x02,\n\r\
    \n\x05\x04G\x02\0\x06\x12\x04\xd8\x15\x02\x1b\n\r\n\x05\x04G\x02\0\x01\
    \x12\x04\xd8\x15\x1c'\n\r\n\x05\x04G\x02\0\x03\x12\x04\xd8\x15*+\n~\n\
    \x04\x04G\x02\x01\x12\x04\xdb\x15\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04G\x02\x01\x05\x12\x04\xdb\x15\x02\x08\n\r\n\x05\x04G\x02\x01\
    \x01\x12\x04\xdb\x15\t\r\n\r\n\x05\x04G\x02\x01\x03\x12\x04\xdb\x15\x10\
    \x11\nu\n\x04\x04G\x02\x02\x12\x04\xde\x15\x02\x16\x1ag\x20(optional\x20\
    URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20b\
    e\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\
    \n\x05\x04G\x02\x02\x05\x12\x04\xde\x15\x02\x08\n\r\n\x05\x04G\x02\x02\
    \x01\x12\x04\xde\x15\t\x11\n\r\n\x05\x04G\x02\x02\x03\x12\x04\xde\x15\
    \x14\x15\n\x0c\n\x02\x04H\x12\x06\xe1\x15\0\xe4\x15\x01\n\x0b\n\x03\x04H\
    \x01\x12\x04\xe1\x15\x08\x17\n\x0c\n\x04\x04H\x02\0\x12\x04\xe2\x15\x02,\
    \n\r\n\x05\x04H\x02\0\x06\x12\x04\xe2\x15\x02\x1b\n\r\n\x05\x04H\x02\0\
    \x01\x12\x04\xe2\x15\x1c'\n\r\n\x05\x04H\x02\0\x03\x12\x04\xe2\x15*+\n\
    \x0c\n\x04\x04H\x02\x01\x12\x04\xe3\x15\x02\x18\n\r\n\x05\x04H\x02\x01\
    \x04\x12\x04\xe3\x15\x02\n\n\r\n\x05\x04H\x02\x01\x06\x12\x04\xe3\x15\
    \x0b\x0e\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xe3\x15\x0f\x13\n\r\n\x05\
    \x04H\x02\x01\x03\x12\x04\xe3\x15\x16\x17\n\x0c\n\x02\x04I\x12\x06\xe6\
    \x15\0\xe9\x15\x01\n\x0b\n\x03\x04I\x01\x12\x04\xe6\x15\x08\x18\n\x0c\n\
    \x04\x04I\x02\0\x12\x04\xe7\x15\x02,\n\r\n\x05\x04I\x02\0\x06\x12\x04\
    \xe7\x15\x02\x1b\n\r\n\x05\x04I\x02\0\x01\x12\x04\xe7\x15\x1c'\n\r\n\x05\
    \x04I\x02\0\x03\x12\x04\xe7\x15*+\n\x0c\n\x04\x04I\x02\x01\x12\x04\xe8\
    \x15\x02\x14\n\r\n\x05\x04I\x02\x01\x05\x12\x04\xe8\x15\x02\x08\n\r\n\
    \x05\x04I\x02\x01\x01\x12\x04\xe8\x15\t\x0f\n\r\n\x05\x04I\x02\x01\x03\
    \x12\x04\xe8\x15\x12\x13\n\x0c\n\x02\x04J\x12\x06\xeb\x15\0\xf2\x15\x01\
    \n\x0b\n\x03\x04J\x01\x12\x04\xeb\x15\x08\x18\n\x0c\n\x04\x04J\x02\0\x12\
    \x04\xec\x15\x02,\n\r\n\x05\x04J\x02\0\x06\x12\x04\xec\x15\x02\x1b\n\r\n\
    \x05\x04J\x02\0\x01\x12\x04\xec\x15\x1c'\n\r\n\x05\x04J\x02\0\x03\x12\
    \x04\xec\x15*+\n\x0c\n\x04\x04J\x02\x01\x12\x04\xed\x15\x02\x18\n\r\n\
    \x05\x04J\x02\x01\x04\x12\x04\xed\x15\x02\n\n\r\n\x05\x04J\x02\x01\x06\
    \x12\x04\xed\x15\x0b\x0e\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xed\x15\x0f\
    \x13\n\r\n\x05\x04J\x02\x01\x03\x12\x04\xed\x15\x16\x17\nj\n\x04\x04J\
    \x02\x02\x12\x04\xf1\x15\x02\x14\x1a\\\x20The\x20action\x20to\x20perform\
    \x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20only\x20action\
    \x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04J\x02\x02\x05\x12\x04\
    \xf1\x15\x02\x08\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xf1\x15\t\x0f\n\r\n\
    \x05\x04J\x02\x02\x03\x12\x04\xf1\x15\x12\x13\n\x0c\n\x02\x04K\x12\x06\
    \xf4\x15\0\xf7\x15\x01\n\x0b\n\x03\x04K\x01\x12\x04\xf4\x15\x08\x19\n\
    \x0c\n\x04\x04K\x02\0\x12\x04\xf5\x15\x02(\n\r\n\x05\x04K\x02\0\x06\x12\
    \x04\xf5\x15\x02\x1c\n\r\n\x05\x04K\x02\0\x01\x12\x04\xf5\x15\x1d#\n\r\n\
    \x05\x04K\x02\0\x03\x12\x04\xf5\x15&'\n\x0c\n\x04\x04K\x02\x01\x12\x04\
    \xf6\x15\x02\x0e\n\r\n\x05\x04K\x02\x01\x06\x12\x04\xf6\x15\x02\x05\n\r\
    \n\x05\x04K\x02\x01\x01\x12\x04\xf6\x15\x06\t\n\r\n\x05\x04K\x02\x01\x03\
    \x12\x04\xf6\x15\x0c\r\n\x0c\n\x02\x04L\x12\x06\xf9\x15\0\xfc\x15\x01\n\
    \x0b\n\x03\x04L\x01\x12\x04\xf9\x15\x08\x18\n\x0c\n\x04\x04L\x02\0\x12\
    \x04\xfa\x15\x02(\n\r\n\x05\x04L\x02\0\x06\x12\x04\xfa\x15\x02\x1c\n\r\n\
    \x05\x04L\x02\0\x01\x12\x04\xfa\x15\x1d#\n\r\n\x05\x04L\x02\0\x03\x12\
    \x04\xfa\x15&'\n\x0c\n\x04\x04L\x02\x01\x12\x04\xfb\x15\x02G\n\r\n\x05\
    \x04L\x02\x01\x04\x12\x04\xfb\x15\x02\n\n\r\n\x05\x04L\x02\x01\x06\x12\
    \x04\xfb\x15\x0b\x0e\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xfb\x15\x0f\x13\
    \n\r\n\x05\x04L\x02\x01\x03\x12\x04\xfb\x15\x16\x17\n\r\n\x05\x04L\x02\
    \x01\x08\x12\x04\xfb\x15\x18F\n\x10\n\x08\x04L\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xfb\x15\x19E\n\xb9\x02\n\x02\x04M\x12\x06\x93\x16\0\x9b\x16\x01\
    \x1a\xd9\x01////////////////////////////////////////////////////////////\
    //////////////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/cla\
    rifai/api/model.proto\n/////////////////////////////////////////////////\
    /////////////////////////////\n2O///////////////////////////////////////\
    ///////////////////////////////////////\n\n\x0b\n\x03\x04M\x01\x12\x04\
    \x93\x16\x08\x17\n\x0c\n\x04\x04M\x02\0\x12\x04\x94\x16\x02,\n\r\n\x05\
    \x04M\x02\0\x06\x12\x04\x94\x16\x02\x1b\n\r\n\x05\x04M\x02\0\x01\x12\x04\
    \x94\x16\x1c'\n\r\n\x05\x04M\x02\0\x03\x12\x04\x94\x16*+\n\x0c\n\x04\x04\
    M\x02\x01\x12\x04\x95\x16\x02\x16\n\r\n\x05\x04M\x02\x01\x05\x12\x04\x95\
    \x16\x02\x08\n\r\n\x05\x04M\x02\x01\x01\x12\x04\x95\x16\t\x11\n\r\n\x05\
    \x04M\x02\x01\x03\x12\x04\x95\x16\x14\x15\nw\n\x04\x04M\x02\x02\x12\x04\
    \x98\x16\x02\x18\x1ai\x20This\x20is\x20included\x20so\x20that\x20we\x20c\
    an\x20re-use\x20this\x20request\x20for\x20multiple\n\x20rpcs\x20with\x20\
    and\x20without\x20the\x20version_id.\n\n\r\n\x05\x04M\x02\x02\x05\x12\
    \x04\x98\x16\x02\x08\n\r\n\x05\x04M\x02\x02\x01\x12\x04\x98\x16\t\x13\n\
    \r\n\x05\x04M\x02\x02\x03\x12\x04\x98\x16\x16\x17\n\x0c\n\x04\x04M\x02\
    \x03\x12\x04\x99\x16\x02\x16\n\r\n\x05\x04M\x02\x03\x05\x12\x04\x99\x16\
    \x02\x08\n\r\n\x05\x04M\x02\x03\x01\x12\x04\x99\x16\t\x11\n\r\n\x05\x04M\
    \x02\x03\x03\x12\x04\x99\x16\x14\x15\n\x0c\n\x04\x04M\x02\x04\x12\x04\
    \x9a\x16\x02\x1a\n\r\n\x05\x04M\x02\x04\x05\x12\x04\x9a\x16\x02\x06\n\r\
    \n\x05\x04M\x02\x04\x01\x12\x04\x9a\x16\x07\x15\n\r\n\x05\x04M\x02\x04\
    \x03\x12\x04\x9a\x16\x18\x19\n\x0c\n\x02\x04N\x12\x06\x9d\x16\0\xa6\x16\
    \x01\n\x0b\n\x03\x04N\x01\x12\x04\x9d\x16\x08\x19\n\x0c\n\x04\x04N\x02\0\
    \x12\x04\x9e\x16\x02,\n\r\n\x05\x04N\x02\0\x06\x12\x04\x9e\x16\x02\x1b\n\
    \r\n\x05\x04N\x02\0\x01\x12\x04\x9e\x16\x1c'\n\r\n\x05\x04N\x02\0\x03\
    \x12\x04\x9e\x16*+\n~\n\x04\x04N\x02\x01\x12\x04\xa1\x16\x02\x12\x1ap\
    \x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginati\
    on\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\r\n\x05\x04N\x02\x01\x05\x12\x04\xa1\x16\
    \x02\x08\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xa1\x16\t\r\n\r\n\x05\x04N\
    \x02\x01\x03\x12\x04\xa1\x16\x10\x11\nu\n\x04\x04N\x02\x02\x12\x04\xa4\
    \x16\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xa4\
    \x16\x02\x08\n\r\n\x05\x04N\x02\x02\x01\x12\x04\xa4\x16\t\x11\n\r\n\x05\
    \x04N\x02\x02\x03\x12\x04\xa4\x16\x14\x15\n\x0c\n\x04\x04N\x02\x03\x12\
    \x04\xa5\x16\x02\x1a\n\r\n\x05\x04N\x02\x03\x04\x12\x04\xa5\x16\x02\n\n\
    \r\n\x05\x04N\x02\x03\x05\x12\x04\xa5\x16\x0b\x11\n\r\n\x05\x04N\x02\x03\
    \x01\x12\x04\xa5\x16\x12\x15\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xa5\x16\
    \x18\x19\n\x0c\n\x02\x04O\x12\x06\xa8\x16\0\xb2\x16\x01\n\x0b\n\x03\x04O\
    \x01\x12\x04\xa8\x16\x08\x19\n\x0c\n\x04\x04O\x02\0\x12\x04\xa9\x16\x02,\
    \n\r\n\x05\x04O\x02\0\x06\x12\x04\xa9\x16\x02\x1b\n\r\n\x05\x04O\x02\0\
    \x01\x12\x04\xa9\x16\x1c'\n\r\n\x05\x04O\x02\0\x03\x12\x04\xa9\x16*+\n\
    \x91\x02\n\x04\x04O\x02\x01\x12\x04\xaf\x16\x02&\x1a\x82\x02\x20NOTE:\
    \x20inconsistent\x20since\x20\"model\"\x20is\x20not\x20plural,\x20please\
    \x20use\x20\"models\"\x20below.\n\x20Previously\x20you\x20could\x20only\
    \x20create\x20one\x20model\x20at\x20a\x20time.\n\x20We\x20still\x20suppo\
    rt\x20this\x20but\x20you\x20should\x20pass\x20it\x20as\x20models=[model]\
    \x20so\n\x20that\x20this\x20endpoint\x20is\x20consistent\x20with\x20the\
    \x20rest\x20of\x20our\x20API.\n\n\r\n\x05\x04O\x02\x01\x06\x12\x04\xaf\
    \x16\x02\x07\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xaf\x16\x08\r\n\r\n\x05\
    \x04O\x02\x01\x03\x12\x04\xaf\x16\x10\x11\n\r\n\x05\x04O\x02\x01\x08\x12\
    \x04\xaf\x16\x12%\n\x0e\n\x06\x04O\x02\x01\x08\x03\x12\x04\xaf\x16\x13$\
    \nU\n\x04\x04O\x02\x02\x12\x04\xb1\x16\x02\x1c\x1aG\x20This\x20allows\
    \x20you\x20to\x20create\x20one\x20or\x20more\x20model\x20by\x20posting\
    \x20it\x20to\x20the\x20API.\n\n\r\n\x05\x04O\x02\x02\x04\x12\x04\xb1\x16\
    \x02\n\n\r\n\x05\x04O\x02\x02\x06\x12\x04\xb1\x16\x0b\x10\n\r\n\x05\x04O\
    \x02\x02\x01\x12\x04\xb1\x16\x11\x17\n\r\n\x05\x04O\x02\x02\x03\x12\x04\
    \xb1\x16\x1a\x1b\n\x0c\n\x02\x04P\x12\x06\xb4\x16\0\xbb\x16\x01\n\x0b\n\
    \x03\x04P\x01\x12\x04\xb4\x16\x08\x1a\n\x0c\n\x04\x04P\x02\0\x12\x04\xb5\
    \x16\x02,\n\r\n\x05\x04P\x02\0\x06\x12\x04\xb5\x16\x02\x1b\n\r\n\x05\x04\
    P\x02\0\x01\x12\x04\xb5\x16\x1c'\n\r\n\x05\x04P\x02\0\x03\x12\x04\xb5\
    \x16*+\n\x0c\n\x04\x04P\x02\x01\x12\x04\xb6\x16\x02\x1c\n\r\n\x05\x04P\
    \x02\x01\x04\x12\x04\xb6\x16\x02\n\n\r\n\x05\x04P\x02\x01\x06\x12\x04\
    \xb6\x16\x0b\x10\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xb6\x16\x11\x17\n\r\
    \n\x05\x04P\x02\x01\x03\x12\x04\xb6\x16\x1a\x1b\n~\n\x04\x04P\x02\x02\
    \x12\x04\xba\x16\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\
    \x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20\
    'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\r\n\x05\x04P\x02\
    \x02\x05\x12\x04\xba\x16\x02\x08\n\r\n\x05\x04P\x02\x02\x01\x12\x04\xba\
    \x16\t\x0f\n\r\n\x05\x04P\x02\x02\x03\x12\x04\xba\x16\x12\x13\n\x0c\n\
    \x02\x04Q\x12\x06\xbd\x16\0\xc0\x16\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xbd\
    \x16\x08\x1a\n\x0c\n\x04\x04Q\x02\0\x12\x04\xbe\x16\x02,\n\r\n\x05\x04Q\
    \x02\0\x06\x12\x04\xbe\x16\x02\x1b\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xbe\
    \x16\x1c'\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xbe\x16*+\n\x0c\n\x04\x04Q\
    \x02\x01\x12\x04\xbf\x16\x02\x16\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\xbf\
    \x16\x02\x08\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\xbf\x16\t\x11\n\r\n\x05\
    \x04Q\x02\x01\x03\x12\x04\xbf\x16\x14\x15\nD\n\x02\x04R\x12\x06\xc3\x16\
    \0\xc7\x16\x01\x1a6\x20Request\x20to\x20delete\x20several\x20things\x20b\
    y\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04R\x01\x12\x04\xc3\x16\
    \x08\x1b\n\x0c\n\x04\x04R\x02\0\x12\x04\xc4\x16\x02,\n\r\n\x05\x04R\x02\
    \0\x06\x12\x04\xc4\x16\x02\x1b\n\r\n\x05\x04R\x02\0\x01\x12\x04\xc4\x16\
    \x1c'\n\r\n\x05\x04R\x02\0\x03\x12\x04\xc4\x16*+\n\x0c\n\x04\x04R\x02\
    \x01\x12\x04\xc5\x16\x02\x1a\n\r\n\x05\x04R\x02\x01\x04\x12\x04\xc5\x16\
    \x02\n\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xc5\x16\x0b\x11\n\r\n\x05\x04R\
    \x02\x01\x01\x12\x04\xc5\x16\x12\x15\n\r\n\x05\x04R\x02\x01\x03\x12\x04\
    \xc5\x16\x18\x19\n\x0c\n\x04\x04R\x02\x02\x12\x04\xc6\x16\x02\x16\n\r\n\
    \x05\x04R\x02\x02\x05\x12\x04\xc6\x16\x02\x06\n\r\n\x05\x04R\x02\x02\x01\
    \x12\x04\xc6\x16\x07\x11\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xc6\x16\x14\
    \x15\n1\n\x02\x04S\x12\x06\xca\x16\0\xd2\x16\x01\x1a#\x20Search\x20over\
    \x20the\x20available\x20models.\n\n\x0b\n\x03\x04S\x01\x12\x04\xca\x16\
    \x08!\n6\n\x04\x04S\x02\0\x12\x04\xcc\x16\x02,\x1a(\x20Ids\x20present\
    \x20in\x20the\x20url\x20of\x20the\x20request.\n\n\r\n\x05\x04S\x02\0\x06\
    \x12\x04\xcc\x16\x02\x1b\n\r\n\x05\x04S\x02\0\x01\x12\x04\xcc\x16\x1c'\n\
    \r\n\x05\x04S\x02\0\x03\x12\x04\xcc\x16*+\n(\n\x04\x04S\x02\x01\x12\x04\
    \xce\x16\x02\x1d\x1a\x1a\x20The\x20body\x20of\x20the\x20request.\n\n\r\n\
    \x05\x04S\x02\x01\x06\x12\x04\xce\x16\x02\x0c\n\r\n\x05\x04S\x02\x01\x01\
    \x12\x04\xce\x16\r\x18\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xce\x16\x1b\
    \x1c\n]\n\x04\x04S\x02\x02\x12\x04\xd1\x16\x02\x1c\x1aO\x20Pagination\
    \x20parameters\x20here\x20since\x20there\x20are\x20no\x20url\x20args\x20\
    in\x20this\n\x20POST\x20request.\n\n\r\n\x05\x04S\x02\x02\x06\x12\x04\
    \xd1\x16\x02\x0c\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xd1\x16\r\x17\n\r\n\
    \x05\x04S\x02\x02\x03\x12\x04\xd1\x16\x1a\x1b\n\x0c\n\x02\x04T\x12\x06\
    \xd4\x16\0\xd7\x16\x01\n\x0b\n\x03\x04T\x01\x12\x04\xd4\x16\x08\x1b\n\
    \x0c\n\x04\x04T\x02\0\x12\x04\xd5\x16\x02(\n\r\n\x05\x04T\x02\0\x06\x12\
    \x04\xd5\x16\x02\x1c\n\r\n\x05\x04T\x02\0\x01\x12\x04\xd5\x16\x1d#\n\r\n\
    \x05\x04T\x02\0\x03\x12\x04\xd5\x16&'\n\x0c\n\x04\x04T\x02\x01\x12\x04\
    \xd6\x16\x02\x12\n\r\n\x05\x04T\x02\x01\x06\x12\x04\xd6\x16\x02\x07\n\r\
    \n\x05\x04T\x02\x01\x01\x12\x04\xd6\x16\x08\r\n\r\n\x05\x04T\x02\x01\x03\
    \x12\x04\xd6\x16\x10\x11\n\x0c\n\x02\x04U\x12\x06\xd9\x16\0\xdc\x16\x01\
    \n\x0b\n\x03\x04U\x01\x12\x04\xd9\x16\x08\x1a\n\x0c\n\x04\x04U\x02\0\x12\
    \x04\xda\x16\x02(\n\r\n\x05\x04U\x02\0\x06\x12\x04\xda\x16\x02\x1c\n\r\n\
    \x05\x04U\x02\0\x01\x12\x04\xda\x16\x1d#\n\r\n\x05\x04U\x02\0\x03\x12\
    \x04\xda\x16&'\n\x0c\n\x04\x04U\x02\x01\x12\x04\xdb\x16\x02K\n\r\n\x05\
    \x04U\x02\x01\x04\x12\x04\xdb\x16\x02\n\n\r\n\x05\x04U\x02\x01\x06\x12\
    \x04\xdb\x16\x0b\x10\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xdb\x16\x11\x17\
    \n\r\n\x05\x04U\x02\x01\x03\x12\x04\xdb\x16\x1a\x1b\n\r\n\x05\x04U\x02\
    \x01\x08\x12\x04\xdb\x16\x1cJ\n\x10\n\x08\x04U\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xdb\x16\x1dI\n\xc1\x02\n\x02\x04V\x12\x06\xe8\x16\0\xef\x16\x01\
    \x1a\xe1\x01////////////////////////////////////////////////////////////\
    //////////////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/cla\
    rifai/api/model_version.proto\n/////////////////////////////////////////\
    /////////////////////////////////////\n2O///////////////////////////////\
    ///////////////////////////////////////////////\n\n\x0b\n\x03\x04V\x01\
    \x12\x04\xe8\x16\x08!\n\x0c\n\x04\x04V\x02\0\x12\x04\xe9\x16\x02,\n\r\n\
    \x05\x04V\x02\0\x06\x12\x04\xe9\x16\x02\x1b\n\r\n\x05\x04V\x02\0\x01\x12\
    \x04\xe9\x16\x1c'\n\r\n\x05\x04V\x02\0\x03\x12\x04\xe9\x16*+\n\x0c\n\x04\
    \x04V\x02\x01\x12\x04\xea\x16\x02\x16\n\r\n\x05\x04V\x02\x01\x05\x12\x04\
    \xea\x16\x02\x08\n\r\n\x05\x04V\x02\x01\x01\x12\x04\xea\x16\t\x11\n\r\n\
    \x05\x04V\x02\x01\x03\x12\x04\xea\x16\x14\x15\n\x0c\n\x04\x04V\x02\x02\
    \x12\x04\xeb\x16\x02+\n\r\n\x05\x04V\x02\x02\x04\x12\x04\xeb\x16\x02\n\n\
    \r\n\x05\x04V\x02\x02\x06\x12\x04\xeb\x16\x0b\x17\n\r\n\x05\x04V\x02\x02\
    \x01\x12\x04\xeb\x16\x18&\n\r\n\x05\x04V\x02\x02\x03\x12\x04\xeb\x16)*\n\
    ~\n\x04\x04V\x02\x03\x12\x04\xee\x16\x02\x14\x1ap\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20action\
    s\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\
    \r\n\x05\x04V\x02\x03\x05\x12\x04\xee\x16\x02\x08\n\r\n\x05\x04V\x02\x03\
    \x01\x12\x04\xee\x16\t\x0f\n\r\n\x05\x04V\x02\x03\x03\x12\x04\xee\x16\
    \x12\x13\n\x8a\x01\n\x02\x04W\x12\x06\xf3\x16\0\xf7\x16\x01\x1a|\x20NOTE\
    :\x20this\x20is\x20same\x20as\x20GetModelRequest\x20but\x20backend\x20do\
    esn't\x20support\x20sharing\x20same\n\x20request\x20for\x20different\x20\
    endpoints\x20currently.\n\n\x0b\n\x03\x04W\x01\x12\x04\xf3\x16\x08\x1e\n\
    \x0c\n\x04\x04W\x02\0\x12\x04\xf4\x16\x02,\n\r\n\x05\x04W\x02\0\x06\x12\
    \x04\xf4\x16\x02\x1b\n\r\n\x05\x04W\x02\0\x01\x12\x04\xf4\x16\x1c'\n\r\n\
    \x05\x04W\x02\0\x03\x12\x04\xf4\x16*+\n\x0c\n\x04\x04W\x02\x01\x12\x04\
    \xf5\x16\x02\x16\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xf5\x16\x02\x08\n\r\
    \n\x05\x04W\x02\x01\x01\x12\x04\xf5\x16\t\x11\n\r\n\x05\x04W\x02\x01\x03\
    \x12\x04\xf5\x16\x14\x15\n\x0c\n\x04\x04W\x02\x02\x12\x04\xf6\x16\x02\
    \x18\n\r\n\x05\x04W\x02\x02\x05\x12\x04\xf6\x16\x02\x08\n\r\n\x05\x04W\
    \x02\x02\x01\x12\x04\xf6\x16\t\x13\n\r\n\x05\x04W\x02\x02\x03\x12\x04\
    \xf6\x16\x16\x17\n\x0c\n\x02\x04X\x12\x06\xf9\x16\0\x84\x17\x01\n\x0b\n\
    \x03\x04X\x01\x12\x04\xf9\x16\x08\x20\n\x0c\n\x04\x04X\x02\0\x12\x04\xfa\
    \x16\x02,\n\r\n\x05\x04X\x02\0\x06\x12\x04\xfa\x16\x02\x1b\n\r\n\x05\x04\
    X\x02\0\x01\x12\x04\xfa\x16\x1c'\n\r\n\x05\x04X\x02\0\x03\x12\x04\xfa\
    \x16*+\n\x0c\n\x04\x04X\x02\x01\x12\x04\xfb\x16\x02\x16\n\r\n\x05\x04X\
    \x02\x01\x05\x12\x04\xfb\x16\x02\x08\n\r\n\x05\x04X\x02\x01\x01\x12\x04\
    \xfb\x16\t\x11\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xfb\x16\x14\x15\n~\n\
    \x04\x04X\x02\x02\x12\x04\xfe\x16\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04X\x02\x02\x05\x12\x04\xfe\x16\x02\x08\n\r\n\x05\x04X\x02\x02\
    \x01\x12\x04\xfe\x16\t\r\n\r\n\x05\x04X\x02\x02\x03\x12\x04\xfe\x16\x10\
    \x11\nu\n\x04\x04X\x02\x03\x12\x04\x81\x17\x02\x16\x1ag\x20(optional\x20\
    URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20b\
    e\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\
    \n\x05\x04X\x02\x03\x05\x12\x04\x81\x17\x02\x08\n\r\n\x05\x04X\x02\x03\
    \x01\x12\x04\x81\x17\t\x11\n\r\n\x05\x04X\x02\x03\x03\x12\x04\x81\x17\
    \x14\x15\n\\\n\x04\x04X\x02\x04\x12\x04\x83\x17\x02\"\x1aN\x20To\x20list\
    \x20only\x20the\x20model\x20versions\x20that\x20have\x20these\x20concept\
    \x20ids\x20present\x20in\x20them.\n\n\r\n\x05\x04X\x02\x04\x04\x12\x04\
    \x83\x17\x02\n\n\r\n\x05\x04X\x02\x04\x05\x12\x04\x83\x17\x0b\x11\n\r\n\
    \x05\x04X\x02\x04\x01\x12\x04\x83\x17\x12\x1d\n\r\n\x05\x04X\x02\x04\x03\
    \x12\x04\x83\x17\x20!\n\x0c\n\x02\x04Y\x12\x06\x86\x17\0\x8a\x17\x01\n\
    \x0b\n\x03\x04Y\x01\x12\x04\x86\x17\x08!\n\x0c\n\x04\x04Y\x02\0\x12\x04\
    \x87\x17\x02,\n\r\n\x05\x04Y\x02\0\x06\x12\x04\x87\x17\x02\x1b\n\r\n\x05\
    \x04Y\x02\0\x01\x12\x04\x87\x17\x1c'\n\r\n\x05\x04Y\x02\0\x03\x12\x04\
    \x87\x17*+\n\x0c\n\x04\x04Y\x02\x01\x12\x04\x88\x17\x02\x16\n\r\n\x05\
    \x04Y\x02\x01\x05\x12\x04\x88\x17\x02\x08\n\r\n\x05\x04Y\x02\x01\x01\x12\
    \x04\x88\x17\t\x11\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\x88\x17\x14\x15\n\
    \x0c\n\x04\x04Y\x02\x02\x12\x04\x89\x17\x02\x18\n\r\n\x05\x04Y\x02\x02\
    \x05\x12\x04\x89\x17\x02\x08\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\x89\x17\
    \t\x13\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\x89\x17\x16\x17\n\x0c\n\x02\
    \x04Z\x12\x06\x8c\x17\0\x8f\x17\x01\n\x0b\n\x03\x04Z\x01\x12\x04\x8c\x17\
    \x08\"\n\x0c\n\x04\x04Z\x02\0\x12\x04\x8d\x17\x02(\n\r\n\x05\x04Z\x02\0\
    \x06\x12\x04\x8d\x17\x02\x1c\n\r\n\x05\x04Z\x02\0\x01\x12\x04\x8d\x17\
    \x1d#\n\r\n\x05\x04Z\x02\0\x03\x12\x04\x8d\x17&'\n\x0c\n\x04\x04Z\x02\
    \x01\x12\x04\x8e\x17\x02!\n\r\n\x05\x04Z\x02\x01\x06\x12\x04\x8e\x17\x02\
    \x0e\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\x8e\x17\x0f\x1c\n\r\n\x05\x04Z\
    \x02\x01\x03\x12\x04\x8e\x17\x1f\x20\n\x0c\n\x02\x04[\x12\x06\x91\x17\0\
    \x94\x17\x01\n\x0b\n\x03\x04[\x01\x12\x04\x91\x17\x08!\n\x0c\n\x04\x04[\
    \x02\0\x12\x04\x92\x17\x02(\n\r\n\x05\x04[\x02\0\x06\x12\x04\x92\x17\x02\
    \x1c\n\r\n\x05\x04[\x02\0\x01\x12\x04\x92\x17\x1d#\n\r\n\x05\x04[\x02\0\
    \x03\x12\x04\x92\x17&'\n\x0c\n\x04\x04[\x02\x01\x12\x04\x93\x17\x02Z\n\r\
    \n\x05\x04[\x02\x01\x04\x12\x04\x93\x17\x02\n\n\r\n\x05\x04[\x02\x01\x06\
    \x12\x04\x93\x17\x0b\x17\n\r\n\x05\x04[\x02\x01\x01\x12\x04\x93\x17\x18&\
    \n\r\n\x05\x04[\x02\x01\x03\x12\x04\x93\x17)*\n\r\n\x05\x04[\x02\x01\x08\
    \x12\x04\x93\x17+Y\n\x10\n\x08\x04[\x02\x01\x08\xd0\x86\x03\x12\x04\x93\
    \x17,X\n3\n\x02\x04\\\x12\x06\x97\x17\0\xa9\x17\x01\x1a%\x20Create\x20(t\
    rain)\x20a\x20new\x20model\x20version.\n\n\x0b\n\x03\x04\\\x01\x12\x04\
    \x97\x17\x08\x20\n\x0c\n\x04\x04\\\x02\0\x12\x04\x98\x17\x02,\n\r\n\x05\
    \x04\\\x02\0\x06\x12\x04\x98\x17\x02\x1b\n\r\n\x05\x04\\\x02\0\x01\x12\
    \x04\x98\x17\x1c'\n\r\n\x05\x04\\\x02\0\x03\x12\x04\x98\x17*+\n\x0c\n\
    \x04\x04\\\x02\x01\x12\x04\x99\x17\x02\x16\n\r\n\x05\x04\\\x02\x01\x05\
    \x12\x04\x99\x17\x02\x08\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\x99\x17\t\
    \x11\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\x99\x17\x14\x15\n\x86\x01\n\x04\
    \x04\\\x02\x02\x12\x04\x9d\x17\x02+\x1ax\x20This\x20lets\x20you\x20post\
    \x20an\x20existing\x20model\x20version\x20rather\x20than\x20training\x20\
    a\x20new\x20one.\n\x20For\x20internal\x20Clarifai\x20use\x20only\x20to\
    \x20start.\n\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\x9d\x17\x02\n\n\r\n\x05\
    \x04\\\x02\x02\x06\x12\x04\x9d\x17\x0b\x17\n\r\n\x05\x04\\\x02\x02\x01\
    \x12\x04\x9d\x17\x18&\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\x9d\x17)*\nC\n\
    \x04\x04\\\x02\x03\x12\x04\xa0\x17\x025\x1a5\x20Use\x20this\x20to\x20fil\
    ter\x20inputs\x20that\x20are\x20used\x20in\x20training\n\n\r\n\x05\x04\\\
    \x02\x03\x06\x12\x04\xa0\x17\x02\x15\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\
    \xa0\x17\x16\x1c\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\xa0\x17\x1f\x20\n\r\
    \n\x05\x04\\\x02\x03\x08\x12\x04\xa0\x17!4\n\x0e\n\x06\x04\\\x02\x03\x08\
    \x03\x12\x04\xa0\x17\"3\nE\n\x04\x04\\\x02\x04\x12\x04\xa2\x17\x02'\x1a7\
    train_search\x20is\x20used\x20to\x20specify\x20what\x20data\x20to\x20tra\
    in\x20on.\n\n\r\n\x05\x04\\\x02\x04\x06\x12\x04\xa2\x17\x02\x15\n\r\n\
    \x05\x04\\\x02\x04\x01\x12\x04\xa2\x17\x16\"\n\r\n\x05\x04\\\x02\x04\x03\
    \x12\x04\xa2\x17%&\nC\n\x04\x04\\\x02\x05\x12\x04\xa4\x17\x02&\x1a5test_\
    search\x20is\x20used\x20to\x20specify\x20what\x20data\x20to\x20test\x20o\
    n.\n\n\r\n\x05\x04\\\x02\x05\x06\x12\x04\xa4\x17\x02\x15\n\r\n\x05\x04\\\
    \x02\x05\x01\x12\x04\xa4\x17\x16!\n\r\n\x05\x04\\\x02\x05\x03\x12\x04\
    \xa4\x17$%\nM\n\x04\x04\\\x02\x06\x12\x04\xa6\x17\x02#\x1a?\x20whether\
    \x20to\x20evaluate\x20the\x20transfer\x20trained\x20model\x20after\x20tr\
    aining\n\n\r\n\x05\x04\\\x02\x06\x05\x12\x04\xa6\x17\x02\x06\n\r\n\x05\
    \x04\\\x02\x06\x01\x12\x04\xa6\x17\x07\x1e\n\r\n\x05\x04\\\x02\x06\x03\
    \x12\x04\xa6\x17!\"\n3\n\x04\x04\\\x02\x07\x12\x04\xa8\x17\x02\x19\x1a%\
    \x20Description\x20about\x20this\x20training\x20run\n\n\r\n\x05\x04\\\
    \x02\x07\x05\x12\x04\xa8\x17\x02\x08\n\r\n\x05\x04\\\x02\x07\x01\x12\x04\
    \xa8\x17\t\x14\n\r\n\x05\x04\\\x02\x07\x03\x12\x04\xa8\x17\x17\x18\n,\n\
    \x02\x04]\x12\x06\xae\x17\0\xb6\x17\x01\x1a\x1e\x20Evaluate\x20this\x20m\
    odel\x20version.\n\n\x0b\n\x03\x04]\x01\x12\x04\xae\x17\x08&\n\x0c\n\x04\
    \x04]\x02\0\x12\x04\xaf\x17\x02,\n\r\n\x05\x04]\x02\0\x06\x12\x04\xaf\
    \x17\x02\x1b\n\r\n\x05\x04]\x02\0\x01\x12\x04\xaf\x17\x1c'\n\r\n\x05\x04\
    ]\x02\0\x03\x12\x04\xaf\x17*+\n\x0c\n\x04\x04]\x02\x01\x12\x04\xb0\x17\
    \x02\x16\n\r\n\x05\x04]\x02\x01\x05\x12\x04\xb0\x17\x02\x08\n\r\n\x05\
    \x04]\x02\x01\x01\x12\x04\xb0\x17\t\x11\n\r\n\x05\x04]\x02\x01\x03\x12\
    \x04\xb0\x17\x14\x15\n\x0c\n\x04\x04]\x02\x02\x12\x04\xb1\x17\x02\x18\n\
    \r\n\x05\x04]\x02\x02\x05\x12\x04\xb1\x17\x02\x08\n\r\n\x05\x04]\x02\x02\
    \x01\x12\x04\xb1\x17\t\x13\n\r\n\x05\x04]\x02\x02\x03\x12\x04\xb1\x17\
    \x16\x17\n\x0c\n\x04\x04]\x02\x03\x12\x04\xb2\x17\x02\x1a\n\r\n\x05\x04]\
    \x02\x03\x05\x12\x04\xb2\x17\x02\x08\n\r\n\x05\x04]\x02\x03\x01\x12\x04\
    \xb2\x17\t\x15\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xb2\x17\x18\x19\nE\n\
    \x04\x04]\x02\x04\x12\x04\xb5\x17\x02&\x1a7\x20Use\x20this\x20to\x20filt\
    er\x20inputs\x20that\x20are\x20used\x20in\x20evaluation\n\n\r\n\x05\x04]\
    \x02\x04\x06\x12\x04\xb5\x17\x02\x15\n\r\n\x05\x04]\x02\x04\x01\x12\x04\
    \xb5\x17\x16!\n\r\n\x05\x04]\x02\x04\x03\x12\x04\xb5\x17$%\nT\n\x02\x04^\
    \x12\x06\xba\x17\0\xc1\x17\x01\x1aF\x20Get\x20the\x20already\x20computed\
    \x20evaluation\x20metrics\x20for\x20this\x20model\n\x20version.\n\n\x0b\
    \n\x03\x04^\x01\x12\x04\xba\x17\x08%\n\x0c\n\x04\x04^\x02\0\x12\x04\xbb\
    \x17\x02,\n\r\n\x05\x04^\x02\0\x06\x12\x04\xbb\x17\x02\x1b\n\r\n\x05\x04\
    ^\x02\0\x01\x12\x04\xbb\x17\x1c'\n\r\n\x05\x04^\x02\0\x03\x12\x04\xbb\
    \x17*+\n\x0c\n\x04\x04^\x02\x01\x12\x04\xbc\x17\x02\x16\n\r\n\x05\x04^\
    \x02\x01\x05\x12\x04\xbc\x17\x02\x08\n\r\n\x05\x04^\x02\x01\x01\x12\x04\
    \xbc\x17\t\x11\n\r\n\x05\x04^\x02\x01\x03\x12\x04\xbc\x17\x14\x15\n\x0c\
    \n\x04\x04^\x02\x02\x12\x04\xbd\x17\x02\x18\n\r\n\x05\x04^\x02\x02\x05\
    \x12\x04\xbd\x17\x02\x08\n\r\n\x05\x04^\x02\x02\x01\x12\x04\xbd\x17\t\
    \x13\n\r\n\x05\x04^\x02\x02\x03\x12\x04\xbd\x17\x16\x17\nL\n\x04\x04^\
    \x02\x03\x12\x04\xc0\x17\x02\x19\x1a>\x20Any\x20of\x20the\x20fields\x20y\
    ou\x20wish\x20to\x20return\x20from\x20multiclass_metrics\n\n\r\n\x05\x04\
    ^\x02\x03\x06\x12\x04\xc0\x17\x02\r\n\r\n\x05\x04^\x02\x03\x01\x12\x04\
    \xc0\x17\x0e\x14\n\r\n\x05\x04^\x02\x03\x03\x12\x04\xc0\x17\x17\x18\n\
    \xdd\x02\n\x02\x04_\x12\x06\xd1\x17\0\xd6\x17\x012\xfd\x01\x20TODO:\x20s\
    hould\x20we\x20just\x20move\x20to\x20this\x20and\x20get\x20rid\x20of\x20\
    above.\n\x20//\x20Request\x20to\x20delete\x20several\x20things\x20by\x20\
    the\x20list\x20of\x20ids.\n\x20message\x20DeleteModelVersionsRequest\x20\
    {\n\x20\x20\x20clarifai.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\
    \x20\x20repeated\x20string\x20ids\x20=\x202;\n\x20\x20\x20bool\x20delete\
    _all\x20=\x203;\n\x20}\n2O//////////////////////////////////////////////\
    ////////////////////////////////\n\n\x0b\n\x03\x04_\x01\x12\x04\xd1\x17\
    \x08\x1b\nk\n\x04\x04_\x02\0\x12\x04\xd3\x17\x02,\x1a]\x20use\x20and\x20\
    app\x20combo.\x20Not\x20really\x20used\x20for\x20this\x20endpoint\x20at\
    \x20this\x20time\x20so\x20may\x20go\x20away\x20in\x20future.\n\n\r\n\x05\
    \x04_\x02\0\x06\x12\x04\xd3\x17\x02\x1b\n\r\n\x05\x04_\x02\0\x01\x12\x04\
    \xd3\x17\x1c'\n\r\n\x05\x04_\x02\0\x03\x12\x04\xd3\x17*+\n?\n\x04\x04_\
    \x02\x01\x12\x04\xd5\x17\x02\x1b\x1a1\x20The\x20specific\x20ModelType.Id\
    \x20you\x20want\x20to\x20retrieve.\n\n\r\n\x05\x04_\x02\x01\x05\x12\x04\
    \xd5\x17\x02\x08\n\r\n\x05\x04_\x02\x01\x01\x12\x04\xd5\x17\t\x16\n\r\n\
    \x05\x04_\x02\x01\x03\x12\x04\xd5\x17\x19\x1a\n\x0c\n\x02\x04`\x12\x06\
    \xd8\x17\0\xe1\x17\x01\n\x0b\n\x03\x04`\x01\x12\x04\xd8\x17\x08\x1d\nk\n\
    \x04\x04`\x02\0\x12\x04\xda\x17\x02,\x1a]\x20use\x20and\x20app\x20combo.\
    \x20Not\x20really\x20used\x20for\x20this\x20endpoint\x20at\x20this\x20ti\
    me\x20so\x20may\x20go\x20away\x20in\x20future.\n\n\r\n\x05\x04`\x02\0\
    \x06\x12\x04\xda\x17\x02\x1b\n\r\n\x05\x04`\x02\0\x01\x12\x04\xda\x17\
    \x1c'\n\r\n\x05\x04`\x02\0\x03\x12\x04\xda\x17*+\n~\n\x04\x04`\x02\x01\
    \x12\x04\xdd\x17\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    `\x02\x01\x05\x12\x04\xdd\x17\x02\x08\n\r\n\x05\x04`\x02\x01\x01\x12\x04\
    \xdd\x17\t\r\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xdd\x17\x10\x11\nu\n\x04\
    \x04`\x02\x02\x12\x04\xe0\x17\x02\x16\x1ag\x20(optional\x20URL\x20parame\
    ter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20containe\
    d\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04`\
    \x02\x02\x05\x12\x04\xe0\x17\x02\x08\n\r\n\x05\x04`\x02\x02\x01\x12\x04\
    \xe0\x17\t\x11\n\r\n\x05\x04`\x02\x02\x03\x12\x04\xe0\x17\x14\x15\n\x0c\
    \n\x02\x04a\x12\x06\xe3\x17\0\xe8\x17\x01\n\x0b\n\x03\x04a\x01\x12\x04\
    \xe3\x17\x08\x1f\n'\n\x04\x04a\x02\0\x12\x04\xe5\x17\x02(\x1a\x19\x20Sta\
    tus\x20of\x20the\x20response.\n\n\r\n\x05\x04a\x02\0\x06\x12\x04\xe5\x17\
    \x02\x1c\n\r\n\x05\x04a\x02\0\x01\x12\x04\xe5\x17\x1d#\n\r\n\x05\x04a\
    \x02\0\x03\x12\x04\xe5\x17&'\n1\n\x04\x04a\x02\x01\x12\x04\xe7\x17\x02J\
    \x1a#\x20The\x20retrieved\x20ModelType\x20object.\x20.\n\n\r\n\x05\x04a\
    \x02\x01\x06\x12\x04\xe7\x17\x02\x0b\n\r\n\x05\x04a\x02\x01\x01\x12\x04\
    \xe7\x17\x0c\x16\n\r\n\x05\x04a\x02\x01\x03\x12\x04\xe7\x17\x19\x1a\n\r\
    \n\x05\x04a\x02\x01\x08\x12\x04\xe7\x17\x1bI\n\x10\n\x08\x04a\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xe7\x17\x1cH\n\x0c\n\x02\x04b\x12\x06\xea\x17\0\
    \xef\x17\x01\n\x0b\n\x03\x04b\x01\x12\x04\xea\x17\x08\x1e\n'\n\x04\x04b\
    \x02\0\x12\x04\xec\x17\x02(\x1a\x19\x20Status\x20of\x20the\x20response.\
    \n\n\r\n\x05\x04b\x02\0\x06\x12\x04\xec\x17\x02\x1c\n\r\n\x05\x04b\x02\0\
    \x01\x12\x04\xec\x17\x1d#\n\r\n\x05\x04b\x02\0\x03\x12\x04\xec\x17&'\n*\
    \n\x04\x04b\x02\x01\x12\x04\xee\x17\x02T\x1a\x1c\x20List\x20of\x20ModelT\
    ype\x20objects.\n\n\r\n\x05\x04b\x02\x01\x04\x12\x04\xee\x17\x02\n\n\r\n\
    \x05\x04b\x02\x01\x06\x12\x04\xee\x17\x0b\x14\n\r\n\x05\x04b\x02\x01\x01\
    \x12\x04\xee\x17\x15\x20\n\r\n\x05\x04b\x02\x01\x03\x12\x04\xee\x17#$\n\
    \r\n\x05\x04b\x02\x01\x08\x12\x04\xee\x17%S\n\x10\n\x08\x04b\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xee\x17&R\n\xe9\x02\n\x02\x04c\x12\x06\xf9\x17\0\
    \xfc\x17\x01\x1a\xda\x02////////////////////////////////////////////////\
    //////////////////////////////\n\x20Requests\x20/\x20Responses\x20from\
    \x20/proto/clarifai/api/output.proto\n//////////////////////////////////\
    ////////////////////////////////////////////\n//////////////////////////\
    ////////////////////////\n\x20Outputs\x20related\x20requests\n//////////\
    ////////////////////////////////////////\n\n\x0b\n\x03\x04c\x01\x12\x04\
    \xf9\x17\x08\x1b\n\x0c\n\x04\x04c\x02\0\x12\x04\xfa\x17\x02(\n\r\n\x05\
    \x04c\x02\0\x06\x12\x04\xfa\x17\x02\x1c\n\r\n\x05\x04c\x02\0\x01\x12\x04\
    \xfa\x17\x1d#\n\r\n\x05\x04c\x02\0\x03\x12\x04\xfa\x17&'\n\x0c\n\x04\x04\
    c\x02\x01\x12\x04\xfb\x17\x02M\n\r\n\x05\x04c\x02\x01\x04\x12\x04\xfb\
    \x17\x02\n\n\r\n\x05\x04c\x02\x01\x06\x12\x04\xfb\x17\x0b\x11\n\r\n\x05\
    \x04c\x02\x01\x01\x12\x04\xfb\x17\x12\x19\n\r\n\x05\x04c\x02\x01\x03\x12\
    \x04\xfb\x17\x1c\x1d\n\r\n\x05\x04c\x02\x01\x08\x12\x04\xfb\x17\x1eL\n\
    \x10\n\x08\x04c\x02\x01\x08\xd0\x86\x03\x12\x04\xfb\x17\x1fK\n\xb9\x02\n\
    \x02\x04d\x12\x06\x88\x18\0\x8f\x18\x01\x1a\xd9\x01/////////////////////\
    /////////////////////////////////////////////////////////\n\x20Requests\
    \x20/\x20Responses\x20from\x20/proto/clarifai/api/scope.proto\n/////////\
    /////////////////////////////////////////////////////////////////////\n2\
    O///////////////////////////////////////////////////////////////////////\
    ///////\n\n\x0b\n\x03\x04d\x01\x12\x04\x88\x18\x08\x19\n\xc2\x01\n\x04\
    \x04d\x02\0\x12\x04\x8b\x18\x02\x16\x1a\xb3\x01\x20If\x20\"personal_acce\
    ss_token\"\x20include\x20scopes\x20and\x20endpoints\x20available\x20to\
    \x20personal\x20access\x20tokens.\n\x20If\x20\"api_key\"\x20include\x20s\
    copes\x20and\x20endpoints\x20available\x20to\x20app-specific\x20keys.\
    \x20(default)\n\n\r\n\x05\x04d\x02\0\x05\x12\x04\x8b\x18\x02\x08\n\r\n\
    \x05\x04d\x02\0\x01\x12\x04\x8b\x18\t\x11\n\r\n\x05\x04d\x02\0\x03\x12\
    \x04\x8b\x18\x14\x15\no\n\x04\x04d\x02\x01\x12\x04\x8e\x18\x02,\x1aa\x20\
    For\x20all\x20user\x20specific\x20information\x20we\x20include\x20user_a\
    pp_id\x20to\x20get\x20the\x20user_id\x20in\x20a\x20consistent\x20way\n\n\
    \r\n\x05\x04d\x02\x01\x06\x12\x04\x8e\x18\x02\x1b\n\r\n\x05\x04d\x02\x01\
    \x01\x12\x04\x8e\x18\x1c'\n\r\n\x05\x04d\x02\x01\x03\x12\x04\x8e\x18*+\n\
    \x0c\n\x02\x04e\x12\x06\x91\x18\0\x93\x18\x01\n\x0b\n\x03\x04e\x01\x12\
    \x04\x91\x18\x08\x17\n\x0c\n\x04\x04e\x02\0\x12\x04\x92\x18\x02,\n\r\n\
    \x05\x04e\x02\0\x06\x12\x04\x92\x18\x02\x1b\n\r\n\x05\x04e\x02\0\x01\x12\
    \x04\x92\x18\x1c'\n\r\n\x05\x04e\x02\0\x03\x12\x04\x92\x18*+\n\x0c\n\x02\
    \x04f\x12\x06\x95\x18\0\x9e\x18\x01\n\x0b\n\x03\x04f\x01\x12\x04\x95\x18\
    \x08\x1e\n*\n\x04\x04f\x02\0\x12\x04\x97\x18\x02(\x1a\x1c\x20The\x20stat\
    us\x20of\x20the\x20request.\n\n\r\n\x05\x04f\x02\0\x06\x12\x04\x97\x18\
    \x02\x1c\n\r\n\x05\x04f\x02\0\x01\x12\x04\x97\x18\x1d#\n\r\n\x05\x04f\
    \x02\0\x03\x12\x04\x97\x18&'\nL\n\x04\x04f\x02\x01\x12\x04\x99\x18\x02$\
    \x1a>\x20scopes\x20is\x20a\x20list\x20of\x20low-level\x20scopes\x20and\
    \x20their\x20dependencies.\n\n\r\n\x05\x04f\x02\x01\x04\x12\x04\x99\x18\
    \x02\n\n\r\n\x05\x04f\x02\x01\x06\x12\x04\x99\x18\x0b\x14\n\r\n\x05\x04f\
    \x02\x01\x01\x12\x04\x99\x18\x15\x1f\n\r\n\x05\x04f\x02\x01\x03\x12\x04\
    \x99\x18\"#\n\xc2\x01\n\x04\x04f\x02\x02\x12\x04\x9d\x18\x02*\x1a\xb3\
    \x01\x20endpoint_scopes\x20is\x20a\x20listof\x20all\x20the\x20publicly\
    \x20available\x20endponts\x20which\x20can\x20be\n\x20used\x20as\x20scope\
    s\x20as\x20well.\x20A\x20call\x20to\x20each\x20of\x20those\x20endpoint\
    \x20depends\x20on\x20a\x20subset\n\x20of\x20the\x20above\x20\"scopes\"\n\
    \n\r\n\x05\x04f\x02\x02\x04\x12\x04\x9d\x18\x02\n\n\r\n\x05\x04f\x02\x02\
    \x06\x12\x04\x9d\x18\x0b\x17\n\r\n\x05\x04f\x02\x02\x01\x12\x04\x9d\x18\
    \x18%\n\r\n\x05\x04f\x02\x02\x03\x12\x04\x9d\x18()\n\x0c\n\x02\x04g\x12\
    \x06\xa0\x18\0\xa9\x18\x01\n\x0b\n\x03\x04g\x01\x12\x04\xa0\x18\x08\x1a\
    \n*\n\x04\x04g\x02\0\x12\x04\xa2\x18\x02(\x1a\x1c\x20The\x20status\x20of\
    \x20the\x20request.\n\n\r\n\x05\x04g\x02\0\x06\x12\x04\xa2\x18\x02\x1c\n\
    \r\n\x05\x04g\x02\0\x01\x12\x04\xa2\x18\x1d#\n\r\n\x05\x04g\x02\0\x03\
    \x12\x04\xa2\x18&'\n?\n\x04\x04g\x02\x01\x12\x04\xa4\x18\x02\x1d\x1a1\
    \x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\x20that\x20your\x20ke\
    y\x20has.\n\n\r\n\x05\x04g\x02\x01\x04\x12\x04\xa4\x18\x02\n\n\r\n\x05\
    \x04g\x02\x01\x05\x12\x04\xa4\x18\x0b\x11\n\r\n\x05\x04g\x02\x01\x01\x12\
    \x04\xa4\x18\x12\x18\n\r\n\x05\x04g\x02\x01\x03\x12\x04\xa4\x18\x1b\x1c\
    \n3\n\x04\x04g\x02\x02\x12\x04\xa6\x18\x02\x0e\x1a%\x20The\x20app\x20tha\
    t\x20the\x20key\x20has\x20access\x20to.\n\n\r\n\x05\x04g\x02\x02\x06\x12\
    \x04\xa6\x18\x02\x05\n\r\n\x05\x04g\x02\x02\x01\x12\x04\xa6\x18\x06\t\n\
    \r\n\x05\x04g\x02\x02\x03\x12\x04\xa6\x18\x0c\r\nI\n\x04\x04g\x02\x03\
    \x12\x04\xa8\x18\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoi\
    nt\x20permissions\x20that\x20your\x20key\x20has.\n\n\r\n\x05\x04g\x02\
    \x03\x04\x12\x04\xa8\x18\x02\n\n\r\n\x05\x04g\x02\x03\x05\x12\x04\xa8\
    \x18\x0b\x11\n\r\n\x05\x04g\x02\x03\x01\x12\x04\xa8\x18\x12\x1b\n\r\n\
    \x05\x04g\x02\x03\x03\x12\x04\xa8\x18\x1e\x1f\n\xba\x02\n\x02\x04h\x12\
    \x06\xb5\x18\0\xb8\x18\x01\x1a\xda\x01//////////////////////////////////\
    ////////////////////////////////////////////\n\x20Requests\x20/\x20Respo\
    nses\x20from\x20/proto/clarifai/api/search.proto\n//////////////////////\
    ////////////////////////////////////////////////////////\n2O////////////\
    //////////////////////////////////////////////////////////////////\n\n\
    \x0b\n\x03\x04h\x01\x12\x04\xb5\x18\x08\x18\n\x0c\n\x04\x04h\x02\0\x12\
    \x04\xb6\x18\x02,\n\r\n\x05\x04h\x02\0\x06\x12\x04\xb6\x18\x02\x1b\n\r\n\
    \x05\x04h\x02\0\x01\x12\x04\xb6\x18\x1c'\n\r\n\x05\x04h\x02\0\x03\x12\
    \x04\xb6\x18*+\n\x0c\n\x04\x04h\x02\x01\x12\x04\xb7\x18\x02\x10\n\r\n\
    \x05\x04h\x02\x01\x05\x12\x04\xb7\x18\x02\x08\n\r\n\x05\x04h\x02\x01\x01\
    \x12\x04\xb7\x18\t\x0b\n\r\n\x05\x04h\x02\x01\x03\x12\x04\xb7\x18\x0e\
    \x0f\n\x0c\n\x02\x04i\x12\x06\xba\x18\0\xc2\x18\x01\n\x0b\n\x03\x04i\x01\
    \x12\x04\xba\x18\x08\x1b\n\x0c\n\x04\x04i\x02\0\x12\x04\xbb\x18\x02,\n\r\
    \n\x05\x04i\x02\0\x06\x12\x04\xbb\x18\x02\x1b\n\r\n\x05\x04i\x02\0\x01\
    \x12\x04\xbb\x18\x1c'\n\r\n\x05\x04i\x02\0\x03\x12\x04\xbb\x18*+\n~\n\
    \x04\x04i\x02\x01\x12\x04\xbe\x18\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04i\x02\x01\x05\x12\x04\xbe\x18\x02\x08\n\r\n\x05\x04i\x02\x01\
    \x01\x12\x04\xbe\x18\t\r\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xbe\x18\x10\
    \x11\nu\n\x04\x04i\x02\x02\x12\x04\xc1\x18\x02\x16\x1ag\x20(optional\x20\
    URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20b\
    e\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\
    \n\x05\x04i\x02\x02\x05\x12\x04\xc1\x18\x02\x08\n\r\n\x05\x04i\x02\x02\
    \x01\x12\x04\xc1\x18\t\x11\n\r\n\x05\x04i\x02\x02\x03\x12\x04\xc1\x18\
    \x14\x15\n\x0c\n\x02\x04j\x12\x06\xc4\x18\0\xd2\x18\x01\n\x0b\n\x03\x04j\
    \x01\x12\x04\xc4\x18\x08\x1b\n5\n\x04\x04j\x02\0\x12\x04\xc6\x18\x02,\
    \x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\r\n\
    \x05\x04j\x02\0\x06\x12\x04\xc6\x18\x02\x1b\n\r\n\x05\x04j\x02\0\x01\x12\
    \x04\xc6\x18\x1c'\n\r\n\x05\x04j\x02\0\x03\x12\x04\xc6\x18*+\nj\n\x04\
    \x04j\x02\x01\x12\x04\xca\x18\x02$\x1a\\\x20The\x20query;\x20this\x20spe\
    cifies\x20how\x20the\x20data\x20to\x20be\x20searched\n\x20this\x20will\
    \x20be\x20replaced\x20by\x20\"Searches\"\n\n\r\n\x05\x04j\x02\x01\x06\
    \x12\x04\xca\x18\x02\x07\n\r\n\x05\x04j\x02\x01\x01\x12\x04\xca\x18\x08\
    \r\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xca\x18\x10\x11\n\r\n\x05\x04j\x02\
    \x01\x08\x12\x04\xca\x18\x12#\n\x0e\n\x06\x04j\x02\x01\x08\x03\x12\x04\
    \xca\x18\x13\"\n\x84\x01\n\x04\x04j\x02\x02\x12\x04\xce\x18\x02\x1f\x1av\
    \x20The\x20searched\x20to\x20be\x20executed\x20or\x20saved\n\x20Eventual\
    ly\x20the\x20request\x20level\x20fields\x20will\x20be\x20deprecated\x20i\
    n\x20favor\x20of\x20this\x20object\n\n\r\n\x05\x04j\x02\x02\x04\x12\x04\
    \xce\x18\x02\n\n\r\n\x05\x04j\x02\x02\x06\x12\x04\xce\x18\x0b\x11\n\r\n\
    \x05\x04j\x02\x02\x01\x12\x04\xce\x18\x12\x1a\n\r\n\x05\x04j\x02\x02\x03\
    \x12\x04\xce\x18\x1d\x1e\nN\n\x04\x04j\x02\x03\x12\x04\xd1\x18\x02\x1c\
    \x1a@\x20Pagination\x20information\x20to\x20paginate\x20through\x20searc\
    h\x20result\x20Hits.\n\n\r\n\x05\x04j\x02\x03\x06\x12\x04\xd1\x18\x02\
    \x0c\n\r\n\x05\x04j\x02\x03\x01\x12\x04\xd1\x18\r\x17\n\r\n\x05\x04j\x02\
    \x03\x03\x12\x04\xd1\x18\x1a\x1b\n_\n\x02\x04k\x12\x06\xd5\x18\0\xdd\x18\
    \x01\x1aQ\x20PostSearchesByIDRequest\x20performs\x20returns\x20results\
    \x20of\x20a\x20saved\x20search\x20given\x20its\x20ID\n\n\x0b\n\x03\x04k\
    \x01\x12\x04\xd5\x18\x08\x1f\n\x0c\n\x04\x04k\x02\0\x12\x04\xd6\x18\x02,\
    \n\r\n\x05\x04k\x02\0\x06\x12\x04\xd6\x18\x02\x1b\n\r\n\x05\x04k\x02\0\
    \x01\x12\x04\xd6\x18\x1c'\n\r\n\x05\x04k\x02\0\x03\x12\x04\xd6\x18*+\n2\
    \n\x04\x04k\x02\x01\x12\x04\xd9\x18\x02\x10\x1a$\x20ID\x20for\x20saves\
    \x20search\x20to\x20be\x20executed\n\n\r\n\x05\x04k\x02\x01\x05\x12\x04\
    \xd9\x18\x02\x08\n\r\n\x05\x04k\x02\x01\x01\x12\x04\xd9\x18\t\x0b\n\r\n\
    \x05\x04k\x02\x01\x03\x12\x04\xd9\x18\x0e\x0f\nN\n\x04\x04k\x02\x02\x12\
    \x04\xdc\x18\x02\x1c\x1a@\x20Pagination\x20information\x20to\x20paginate\
    \x20through\x20search\x20result\x20Hits.\n\n\r\n\x05\x04k\x02\x02\x06\
    \x12\x04\xdc\x18\x02\x0c\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xdc\x18\r\
    \x17\n\r\n\x05\x04k\x02\x02\x03\x12\x04\xdc\x18\x1a\x1b\n\x0c\n\x02\x04l\
    \x12\x06\xdf\x18\0\xe2\x18\x01\n\x0b\n\x03\x04l\x01\x12\x04\xdf\x18\x08\
    \x1b\n\x0c\n\x04\x04l\x02\0\x12\x04\xe0\x18\x02,\n\r\n\x05\x04l\x02\0\
    \x06\x12\x04\xe0\x18\x02\x1b\n\r\n\x05\x04l\x02\0\x01\x12\x04\xe0\x18\
    \x1c'\n\r\n\x05\x04l\x02\0\x03\x12\x04\xe0\x18*+\n\x0c\n\x04\x04l\x02\
    \x01\x12\x04\xe1\x18\x02\x10\n\r\n\x05\x04l\x02\x01\x05\x12\x04\xe1\x18\
    \x02\x08\n\r\n\x05\x04l\x02\x01\x01\x12\x04\xe1\x18\t\x0b\n\r\n\x05\x04l\
    \x02\x01\x03\x12\x04\xe1\x18\x0e\x0f\n\x86\x01\n\x02\x04m\x12\x06\xe7\
    \x18\0\xf0\x18\x01\x1ax\x20Execute\x20a\x20new\x20annotation\x20search\
    \x20and\x20optionally\x20save\x20it\n\x20annotation\x20search\x20over\
    \x20annotations\x20using\x20rank\x20and\x20filter\x20proto\n\n\x0b\n\x03\
    \x04m\x01\x12\x04\xe7\x18\x08&\n5\n\x04\x04m\x02\0\x12\x04\xe9\x18\x02,\
    \x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\r\n\
    \x05\x04m\x02\0\x06\x12\x04\xe9\x18\x02\x1b\n\r\n\x05\x04m\x02\0\x01\x12\
    \x04\xe9\x18\x1c'\n\r\n\x05\x04m\x02\0\x03\x12\x04\xe9\x18*+\n4\n\x04\
    \x04m\x02\x01\x12\x04\xec\x18\x02\x1f\x1a&\x20The\x20searched\x20to\x20b\
    e\x20executed\x20or\x20saved\n\n\r\n\x05\x04m\x02\x01\x04\x12\x04\xec\
    \x18\x02\n\n\r\n\x05\x04m\x02\x01\x06\x12\x04\xec\x18\x0b\x11\n\r\n\x05\
    \x04m\x02\x01\x01\x12\x04\xec\x18\x12\x1a\n\r\n\x05\x04m\x02\x01\x03\x12\
    \x04\xec\x18\x1d\x1e\nN\n\x04\x04m\x02\x02\x12\x04\xef\x18\x02\x1c\x1a@\
    \x20Pagination\x20information\x20to\x20paginate\x20through\x20search\x20\
    result\x20Hits.\n\n\r\n\x05\x04m\x02\x02\x06\x12\x04\xef\x18\x02\x0c\n\r\
    \n\x05\x04m\x02\x02\x01\x12\x04\xef\x18\r\x17\n\r\n\x05\x04m\x02\x02\x03\
    \x12\x04\xef\x18\x1a\x1b\n\x0c\n\x02\x04n\x12\x06\xf2\x18\0\xf5\x18\x01\
    \n\x0b\n\x03\x04n\x01\x12\x04\xf2\x18\x08,\n\x0c\n\x04\x04n\x02\0\x12\
    \x04\xf3\x18\x02,\n\r\n\x05\x04n\x02\0\x06\x12\x04\xf3\x18\x02\x1b\n\r\n\
    \x05\x04n\x02\0\x01\x12\x04\xf3\x18\x1c'\n\r\n\x05\x04n\x02\0\x03\x12\
    \x04\xf3\x18*+\n\x0c\n\x04\x04n\x02\x01\x12\x04\xf4\x18\x02\x10\n\r\n\
    \x05\x04n\x02\x01\x05\x12\x04\xf4\x18\x02\x08\n\r\n\x05\x04n\x02\x01\x01\
    \x12\x04\xf4\x18\t\x0b\n\r\n\x05\x04n\x02\x01\x03\x12\x04\xf4\x18\x0e\
    \x0f\nA\n\x02\x04o\x12\x06\xf8\x18\0\x81\x19\x01\x1a3\x20Execute\x20a\
    \x20new\x20input\x20search\x20and\x20optionally\x20save\x20it\n\n\x0b\n\
    \x03\x04o\x01\x12\x04\xf8\x18\x08!\n5\n\x04\x04o\x02\0\x12\x04\xfa\x18\
    \x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\
    \n\r\n\x05\x04o\x02\0\x06\x12\x04\xfa\x18\x02\x1b\n\r\n\x05\x04o\x02\0\
    \x01\x12\x04\xfa\x18\x1c'\n\r\n\x05\x04o\x02\0\x03\x12\x04\xfa\x18*+\n4\
    \n\x04\x04o\x02\x01\x12\x04\xfd\x18\x02\x1f\x1a&\x20The\x20searched\x20t\
    o\x20be\x20executed\x20or\x20saved\n\n\r\n\x05\x04o\x02\x01\x04\x12\x04\
    \xfd\x18\x02\n\n\r\n\x05\x04o\x02\x01\x06\x12\x04\xfd\x18\x0b\x11\n\r\n\
    \x05\x04o\x02\x01\x01\x12\x04\xfd\x18\x12\x1a\n\r\n\x05\x04o\x02\x01\x03\
    \x12\x04\xfd\x18\x1d\x1e\nN\n\x04\x04o\x02\x02\x12\x04\x80\x19\x02\x1c\
    \x1a@\x20Pagination\x20information\x20to\x20paginate\x20through\x20searc\
    h\x20result\x20Hits.\n\n\r\n\x05\x04o\x02\x02\x06\x12\x04\x80\x19\x02\
    \x0c\n\r\n\x05\x04o\x02\x02\x01\x12\x04\x80\x19\r\x17\n\r\n\x05\x04o\x02\
    \x02\x03\x12\x04\x80\x19\x1a\x1b\nY\n\x02\x04p\x12\x06\x84\x19\0\x88\x19\
    \x01\x1aK\x20SingleSearchResponse\x20returns\x20saved\x20search\x20in\
    \x20response\x20to\x20GetSearchRequest\n\n\x0b\n\x03\x04p\x01\x12\x04\
    \x84\x19\x08\x1c\n<\n\x04\x04p\x02\0\x12\x04\x86\x19\x02(\x1a.\x20Status\
    \x20of\x20whether\x20the\x20search\x20was\x20successful.\n\n\r\n\x05\x04\
    p\x02\0\x06\x12\x04\x86\x19\x02\x1c\n\r\n\x05\x04p\x02\0\x01\x12\x04\x86\
    \x19\x1d#\n\r\n\x05\x04p\x02\0\x03\x12\x04\x86\x19&'\n\x0c\n\x04\x04p\
    \x02\x01\x12\x04\x87\x19\x02\x14\n\r\n\x05\x04p\x02\x01\x06\x12\x04\x87\
    \x19\x02\x08\n\r\n\x05\x04p\x02\x01\x01\x12\x04\x87\x19\t\x0f\n\r\n\x05\
    \x04p\x02\x01\x03\x12\x04\x87\x19\x12\x13\n\x0c\n\x02\x04q\x12\x06\x8a\
    \x19\0\x99\x19\x01\n\x0b\n\x03\x04q\x01\x12\x04\x8a\x19\x08\x1b\n<\n\x04\
    \x04q\x02\0\x12\x04\x8c\x19\x02(\x1a.\x20Status\x20of\x20whether\x20the\
    \x20search\x20was\x20successful.\n\n\r\n\x05\x04q\x02\0\x06\x12\x04\x8c\
    \x19\x02\x1c\n\r\n\x05\x04q\x02\0\x01\x12\x04\x8c\x19\x1d#\n\r\n\x05\x04\
    q\x02\0\x03\x12\x04\x8c\x19&'\n>\n\x04\x04q\x02\x01\x12\x04\x8f\x19\x02\
    \x10\x1a0\x20A\x20unique\x20id\x20which\x20uniquely\x20identifies\x20a\
    \x20search\n\n\r\n\x05\x04q\x02\x01\x05\x12\x04\x8f\x19\x02\x08\n\r\n\
    \x05\x04q\x02\x01\x01\x12\x04\x8f\x19\t\x0b\n\r\n\x05\x04q\x02\x01\x03\
    \x12\x04\x8f\x19\x0e\x0f\n/\n\x04\x04q\x02\x02\x12\x04\x92\x19\x02G\x1a!\
    \x20The\x20list\x20of\x20search\x20result\x20Hits.\n\n\r\n\x05\x04q\x02\
    \x02\x04\x12\x04\x92\x19\x02\n\n\r\n\x05\x04q\x02\x02\x06\x12\x04\x92\
    \x19\x0b\x0e\n\r\n\x05\x04q\x02\x02\x01\x12\x04\x92\x19\x0f\x13\n\r\n\
    \x05\x04q\x02\x02\x03\x12\x04\x92\x19\x16\x17\n\r\n\x05\x04q\x02\x02\x08\
    \x12\x04\x92\x19\x18F\n\x10\n\x08\x04q\x02\x02\x08\xd0\x86\x03\x12\x04\
    \x92\x19\x19E\n;\n\x04\x04q\x02\x03\x12\x04\x95\x19\x02\x12\x1a-\x20The\
    \x20original\x20query\x20provided\x20in\x20the\x20request.\n\n\r\n\x05\
    \x04q\x02\x03\x06\x12\x04\x95\x19\x02\x07\n\r\n\x05\x04q\x02\x03\x01\x12\
    \x04\x95\x19\x08\r\n\r\n\x05\x04q\x02\x03\x03\x12\x04\x95\x19\x10\x11\n>\
    \n\x04\x04q\x02\x04\x12\x04\x98\x19\x02\x1f\x1a0\x20The\x20original\x20S\
    earches\x20provided\x20in\x20the\x20request.\n\n\r\n\x05\x04q\x02\x04\
    \x04\x12\x04\x98\x19\x02\n\n\r\n\x05\x04q\x02\x04\x06\x12\x04\x98\x19\
    \x0b\x11\n\r\n\x05\x04q\x02\x04\x01\x12\x04\x98\x19\x12\x1a\n\r\n\x05\
    \x04q\x02\x04\x03\x12\x04\x98\x19\x1d\x1e\n\x0c\n\x02\x04r\x12\x06\x9b\
    \x19\0\xad\x19\x01\n\x0b\n\x03\x04r\x01\x12\x04\x9b\x19\x08*\n\x0c\n\x04\
    \x04r\x02\0\x12\x04\x9c\x19\x02,\n\r\n\x05\x04r\x02\0\x06\x12\x04\x9c\
    \x19\x02\x1b\n\r\n\x05\x04r\x02\0\x01\x12\x04\x9c\x19\x1c'\n\r\n\x05\x04\
    r\x02\0\x03\x12\x04\x9c\x19*+\nI\n\x04\x04r\x02\x01\x12\x04\x9f\x19\x02\
    \x10\x1a;\x20A\x20unique\x20customer\x20facing\x20id\x20to\x20identify\
    \x20this\x20eval\x20request\n\n\r\n\x05\x04r\x02\x01\x05\x12\x04\x9f\x19\
    \x02\x08\n\r\n\x05\x04r\x02\x01\x01\x12\x04\x9f\x19\t\x0b\n\r\n\x05\x04r\
    \x02\x01\x03\x12\x04\x9f\x19\x0e\x0f\n:\n\x04\x04r\x02\x02\x12\x04\xa2\
    \x19\x02'\x1a,\x20The\x20ground\x20truth\x20we\x20are\x20evaluating\x20a\
    gainst\n\n\r\n\x05\x04r\x02\x02\x06\x12\x04\xa2\x19\x02\x15\n\r\n\x05\
    \x04r\x02\x02\x01\x12\x04\xa2\x19\x16\"\n\r\n\x05\x04r\x02\x02\x03\x12\
    \x04\xa2\x19%&\n)\n\x04\x04r\x02\x03\x12\x04\xa5\x19\x02)\x1a\x1b\x20The\
    \x20set\x20we\x20are\x20evaluating\n\n\r\n\x05\x04r\x02\x03\x06\x12\x04\
    \xa5\x19\x02\x15\n\r\n\x05\x04r\x02\x03\x01\x12\x04\xa5\x19\x16$\n\r\n\
    \x05\x04r\x02\x03\x03\x12\x04\xa5\x19'(\nx\n\x04\x04r\x02\x04\x12\x04\
    \xa9\x19\x02\x10\x1aj\x20List\x20of\x20concepts\x20to\x20evaluate\x20are\
    \x20expected\x20to\x20be\x20in\x20data.concepts\n\x20If\x20nil,\x20then\
    \x20all\x20app\x20concepts\x20are\x20used\n\n\r\n\x05\x04r\x02\x04\x06\
    \x12\x04\xa9\x19\x02\x06\n\r\n\x05\x04r\x02\x04\x01\x12\x04\xa9\x19\x07\
    \x0b\n\r\n\x05\x04r\x02\x04\x03\x12\x04\xa9\x19\x0e\x0f\n-\n\x04\x04r\
    \x02\x05\x12\x04\xac\x19\x02%\x1a\x1f\x20The\x20type\x20of\x20evaluation\
    \x20to\x20use\n\n\r\n\x05\x04r\x02\x05\x06\x12\x04\xac\x19\x02\x10\n\r\n\
    \x05\x04r\x02\x05\x01\x12\x04\xac\x19\x11\x20\n\r\n\x05\x04r\x02\x05\x03\
    \x12\x04\xac\x19#$\n\x0c\n\x02\x04s\x12\x06\xaf\x19\0\xb4\x19\x01\n\x0b\
    \n\x03\x04s\x01\x12\x04\xaf\x19\x08)\n\x0c\n\x04\x04s\x02\0\x12\x04\xb0\
    \x19\x02,\n\r\n\x05\x04s\x02\0\x06\x12\x04\xb0\x19\x02\x1b\n\r\n\x05\x04\
    s\x02\0\x01\x12\x04\xb0\x19\x1c'\n\r\n\x05\x04s\x02\0\x03\x12\x04\xb0\
    \x19*+\nG\n\x04\x04s\x02\x01\x12\x04\xb3\x19\x02\x10\x1a9\x20Unique\x20c\
    ustom\x20facing\x20id\x20that\x20identifies\x20the\x20eval\x20to\x20get\
    \n\n\r\n\x05\x04s\x02\x01\x05\x12\x04\xb3\x19\x02\x08\n\r\n\x05\x04s\x02\
    \x01\x01\x12\x04\xb3\x19\t\x0b\n\r\n\x05\x04s\x02\x01\x03\x12\x04\xb3\
    \x19\x0e\x0f\n\x0c\n\x02\x04t\x12\x06\xb6\x19\0\xb8\x19\x01\n\x0b\n\x03\
    \x04t\x01\x12\x04\xb6\x19\x08*\n\x0c\n\x04\x04t\x02\0\x12\x04\xb7\x19\
    \x02,\n\r\n\x05\x04t\x02\0\x06\x12\x04\xb7\x19\x02\x1b\n\r\n\x05\x04t\
    \x02\0\x01\x12\x04\xb7\x19\x1c'\n\r\n\x05\x04t\x02\0\x03\x12\x04\xb7\x19\
    *+\n\x0c\n\x02\x04u\x12\x06\xba\x19\0\xbe\x19\x01\n\x0b\n\x03\x04u\x01\
    \x12\x04\xba\x19\x08,\n%\n\x04\x04u\x02\0\x12\x04\xbc\x19\x02(\x1a\x17\
    \x20Status\x20of\x20the\x20request\n\n\r\n\x05\x04u\x02\0\x06\x12\x04\
    \xbc\x19\x02\x1c\n\r\n\x05\x04u\x02\0\x01\x12\x04\xbc\x19\x1d#\n\r\n\x05\
    \x04u\x02\0\x03\x12\x04\xbc\x19&'\n\x0c\n\x04\x04u\x02\x01\x12\x04\xbd\
    \x19\x02A\n\r\n\x05\x04u\x02\x01\x04\x12\x04\xbd\x19\x02\n\n\r\n\x05\x04\
    u\x02\x01\x06\x12\x04\xbd\x19\x0b\"\n\r\n\x05\x04u\x02\x01\x01\x12\x04\
    \xbd\x19#<\n\r\n\x05\x04u\x02\x01\x03\x12\x04\xbd\x19?@\n\x0c\n\x02\x04v\
    \x12\x06\xfb\x19\0\xff\x19\x01\n\x0b\n\x03\x04v\x01\x12\x04\xfb\x19\x08#\
    \n\x0c\n\x04\x04v\x02\0\x12\x04\xfc\x19\x02,\n\r\n\x05\x04v\x02\0\x06\
    \x12\x04\xfc\x19\x02\x1b\n\r\n\x05\x04v\x02\0\x01\x12\x04\xfc\x19\x1c'\n\
    \r\n\x05\x04v\x02\0\x03\x12\x04\xfc\x19*+\n(\n\x04\x04v\x02\x01\x12\x04\
    \xfe\x19\x02\x18\x1a\x1a\x20password\x20to\x20be\x20validated\n\n\r\n\
    \x05\x04v\x02\x01\x06\x12\x04\xfe\x19\x02\n\n\r\n\x05\x04v\x02\x01\x01\
    \x12\x04\xfe\x19\x0b\x13\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xfe\x19\x16\
    \x17\n\x0c\n\x02\x04w\x12\x06\x81\x1a\0\x85\x1a\x01\n\x0b\n\x03\x04w\x01\
    \x12\x04\x81\x1a\x08(\n-\n\x04\x04w\x02\0\x12\x04\x83\x1a\x02(\x1a\x1f\
    \x20Standard\x20clarifai\x20status\x20code\n\n\r\n\x05\x04w\x02\0\x06\
    \x12\x04\x83\x1a\x02\x1c\n\r\n\x05\x04w\x02\0\x01\x12\x04\x83\x1a\x1d#\n\
    \r\n\x05\x04w\x02\0\x03\x12\x04\x83\x1a&'\n\x0c\n\x04\x04w\x02\x01\x12\
    \x04\x84\x1a\x02-\n\r\n\x05\x04w\x02\x01\x06\x12\x04\x84\x1a\x02\x14\n\r\
    \n\x05\x04w\x02\x01\x01\x12\x04\x84\x1a\x15(\n\r\n\x05\x04w\x02\x01\x03\
    \x12\x04\x84\x1a+,\n\x0c\n\x02\x05\0\x12\x06\xa5\x1a\0\xac\x1a\x01\n\x0b\
    \n\x03\x05\0\x01\x12\x04\xa5\x1a\x05!\n\x0c\n\x04\x05\0\x02\0\x12\x04\
    \xa6\x1a\x02\x0e\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xa6\x1a\x02\t\n\r\n\
    \x05\x05\0\x02\0\x02\x12\x04\xa6\x1a\x0c\r\n\x0c\n\x04\x05\0\x02\x01\x12\
    \x04\xa7\x1a\x02\x0e\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xa7\x1a\x02\t\n\
    \r\n\x05\x05\0\x02\x01\x02\x12\x04\xa7\x1a\x0c\r\n\x0c\n\x04\x05\0\x02\
    \x02\x12\x04\xa8\x1a\x02\x0f\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xa8\x1a\
    \x02\n\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xa8\x1a\r\x0e\n\x0c\n\x04\x05\
    \0\x02\x03\x12\x04\xa9\x1a\x02\x10\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\
    \xa9\x1a\x02\x0b\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\xa9\x1a\x0e\x0f\n\
    \x0c\n\x04\x05\0\x02\x04\x12\x04\xaa\x1a\x02\x0f\n\r\n\x05\x05\0\x02\x04\
    \x01\x12\x04\xaa\x1a\x02\n\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\xaa\x1a\r\
    \x0e\n\x0c\n\x04\x05\0\x02\x05\x12\x04\xab\x1a\x02\x0e\n\r\n\x05\x05\0\
    \x02\x05\x01\x12\x04\xab\x1a\x02\t\n\r\n\x05\x05\0\x02\x05\x02\x12\x04\
    \xab\x1a\x0c\r\n\xbc\x02\n\x02\x04x\x12\x06\xf6\x1a\0\x80\x1b\x01\x1a\
    \xdc\x01////////////////////////////////////////////////////////////////\
    //////////////\n\x20Requests\x20/\x20Responses\x20from\x20/proto/clarifa\
    i/api/workflow.proto\n//////////////////////////////////////////////////\
    ////////////////////////////\n2O////////////////////////////////////////\
    //////////////////////////////////////\n\n\x0b\n\x03\x04x\x01\x12\x04\
    \xf6\x1a\x08\x1a\n\x0c\n\x04\x04x\x02\0\x12\x04\xf7\x1a\x02,\n\r\n\x05\
    \x04x\x02\0\x06\x12\x04\xf7\x1a\x02\x1b\n\r\n\x05\x04x\x02\0\x01\x12\x04\
    \xf7\x1a\x1c'\n\r\n\x05\x04x\x02\0\x03\x12\x04\xf7\x1a*+\n\xc8\x01\n\x04\
    \x04x\x02\x01\x12\x04\xfc\x1a\x02\x19\x1a\xb9\x01\x20Workflow\x20ID\x20t\
    o\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified\x20we\x20return\x20\
    default\x20workflow\x20of\x20the\x20application\n\x20If\x20an\x20ID\x20i\
    s\x20specified\x20by\x20default\x20we\x20first\x20looks\x20into\x20Clari\
    fai\x20workflows\x20for\x20a\x20Workflow\x20ID\n\n\r\n\x05\x04x\x02\x01\
    \x05\x12\x04\xfc\x1a\x02\x08\n\r\n\x05\x04x\x02\x01\x01\x12\x04\xfc\x1a\
    \t\x14\n\r\n\x05\x04x\x02\x01\x03\x12\x04\xfc\x1a\x17\x18\n_\n\x04\x04x\
    \x02\x02\x12\x04\xff\x1a\x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\
    \x20into\x20clarifai\x20published\x20workflows\x20first\x20for\x20a\x20W\
    orkflow\x20ID\n\n\r\n\x05\x04x\x02\x02\x05\x12\x04\xff\x1a\x02\x06\n\r\n\
    \x05\x04x\x02\x02\x01\x12\x04\xff\x1a\x07\x1f\n\r\n\x05\x04x\x02\x02\x03\
    \x12\x04\xff\x1a\"#\n\x0c\n\x02\x04y\x12\x06\x82\x1b\0\x8a\x1b\x01\n\x0b\
    \n\x03\x04y\x01\x12\x04\x82\x1b\x08\x1c\n\x0c\n\x04\x04y\x02\0\x12\x04\
    \x83\x1b\x02,\n\r\n\x05\x04y\x02\0\x06\x12\x04\x83\x1b\x02\x1b\n\r\n\x05\
    \x04y\x02\0\x01\x12\x04\x83\x1b\x1c'\n\r\n\x05\x04y\x02\0\x03\x12\x04\
    \x83\x1b*+\n~\n\x04\x04y\x02\x01\x12\x04\x86\x1b\x02\x12\x1ap\x20(option\
    al\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\r\n\x05\x04y\x02\x01\x05\x12\x04\x86\x1b\x02\x08\n\r\
    \n\x05\x04y\x02\x01\x01\x12\x04\x86\x1b\t\r\n\r\n\x05\x04y\x02\x01\x03\
    \x12\x04\x86\x1b\x10\x11\nu\n\x04\x04y\x02\x02\x12\x04\x89\x1b\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\r\n\x05\x04y\x02\x02\x05\x12\x04\x89\x1b\x02\x08\n\
    \r\n\x05\x04y\x02\x02\x01\x12\x04\x89\x1b\t\x11\n\r\n\x05\x04y\x02\x02\
    \x03\x12\x04\x89\x1b\x14\x15\n\x0c\n\x02\x04z\x12\x06\x8d\x1b\0\x90\x1b\
    \x01\n\x0b\n\x03\x04z\x01\x12\x04\x8d\x1b\x08\x1c\n\x0c\n\x04\x04z\x02\0\
    \x12\x04\x8e\x1b\x02,\n\r\n\x05\x04z\x02\0\x06\x12\x04\x8e\x1b\x02\x1b\n\
    \r\n\x05\x04z\x02\0\x01\x12\x04\x8e\x1b\x1c'\n\r\n\x05\x04z\x02\0\x03\
    \x12\x04\x8e\x1b*+\n\x0c\n\x04\x04z\x02\x01\x12\x04\x8f\x1b\x02\"\n\r\n\
    \x05\x04z\x02\x01\x04\x12\x04\x8f\x1b\x02\n\n\r\n\x05\x04z\x02\x01\x06\
    \x12\x04\x8f\x1b\x0b\x13\n\r\n\x05\x04z\x02\x01\x01\x12\x04\x8f\x1b\x14\
    \x1d\n\r\n\x05\x04z\x02\x01\x03\x12\x04\x8f\x1b\x20!\n\x0c\n\x02\x04{\
    \x12\x06\x92\x1b\0\x99\x1b\x01\n\x0b\n\x03\x04{\x01\x12\x04\x92\x1b\x08\
    \x1d\n\x0c\n\x04\x04{\x02\0\x12\x04\x93\x1b\x02,\n\r\n\x05\x04{\x02\0\
    \x06\x12\x04\x93\x1b\x02\x1b\n\r\n\x05\x04{\x02\0\x01\x12\x04\x93\x1b\
    \x1c'\n\r\n\x05\x04{\x02\0\x03\x12\x04\x93\x1b*+\n\x0c\n\x04\x04{\x02\
    \x01\x12\x04\x94\x1b\x02\"\n\r\n\x05\x04{\x02\x01\x04\x12\x04\x94\x1b\
    \x02\n\n\r\n\x05\x04{\x02\x01\x06\x12\x04\x94\x1b\x0b\x13\n\r\n\x05\x04{\
    \x02\x01\x01\x12\x04\x94\x1b\x14\x1d\n\r\n\x05\x04{\x02\x01\x03\x12\x04\
    \x94\x1b\x20!\n~\n\x04\x04{\x02\x02\x12\x04\x98\x1b\x02\x14\x1ap\x20The\
    \x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\
    \x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\
    \x20supported\n\n\r\n\x05\x04{\x02\x02\x05\x12\x04\x98\x1b\x02\x08\n\r\n\
    \x05\x04{\x02\x02\x01\x12\x04\x98\x1b\t\x0f\n\r\n\x05\x04{\x02\x02\x03\
    \x12\x04\x98\x1b\x12\x13\n\x0c\n\x02\x04|\x12\x06\x9b\x1b\0\x9e\x1b\x01\
    \n\x0b\n\x03\x04|\x01\x12\x04\x9b\x1b\x08\x1d\n\x0c\n\x04\x04|\x02\0\x12\
    \x04\x9c\x1b\x02,\n\r\n\x05\x04|\x02\0\x06\x12\x04\x9c\x1b\x02\x1b\n\r\n\
    \x05\x04|\x02\0\x01\x12\x04\x9c\x1b\x1c'\n\r\n\x05\x04|\x02\0\x03\x12\
    \x04\x9c\x1b*+\n\x0c\n\x04\x04|\x02\x01\x12\x04\x9d\x1b\x02\x19\n\r\n\
    \x05\x04|\x02\x01\x05\x12\x04\x9d\x1b\x02\x08\n\r\n\x05\x04|\x02\x01\x01\
    \x12\x04\x9d\x1b\t\x14\n\r\n\x05\x04|\x02\x01\x03\x12\x04\x9d\x1b\x17\
    \x18\nD\n\x02\x04}\x12\x06\xa1\x1b\0\xa5\x1b\x01\x1a6\x20Request\x20to\
    \x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\
    \x0b\n\x03\x04}\x01\x12\x04\xa1\x1b\x08\x1e\n\x0c\n\x04\x04}\x02\0\x12\
    \x04\xa2\x1b\x02,\n\r\n\x05\x04}\x02\0\x06\x12\x04\xa2\x1b\x02\x1b\n\r\n\
    \x05\x04}\x02\0\x01\x12\x04\xa2\x1b\x1c'\n\r\n\x05\x04}\x02\0\x03\x12\
    \x04\xa2\x1b*+\n\x0c\n\x04\x04}\x02\x01\x12\x04\xa3\x1b\x02\x1a\n\r\n\
    \x05\x04}\x02\x01\x04\x12\x04\xa3\x1b\x02\n\n\r\n\x05\x04}\x02\x01\x05\
    \x12\x04\xa3\x1b\x0b\x11\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xa3\x1b\x12\
    \x15\n\r\n\x05\x04}\x02\x01\x03\x12\x04\xa3\x1b\x18\x19\n\x0c\n\x04\x04}\
    \x02\x02\x12\x04\xa4\x1b\x02\x16\n\r\n\x05\x04}\x02\x02\x05\x12\x04\xa4\
    \x1b\x02\x06\n\r\n\x05\x04}\x02\x02\x01\x12\x04\xa4\x1b\x07\x11\n\r\n\
    \x05\x04}\x02\x02\x03\x12\x04\xa4\x1b\x14\x15\n\x0c\n\x02\x04~\x12\x06\
    \xa7\x1b\0\xaa\x1b\x01\n\x0b\n\x03\x04~\x01\x12\x04\xa7\x1b\x08\x1e\n\
    \x0c\n\x04\x04~\x02\0\x12\x04\xa8\x1b\x02(\n\r\n\x05\x04~\x02\0\x06\x12\
    \x04\xa8\x1b\x02\x1c\n\r\n\x05\x04~\x02\0\x01\x12\x04\xa8\x1b\x1d#\n\r\n\
    \x05\x04~\x02\0\x03\x12\x04\xa8\x1b&'\n\x0c\n\x04\x04~\x02\x01\x12\x04\
    \xa9\x1b\x02\x18\n\r\n\x05\x04~\x02\x01\x06\x12\x04\xa9\x1b\x02\n\n\r\n\
    \x05\x04~\x02\x01\x01\x12\x04\xa9\x1b\x0b\x13\n\r\n\x05\x04~\x02\x01\x03\
    \x12\x04\xa9\x1b\x16\x17\n\x0c\n\x02\x04\x7f\x12\x06\xae\x1b\0\xb1\x1b\
    \x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xae\x1b\x08\x1d\n\x0c\n\x04\x04\x7f\
    \x02\0\x12\x04\xaf\x1b\x02(\n\r\n\x05\x04\x7f\x02\0\x06\x12\x04\xaf\x1b\
    \x02\x1c\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xaf\x1b\x1d#\n\r\n\x05\x04\
    \x7f\x02\0\x03\x12\x04\xaf\x1b&'\n\x0c\n\x04\x04\x7f\x02\x01\x12\x04\xb0\
    \x1b\x02Q\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\xb0\x1b\x02\n\n\r\n\x05\
    \x04\x7f\x02\x01\x06\x12\x04\xb0\x1b\x0b\x13\n\r\n\x05\x04\x7f\x02\x01\
    \x01\x12\x04\xb0\x1b\x14\x1d\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\xb0\
    \x1b\x20!\n\r\n\x05\x04\x7f\x02\x01\x08\x12\x04\xb0\x1b\"P\n\x10\n\x08\
    \x04\x7f\x02\x01\x08\xd0\x86\x03\x12\x04\xb0\x1b#O\n\r\n\x03\x04\x80\x01\
    \x12\x06\xb3\x1b\0\xc6\x1b\x01\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xb3\
    \x1b\x08\"\n\r\n\x05\x04\x80\x01\x02\0\x12\x04\xb4\x1b\x02,\n\x0e\n\x06\
    \x04\x80\x01\x02\0\x06\x12\x04\xb4\x1b\x02\x1b\n\x0e\n\x06\x04\x80\x01\
    \x02\0\x01\x12\x04\xb4\x1b\x1c'\n\x0e\n\x06\x04\x80\x01\x02\0\x03\x12\
    \x04\xb4\x1b*+\n\xc9\x01\n\x05\x04\x80\x01\x02\x01\x12\x04\xb9\x1b\x02\
    \x19\x1a\xb9\x01\x20Workflow\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\
    \x20is\x20specified\x20we\x20return\x20default\x20workflow\x20of\x20the\
    \x20application\n\x20If\x20an\x20ID\x20is\x20specified\x20by\x20default\
    \x20we\x20first\x20looks\x20into\x20Clarifai\x20workflows\x20for\x20a\
    \x20Workflow\x20ID\n\n\x0e\n\x06\x04\x80\x01\x02\x01\x05\x12\x04\xb9\x1b\
    \x02\x08\n\x0e\n\x06\x04\x80\x01\x02\x01\x01\x12\x04\xb9\x1b\t\x14\n\x0e\
    \n\x06\x04\x80\x01\x02\x01\x03\x12\x04\xb9\x1b\x17\x18\n\r\n\x05\x04\x80\
    \x01\x02\x02\x12\x04\xbb\x1b\x02\x1c\n\x0e\n\x06\x04\x80\x01\x02\x02\x04\
    \x12\x04\xbb\x1b\x02\n\n\x0e\n\x06\x04\x80\x01\x02\x02\x06\x12\x04\xbb\
    \x1b\x0b\x10\n\x0e\n\x06\x04\x80\x01\x02\x02\x01\x12\x04\xbb\x1b\x11\x17\
    \n\x0e\n\x06\x04\x80\x01\x02\x02\x03\x12\x04\xbb\x1b\x1a\x1b\n\xb4\x04\n\
    \x05\x04\x80\x01\x02\x03\x12\x04\xc2\x1b\x02!\x1a\xa4\x04\x20FIXME(zeile\
    r):\x20the\x20request\x20for\x20post\x20workflows\x20is\x20using\x20an\
    \x20outputconfig\x20object\x20that\x20is\x20supposed\n\x20to\x20be\x20wi\
    thin\x20models.\x20This\x20is\x20not\x20consistent\x20with\x20setting\
    \x20this\x20on\x20the\x20request\x20for\x20post\x20model\n\x20outputs\
    \x20where\x20it\x20is\x20inside\x20a\x20model\x20object.\x20To\x20make\
    \x20this\x20consistent\x20we\x20would\x20send\x20in\x20the\n\x20workflow\
    \x20object\x20so\x20that\x20each\x20model\x20can\x20have\x20it's\x20own\
    \x20output\x20config.\x20If\x20nobody\x20is\x20setting\n\x20this\x20Outp\
    utConfig\x20it\x20would\x20probably\x20be\x20easier\x20to\x20just\x20rem\
    ove\x20it\x20for\x20now\x20to\x20keep\x20things\x20simpler\n\x20and\x20t\
    hen\x20it's\x20more\x20consistent\x20we\x20just\x20don't\x20support\x20t\
    he\x20OutputConfig\x20on\x20workflows.\n\n\x0e\n\x06\x04\x80\x01\x02\x03\
    \x06\x12\x04\xc2\x1b\x02\x0e\n\x0e\n\x06\x04\x80\x01\x02\x03\x01\x12\x04\
    \xc2\x1b\x0f\x1c\n\x0e\n\x06\x04\x80\x01\x02\x03\x03\x12\x04\xc2\x1b\x1f\
    \x20\n`\n\x05\x04\x80\x01\x02\x04\x12\x04\xc5\x1b\x02$\x1aQ\x20Use\x20th\
    is\x20flag\x20to\x20look\x20into\x20clarifai\x20published\x20workflows\
    \x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\x80\x01\x02\
    \x04\x05\x12\x04\xc5\x1b\x02\x06\n\x0e\n\x06\x04\x80\x01\x02\x04\x01\x12\
    \x04\xc5\x1b\x07\x1f\n\x0e\n\x06\x04\x80\x01\x02\x04\x03\x12\x04\xc5\x1b\
    \"#\n\r\n\x03\x04\x81\x01\x12\x06\xc8\x1b\0\xcc\x1b\x01\n\x0c\n\x04\x04\
    \x81\x01\x01\x12\x04\xc8\x1b\x08#\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\
    \xc9\x1b\x02(\n\x0e\n\x06\x04\x81\x01\x02\0\x06\x12\x04\xc9\x1b\x02\x1c\
    \n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\xc9\x1b\x1d#\n\x0e\n\x06\x04\
    \x81\x01\x02\0\x03\x12\x04\xc9\x1b&'\n\r\n\x05\x04\x81\x01\x02\x01\x12\
    \x04\xca\x1b\x02\x18\n\x0e\n\x06\x04\x81\x01\x02\x01\x06\x12\x04\xca\x1b\
    \x02\n\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\x04\xca\x1b\x0b\x13\n\x0e\
    \n\x06\x04\x81\x01\x02\x01\x03\x12\x04\xca\x1b\x16\x17\n\r\n\x05\x04\x81\
    \x01\x02\x02\x12\x04\xcb\x1b\x02&\n\x0e\n\x06\x04\x81\x01\x02\x02\x04\
    \x12\x04\xcb\x1b\x02\n\n\x0e\n\x06\x04\x81\x01\x02\x02\x06\x12\x04\xcb\
    \x1b\x0b\x19\n\x0e\n\x06\x04\x81\x01\x02\x02\x01\x12\x04\xcb\x1b\x1a!\n\
    \x0e\n\x06\x04\x81\x01\x02\x02\x03\x12\x04\xcb\x1b$%\n\r\n\x03\x04\x82\
    \x01\x12\x06\xce\x1b\0\xd9\x1b\x01\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\
    \xce\x1b\x08,\n\r\n\x05\x04\x82\x01\x02\0\x12\x04\xcf\x1b\x02,\n\x0e\n\
    \x06\x04\x82\x01\x02\0\x06\x12\x04\xcf\x1b\x02\x1b\n\x0e\n\x06\x04\x82\
    \x01\x02\0\x01\x12\x04\xcf\x1b\x1c'\n\x0e\n\x06\x04\x82\x01\x02\0\x03\
    \x12\x04\xcf\x1b*+\n\r\n\x05\x04\x82\x01\x02\x01\x12\x04\xd0\x1b\x02\x19\
    \n\x0e\n\x06\x04\x82\x01\x02\x01\x05\x12\x04\xd0\x1b\x02\x08\n\x0e\n\x06\
    \x04\x82\x01\x02\x01\x01\x12\x04\xd0\x1b\t\x14\n\x0e\n\x06\x04\x82\x01\
    \x02\x01\x03\x12\x04\xd0\x1b\x17\x18\nJ\n\x05\x04\x82\x01\x02\x02\x12\
    \x04\xd2\x1b\x02\x1e\x1a;\x20The\x20specific\x20model\x20version\x20whos\
    e\x20outputs\x20we\x20are\x20comparing\n\n\x0e\n\x06\x04\x82\x01\x02\x02\
    \x05\x12\x04\xd2\x1b\x02\x08\n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\
    \xd2\x1b\t\x19\n\x0e\n\x06\x04\x82\x01\x02\x02\x03\x12\x04\xd2\x1b\x1c\
    \x1d\n@\n\x05\x04\x82\x01\x02\x03\x12\x04\xd4\x1b\x02\"\x1a1\x20Each\x20\
    probe\x20is\x20compared\x20against\x20every\x20pool\x20input\n\n\x0e\n\
    \x06\x04\x82\x01\x02\x03\x04\x12\x04\xd4\x1b\x02\n\n\x0e\n\x06\x04\x82\
    \x01\x02\x03\x06\x12\x04\xd4\x1b\x0b\x10\n\x0e\n\x06\x04\x82\x01\x02\x03\
    \x01\x12\x04\xd4\x1b\x11\x1d\n\x0e\n\x06\x04\x82\x01\x02\x03\x03\x12\x04\
    \xd4\x1b\x20!\nE\n\x05\x04\x82\x01\x02\x04\x12\x04\xd6\x1b\x02!\x1a6\x20\
    Each\x20pool\x20input\x20is\x20compared\x20against\x20ever\x20probe\x20i\
    nput\n\n\x0e\n\x06\x04\x82\x01\x02\x04\x04\x12\x04\xd6\x1b\x02\n\n\x0e\n\
    \x06\x04\x82\x01\x02\x04\x06\x12\x04\xd6\x1b\x0b\x10\n\x0e\n\x06\x04\x82\
    \x01\x02\x04\x01\x12\x04\xd6\x1b\x11\x1c\n\x0e\n\x06\x04\x82\x01\x02\x04\
    \x03\x12\x04\xd6\x1b\x1f\x20\n`\n\x05\x04\x82\x01\x02\x05\x12\x04\xd8\
    \x1b\x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\x20into\x20clarifai\
    \x20published\x20workflows\x20first\x20for\x20a\x20Workflow\x20ID\n\n\
    \x0e\n\x06\x04\x82\x01\x02\x05\x05\x12\x04\xd8\x1b\x02\x06\n\x0e\n\x06\
    \x04\x82\x01\x02\x05\x01\x12\x04\xd8\x1b\x07\x1f\n\x0e\n\x06\x04\x82\x01\
    \x02\x05\x03\x12\x04\xd8\x1b\"#\n\r\n\x03\x04\x83\x01\x12\x06\xdb\x1b\0\
    \xde\x1b\x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\xdb\x1b\x08-\n\r\n\x05\
    \x04\x83\x01\x02\0\x12\x04\xdc\x1b\x02(\n\x0e\n\x06\x04\x83\x01\x02\0\
    \x06\x12\x04\xdc\x1b\x02\x1c\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\
    \xdc\x1b\x1d#\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xdc\x1b&'\n\r\n\
    \x05\x04\x83\x01\x02\x01\x12\x04\xdd\x1b\x021\n\x0e\n\x06\x04\x83\x01\
    \x02\x01\x04\x12\x04\xdd\x1b\x02\n\n\x0e\n\x06\x04\x83\x01\x02\x01\x06\
    \x12\x04\xdd\x1b\x0b$\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xdd\
    \x1b%,\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xdd\x1b/0\n\xec\x01\n\
    \x03\x04\x84\x01\x12\x06\xf4\x1b\0\xf7\x1b\x01\x1a+Request\x20to\x20star\
    t\x20a\x20app\x20duplication\x20process\n2\xaf\x01//////////////////////\
    ////////////////////////////////////////////////////////\n\x20App\x20Dup\
    lication\n//////////////////////////////////////////////////////////////\
    ////////////////\n\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\xf4\x1b\x08\"\n\r\
    \n\x05\x04\x84\x01\x02\0\x12\x04\xf5\x1b\x02,\n\x0e\n\x06\x04\x84\x01\
    \x02\0\x06\x12\x04\xf5\x1b\x02\x1b\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\
    \x04\xf5\x1b\x1c'\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\xf5\x1b*+\n\
    \r\n\x05\x04\x84\x01\x02\x01\x12\x04\xf6\x1b\x02/\n\x0e\n\x06\x04\x84\
    \x01\x02\x01\x04\x12\x04\xf6\x1b\x02\n\n\x0e\n\x06\x04\x84\x01\x02\x01\
    \x06\x12\x04\xf6\x1b\x0b\x19\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\
    \xf6\x1b\x1a*\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\xf6\x1b-.\n7\n\
    \x03\x04\x85\x01\x12\x06\xfa\x1b\0\xfe\x1b\x01\x1a(Request\x20to\x20chec\
    k\x20app\x20duplication\x20status\n\n\x0c\n\x04\x04\x85\x01\x01\x12\x04\
    \xfa\x1b\x08\x20\n\r\n\x05\x04\x85\x01\x02\0\x12\x04\xfb\x1b\x02,\n\x0e\
    \n\x06\x04\x85\x01\x02\0\x06\x12\x04\xfb\x1b\x02\x1b\n\x0e\n\x06\x04\x85\
    \x01\x02\0\x01\x12\x04\xfb\x1b\x1c'\n\x0e\n\x06\x04\x85\x01\x02\0\x03\
    \x12\x04\xfb\x1b*+\n&\n\x05\x04\x85\x01\x02\x01\x12\x04\xfd\x1b\x02\x20\
    \x1a\x17The\x20app\x20duplication\x20id\n\n\x0e\n\x06\x04\x85\x01\x02\
    \x01\x05\x12\x04\xfd\x1b\x02\x08\n\x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\
    \x04\xfd\x1b\t\x1b\n\x0e\n\x06\x04\x85\x01\x02\x01\x03\x12\x04\xfd\x1b\
    \x1e\x1f\nL\n\x03\x04\x86\x01\x12\x06\x81\x1c\0\x89\x1c\x01\x1a=Request\
    \x20to\x20list\x20all\x20the\x20app\x20duplication\x20that\x20user\x20tr\
    iggered.\n\n\x0c\n\x04\x04\x86\x01\x01\x12\x04\x81\x1c\x08\"\n\r\n\x05\
    \x04\x86\x01\x02\0\x12\x04\x82\x1c\x02,\n\x0e\n\x06\x04\x86\x01\x02\0\
    \x06\x12\x04\x82\x1c\x02\x1b\n\x0e\n\x06\x04\x86\x01\x02\0\x01\x12\x04\
    \x82\x1c\x1c'\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\x82\x1c*+\n\x7f\
    \n\x05\x04\x86\x01\x02\x01\x12\x04\x85\x1c\x02\x12\x1ap\x20(optional\x20\
    URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\x0e\n\x06\x04\x86\x01\x02\x01\x05\x12\x04\x85\x1c\x02\x08\n\
    \x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\x85\x1c\t\r\n\x0e\n\x06\x04\
    \x86\x01\x02\x01\x03\x12\x04\x85\x1c\x10\x11\nv\n\x05\x04\x86\x01\x02\
    \x02\x12\x04\x88\x1c\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20T\
    he\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x86\x01\
    \x02\x02\x05\x12\x04\x88\x1c\x02\x08\n\x0e\n\x06\x04\x86\x01\x02\x02\x01\
    \x12\x04\x88\x1c\t\x11\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\x04\x88\
    \x1c\x14\x15\n\r\n\x03\x04\x87\x01\x12\x06\x8b\x1c\0\x8e\x1c\x01\n\x0c\n\
    \x04\x04\x87\x01\x01\x12\x04\x8b\x1c\x08$\n\r\n\x05\x04\x87\x01\x02\0\
    \x12\x04\x8c\x1c\x02(\n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\x04\x8c\x1c\
    \x02\x1c\n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\x8c\x1c\x1d#\n\x0e\n\
    \x06\x04\x87\x01\x02\0\x03\x12\x04\x8c\x1c&'\n\r\n\x05\x04\x87\x01\x02\
    \x01\x12\x04\x8d\x1c\x02/\n\x0e\n\x06\x04\x87\x01\x02\x01\x04\x12\x04\
    \x8d\x1c\x02\n\n\x0e\n\x06\x04\x87\x01\x02\x01\x06\x12\x04\x8d\x1c\x0b\
    \x19\n\x0e\n\x06\x04\x87\x01\x02\x01\x01\x12\x04\x8d\x1c\x1a*\n\x0e\n\
    \x06\x04\x87\x01\x02\x01\x03\x12\x04\x8d\x1c-.\n\r\n\x03\x04\x88\x01\x12\
    \x06\x92\x1c\0\x95\x1c\x01\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\x92\x1c\
    \x08$\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\x93\x1c\x02(\n\x0e\n\x06\x04\
    \x88\x01\x02\0\x06\x12\x04\x93\x1c\x02\x1c\n\x0e\n\x06\x04\x88\x01\x02\0\
    \x01\x12\x04\x93\x1c\x1d#\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\x93\
    \x1c&'\n\r\n\x05\x04\x88\x01\x02\x01\x12\x04\x94\x1c\x02%\n\x0e\n\x06\
    \x04\x88\x01\x02\x01\x06\x12\x04\x94\x1c\x02\x10\n\x0e\n\x06\x04\x88\x01\
    \x02\x01\x01\x12\x04\x94\x1c\x11\x20\n\x0e\n\x06\x04\x88\x01\x02\x01\x03\
    \x12\x04\x94\x1c#$\n\xd1\x01\n\x03\x04\x89\x01\x12\x06\x9d\x1c\0\xa0\x1c\
    \x01\x1a\x1a\x20Request\x20to\x20create\x20Tasks.\n2\xa5\x01////////////\
    //////////////////////////////////////////////////////////////////\n\x20\
    Tasks\n/////////////////////////////////////////////////////////////////\
    /////////////\n\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\x9d\x1c\x08\x18\n\r\
    \n\x05\x04\x89\x01\x02\0\x12\x04\x9e\x1c\x02,\n\x0e\n\x06\x04\x89\x01\
    \x02\0\x06\x12\x04\x9e\x1c\x02\x1b\n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\
    \x04\x9e\x1c\x1c'\n\x0e\n\x06\x04\x89\x01\x02\0\x03\x12\x04\x9e\x1c*+\n\
    \r\n\x05\x04\x89\x01\x02\x01\x12\x04\x9f\x1c\x02\x1a\n\x0e\n\x06\x04\x89\
    \x01\x02\x01\x04\x12\x04\x9f\x1c\x02\n\n\x0e\n\x06\x04\x89\x01\x02\x01\
    \x06\x12\x04\x9f\x1c\x0b\x0f\n\x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\
    \x9f\x1c\x10\x15\n\x0e\n\x06\x04\x89\x01\x02\x01\x03\x12\x04\x9f\x1c\x18\
    \x19\n)\n\x03\x04\x8a\x01\x12\x06\xa3\x1c\0\xa6\x1c\x01\x1a\x1a\x20Reque\
    st\x20to\x20get\x20one\x20task.\n\n\x0c\n\x04\x04\x8a\x01\x01\x12\x04\
    \xa3\x1c\x08\x16\n\r\n\x05\x04\x8a\x01\x02\0\x12\x04\xa4\x1c\x02,\n\x0e\
    \n\x06\x04\x8a\x01\x02\0\x06\x12\x04\xa4\x1c\x02\x1b\n\x0e\n\x06\x04\x8a\
    \x01\x02\0\x01\x12\x04\xa4\x1c\x1c'\n\x0e\n\x06\x04\x8a\x01\x02\0\x03\
    \x12\x04\xa4\x1c*+\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xa5\x1c\x02\x15\
    \n\x0e\n\x06\x04\x8a\x01\x02\x01\x05\x12\x04\xa5\x1c\x02\x08\n\x0e\n\x06\
    \x04\x8a\x01\x02\x01\x01\x12\x04\xa5\x1c\t\x10\n\x0e\n\x06\x04\x8a\x01\
    \x02\x01\x03\x12\x04\xa5\x1c\x13\x14\n0\n\x03\x04\x8b\x01\x12\x06\xa9\
    \x1c\0\xb7\x1c\x01\x1a!\x20Request\x20to\x20list\x20multiple\x20tasks.\n\
    \n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\xa9\x1c\x08\x18\n\r\n\x05\x04\x8b\
    \x01\x02\0\x12\x04\xaa\x1c\x02,\n\x0e\n\x06\x04\x8b\x01\x02\0\x06\x12\
    \x04\xaa\x1c\x02\x1b\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\xaa\x1c\
    \x1c'\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\xaa\x1c*+\n\x7f\n\x05\
    \x04\x8b\x01\x02\x01\x12\x04\xad\x1c\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\x0e\n\x06\x04\x8b\x01\x02\x01\x05\x12\x04\xad\x1c\x02\x08\n\x0e\n\
    \x06\x04\x8b\x01\x02\x01\x01\x12\x04\xad\x1c\t\r\n\x0e\n\x06\x04\x8b\x01\
    \x02\x01\x03\x12\x04\xad\x1c\x10\x11\nv\n\x05\x04\x8b\x01\x02\x02\x12\
    \x04\xb0\x1c\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20nu\
    mber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x8b\x01\x02\x02\
    \x05\x12\x04\xb0\x1c\x02\x08\n\x0e\n\x06\x04\x8b\x01\x02\x02\x01\x12\x04\
    \xb0\x1c\t\x11\n\x0e\n\x06\x04\x8b\x01\x02\x02\x03\x12\x04\xb0\x1c\x14\
    \x15\nP\n\x05\x04\x8b\x01\x02\x03\x12\x04\xb2\x1c\x02&\x1aA\x20Get\x20ta\
    sks\x20that\x20have\x20ANY\x20user\x20from\x20this\x20list\x20assigned\
    \x20as\x20worker.\n\n\x0e\n\x06\x04\x8b\x01\x02\x03\x04\x12\x04\xb2\x1c\
    \x02\n\n\x0e\n\x06\x04\x8b\x01\x02\x03\x05\x12\x04\xb2\x1c\x0b\x11\n\x0e\
    \n\x06\x04\x8b\x01\x02\x03\x01\x12\x04\xb2\x1c\x12!\n\x0e\n\x06\x04\x8b\
    \x01\x02\x03\x03\x12\x04\xb2\x1c$%\nR\n\x05\x04\x8b\x01\x02\x04\x12\x04\
    \xb4\x1c\x02&\x1aC\x20Get\x20tasks\x20that\x20have\x20ANY\x20user\x20fro\
    m\x20this\x20list\x20assigned\x20as\x20reviewer.\n\n\x0e\n\x06\x04\x8b\
    \x01\x02\x04\x04\x12\x04\xb4\x1c\x02\n\n\x0e\n\x06\x04\x8b\x01\x02\x04\
    \x05\x12\x04\xb4\x1c\x0b\x11\n\x0e\n\x06\x04\x8b\x01\x02\x04\x01\x12\x04\
    \xb4\x1c\x12!\n\x0e\n\x06\x04\x8b\x01\x02\x04\x03\x12\x04\xb4\x1c$%\n.\n\
    \x05\x04\x8b\x01\x02\x05\x12\x04\xb6\x1c\x02'\x1a\x1f\x20Get\x20label\
    \x20order\x20tasks\x20as\x20well\n\n\x0e\n\x06\x04\x8b\x01\x02\x05\x05\
    \x12\x04\xb6\x1c\x02\x06\n\x0e\n\x06\x04\x8b\x01\x02\x05\x01\x12\x04\xb6\
    \x1c\x07\"\n\x0e\n\x06\x04\x8b\x01\x02\x05\x03\x12\x04\xb6\x1c%&\n2\n\
    \x03\x04\x8c\x01\x12\x06\xba\x1c\0\xc0\x1c\x01\x1a#\x20Request\x20to\x20\
    patch\x20a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\
    \xba\x1c\x08\x19\n\r\n\x05\x04\x8c\x01\x02\0\x12\x04\xbb\x1c\x02,\n\x0e\
    \n\x06\x04\x8c\x01\x02\0\x06\x12\x04\xbb\x1c\x02\x1b\n\x0e\n\x06\x04\x8c\
    \x01\x02\0\x01\x12\x04\xbb\x1c\x1c'\n\x0e\n\x06\x04\x8c\x01\x02\0\x03\
    \x12\x04\xbb\x1c*+\n\r\n\x05\x04\x8c\x01\x02\x01\x12\x04\xbc\x1c\x02\x1a\
    \n\x0e\n\x06\x04\x8c\x01\x02\x01\x04\x12\x04\xbc\x1c\x02\n\n\x0e\n\x06\
    \x04\x8c\x01\x02\x01\x06\x12\x04\xbc\x1c\x0b\x0f\n\x0e\n\x06\x04\x8c\x01\
    \x02\x01\x01\x12\x04\xbc\x1c\x10\x15\n\x0e\n\x06\x04\x8c\x01\x02\x01\x03\
    \x12\x04\xbc\x1c\x18\x19\n\x7f\n\x05\x04\x8c\x01\x02\x02\x12\x04\xbf\x1c\
    \x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\
    \x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20an\
    d\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\x8c\x01\x02\x02\x05\
    \x12\x04\xbf\x1c\x02\x08\n\x0e\n\x06\x04\x8c\x01\x02\x02\x01\x12\x04\xbf\
    \x1c\t\x0f\n\x0e\n\x06\x04\x8c\x01\x02\x02\x03\x12\x04\xbf\x1c\x12\x13\n\
    3\n\x03\x04\x8d\x01\x12\x06\xc3\x1c\0\xc6\x1c\x01\x1a$\x20Request\x20to\
    \x20delete\x20a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\x04\x8d\x01\x01\
    \x12\x04\xc3\x1c\x08\x1a\n\r\n\x05\x04\x8d\x01\x02\0\x12\x04\xc4\x1c\x02\
    ,\n\x0e\n\x06\x04\x8d\x01\x02\0\x06\x12\x04\xc4\x1c\x02\x1b\n\x0e\n\x06\
    \x04\x8d\x01\x02\0\x01\x12\x04\xc4\x1c\x1c'\n\x0e\n\x06\x04\x8d\x01\x02\
    \0\x03\x12\x04\xc4\x1c*+\n\r\n\x05\x04\x8d\x01\x02\x01\x12\x04\xc5\x1c\
    \x02\x1a\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\x12\x04\xc5\x1c\x02\n\n\x0e\
    \n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\xc5\x1c\x0b\x11\n\x0e\n\x06\x04\
    \x8d\x01\x02\x01\x01\x12\x04\xc5\x1c\x12\x15\n\x0e\n\x06\x04\x8d\x01\x02\
    \x01\x03\x12\x04\xc5\x1c\x18\x19\n.\n\x03\x04\x8e\x01\x12\x06\xc9\x1c\0\
    \xcc\x1c\x01\x1a\x1f\x20Response\x20with\x20multiple\x20Tasks.\n\n\x0c\n\
    \x04\x04\x8e\x01\x01\x12\x04\xc9\x1c\x08\x19\n\r\n\x05\x04\x8e\x01\x02\0\
    \x12\x04\xca\x1c\x02(\n\x0e\n\x06\x04\x8e\x01\x02\0\x06\x12\x04\xca\x1c\
    \x02\x1c\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\xca\x1c\x1d#\n\x0e\n\
    \x06\x04\x8e\x01\x02\0\x03\x12\x04\xca\x1c&'\n\r\n\x05\x04\x8e\x01\x02\
    \x01\x12\x04\xcb\x1c\x02I\n\x0e\n\x06\x04\x8e\x01\x02\x01\x04\x12\x04\
    \xcb\x1c\x02\n\n\x0e\n\x06\x04\x8e\x01\x02\x01\x06\x12\x04\xcb\x1c\x0b\
    \x0f\n\x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\xcb\x1c\x10\x15\n\x0e\n\
    \x06\x04\x8e\x01\x02\x01\x03\x12\x04\xcb\x1c\x18\x19\n\x0e\n\x06\x04\x8e\
    \x01\x02\x01\x08\x12\x04\xcb\x1c\x1aH\n\x11\n\t\x04\x8e\x01\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xcb\x1c\x1bG\n-\n\x03\x04\x8f\x01\x12\x06\xcf\x1c\0\
    \xd2\x1c\x01\x1a\x1e\x20Response\x20with\x20a\x20single\x20Task.\n\n\x0c\
    \n\x04\x04\x8f\x01\x01\x12\x04\xcf\x1c\x08\x1a\n\r\n\x05\x04\x8f\x01\x02\
    \0\x12\x04\xd0\x1c\x02(\n\x0e\n\x06\x04\x8f\x01\x02\0\x06\x12\x04\xd0\
    \x1c\x02\x1c\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\xd0\x1c\x1d#\n\
    \x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xd0\x1c&'\n\r\n\x05\x04\x8f\x01\
    \x02\x01\x12\x04\xd1\x1c\x02\x10\n\x0e\n\x06\x04\x8f\x01\x02\x01\x06\x12\
    \x04\xd1\x1c\x02\x06\n\x0e\n\x06\x04\x8f\x01\x02\x01\x01\x12\x04\xd1\x1c\
    \x07\x0b\n\x0e\n\x06\x04\x8f\x01\x02\x01\x03\x12\x04\xd1\x1c\x0e\x0f\n\
    \xae\x01\n\x03\x04\x90\x01\x12\x06\xd7\x1c\0\xdf\x1c\x01\x1a\x9e\x01\x20\
    GetTaskCountRequest\x20can\x20be\x20used\x20for\x20fetching\x20-\n\x201.\
    \x20Task\x20annotation\x20count\x20per\x20user,\x20per\x20status\n\x201.\
    \x20Task\x20input\x20(anchor\x20annotations)\x20count\x20per\x20user,\
    \x20per\x20status\n\n\x0c\n\x04\x04\x90\x01\x01\x12\x04\xd7\x1c\x08\x1b\
    \n\r\n\x05\x04\x90\x01\x02\0\x12\x04\xd8\x1c\x02,\n\x0e\n\x06\x04\x90\
    \x01\x02\0\x06\x12\x04\xd8\x1c\x02\x1b\n\x0e\n\x06\x04\x90\x01\x02\0\x01\
    \x12\x04\xd8\x1c\x1c'\n\x0e\n\x06\x04\x90\x01\x02\0\x03\x12\x04\xd8\x1c*\
    +\nF\n\x05\x04\x90\x01\x02\x01\x12\x04\xdb\x1c\x02\x15\x1a7\x20task_id\
    \x20for\x20which\x20count\x20per\x20user\x20per\x20status\x20is\x20neede\
    d\n\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\x12\x04\xdb\x1c\x02\x08\n\x0e\n\
    \x06\x04\x90\x01\x02\x01\x01\x12\x04\xdb\x1c\t\x10\n\x0e\n\x06\x04\x90\
    \x01\x02\x01\x03\x12\x04\xdb\x1c\x13\x14\nD\n\x05\x04\x90\x01\x02\x02\
    \x12\x04\xde\x1c\x02\x1e\x1a5\x20for\x20given\x20task_id,\x20user_ids\
    \x20to\x20filter\x20on\x20(optional)\n\n\x0e\n\x06\x04\x90\x01\x02\x02\
    \x04\x12\x04\xde\x1c\x02\n\n\x0e\n\x06\x04\x90\x01\x02\x02\x05\x12\x04\
    \xde\x1c\x0b\x11\n\x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\xde\x1c\x12\
    \x1a\n\x0e\n\x06\x04\x90\x01\x02\x02\x03\x12\x04\xde\x1c\x1c\x1d\n\x81\
    \x01\n\x03\x04\x91\x01\x12\x06\xe4\x1c\0\xe9\x1c\x01\x1ar\x20SingleTaskC\
    ountResponse\x20represent\x20counts\x20of\x20annotations\x20or\x20inputs\
    (anchor\x20annotations)\x20for\x20labelers\x20in\x20given\x20task\n\n\
    \x0c\n\x04\x04\x91\x01\x01\x12\x04\xe4\x1c\x08\x1f\n\r\n\x05\x04\x91\x01\
    \x02\0\x12\x04\xe5\x1c\x02(\n\x0e\n\x06\x04\x91\x01\x02\0\x06\x12\x04\
    \xe5\x1c\x02\x1c\n\x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xe5\x1c\x1d#\
    \n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\xe5\x1c&'\n\r\n\x05\x04\x91\
    \x01\x02\x01\x12\x04\xe6\x1c\x02\x14\n\x0e\n\x06\x04\x91\x01\x02\x01\x05\
    \x12\x04\xe6\x1c\x02\x08\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\xe6\
    \x1c\t\x0f\n\x0e\n\x06\x04\x91\x01\x02\x01\x03\x12\x04\xe6\x1c\x12\x13\n\
    \r\n\x05\x04\x91\x01\x02\x02\x12\x04\xe7\x1c\x02\x15\n\x0e\n\x06\x04\x91\
    \x01\x02\x02\x05\x12\x04\xe7\x1c\x02\x08\n\x0e\n\x06\x04\x91\x01\x02\x02\
    \x01\x12\x04\xe7\x1c\t\x10\n\x0e\n\x06\x04\x91\x01\x02\x02\x03\x12\x04\
    \xe7\x1c\x13\x14\n\r\n\x05\x04\x91\x01\x02\x03\x12\x04\xe8\x1c\x02-\n\
    \x0e\n\x06\x04\x91\x01\x02\x03\x04\x12\x04\xe8\x1c\x02\n\n\x0e\n\x06\x04\
    \x91\x01\x02\x03\x06\x12\x04\xe8\x1c\x0b!\n\x0e\n\x06\x04\x91\x01\x02\
    \x03\x01\x12\x04\xe8\x1c\"(\n\x0e\n\x06\x04\x91\x01\x02\x03\x03\x12\x04\
    \xe8\x1c+,\n\xdb\x01\n\x03\x04\x92\x01\x12\x06\xf9\x1c\0\xfc\x1c\x01\x1a\
    \x1f\x20Request\x20to\x20create\x20Collectors.\n2\xaa\x01///////////////\
    ///////////////////////////////////////////////////////////////\n\x20Col\
    lectors\n///////////////////////////////////////////////////////////////\
    ///////////////\n\n\x0c\n\x04\x04\x92\x01\x01\x12\x04\xf9\x1c\x08\x1d\n\
    \r\n\x05\x04\x92\x01\x02\0\x12\x04\xfa\x1c\x02,\n\x0e\n\x06\x04\x92\x01\
    \x02\0\x06\x12\x04\xfa\x1c\x02\x1b\n\x0e\n\x06\x04\x92\x01\x02\0\x01\x12\
    \x04\xfa\x1c\x1c'\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\x04\xfa\x1c*+\n\
    \r\n\x05\x04\x92\x01\x02\x01\x12\x04\xfb\x1c\x02$\n\x0e\n\x06\x04\x92\
    \x01\x02\x01\x04\x12\x04\xfb\x1c\x02\n\n\x0e\n\x06\x04\x92\x01\x02\x01\
    \x06\x12\x04\xfb\x1c\x0b\x14\n\x0e\n\x06\x04\x92\x01\x02\x01\x01\x12\x04\
    \xfb\x1c\x15\x1f\n\x0e\n\x06\x04\x92\x01\x02\x01\x03\x12\x04\xfb\x1c\"#\
    \n\r\n\x03\x04\x93\x01\x12\x06\xfe\x1c\0\x86\x1d\x01\n\x0c\n\x04\x04\x93\
    \x01\x01\x12\x04\xfe\x1c\x08\x1e\n\r\n\x05\x04\x93\x01\x02\0\x12\x04\xff\
    \x1c\x02,\n\x0e\n\x06\x04\x93\x01\x02\0\x06\x12\x04\xff\x1c\x02\x1b\n\
    \x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xff\x1c\x1c'\n\x0e\n\x06\x04\
    \x93\x01\x02\0\x03\x12\x04\xff\x1c*+\n\r\n\x05\x04\x93\x01\x02\x01\x12\
    \x04\x81\x1d\x02$\n\x0e\n\x06\x04\x93\x01\x02\x01\x04\x12\x04\x81\x1d\
    \x02\n\n\x0e\n\x06\x04\x93\x01\x02\x01\x06\x12\x04\x81\x1d\x0b\x14\n\x0e\
    \n\x06\x04\x93\x01\x02\x01\x01\x12\x04\x81\x1d\x15\x1f\n\x0e\n\x06\x04\
    \x93\x01\x02\x01\x03\x12\x04\x81\x1d\"#\n\x7f\n\x05\x04\x93\x01\x02\x02\
    \x12\x04\x85\x1d\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\
    \x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20\
    'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\
    \x93\x01\x02\x02\x05\x12\x04\x85\x1d\x02\x08\n\x0e\n\x06\x04\x93\x01\x02\
    \x02\x01\x12\x04\x85\x1d\t\x0f\n\x0e\n\x06\x04\x93\x01\x02\x02\x03\x12\
    \x04\x85\x1d\x12\x13\nE\n\x03\x04\x94\x01\x12\x06\x89\x1d\0\x8d\x1d\x01\
    \x1a6\x20Request\x20to\x20delete\x20several\x20things\x20by\x20the\x20li\
    st\x20of\x20ids.\n\n\x0c\n\x04\x04\x94\x01\x01\x12\x04\x89\x1d\x08\x1f\n\
    \r\n\x05\x04\x94\x01\x02\0\x12\x04\x8a\x1d\x02,\n\x0e\n\x06\x04\x94\x01\
    \x02\0\x06\x12\x04\x8a\x1d\x02\x1b\n\x0e\n\x06\x04\x94\x01\x02\0\x01\x12\
    \x04\x8a\x1d\x1c'\n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\x8a\x1d*+\n\
    \r\n\x05\x04\x94\x01\x02\x01\x12\x04\x8b\x1d\x02\x1a\n\x0e\n\x06\x04\x94\
    \x01\x02\x01\x04\x12\x04\x8b\x1d\x02\n\n\x0e\n\x06\x04\x94\x01\x02\x01\
    \x05\x12\x04\x8b\x1d\x0b\x11\n\x0e\n\x06\x04\x94\x01\x02\x01\x01\x12\x04\
    \x8b\x1d\x12\x15\n\x0e\n\x06\x04\x94\x01\x02\x01\x03\x12\x04\x8b\x1d\x18\
    \x19\n\r\n\x05\x04\x94\x01\x02\x02\x12\x04\x8c\x1d\x02\x16\n\x0e\n\x06\
    \x04\x94\x01\x02\x02\x05\x12\x04\x8c\x1d\x02\x06\n\x0e\n\x06\x04\x94\x01\
    \x02\x02\x01\x12\x04\x8c\x1d\x07\x11\n\x0e\n\x06\x04\x94\x01\x02\x02\x03\
    \x12\x04\x8c\x1d\x14\x15\n3\n\x03\x04\x95\x01\x12\x06\x90\x1d\0\x94\x1d\
    \x01\x1a$\x20Request\x20to\x20GET\x20a\x20single\x20Collector.\n\n\x0c\n\
    \x04\x04\x95\x01\x01\x12\x04\x90\x1d\x08\x1b\n\r\n\x05\x04\x95\x01\x02\0\
    \x12\x04\x91\x1d\x02,\n\x0e\n\x06\x04\x95\x01\x02\0\x06\x12\x04\x91\x1d\
    \x02\x1b\n\x0e\n\x06\x04\x95\x01\x02\0\x01\x12\x04\x91\x1d\x1c'\n\x0e\n\
    \x06\x04\x95\x01\x02\0\x03\x12\x04\x91\x1d*+\n!\n\x05\x04\x95\x01\x02\
    \x01\x12\x04\x93\x1d\x02\x1a\x1a\x12The\x20collecgtor\x20id\n\n\x0e\n\
    \x06\x04\x95\x01\x02\x01\x05\x12\x04\x93\x1d\x02\x08\n\x0e\n\x06\x04\x95\
    \x01\x02\x01\x01\x12\x04\x93\x1d\t\x15\n\x0e\n\x06\x04\x95\x01\x02\x01\
    \x03\x12\x04\x93\x1d\x18\x19\n3\n\x03\x04\x96\x01\x12\x06\x97\x1d\0\x9f\
    \x1d\x01\x1a$\x20Request\x20to\x20GET\x20all\x20the\x20Collectors.\n\n\
    \x0c\n\x04\x04\x96\x01\x01\x12\x04\x97\x1d\x08\x1d\n\r\n\x05\x04\x96\x01\
    \x02\0\x12\x04\x98\x1d\x02,\n\x0e\n\x06\x04\x96\x01\x02\0\x06\x12\x04\
    \x98\x1d\x02\x1b\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\x98\x1d\x1c'\
    \n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\x04\x98\x1d*+\n\x7f\n\x05\x04\x96\
    \x01\x02\x01\x12\x04\x9b\x1d\x02\x12\x1ap\x20(optional\x20URL\x20paramet\
    er)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\x96\x01\x02\x01\x05\x12\x04\x9b\x1d\x02\x08\n\x0e\n\x06\x04\
    \x96\x01\x02\x01\x01\x12\x04\x9b\x1d\t\r\n\x0e\n\x06\x04\x96\x01\x02\x01\
    \x03\x12\x04\x9b\x1d\x10\x11\nv\n\x05\x04\x96\x01\x02\x02\x12\x04\x9e\
    \x1d\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x96\x01\x02\x02\x05\x12\
    \x04\x9e\x1d\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x02\x01\x12\x04\x9e\x1d\
    \t\x11\n\x0e\n\x06\x04\x96\x01\x02\x02\x03\x12\x04\x9e\x1d\x14\x15\n3\n\
    \x03\x04\x97\x01\x12\x06\xa2\x1d\0\xa5\x1d\x01\x1a$\x20Response\x20with\
    \x20multiple\x20Collectors.\n\n\x0c\n\x04\x04\x97\x01\x01\x12\x04\xa2\
    \x1d\x08\x1e\n\r\n\x05\x04\x97\x01\x02\0\x12\x04\xa3\x1d\x02(\n\x0e\n\
    \x06\x04\x97\x01\x02\0\x06\x12\x04\xa3\x1d\x02\x1c\n\x0e\n\x06\x04\x97\
    \x01\x02\0\x01\x12\x04\xa3\x1d\x1d#\n\x0e\n\x06\x04\x97\x01\x02\0\x03\
    \x12\x04\xa3\x1d&'\n\r\n\x05\x04\x97\x01\x02\x01\x12\x04\xa4\x1d\x02$\n\
    \x0e\n\x06\x04\x97\x01\x02\x01\x04\x12\x04\xa4\x1d\x02\n\n\x0e\n\x06\x04\
    \x97\x01\x02\x01\x06\x12\x04\xa4\x1d\x0b\x14\n\x0e\n\x06\x04\x97\x01\x02\
    \x01\x01\x12\x04\xa4\x1d\x15\x1f\n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\
    \x04\xa4\x1d\"#\n2\n\x03\x04\x98\x01\x12\x06\xa8\x1d\0\xab\x1d\x01\x1a#\
    \x20Response\x20with\x20a\x20single\x20Collector.\n\n\x0c\n\x04\x04\x98\
    \x01\x01\x12\x04\xa8\x1d\x08\x1f\n\r\n\x05\x04\x98\x01\x02\0\x12\x04\xa9\
    \x1d\x02(\n\x0e\n\x06\x04\x98\x01\x02\0\x06\x12\x04\xa9\x1d\x02\x1c\n\
    \x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\xa9\x1d\x1d#\n\x0e\n\x06\x04\
    \x98\x01\x02\0\x03\x12\x04\xa9\x1d&'\n\r\n\x05\x04\x98\x01\x02\x01\x12\
    \x04\xaa\x1d\x02\x1a\n\x0e\n\x06\x04\x98\x01\x02\x01\x06\x12\x04\xaa\x1d\
    \x02\x0b\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\x12\x04\xaa\x1d\x0c\x15\n\
    \x0e\n\x06\x04\x98\x01\x02\x01\x03\x12\x04\xaa\x1d\x18\x19\n\xcb\x01\n\
    \x03\x04\x99\x01\x12\x06\xb4\x1d\0\xb9\x1d\x01\x1a\xbb\x01//////////////\
    ////////////////////////////////////////////////////////////////\n\x20St\
    ats\x20Collection\x20Endpoints.\n///////////////////////////////////////\
    ///////////////////////////////////////\n\n\x0c\n\x04\x04\x99\x01\x01\
    \x12\x04\xb4\x1d\x08\x1d\n>\n\x05\x04\x99\x01\x02\0\x12\x04\xb6\x1d\x02,\
    \x1a/\x20The\x20user\x20and\x20app\x20information\x20for\x20the\x20reque\
    st.\n\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\xb6\x1d\x02\x1b\n\x0e\n\
    \x06\x04\x99\x01\x02\0\x01\x12\x04\xb6\x1d\x1c'\n\x0e\n\x06\x04\x99\x01\
    \x02\0\x03\x12\x04\xb6\x1d*+\nE\n\x05\x04\x99\x01\x02\x01\x12\x04\xb8\
    \x1d\x02%\x1a6\x20The\x20stats\x20to\x20post,\x20can\x20post\x20more\x20\
    than\x20one\x20at\x20a\x20time.\n\n\x0e\n\x06\x04\x99\x01\x02\x01\x04\
    \x12\x04\xb8\x1d\x02\n\n\x0e\n\x06\x04\x99\x01\x02\x01\x06\x12\x04\xb8\
    \x1d\x0b\x14\n\x0e\n\x06\x04\x99\x01\x02\x01\x01\x12\x04\xb8\x1d\x15\x20\
    \n\x0e\n\x06\x04\x99\x01\x02\x01\x03\x12\x04\xb8\x1d#$\n\r\n\x03\x04\x9a\
    \x01\x12\x06\xbb\x1d\0\xc0\x1d\x01\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\
    \xbb\x1d\x08\x1e\n%\n\x05\x04\x9a\x01\x02\0\x12\x04\xbd\x1d\x02(\x1a\x16\
    \x20The\x20response\x20status.\n\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\
    \x04\xbd\x1d\x02\x1c\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\xbd\x1d\
    \x1d#\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\x12\x04\xbd\x1d&'\n+\n\x05\x04\
    \x9a\x01\x02\x01\x12\x04\xbf\x1d\x02T\x1a\x1c\x20The\x20returned\x20stat\
    s\x20values.\n\n\x0e\n\x06\x04\x9a\x01\x02\x01\x04\x12\x04\xbf\x1d\x02\n\
    \n\x0e\n\x06\x04\x9a\x01\x02\x01\x06\x12\x04\xbf\x1d\x0b\x14\n\x0e\n\x06\
    \x04\x9a\x01\x02\x01\x01\x12\x04\xbf\x1d\x15\x20\n\x0e\n\x06\x04\x9a\x01\
    \x02\x01\x03\x12\x04\xbf\x1d#$\n\x0e\n\x06\x04\x9a\x01\x02\x01\x08\x12\
    \x04\xbf\x1d%S\n\x11\n\t\x04\x9a\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xbf\
    \x1d&R\n\r\n\x03\x04\x9b\x01\x12\x06\xc4\x1d\0\xca\x1d\x01\n\x0c\n\x04\
    \x04\x9b\x01\x01\x12\x04\xc4\x1d\x08&\n7\n\x05\x04\x9b\x01\x02\0\x12\x04\
    \xc6\x1d\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20of\x20the\
    \x20request.\n\n\x0e\n\x06\x04\x9b\x01\x02\0\x06\x12\x04\xc6\x1d\x02\x1b\
    \n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\xc6\x1d\x1c'\n\x0e\n\x06\x04\
    \x9b\x01\x02\0\x03\x12\x04\xc6\x1d*+\n4\n\x05\x04\x9b\x01\x02\x01\x12\
    \x04\xc9\x1d\x02D\x1a%\x20Query\x20to\x20retrieve\x20aggregate\x20values\
    .\n\n\x0e\n\x06\x04\x9b\x01\x02\x01\x04\x12\x04\xc9\x1d\x02\n\n\x0e\n\
    \x06\x04\x9b\x01\x02\x01\x06\x12\x04\xc9\x1d\x0b\"\n\x0e\n\x06\x04\x9b\
    \x01\x02\x01\x01\x12\x04\xc9\x1d#?\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\
    \x12\x04\xc9\x1dBC\n\r\n\x03\x04\x9c\x01\x12\x06\xcc\x1d\0\xd2\x1d\x01\n\
    \x0c\n\x04\x04\x9c\x01\x01\x12\x04\xcc\x1d\x08'\n%\n\x05\x04\x9c\x01\x02\
    \0\x12\x04\xce\x1d\x02(\x1a\x16\x20The\x20response\x20status.\n\n\x0e\n\
    \x06\x04\x9c\x01\x02\0\x06\x12\x04\xce\x1d\x02\x1c\n\x0e\n\x06\x04\x9c\
    \x01\x02\0\x01\x12\x04\xce\x1d\x1d#\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\
    \x12\x04\xce\x1d&'\n?\n\x05\x04\x9c\x01\x02\x01\x12\x04\xd1\x1d\x02E\x1a\
    0\x20The\x20aggregate\x20results\x20for\x20each\x20query\x20passedin.\n\
    \n\x0e\n\x06\x04\x9c\x01\x02\x01\x04\x12\x04\xd1\x1d\x02\n\n\x0e\n\x06\
    \x04\x9c\x01\x02\x01\x06\x12\x04\xd1\x1d\x0b#\n\x0e\n\x06\x04\x9c\x01\
    \x02\x01\x01\x12\x04\xd1\x1d$@\n\x0e\n\x06\x04\x9c\x01\x02\x01\x03\x12\
    \x04\xd1\x1dCDb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
