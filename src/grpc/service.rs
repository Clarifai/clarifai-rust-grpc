// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/clarifai/api/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Split the results into pages.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.Pagination)
pub struct Pagination {
    // message fields
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.Pagination.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
    // @@protoc_insertion_point(field:clarifai.api.Pagination.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &Pagination| { &m.page },
            |m: &mut Pagination| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &Pagination| { &m.per_page },
            |m: &mut Pagination| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page = is.read_uint32()?;
                },
                16 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.page != 0 {
            os.write_uint32(1, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationRequest)
pub struct GetAnnotationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.annotation_id)
    pub annotation_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationRequest {
    fn default() -> &'a GetAnnotationRequest {
        <GetAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationRequest {
    pub fn new() -> GetAnnotationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationRequest| { &m.user_app_id },
            |m: &mut GetAnnotationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_id",
            |m: &GetAnnotationRequest| { &m.annotation_id },
            |m: &mut GetAnnotationRequest| { &mut m.annotation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetAnnotationRequest| { &m.input_id },
            |m: &mut GetAnnotationRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationRequest>(
            "GetAnnotationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationRequest {
    const NAME: &'static str = "GetAnnotationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(2, &self.annotation_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationRequest {
        GetAnnotationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationRequest {
        static instance: GetAnnotationRequest = GetAnnotationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationsRequest)
pub struct ListAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List annotations for these IDs
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    ///  List annotations for these Input IDs
    ///  Note that 'ids' are optional but if the are provided the number and order in
    ///  'ids' and 'input_ids' should match
    ///  If you do not specify 'ids' all the annotations for 'input_ids' are returned
    ///  If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these user IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If model_version_ids are also provided these user_ids are OR'd with them as well since
    ///  annotations are either provided by users or model versions and we want the union of any
    ///  provided user or model version annotations in the results of ListAnnotations request.
    ///  If no user_ids are provided then annotations from all users are returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these model version IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If user_ids are also provided these model_versions_ids are OR'd with them as well since
    ///  annotations are either provided by users or model versions and we want the union of any
    ///  provided user or model version annotations in the results of ListAnnotations request.
    ///  If no model_version_ids are provided then annotations from all model versions are returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.model_version_ids)
    pub model_version_ids: ::std::vec::Vec<::std::string::String>,
    ///  Set status to filter by a list of statuses
    ///  If not statuses are provided then annotations with any status will be returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.statuses)
    pub statuses: ::std::vec::Vec<super::status::Status>,
    ///  Set this flag to list both trusted and not trusted annotations
    ///  by default it's listing only trusted annotations
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.list_all_annotations)
    pub list_all_annotations: bool,
    ///  Set this flag to return the model output for model annotations in the response.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.return_model_output)
    pub return_model_output: bool,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.per_page)
    pub per_page: u32,
    ///  Flag to filter annotations by task_id
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.task_id)
    pub task_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationsRequest {
    fn default() -> &'a ListAnnotationsRequest {
        <ListAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationsRequest {
    pub fn new() -> ListAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationsRequest| { &m.user_app_id },
            |m: &mut ListAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListAnnotationsRequest| { &m.ids },
            |m: &mut ListAnnotationsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &ListAnnotationsRequest| { &m.input_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.input_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &ListAnnotationsRequest| { &m.user_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_ids",
            |m: &ListAnnotationsRequest| { &m.model_version_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.model_version_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &ListAnnotationsRequest| { &m.statuses },
            |m: &mut ListAnnotationsRequest| { &mut m.statuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_all_annotations",
            |m: &ListAnnotationsRequest| { &m.list_all_annotations },
            |m: &mut ListAnnotationsRequest| { &mut m.list_all_annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_model_output",
            |m: &ListAnnotationsRequest| { &m.return_model_output },
            |m: &mut ListAnnotationsRequest| { &mut m.return_model_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationsRequest| { &m.page },
            |m: &mut ListAnnotationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationsRequest| { &m.per_page },
            |m: &mut ListAnnotationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &ListAnnotationsRequest| { &m.task_id },
            |m: &mut ListAnnotationsRequest| { &mut m.task_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationsRequest>(
            "ListAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationsRequest {
    const NAME: &'static str = "ListAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                74 => {
                    self.user_ids.push(is.read_string()?);
                },
                82 => {
                    self.model_version_ids.push(is.read_string()?);
                },
                42 => {
                    self.statuses.push(is.read_message()?);
                },
                48 => {
                    self.list_all_annotations = is.read_bool()?;
                },
                96 => {
                    self.return_model_output = is.read_bool()?;
                },
                56 => {
                    self.page = is.read_uint32()?;
                },
                64 => {
                    self.per_page = is.read_uint32()?;
                },
                90 => {
                    self.task_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.model_version_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.list_all_annotations != false {
            my_size += 1 + 1;
        }
        if self.return_model_output != false {
            my_size += 1 + 1;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.per_page);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.user_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.model_version_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.statuses {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.list_all_annotations != false {
            os.write_bool(6, self.list_all_annotations)?;
        }
        if self.return_model_output != false {
            os.write_bool(12, self.return_model_output)?;
        }
        if self.page != 0 {
            os.write_uint32(7, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(8, self.per_page)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(11, &self.task_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationsRequest {
        ListAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.user_ids.clear();
        self.model_version_ids.clear();
        self.statuses.clear();
        self.list_all_annotations = false;
        self.return_model_output = false;
        self.page = 0;
        self.per_page = 0;
        self.task_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationsRequest {
        static instance: ListAnnotationsRequest = ListAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            input_ids: ::std::vec::Vec::new(),
            user_ids: ::std::vec::Vec::new(),
            model_version_ids: ::std::vec::Vec::new(),
            statuses: ::std::vec::Vec::new(),
            list_all_annotations: false,
            return_model_output: false,
            page: 0,
            per_page: 0,
            task_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostAnnotationsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationsRequest)
pub struct PostAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsRequest.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsRequest {
    fn default() -> &'a PostAnnotationsRequest {
        <PostAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsRequest {
    pub fn new() -> PostAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationsRequest| { &m.user_app_id },
            |m: &mut PostAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &PostAnnotationsRequest| { &m.annotations },
            |m: &mut PostAnnotationsRequest| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationsRequest>(
            "PostAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationsRequest {
    const NAME: &'static str = "PostAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationsRequest {
        PostAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationsRequest {
        static instance: PostAnnotationsRequest = PostAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsRequest)
pub struct PatchAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.action)
    pub action: ::std::string::String,
    ///  If the request is a "remove" action and the annotation is left with empty data,
    ///  then setting delete_if_empty_data to true will delete the annotation,
    ///  if possible (for example, will not delete an input-level annotation).
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.delete_if_empty_data)
    pub delete_if_empty_data: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsRequest {
    fn default() -> &'a PatchAnnotationsRequest {
        <PatchAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsRequest {
    pub fn new() -> PatchAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &PatchAnnotationsRequest| { &m.annotations },
            |m: &mut PatchAnnotationsRequest| { &mut m.annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsRequest| { &m.action },
            |m: &mut PatchAnnotationsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_if_empty_data",
            |m: &PatchAnnotationsRequest| { &m.delete_if_empty_data },
            |m: &mut PatchAnnotationsRequest| { &mut m.delete_if_empty_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsRequest>(
            "PatchAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsRequest {
    const NAME: &'static str = "PatchAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                32 => {
                    self.delete_if_empty_data = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if self.delete_if_empty_data != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if self.delete_if_empty_data != false {
            os.write_bool(4, self.delete_if_empty_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsRequest {
        PatchAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.action.clear();
        self.delete_if_empty_data = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsRequest {
        static instance: PatchAnnotationsRequest = PatchAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            delete_if_empty_data: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsStatusRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsStatusRequest)
pub struct PatchAnnotationsStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Annotation Status code
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.status_code)
    pub status_code: ::protobuf::EnumOrUnknown<super::status_code::StatusCode>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.task_id)
    pub task_id: ::std::string::String,
    ///  'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusRequest {
    fn default() -> &'a PatchAnnotationsStatusRequest {
        <PatchAnnotationsStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusRequest {
    pub fn new() -> PatchAnnotationsStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsStatusRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code",
            |m: &PatchAnnotationsStatusRequest| { &m.status_code },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &PatchAnnotationsStatusRequest| { &m.user_ids },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &PatchAnnotationsStatusRequest| { &m.task_id },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsStatusRequest| { &m.action },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsStatusRequest>(
            "PatchAnnotationsStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusRequest {
    const NAME: &'static str = "PatchAnnotationsStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.status_code = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                34 => {
                    self.task_id = is.read_string()?;
                },
                42 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            my_size += ::protobuf::rt::int32_size(2, self.status_code.value());
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.task_id);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status_code))?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        if !self.task_id.is_empty() {
            os.write_string(4, &self.task_id)?;
        }
        if !self.action.is_empty() {
            os.write_string(5, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsStatusRequest {
        PatchAnnotationsStatusRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.status_code = ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO);
        self.user_ids.clear();
        self.task_id.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsStatusRequest {
        static instance: PatchAnnotationsStatusRequest = PatchAnnotationsStatusRequest {
            user_app_id: ::protobuf::MessageField::none(),
            status_code: ::protobuf::EnumOrUnknown::from_i32(0),
            user_ids: ::std::vec::Vec::new(),
            task_id: ::std::string::String::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsStatusResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsStatusResponse)
pub struct PatchAnnotationsStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.updated_count)
    pub updated_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusResponse {
    fn default() -> &'a PatchAnnotationsStatusResponse {
        <PatchAnnotationsStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusResponse {
    pub fn new() -> PatchAnnotationsStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PatchAnnotationsStatusResponse| { &m.status },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &PatchAnnotationsStatusResponse| { &m.user_ids },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_count",
            |m: &PatchAnnotationsStatusResponse| { &m.updated_count },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.updated_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsStatusResponse>(
            "PatchAnnotationsStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusResponse {
    const NAME: &'static str = "PatchAnnotationsStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.user_ids.push(is.read_string()?);
                },
                24 => {
                    self.updated_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.updated_count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.updated_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if self.updated_count != 0 {
            os.write_uint32(3, self.updated_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsStatusResponse {
        PatchAnnotationsStatusResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user_ids.clear();
        self.updated_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsStatusResponse {
        static instance: PatchAnnotationsStatusResponse = PatchAnnotationsStatusResponse {
            status: ::protobuf::MessageField::none(),
            user_ids: ::std::vec::Vec::new(),
            updated_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAnnotationRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationRequest)
pub struct DeleteAnnotationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.input_id)
    pub input_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.annotation_id)
    pub annotation_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationRequest {
    fn default() -> &'a DeleteAnnotationRequest {
        <DeleteAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationRequest {
    pub fn new() -> DeleteAnnotationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &DeleteAnnotationRequest| { &m.input_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.input_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_id",
            |m: &DeleteAnnotationRequest| { &m.annotation_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.annotation_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationRequest>(
            "DeleteAnnotationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationRequest {
    const NAME: &'static str = "DeleteAnnotationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                26 => {
                    self.annotation_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.annotation_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(3, &self.annotation_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationRequest {
        DeleteAnnotationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.annotation_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationRequest {
        static instance: DeleteAnnotationRequest = DeleteAnnotationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            annotation_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationsRequest)
pub struct DeleteAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Delete annotations with IDs
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    ///  Delete annotations for these Input IDs
    ///  Note that 'ids' are optional but if the are provided the number and order in
    ///  'ids' and 'input_ids' should match
    ///  If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
    ///  However you need to specify at least one value for 'input_ids'
    ///  i.e. this API does not support deleting all annotations
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationsRequest {
    fn default() -> &'a DeleteAnnotationsRequest {
        <DeleteAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationsRequest {
    pub fn new() -> DeleteAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationsRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteAnnotationsRequest| { &m.ids },
            |m: &mut DeleteAnnotationsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &DeleteAnnotationsRequest| { &m.input_ids },
            |m: &mut DeleteAnnotationsRequest| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationsRequest>(
            "DeleteAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationsRequest {
    const NAME: &'static str = "DeleteAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationsRequest {
        DeleteAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationsRequest {
        static instance: DeleteAnnotationsRequest = DeleteAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAnnotationResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleAnnotationResponse)
pub struct SingleAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationResponse.annotation)
    pub annotation: ::protobuf::MessageField<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationResponse {
    fn default() -> &'a SingleAnnotationResponse {
        <SingleAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationResponse {
    pub fn new() -> SingleAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAnnotationResponse| { &m.status },
            |m: &mut SingleAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Annotation>(
            "annotation",
            |m: &SingleAnnotationResponse| { &m.annotation },
            |m: &mut SingleAnnotationResponse| { &mut m.annotation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAnnotationResponse>(
            "SingleAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAnnotationResponse {
    const NAME: &'static str = "SingleAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAnnotationResponse {
        SingleAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAnnotationResponse {
        static instance: SingleAnnotationResponse = SingleAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            annotation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationResponse)
pub struct MultiAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationResponse.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationResponse {
    fn default() -> &'a MultiAnnotationResponse {
        <MultiAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationResponse {
    pub fn new() -> MultiAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationResponse| { &m.status },
            |m: &mut MultiAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &MultiAnnotationResponse| { &m.annotations },
            |m: &mut MultiAnnotationResponse| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationResponse>(
            "MultiAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationResponse {
    const NAME: &'static str = "MultiAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationResponse {
        MultiAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationResponse {
        static instance: MultiAnnotationResponse = MultiAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAppRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetAppRequest)
pub struct GetAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetAppRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAppRequest {
    fn default() -> &'a GetAppRequest {
        <GetAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppRequest {
    pub fn new() -> GetAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAppRequest| { &m.user_app_id },
            |m: &mut GetAppRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetAppRequest| { &m.additional_fields },
            |m: &mut GetAppRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAppRequest>(
            "GetAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAppRequest {
    const NAME: &'static str = "GetAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAppRequest {
        GetAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAppRequest {
        static instance: GetAppRequest = GetAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAppsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListAppsRequest)
pub struct ListAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.per_page)
    pub per_page: u32,
    ///  Sorting opitons:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  Query various text fields that can contain the words in the query string
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the name of the app. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated in favor of query
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.name)
    pub name: ::std::string::String,
    ///  Filter by the user-unique-id of the app. This supports wilcard queries like "gen*" to match "general" as an example.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.id)
    pub id: ::std::string::String,
    ///  If true, we only return apps that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return apps that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.starred_only)
    pub starred_only: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_apps_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppsRequest {
    fn default() -> &'a ListAppsRequest {
        <ListAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppsRequest {
    pub fn new() -> ListAppsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_name = 6;

    pub fn sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(v))
    }

    // bool sort_by_modified_at = 7;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 12;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 13;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppsRequest| { &m.user_app_id },
            |m: &mut ListAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppsRequest| { &m.page },
            |m: &mut ListAppsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppsRequest| { &m.per_page },
            |m: &mut ListAppsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListAppsRequest| { &m.sort_ascending },
            |m: &mut ListAppsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_name",
            ListAppsRequest::has_sort_by_name,
            ListAppsRequest::sort_by_name,
            ListAppsRequest::set_sort_by_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListAppsRequest::has_sort_by_modified_at,
            ListAppsRequest::sort_by_modified_at,
            ListAppsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListAppsRequest::has_sort_by_created_at,
            ListAppsRequest::sort_by_created_at,
            ListAppsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListAppsRequest::has_sort_by_star_count,
            ListAppsRequest::sort_by_star_count,
            ListAppsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListAppsRequest| { &m.query },
            |m: &mut ListAppsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListAppsRequest| { &m.name },
            |m: &mut ListAppsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListAppsRequest| { &m.id },
            |m: &mut ListAppsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListAppsRequest| { &m.featured_only },
            |m: &mut ListAppsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListAppsRequest| { &m.starred_only },
            |m: &mut ListAppsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListAppsRequest| { &m.additional_fields },
            |m: &mut ListAppsRequest| { &mut m.additional_fields },
        ));
        oneofs.push(list_apps_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppsRequest>(
            "ListAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppsRequest {
    const NAME: &'static str = "ListAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                40 => {
                    self.sort_ascending = is.read_bool()?;
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                96 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                66 => {
                    self.query = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                114 => {
                    self.id = is.read_string()?;
                },
                72 => {
                    self.featured_only = is.read_bool()?;
                },
                88 => {
                    self.starred_only = is.read_bool()?;
                },
                82 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.id);
        }
        if self.featured_only != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_apps_request::Sort_by::SortByName(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(14, &self.id)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_apps_request::Sort_by::SortByName(v) => {
                    os.write_bool(6, v)?;
                },
                &list_apps_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_apps_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(12, v)?;
                },
                &list_apps_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(13, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppsRequest {
        ListAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.query.clear();
        self.name.clear();
        self.id.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppsRequest {
        static instance: ListAppsRequest = ListAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            sort_ascending: false,
            query: ::std::string::String::new(),
            name: ::std::string::String::new(),
            id: ::std::string::String::new(),
            featured_only: false,
            starred_only: false,
            additional_fields: ::std::vec::Vec::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListAppsRequest`
pub mod list_apps_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListAppsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_name)
        SortByName(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListAppsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostAppsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAppsRequest)
pub struct PostAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAppsRequest.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppsRequest {
    fn default() -> &'a PostAppsRequest {
        <PostAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsRequest {
    pub fn new() -> PostAppsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppsRequest| { &m.user_app_id },
            |m: &mut PostAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &PostAppsRequest| { &m.apps },
            |m: &mut PostAppsRequest| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppsRequest>(
            "PostAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppsRequest {
    const NAME: &'static str = "PostAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppsRequest {
        PostAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppsRequest {
        static instance: PostAppsRequest = PostAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAppRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteAppRequest)
pub struct DeleteAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAppRequest {
    fn default() -> &'a DeleteAppRequest {
        <DeleteAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAppRequest {
    pub fn new() -> DeleteAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAppRequest| { &m.user_app_id },
            |m: &mut DeleteAppRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAppRequest>(
            "DeleteAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAppRequest {
    const NAME: &'static str = "DeleteAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAppRequest {
        DeleteAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAppRequest {
        static instance: DeleteAppRequest = DeleteAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAppsRequest)
pub struct PatchAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    ///  The action to perform on the patched App objects except App.Metadata
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.action)
    pub action: ::std::string::String,
    ///  The action to perform on the patched App.Metadata
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.metadata_action)
    pub metadata_action: ::protobuf::MessageField<super::resources::PatchAction>,
    ///  If set, the app will be automatically reindexed upon change of its base workflow.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.reindex)
    pub reindex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppsRequest {
    fn default() -> &'a PatchAppsRequest {
        <PatchAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsRequest {
    pub fn new() -> PatchAppsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppsRequest| { &m.user_app_id },
            |m: &mut PatchAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &PatchAppsRequest| { &m.apps },
            |m: &mut PatchAppsRequest| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppsRequest| { &m.action },
            |m: &mut PatchAppsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PatchAction>(
            "metadata_action",
            |m: &PatchAppsRequest| { &m.metadata_action },
            |m: &mut PatchAppsRequest| { &mut m.metadata_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex",
            |m: &PatchAppsRequest| { &m.reindex },
            |m: &mut PatchAppsRequest| { &mut m.reindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppsRequest>(
            "PatchAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppsRequest {
    const NAME: &'static str = "PatchAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata_action)?;
                },
                40 => {
                    self.reindex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reindex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(v) = self.metadata_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppsRequest {
        PatchAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppsRequest {
        static instance: PatchAppsRequest = PatchAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            metadata_action: ::protobuf::MessageField::none(),
            reindex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAppRequest)
pub struct PatchAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    ///  The action to perform on the patched App object except App.Metadata
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.action)
    pub action: ::std::string::String,
    ///  The action to perform on the patched App.Metadata
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.metadata_action)
    pub metadata_action: ::protobuf::MessageField<super::resources::PatchAction>,
    ///  If set, the app will be automatically reindexed upon change of its base workflow.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.reindex)
    pub reindex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppRequest {
    fn default() -> &'a PatchAppRequest {
        <PatchAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppRequest {
    pub fn new() -> PatchAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppRequest| { &m.user_app_id },
            |m: &mut PatchAppRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &PatchAppRequest| { &m.app },
            |m: &mut PatchAppRequest| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppRequest| { &m.action },
            |m: &mut PatchAppRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PatchAction>(
            "metadata_action",
            |m: &PatchAppRequest| { &m.metadata_action },
            |m: &mut PatchAppRequest| { &mut m.metadata_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex",
            |m: &PatchAppRequest| { &m.reindex },
            |m: &mut PatchAppRequest| { &mut m.reindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppRequest>(
            "PatchAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppRequest {
    const NAME: &'static str = "PatchAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                26 => {
                    self.action = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata_action)?;
                },
                40 => {
                    self.reindex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reindex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(v) = self.metadata_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppRequest {
        PatchAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppRequest {
        static instance: PatchAppRequest = PatchAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app: ::protobuf::MessageField::none(),
            action: ::std::string::String::new(),
            metadata_action: ::protobuf::MessageField::none(),
            reindex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppsIdsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAppsIdsRequest)
pub struct PatchAppsIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppsIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppsIdsRequest {
    fn default() -> &'a PatchAppsIdsRequest {
        <PatchAppsIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsIdsRequest {
    pub fn new() -> PatchAppsIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppsIdsRequest| { &m.user_app_id },
            |m: &mut PatchAppsIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchAppsIdsRequest| { &m.ids },
            |m: &mut PatchAppsIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppsIdsRequest| { &m.action },
            |m: &mut PatchAppsIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppsIdsRequest>(
            "PatchAppsIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppsIdsRequest {
    const NAME: &'static str = "PatchAppsIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppsIdsRequest {
        PatchAppsIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppsIdsRequest {
        static instance: PatchAppsIdsRequest = PatchAppsIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppsIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppsIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppsIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Search over the available applications.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAppsSearchesRequest)
pub struct PostAppsSearchesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.app_query)
    pub app_query: ::protobuf::MessageField<super::resources::AppQuery>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppsSearchesRequest {
    fn default() -> &'a PostAppsSearchesRequest {
        <PostAppsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsSearchesRequest {
    pub fn new() -> PostAppsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppsSearchesRequest| { &m.user_app_id },
            |m: &mut PostAppsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AppQuery>(
            "app_query",
            |m: &PostAppsSearchesRequest| { &m.app_query },
            |m: &mut PostAppsSearchesRequest| { &mut m.app_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostAppsSearchesRequest| { &m.pagination },
            |m: &mut PostAppsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppsSearchesRequest>(
            "PostAppsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppsSearchesRequest {
    const NAME: &'static str = "PostAppsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_query)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppsSearchesRequest {
        PostAppsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_query.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppsSearchesRequest {
        static instance: PostAppsSearchesRequest = PostAppsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_query: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAppResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleAppResponse)
pub struct SingleAppResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAppResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAppResponse.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAppResponse {
    fn default() -> &'a SingleAppResponse {
        <SingleAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppResponse {
    pub fn new() -> SingleAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAppResponse| { &m.status },
            |m: &mut SingleAppResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &SingleAppResponse| { &m.app },
            |m: &mut SingleAppResponse| { &mut m.app },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAppResponse>(
            "SingleAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAppResponse {
    const NAME: &'static str = "SingleAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAppResponse {
        SingleAppResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAppResponse {
        static instance: SingleAppResponse = SingleAppResponse {
            status: ::protobuf::MessageField::none(),
            app: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAppResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiAppResponse)
pub struct MultiAppResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAppResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAppResponse.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAppResponse {
    fn default() -> &'a MultiAppResponse {
        <MultiAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppResponse {
    pub fn new() -> MultiAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAppResponse| { &m.status },
            |m: &mut MultiAppResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &MultiAppResponse| { &m.apps },
            |m: &mut MultiAppResponse| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAppResponse>(
            "MultiAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAppResponse {
    const NAME: &'static str = "MultiAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAppResponse {
        MultiAppResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAppResponse {
        static instance: MultiAppResponse = MultiAppResponse {
            status: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListCollaboratorsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListCollaboratorsRequest)
pub struct ListCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Set this flag to list both deleted and not deleted collaborators
    ///  by default it's listing only not deleted collaborators
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.list_all_collaborators)
    pub list_all_collaborators: bool,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollaboratorsRequest {
    fn default() -> &'a ListCollaboratorsRequest {
        <ListCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaboratorsRequest {
    pub fn new() -> ListCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollaboratorsRequest| { &m.user_app_id },
            |m: &mut ListCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_all_collaborators",
            |m: &ListCollaboratorsRequest| { &m.list_all_collaborators },
            |m: &mut ListCollaboratorsRequest| { &mut m.list_all_collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollaboratorsRequest| { &m.page },
            |m: &mut ListCollaboratorsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollaboratorsRequest| { &m.per_page },
            |m: &mut ListCollaboratorsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollaboratorsRequest>(
            "ListCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollaboratorsRequest {
    const NAME: &'static str = "ListCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.list_all_collaborators = is.read_bool()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.list_all_collaborators != false {
            my_size += 1 + 1;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.list_all_collaborators != false {
            os.write_bool(2, self.list_all_collaborators)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollaboratorsRequest {
        ListCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.list_all_collaborators = false;
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollaboratorsRequest {
        static instance: ListCollaboratorsRequest = ListCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            list_all_collaborators: false,
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostCollaboratorsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostCollaboratorsRequest)
pub struct PostCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostCollaboratorsRequest.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCollaboratorsRequest {
    fn default() -> &'a PostCollaboratorsRequest {
        <PostCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollaboratorsRequest {
    pub fn new() -> PostCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostCollaboratorsRequest| { &m.user_app_id },
            |m: &mut PostCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &PostCollaboratorsRequest| { &m.collaborators },
            |m: &mut PostCollaboratorsRequest| { &mut m.collaborators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCollaboratorsRequest>(
            "PostCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCollaboratorsRequest {
    const NAME: &'static str = "PostCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCollaboratorsRequest {
        PostCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCollaboratorsRequest {
        static instance: PostCollaboratorsRequest = PostCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchCollaboratorsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchCollaboratorsRequest)
pub struct PatchCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    ///  The action to perform on the patched objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchCollaboratorsRequest {
    fn default() -> &'a PatchCollaboratorsRequest {
        <PatchCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollaboratorsRequest {
    pub fn new() -> PatchCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchCollaboratorsRequest| { &m.user_app_id },
            |m: &mut PatchCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &PatchCollaboratorsRequest| { &m.collaborators },
            |m: &mut PatchCollaboratorsRequest| { &mut m.collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchCollaboratorsRequest| { &m.action },
            |m: &mut PatchCollaboratorsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchCollaboratorsRequest>(
            "PatchCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchCollaboratorsRequest {
    const NAME: &'static str = "PatchCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchCollaboratorsRequest {
        PatchCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchCollaboratorsRequest {
        static instance: PatchCollaboratorsRequest = PatchCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteCollaboratorsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteCollaboratorsRequest)
pub struct DeleteCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.collaborator_ids)
    pub collaborator_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.user_emails)
    pub user_emails: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollaboratorsRequest {
    fn default() -> &'a DeleteCollaboratorsRequest {
        <DeleteCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollaboratorsRequest {
    pub fn new() -> DeleteCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteCollaboratorsRequest| { &m.user_app_id },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborator_ids",
            |m: &DeleteCollaboratorsRequest| { &m.collaborator_ids },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.collaborator_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_emails",
            |m: &DeleteCollaboratorsRequest| { &m.user_emails },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.user_emails },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollaboratorsRequest>(
            "DeleteCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollaboratorsRequest {
    const NAME: &'static str = "DeleteCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborator_ids.push(is.read_string()?);
                },
                26 => {
                    self.user_emails.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborator_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.user_emails {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborator_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.user_emails {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollaboratorsRequest {
        DeleteCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborator_ids.clear();
        self.user_emails.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollaboratorsRequest {
        static instance: DeleteCollaboratorsRequest = DeleteCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborator_ids: ::std::vec::Vec::new(),
            user_emails: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiCollaboratorsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiCollaboratorsResponse)
pub struct MultiCollaboratorsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollaboratorsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollaboratorsResponse {
    fn default() -> &'a MultiCollaboratorsResponse {
        <MultiCollaboratorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaboratorsResponse {
    pub fn new() -> MultiCollaboratorsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollaboratorsResponse| { &m.status },
            |m: &mut MultiCollaboratorsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &MultiCollaboratorsResponse| { &m.collaborators },
            |m: &mut MultiCollaboratorsResponse| { &mut m.collaborators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollaboratorsResponse>(
            "MultiCollaboratorsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollaboratorsResponse {
    const NAME: &'static str = "MultiCollaboratorsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollaboratorsResponse {
        MultiCollaboratorsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collaborators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollaboratorsResponse {
        static instance: MultiCollaboratorsResponse = MultiCollaboratorsResponse {
            status: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollaboratorsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollaboratorsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollaboratorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaboratorsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListCollaborationsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListCollaborationsRequest)
pub struct ListCollaborationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollaborationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollaborationsRequest {
    fn default() -> &'a ListCollaborationsRequest {
        <ListCollaborationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaborationsRequest {
    pub fn new() -> ListCollaborationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollaborationsRequest| { &m.user_app_id },
            |m: &mut ListCollaborationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollaborationsRequest| { &m.page },
            |m: &mut ListCollaborationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollaborationsRequest| { &m.per_page },
            |m: &mut ListCollaborationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollaborationsRequest>(
            "ListCollaborationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollaborationsRequest {
    const NAME: &'static str = "ListCollaborationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollaborationsRequest {
        ListCollaborationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollaborationsRequest {
        static instance: ListCollaborationsRequest = ListCollaborationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollaborationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollaborationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollaborationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaborationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiCollaborationsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiCollaborationsResponse)
pub struct MultiCollaborationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaborationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaborationsResponse.collaborations)
    pub collaborations: ::std::vec::Vec<super::resources::Collaboration>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollaborationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollaborationsResponse {
    fn default() -> &'a MultiCollaborationsResponse {
        <MultiCollaborationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaborationsResponse {
    pub fn new() -> MultiCollaborationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollaborationsResponse| { &m.status },
            |m: &mut MultiCollaborationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborations",
            |m: &MultiCollaborationsResponse| { &m.collaborations },
            |m: &mut MultiCollaborationsResponse| { &mut m.collaborations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollaborationsResponse>(
            "MultiCollaborationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollaborationsResponse {
    const NAME: &'static str = "MultiCollaborationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collaborations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollaborationsResponse {
        MultiCollaborationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collaborations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollaborationsResponse {
        static instance: MultiCollaborationsResponse = MultiCollaborationsResponse {
            status: ::protobuf::MessageField::none(),
            collaborations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollaborationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollaborationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollaborationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaborationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetStatusCodeRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetStatusCodeRequest)
pub struct GetStatusCodeRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetStatusCodeRequest.status_code_id)
    pub status_code_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetStatusCodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStatusCodeRequest {
    fn default() -> &'a GetStatusCodeRequest {
        <GetStatusCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusCodeRequest {
    pub fn new() -> GetStatusCodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code_id",
            |m: &GetStatusCodeRequest| { &m.status_code_id },
            |m: &mut GetStatusCodeRequest| { &mut m.status_code_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStatusCodeRequest>(
            "GetStatusCodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStatusCodeRequest {
    const NAME: &'static str = "GetStatusCodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.status_code_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.status_code_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status_code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.status_code_id.is_empty() {
            os.write_string(1, &self.status_code_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStatusCodeRequest {
        GetStatusCodeRequest::new()
    }

    fn clear(&mut self) {
        self.status_code_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStatusCodeRequest {
        static instance: GetStatusCodeRequest = GetStatusCodeRequest {
            status_code_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStatusCodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStatusCodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStatusCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusCodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListStatusCodesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListStatusCodesRequest)
pub struct ListStatusCodesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListStatusCodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListStatusCodesRequest {
    fn default() -> &'a ListStatusCodesRequest {
        <ListStatusCodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStatusCodesRequest {
    pub fn new() -> ListStatusCodesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListStatusCodesRequest>(
            "ListStatusCodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListStatusCodesRequest {
    const NAME: &'static str = "ListStatusCodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListStatusCodesRequest {
        ListStatusCodesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListStatusCodesRequest {
        static instance: ListStatusCodesRequest = ListStatusCodesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListStatusCodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListStatusCodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListStatusCodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleStatusCodeResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleStatusCodeResponse)
pub struct SingleStatusCodeResponse {
    // message fields
    ///  Status of this request.
    // @@protoc_insertion_point(field:clarifai.api.SingleStatusCodeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleStatusCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleStatusCodeResponse {
    fn default() -> &'a SingleStatusCodeResponse {
        <SingleStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleStatusCodeResponse {
    pub fn new() -> SingleStatusCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleStatusCodeResponse| { &m.status },
            |m: &mut SingleStatusCodeResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleStatusCodeResponse>(
            "SingleStatusCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleStatusCodeResponse {
    const NAME: &'static str = "SingleStatusCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleStatusCodeResponse {
        SingleStatusCodeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleStatusCodeResponse {
        static instance: SingleStatusCodeResponse = SingleStatusCodeResponse {
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleStatusCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleStatusCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleStatusCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatusCodeResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiStatusCodeResponse)
pub struct MultiStatusCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiStatusCodeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiStatusCodeResponse.statuses)
    pub statuses: ::std::vec::Vec<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatusCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatusCodeResponse {
    fn default() -> &'a MultiStatusCodeResponse {
        <MultiStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatusCodeResponse {
    pub fn new() -> MultiStatusCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatusCodeResponse| { &m.status },
            |m: &mut MultiStatusCodeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &MultiStatusCodeResponse| { &m.statuses },
            |m: &mut MultiStatusCodeResponse| { &mut m.statuses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatusCodeResponse>(
            "MultiStatusCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatusCodeResponse {
    const NAME: &'static str = "MultiStatusCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.statuses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.statuses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatusCodeResponse {
        MultiStatusCodeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.statuses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatusCodeResponse {
        static instance: MultiStatusCodeResponse = MultiStatusCodeResponse {
            status: ::protobuf::MessageField::none(),
            statuses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatusCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatusCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatusCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConceptRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetConceptRequest)
pub struct GetConceptRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept's id.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptRequest.concept_id)
    pub concept_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptRequest {
    fn default() -> &'a GetConceptRequest {
        <GetConceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptRequest {
    pub fn new() -> GetConceptRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptRequest| { &m.user_app_id },
            |m: &mut GetConceptRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &GetConceptRequest| { &m.concept_id },
            |m: &mut GetConceptRequest| { &mut m.concept_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptRequest>(
            "GetConceptRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptRequest {
    const NAME: &'static str = "GetConceptRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptRequest {
        GetConceptRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptRequest {
        static instance: GetConceptRequest = GetConceptRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListConceptsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListConceptsRequest)
pub struct ListConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptsRequest {
    fn default() -> &'a ListConceptsRequest {
        <ListConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptsRequest {
    pub fn new() -> ListConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptsRequest| { &m.user_app_id },
            |m: &mut ListConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptsRequest| { &m.page },
            |m: &mut ListConceptsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptsRequest| { &m.per_page },
            |m: &mut ListConceptsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptsRequest>(
            "ListConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptsRequest {
    const NAME: &'static str = "ListConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptsRequest {
        ListConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptsRequest {
        static instance: ListConceptsRequest = ListConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelConceptsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelConceptsRequest)
pub struct ListModelConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Model id
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  Model version Id. Optional, if not provided latest model version is used.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelConceptsRequest {
    fn default() -> &'a ListModelConceptsRequest {
        <ListModelConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelConceptsRequest {
    pub fn new() -> ListModelConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelConceptsRequest| { &m.user_app_id },
            |m: &mut ListModelConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelConceptsRequest| { &m.model_id },
            |m: &mut ListModelConceptsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ListModelConceptsRequest| { &m.version_id },
            |m: &mut ListModelConceptsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelConceptsRequest| { &m.page },
            |m: &mut ListModelConceptsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelConceptsRequest| { &m.per_page },
            |m: &mut ListModelConceptsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelConceptsRequest>(
            "ListModelConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelConceptsRequest {
    const NAME: &'static str = "ListModelConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelConceptsRequest {
        ListModelConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelConceptsRequest {
        static instance: ListModelConceptsRequest = ListModelConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostConceptsSearchesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostConceptsSearchesRequest)
pub struct PostConceptsSearchesRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.concept_query)
    pub concept_query: ::protobuf::MessageField<super::resources::ConceptQuery>,
    ///  Request additional info to be retrieved for each concept in the response.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.extra_info)
    pub extra_info: ::protobuf::MessageField<ConceptExtraInfoRequest>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptsSearchesRequest {
    fn default() -> &'a PostConceptsSearchesRequest {
        <PostConceptsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsSearchesRequest {
    pub fn new() -> PostConceptsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptsSearchesRequest| { &m.user_app_id },
            |m: &mut PostConceptsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ConceptQuery>(
            "concept_query",
            |m: &PostConceptsSearchesRequest| { &m.concept_query },
            |m: &mut PostConceptsSearchesRequest| { &mut m.concept_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptExtraInfoRequest>(
            "extra_info",
            |m: &PostConceptsSearchesRequest| { &m.extra_info },
            |m: &mut PostConceptsSearchesRequest| { &mut m.extra_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostConceptsSearchesRequest| { &m.pagination },
            |m: &mut PostConceptsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptsSearchesRequest>(
            "PostConceptsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptsSearchesRequest {
    const NAME: &'static str = "PostConceptsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_query)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extra_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.extra_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptsSearchesRequest {
        PostConceptsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_query.clear();
        self.extra_info.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptsSearchesRequest {
        static instance: PostConceptsSearchesRequest = PostConceptsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_query: ::protobuf::MessageField::none(),
            extra_info: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ConceptExtraInfoRequest)
pub struct ConceptExtraInfoRequest {
    // message fields
    ///  Determine if the concept is searchable by rank using this model.
    ///  Currently, only embedder models are supported.
    ///  ########## Supported fields ##########
    ///  - app_id
    ///  - id
    ///  - model_version.id
    ///  - user_id
    // @@protoc_insertion_point(field:clarifai.api.ConceptExtraInfoRequest.rankable_model)
    pub rankable_model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptExtraInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptExtraInfoRequest {
    fn default() -> &'a ConceptExtraInfoRequest {
        <ConceptExtraInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConceptExtraInfoRequest {
    pub fn new() -> ConceptExtraInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "rankable_model",
            |m: &ConceptExtraInfoRequest| { &m.rankable_model },
            |m: &mut ConceptExtraInfoRequest| { &mut m.rankable_model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptExtraInfoRequest>(
            "ConceptExtraInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptExtraInfoRequest {
    const NAME: &'static str = "ConceptExtraInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankable_model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rankable_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rankable_model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptExtraInfoRequest {
        ConceptExtraInfoRequest::new()
    }

    fn clear(&mut self) {
        self.rankable_model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptExtraInfoRequest {
        static instance: ConceptExtraInfoRequest = ConceptExtraInfoRequest {
            rankable_model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptExtraInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptExtraInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptExtraInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptExtraInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostConceptsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostConceptsRequest)
pub struct PostConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concepts to add.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsRequest.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptsRequest {
    fn default() -> &'a PostConceptsRequest {
        <PostConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsRequest {
    pub fn new() -> PostConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptsRequest| { &m.user_app_id },
            |m: &mut PostConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &PostConceptsRequest| { &m.concepts },
            |m: &mut PostConceptsRequest| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptsRequest>(
            "PostConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptsRequest {
    const NAME: &'static str = "PostConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptsRequest {
        PostConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptsRequest {
        static instance: PostConceptsRequest = PostConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchConceptsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchConceptsRequest)
pub struct PatchConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concepts to patch.
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    ///  The action to perform on the patched objects
    ///  For now ony action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchConceptsRequest {
    fn default() -> &'a PatchConceptsRequest {
        <PatchConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptsRequest {
    pub fn new() -> PatchConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchConceptsRequest| { &m.user_app_id },
            |m: &mut PatchConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &PatchConceptsRequest| { &m.concepts },
            |m: &mut PatchConceptsRequest| { &mut m.concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchConceptsRequest| { &m.action },
            |m: &mut PatchConceptsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchConceptsRequest>(
            "PatchConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchConceptsRequest {
    const NAME: &'static str = "PatchConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchConceptsRequest {
        PatchConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchConceptsRequest {
        static instance: PatchConceptsRequest = PatchConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConceptCountsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetConceptCountsRequest)
pub struct GetConceptCountsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptCountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptCountsRequest {
    fn default() -> &'a GetConceptCountsRequest {
        <GetConceptCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptCountsRequest {
    pub fn new() -> GetConceptCountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptCountsRequest| { &m.user_app_id },
            |m: &mut GetConceptCountsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &GetConceptCountsRequest| { &m.page },
            |m: &mut GetConceptCountsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &GetConceptCountsRequest| { &m.per_page },
            |m: &mut GetConceptCountsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptCountsRequest>(
            "GetConceptCountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptCountsRequest {
    const NAME: &'static str = "GetConceptCountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptCountsRequest {
        GetConceptCountsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptCountsRequest {
        static instance: GetConceptCountsRequest = GetConceptCountsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptCountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptCountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptCountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleConceptResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleConceptResponse)
pub struct SingleConceptResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept.
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptResponse.concept)
    pub concept: ::protobuf::MessageField<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleConceptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleConceptResponse {
    fn default() -> &'a SingleConceptResponse {
        <SingleConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptResponse {
    pub fn new() -> SingleConceptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleConceptResponse| { &m.status },
            |m: &mut SingleConceptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Concept>(
            "concept",
            |m: &SingleConceptResponse| { &m.concept },
            |m: &mut SingleConceptResponse| { &mut m.concept },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleConceptResponse>(
            "SingleConceptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleConceptResponse {
    const NAME: &'static str = "SingleConceptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleConceptResponse {
        SingleConceptResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleConceptResponse {
        static instance: SingleConceptResponse = SingleConceptResponse {
            status: ::protobuf::MessageField::none(),
            concept: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleConceptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleConceptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiConceptResponse)
pub struct MultiConceptResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concepts.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptResponse.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptResponse {
    fn default() -> &'a MultiConceptResponse {
        <MultiConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptResponse {
    pub fn new() -> MultiConceptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptResponse| { &m.status },
            |m: &mut MultiConceptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &MultiConceptResponse| { &m.concepts },
            |m: &mut MultiConceptResponse| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptResponse>(
            "MultiConceptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptResponse {
    const NAME: &'static str = "MultiConceptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptResponse {
        MultiConceptResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptResponse {
        static instance: MultiConceptResponse = MultiConceptResponse {
            status: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptCountResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiConceptCountResponse)
pub struct MultiConceptCountResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept counts.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptCountResponse.concept_counts)
    pub concept_counts: ::std::vec::Vec<super::resources::ConceptCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptCountResponse {
    fn default() -> &'a MultiConceptCountResponse {
        <MultiConceptCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptCountResponse {
    pub fn new() -> MultiConceptCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptCountResponse| { &m.status },
            |m: &mut MultiConceptCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_counts",
            |m: &MultiConceptCountResponse| { &m.concept_counts },
            |m: &mut MultiConceptCountResponse| { &mut m.concept_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptCountResponse>(
            "MultiConceptCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptCountResponse {
    const NAME: &'static str = "MultiConceptCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_counts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptCountResponse {
        MultiConceptCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptCountResponse {
        static instance: MultiConceptCountResponse = MultiConceptCountResponse {
            status: ::protobuf::MessageField::none(),
            concept_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET all relations such that the concept_id refers to the subject of the relation
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListConceptRelationsRequest)
pub struct ListConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The subject concept id in your app to get all the relationships for.
    ///  Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
    ///
    ///  When listing all the relations it will only return one direction of the relationship
    ///  with the predicate acting on the subject and not the inverse like is done when providing a
    ///  concept_id so that we can return a reliable page size always.
    ///
    ///  When providing a concept_id, if a hyponym is present in the DB such as:
    ///  'honey' (subject), 'hyponym' (predicate for "is a kind of"), 'food' (object)
    ///  then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
    ///  object.
    ///  But you can also list the concept relations for 'food' and it will return the same hyponym
    ///  relationship with 'honey' as object and 'hypernym' as predicate.
    ///  Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
    ///  when listing the relations.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  If predicate is provided then only list relations with that predicate.
    ///
    ///  Note that if no subject is set in concept_id and predicate is set to
    ///  'hypernym', then it will return any stored hyponyms as hypernyms with
    ///  just the subject and object swapped since they are reversed relations.
    ///
    ///  Valid predicates are:
    ///  - 'hypernym'
    ///  - 'hyponym'
    ///  - 'synonym'
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.predicate)
    pub predicate: ::std::string::String,
    ///  If knowledge_graph_id is provided then just list relations from that knowledge graph.
    ///  If not provided then list relations from all knowledge graphs including the global one for this
    ///  app one (ie. knowledge_graph "") and any specific ones in the app.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.knowledge_graph_id)
    pub knowledge_graph_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptRelationsRequest {
    fn default() -> &'a ListConceptRelationsRequest {
        <ListConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptRelationsRequest {
    pub fn new() -> ListConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptRelationsRequest| { &m.user_app_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &ListConceptRelationsRequest| { &m.concept_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "predicate",
            |m: &ListConceptRelationsRequest| { &m.predicate },
            |m: &mut ListConceptRelationsRequest| { &mut m.predicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "knowledge_graph_id",
            |m: &ListConceptRelationsRequest| { &m.knowledge_graph_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.knowledge_graph_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptRelationsRequest| { &m.page },
            |m: &mut ListConceptRelationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptRelationsRequest| { &m.per_page },
            |m: &mut ListConceptRelationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptRelationsRequest>(
            "ListConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptRelationsRequest {
    const NAME: &'static str = "ListConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.predicate = is.read_string()?;
                },
                34 => {
                    self.knowledge_graph_id = is.read_string()?;
                },
                40 => {
                    self.page = is.read_uint32()?;
                },
                48 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.knowledge_graph_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(3, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(4, &self.knowledge_graph_id)?;
        }
        if self.page != 0 {
            os.write_uint32(5, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(6, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptRelationsRequest {
        ListConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptRelationsRequest {
        static instance: ListConceptRelationsRequest = ListConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            predicate: ::std::string::String::new(),
            knowledge_graph_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST new concept relations
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostConceptRelationsRequest)
pub struct PostConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The subject concept id you're going to add relations for.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  The relationships you're going to add.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.concept_relations)
    pub concept_relations: ::std::vec::Vec<super::resources::ConceptRelation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptRelationsRequest {
    fn default() -> &'a PostConceptRelationsRequest {
        <PostConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptRelationsRequest {
    pub fn new() -> PostConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptRelationsRequest| { &m.user_app_id },
            |m: &mut PostConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PostConceptRelationsRequest| { &m.concept_id },
            |m: &mut PostConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relations",
            |m: &PostConceptRelationsRequest| { &m.concept_relations },
            |m: &mut PostConceptRelationsRequest| { &mut m.concept_relations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptRelationsRequest>(
            "PostConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptRelationsRequest {
    const NAME: &'static str = "PostConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_relations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_relations {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptRelationsRequest {
        PostConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_relations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptRelationsRequest {
        static instance: PostConceptRelationsRequest = PostConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_relations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DELETE concept relations
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteConceptRelationsRequest)
pub struct DeleteConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept to delete relationship for.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  The concept relationship ids to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteConceptRelationsRequest {
    fn default() -> &'a DeleteConceptRelationsRequest {
        <DeleteConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConceptRelationsRequest {
    pub fn new() -> DeleteConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteConceptRelationsRequest| { &m.user_app_id },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &DeleteConceptRelationsRequest| { &m.concept_id },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteConceptRelationsRequest| { &m.ids },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteConceptRelationsRequest>(
            "DeleteConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteConceptRelationsRequest {
    const NAME: &'static str = "DeleteConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteConceptRelationsRequest {
        DeleteConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteConceptRelationsRequest {
        static instance: DeleteConceptRelationsRequest = DeleteConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET all knowledge graphs
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListKnowledgeGraphsRequest)
pub struct ListKnowledgeGraphsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListKnowledgeGraphsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListKnowledgeGraphsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKnowledgeGraphsRequest {
    fn default() -> &'a ListKnowledgeGraphsRequest {
        <ListKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKnowledgeGraphsRequest {
    pub fn new() -> ListKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListKnowledgeGraphsRequest| { &m.user_app_id },
            |m: &mut ListKnowledgeGraphsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListKnowledgeGraphsRequest>(
            "ListKnowledgeGraphsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListKnowledgeGraphsRequest {
    const NAME: &'static str = "ListKnowledgeGraphsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKnowledgeGraphsRequest {
        ListKnowledgeGraphsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKnowledgeGraphsRequest {
        static instance: ListKnowledgeGraphsRequest = ListKnowledgeGraphsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListKnowledgeGraphsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListKnowledgeGraphsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKnowledgeGraphsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST new knowledge graphs
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostKnowledgeGraphsRequest)
pub struct PostKnowledgeGraphsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostKnowledgeGraphsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostKnowledgeGraphsRequest.knowledge_graphs)
    pub knowledge_graphs: ::std::vec::Vec<super::resources::KnowledgeGraph>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostKnowledgeGraphsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostKnowledgeGraphsRequest {
    fn default() -> &'a PostKnowledgeGraphsRequest {
        <PostKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKnowledgeGraphsRequest {
    pub fn new() -> PostKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostKnowledgeGraphsRequest| { &m.user_app_id },
            |m: &mut PostKnowledgeGraphsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "knowledge_graphs",
            |m: &PostKnowledgeGraphsRequest| { &m.knowledge_graphs },
            |m: &mut PostKnowledgeGraphsRequest| { &mut m.knowledge_graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostKnowledgeGraphsRequest>(
            "PostKnowledgeGraphsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostKnowledgeGraphsRequest {
    const NAME: &'static str = "PostKnowledgeGraphsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.knowledge_graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.knowledge_graphs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostKnowledgeGraphsRequest {
        PostKnowledgeGraphsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.knowledge_graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostKnowledgeGraphsRequest {
        static instance: PostKnowledgeGraphsRequest = PostKnowledgeGraphsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            knowledge_graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostKnowledgeGraphsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostKnowledgeGraphsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKnowledgeGraphsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start concept mapping jobs
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostConceptMappingJobsRequest)
pub struct PostConceptMappingJobsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptMappingJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept mapping jobs that are being started
    // @@protoc_insertion_point(field:clarifai.api.PostConceptMappingJobsRequest.concept_mapping_jobs)
    pub concept_mapping_jobs: ::std::vec::Vec<super::resources::ConceptMappingJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptMappingJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptMappingJobsRequest {
    fn default() -> &'a PostConceptMappingJobsRequest {
        <PostConceptMappingJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptMappingJobsRequest {
    pub fn new() -> PostConceptMappingJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptMappingJobsRequest| { &m.user_app_id },
            |m: &mut PostConceptMappingJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_mapping_jobs",
            |m: &PostConceptMappingJobsRequest| { &m.concept_mapping_jobs },
            |m: &mut PostConceptMappingJobsRequest| { &mut m.concept_mapping_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptMappingJobsRequest>(
            "PostConceptMappingJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptMappingJobsRequest {
    const NAME: &'static str = "PostConceptMappingJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_mapping_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_mapping_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_mapping_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptMappingJobsRequest {
        PostConceptMappingJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_mapping_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptMappingJobsRequest {
        static instance: PostConceptMappingJobsRequest = PostConceptMappingJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_mapping_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptMappingJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptMappingJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptMappingJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptMappingJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptRelationResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiConceptRelationResponse)
pub struct MultiConceptRelationResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptRelationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept relations.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptRelationResponse.concept_relations)
    pub concept_relations: ::std::vec::Vec<super::resources::ConceptRelation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptRelationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptRelationResponse {
    fn default() -> &'a MultiConceptRelationResponse {
        <MultiConceptRelationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptRelationResponse {
    pub fn new() -> MultiConceptRelationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptRelationResponse| { &m.status },
            |m: &mut MultiConceptRelationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relations",
            |m: &MultiConceptRelationResponse| { &m.concept_relations },
            |m: &mut MultiConceptRelationResponse| { &mut m.concept_relations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptRelationResponse>(
            "MultiConceptRelationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptRelationResponse {
    const NAME: &'static str = "MultiConceptRelationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_relations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_relations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptRelationResponse {
        MultiConceptRelationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_relations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptRelationResponse {
        static instance: MultiConceptRelationResponse = MultiConceptRelationResponse {
            status: ::protobuf::MessageField::none(),
            concept_relations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptRelationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptRelationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptRelationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptRelationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiKnowledgeGraphResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiKnowledgeGraphResponse)
pub struct MultiKnowledgeGraphResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiKnowledgeGraphResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned knowledge graphs.
    // @@protoc_insertion_point(field:clarifai.api.MultiKnowledgeGraphResponse.knowledge_graphs)
    pub knowledge_graphs: ::std::vec::Vec<super::resources::KnowledgeGraph>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiKnowledgeGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiKnowledgeGraphResponse {
    fn default() -> &'a MultiKnowledgeGraphResponse {
        <MultiKnowledgeGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKnowledgeGraphResponse {
    pub fn new() -> MultiKnowledgeGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiKnowledgeGraphResponse| { &m.status },
            |m: &mut MultiKnowledgeGraphResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "knowledge_graphs",
            |m: &MultiKnowledgeGraphResponse| { &m.knowledge_graphs },
            |m: &mut MultiKnowledgeGraphResponse| { &mut m.knowledge_graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiKnowledgeGraphResponse>(
            "MultiKnowledgeGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiKnowledgeGraphResponse {
    const NAME: &'static str = "MultiKnowledgeGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.knowledge_graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.knowledge_graphs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiKnowledgeGraphResponse {
        MultiKnowledgeGraphResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.knowledge_graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiKnowledgeGraphResponse {
        static instance: MultiKnowledgeGraphResponse = MultiKnowledgeGraphResponse {
            status: ::protobuf::MessageField::none(),
            knowledge_graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiKnowledgeGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiKnowledgeGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiKnowledgeGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKnowledgeGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptMappingJobResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiConceptMappingJobResponse)
pub struct MultiConceptMappingJobResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptMappingJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The ids of the concept mapping jobs underway.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptMappingJobResponse.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptMappingJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptMappingJobResponse {
    fn default() -> &'a MultiConceptMappingJobResponse {
        <MultiConceptMappingJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptMappingJobResponse {
    pub fn new() -> MultiConceptMappingJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptMappingJobResponse| { &m.status },
            |m: &mut MultiConceptMappingJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &MultiConceptMappingJobResponse| { &m.ids },
            |m: &mut MultiConceptMappingJobResponse| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptMappingJobResponse>(
            "MultiConceptMappingJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptMappingJobResponse {
    const NAME: &'static str = "MultiConceptMappingJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptMappingJobResponse {
        MultiConceptMappingJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptMappingJobResponse {
        static instance: MultiConceptMappingJobResponse = MultiConceptMappingJobResponse {
            status: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptMappingJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptMappingJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptMappingJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptMappingJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET single concept language for the given concept.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetConceptLanguageRequest)
pub struct GetConceptLanguageRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  This is the language identifier.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.language)
    pub language: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptLanguageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptLanguageRequest {
    fn default() -> &'a GetConceptLanguageRequest {
        <GetConceptLanguageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptLanguageRequest {
    pub fn new() -> GetConceptLanguageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptLanguageRequest| { &m.user_app_id },
            |m: &mut GetConceptLanguageRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &GetConceptLanguageRequest| { &m.concept_id },
            |m: &mut GetConceptLanguageRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &GetConceptLanguageRequest| { &m.language },
            |m: &mut GetConceptLanguageRequest| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptLanguageRequest>(
            "GetConceptLanguageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptLanguageRequest {
    const NAME: &'static str = "GetConceptLanguageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.language = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(3, &self.language)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptLanguageRequest {
        GetConceptLanguageRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptLanguageRequest {
        static instance: GetConceptLanguageRequest = GetConceptLanguageRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptLanguageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptLanguageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptLanguageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptLanguageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  List multiple concept languages for the given concept.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListConceptLanguagesRequest)
pub struct ListConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptLanguagesRequest {
    fn default() -> &'a ListConceptLanguagesRequest {
        <ListConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptLanguagesRequest {
    pub fn new() -> ListConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut ListConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &ListConceptLanguagesRequest| { &m.concept_id },
            |m: &mut ListConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptLanguagesRequest| { &m.page },
            |m: &mut ListConceptLanguagesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptLanguagesRequest| { &m.per_page },
            |m: &mut ListConceptLanguagesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptLanguagesRequest>(
            "ListConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptLanguagesRequest {
    const NAME: &'static str = "ListConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptLanguagesRequest {
        ListConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptLanguagesRequest {
        static instance: ListConceptLanguagesRequest = ListConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PATCH multiple concept languages for the given concept.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchConceptLanguagesRequest)
pub struct PatchConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    ///  The action to perform with the objects in the PATCH.
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchConceptLanguagesRequest {
    fn default() -> &'a PatchConceptLanguagesRequest {
        <PatchConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptLanguagesRequest {
    pub fn new() -> PatchConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PatchConceptLanguagesRequest| { &m.concept_id },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &PatchConceptLanguagesRequest| { &m.concept_languages },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchConceptLanguagesRequest| { &m.action },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchConceptLanguagesRequest>(
            "PatchConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchConceptLanguagesRequest {
    const NAME: &'static str = "PatchConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_languages.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchConceptLanguagesRequest {
        PatchConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchConceptLanguagesRequest {
        static instance: PatchConceptLanguagesRequest = PatchConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_languages: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST multiple concept languages for the given concept.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostConceptLanguagesRequest)
pub struct PostConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptLanguagesRequest {
    fn default() -> &'a PostConceptLanguagesRequest {
        <PostConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptLanguagesRequest {
    pub fn new() -> PostConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut PostConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PostConceptLanguagesRequest| { &m.concept_id },
            |m: &mut PostConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &PostConceptLanguagesRequest| { &m.concept_languages },
            |m: &mut PostConceptLanguagesRequest| { &mut m.concept_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptLanguagesRequest>(
            "PostConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptLanguagesRequest {
    const NAME: &'static str = "PostConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptLanguagesRequest {
        PostConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptLanguagesRequest {
        static instance: PostConceptLanguagesRequest = PostConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleConceptLanguageResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleConceptLanguageResponse)
pub struct SingleConceptLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptLanguageResponse.concept_language)
    pub concept_language: ::protobuf::MessageField<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleConceptLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleConceptLanguageResponse {
    fn default() -> &'a SingleConceptLanguageResponse {
        <SingleConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptLanguageResponse {
    pub fn new() -> SingleConceptLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleConceptLanguageResponse| { &m.status },
            |m: &mut SingleConceptLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ConceptLanguage>(
            "concept_language",
            |m: &SingleConceptLanguageResponse| { &m.concept_language },
            |m: &mut SingleConceptLanguageResponse| { &mut m.concept_language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleConceptLanguageResponse>(
            "SingleConceptLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleConceptLanguageResponse {
    const NAME: &'static str = "SingleConceptLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_language)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept_language.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept_language.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleConceptLanguageResponse {
        SingleConceptLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleConceptLanguageResponse {
        static instance: SingleConceptLanguageResponse = SingleConceptLanguageResponse {
            status: ::protobuf::MessageField::none(),
            concept_language: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleConceptLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleConceptLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptLanguageResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiConceptLanguageResponse)
pub struct MultiConceptLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptLanguageResponse.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptLanguageResponse {
    fn default() -> &'a MultiConceptLanguageResponse {
        <MultiConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptLanguageResponse {
    pub fn new() -> MultiConceptLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptLanguageResponse| { &m.status },
            |m: &mut MultiConceptLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &MultiConceptLanguageResponse| { &m.concept_languages },
            |m: &mut MultiConceptLanguageResponse| { &mut m.concept_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptLanguageResponse>(
            "MultiConceptLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptLanguageResponse {
    const NAME: &'static str = "MultiConceptLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptLanguageResponse {
        MultiConceptLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptLanguageResponse {
        static instance: MultiConceptLanguageResponse = MultiConceptLanguageResponse {
            status: ::protobuf::MessageField::none(),
            concept_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetInputRequest)
pub struct GetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputRequest {
    fn default() -> &'a GetInputRequest {
        <GetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputRequest {
    pub fn new() -> GetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputRequest| { &m.user_app_id },
            |m: &mut GetInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetInputRequest| { &m.input_id },
            |m: &mut GetInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputRequest>(
            "GetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputRequest {
    const NAME: &'static str = "GetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputRequest {
        GetInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputRequest {
        static instance: GetInputRequest = GetInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetVideoManifestRequest)
pub struct GetVideoManifestRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetVideoManifestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVideoManifestRequest {
    fn default() -> &'a GetVideoManifestRequest {
        <GetVideoManifestRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVideoManifestRequest {
    pub fn new() -> GetVideoManifestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetVideoManifestRequest| { &m.user_app_id },
            |m: &mut GetVideoManifestRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetVideoManifestRequest| { &m.input_id },
            |m: &mut GetVideoManifestRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVideoManifestRequest>(
            "GetVideoManifestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVideoManifestRequest {
    const NAME: &'static str = "GetVideoManifestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVideoManifestRequest {
        GetVideoManifestRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVideoManifestRequest {
        static instance: GetVideoManifestRequest = GetVideoManifestRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVideoManifestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVideoManifestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVideoManifestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVideoManifestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputSamplesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetInputSamplesRequest)
pub struct GetInputSamplesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.task_id)
    pub task_id: ::std::string::String,
    ///  URL param. If zero ids provided, returns for all task labelers
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputSamplesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputSamplesRequest {
    fn default() -> &'a GetInputSamplesRequest {
        <GetInputSamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputSamplesRequest {
    pub fn new() -> GetInputSamplesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputSamplesRequest| { &m.user_app_id },
            |m: &mut GetInputSamplesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetInputSamplesRequest| { &m.task_id },
            |m: &mut GetInputSamplesRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &GetInputSamplesRequest| { &m.user_ids },
            |m: &mut GetInputSamplesRequest| { &mut m.user_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputSamplesRequest>(
            "GetInputSamplesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputSamplesRequest {
    const NAME: &'static str = "GetInputSamplesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputSamplesRequest {
        GetInputSamplesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputSamplesRequest {
        static instance: GetInputSamplesRequest = GetInputSamplesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            user_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputSamplesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputSamplesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputSamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputSamplesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListInputsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListInputsRequest)
pub struct ListInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.per_page)
    pub per_page: u32,
    ///  Set status to filter by status
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsRequest {
    fn default() -> &'a ListInputsRequest {
        <ListInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsRequest {
    pub fn new() -> ListInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsRequest| { &m.user_app_id },
            |m: &mut ListInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsRequest| { &m.page },
            |m: &mut ListInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsRequest| { &m.per_page },
            |m: &mut ListInputsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ListInputsRequest| { &m.status },
            |m: &mut ListInputsRequest| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListInputsRequest| { &m.ids },
            |m: &mut ListInputsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsRequest>(
            "ListInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsRequest {
    const NAME: &'static str = "ListInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                34 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsRequest {
        ListInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.status.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsRequest {
        static instance: ListInputsRequest = ListInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            status: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StreamInputsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.StreamInputsRequest)
pub struct StreamInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 20.
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.last_id)
    pub last_id: ::std::string::String,
    ///  By default, the endpoint return inputs by the time when it is added.
    ///  If this is set to true, we will return inputs by id.
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.order_by_id)
    pub order_by_id: bool,
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.descending)
    pub descending: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StreamInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamInputsRequest {
    fn default() -> &'a StreamInputsRequest {
        <StreamInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamInputsRequest {
    pub fn new() -> StreamInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &StreamInputsRequest| { &m.user_app_id },
            |m: &mut StreamInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &StreamInputsRequest| { &m.per_page },
            |m: &mut StreamInputsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_id",
            |m: &StreamInputsRequest| { &m.last_id },
            |m: &mut StreamInputsRequest| { &mut m.last_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_by_id",
            |m: &StreamInputsRequest| { &m.order_by_id },
            |m: &mut StreamInputsRequest| { &mut m.order_by_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "descending",
            |m: &StreamInputsRequest| { &m.descending },
            |m: &mut StreamInputsRequest| { &mut m.descending },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamInputsRequest>(
            "StreamInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamInputsRequest {
    const NAME: &'static str = "StreamInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.per_page = is.read_uint32()?;
                },
                26 => {
                    self.last_id = is.read_string()?;
                },
                40 => {
                    self.order_by_id = is.read_bool()?;
                },
                32 => {
                    self.descending = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.per_page);
        }
        if !self.last_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.last_id);
        }
        if self.order_by_id != false {
            my_size += 1 + 1;
        }
        if self.descending != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        if !self.last_id.is_empty() {
            os.write_string(3, &self.last_id)?;
        }
        if self.order_by_id != false {
            os.write_bool(5, self.order_by_id)?;
        }
        if self.descending != false {
            os.write_bool(4, self.descending)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamInputsRequest {
        StreamInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.per_page = 0;
        self.last_id.clear();
        self.order_by_id = false;
        self.descending = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamInputsRequest {
        static instance: StreamInputsRequest = StreamInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            per_page: 0,
            last_id: ::std::string::String::new(),
            order_by_id: false,
            descending: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInputsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostInputsRequest)
pub struct PostInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of inputs to post.
    ///  For each input, the following fields are used:
    ///  * id
    ///  * data
    ///  * dataset_ids
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Collect statistics about created inputs in job with given ID.
    ///  * If job ID is empty, then job is not created.
    ///  * If job ID is non-empty and doesn't already exist, then a new job will be created with given ID.
    ///  * If job ID does already exist, then new inputs statistics are merged with previous inputs statistics.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.inputs_add_job_id)
    pub inputs_add_job_id: ::std::string::String,
    ///  How to handle input ID conflicts.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.input_id_conflict_resolution)
    pub input_id_conflict_resolution: ::protobuf::EnumOrUnknown<super::resources::InputIDConflictResolution>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsRequest {
    fn default() -> &'a PostInputsRequest {
        <PostInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsRequest {
    pub fn new() -> PostInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsRequest| { &m.user_app_id },
            |m: &mut PostInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostInputsRequest| { &m.inputs },
            |m: &mut PostInputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_add_job_id",
            |m: &PostInputsRequest| { &m.inputs_add_job_id },
            |m: &mut PostInputsRequest| { &mut m.inputs_add_job_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id_conflict_resolution",
            |m: &PostInputsRequest| { &m.input_id_conflict_resolution },
            |m: &mut PostInputsRequest| { &mut m.input_id_conflict_resolution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsRequest>(
            "PostInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsRequest {
    const NAME: &'static str = "PostInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    self.inputs_add_job_id = is.read_string()?;
                },
                32 => {
                    self.input_id_conflict_resolution = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.inputs_add_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.inputs_add_job_id);
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.input_id_conflict_resolution.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.inputs_add_job_id.is_empty() {
            os.write_string(3, &self.inputs_add_job_id)?;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.input_id_conflict_resolution))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsRequest {
        PostInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.inputs_add_job_id.clear();
        self.input_id_conflict_resolution = ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsRequest {
        static instance: PostInputsRequest = PostInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            inputs_add_job_id: ::std::string::String::new(),
            input_id_conflict_resolution: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchInputsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchInputsRequest)
pub struct PatchInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of inputs to patch.
    ///  Inputs are identified by id field.
    ///  For each input, the following fields are patchable:
    ///  * data
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchInputsRequest {
    fn default() -> &'a PatchInputsRequest {
        <PatchInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsRequest {
    pub fn new() -> PatchInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchInputsRequest| { &m.user_app_id },
            |m: &mut PatchInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PatchInputsRequest| { &m.inputs },
            |m: &mut PatchInputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchInputsRequest| { &m.action },
            |m: &mut PatchInputsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchInputsRequest>(
            "PatchInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchInputsRequest {
    const NAME: &'static str = "PatchInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchInputsRequest {
        PatchInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchInputsRequest {
        static instance: PatchInputsRequest = PatchInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteInputRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteInputRequest)
pub struct DeleteInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInputRequest {
    fn default() -> &'a DeleteInputRequest {
        <DeleteInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputRequest {
    pub fn new() -> DeleteInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInputRequest| { &m.user_app_id },
            |m: &mut DeleteInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &DeleteInputRequest| { &m.input_id },
            |m: &mut DeleteInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInputRequest>(
            "DeleteInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInputRequest {
    const NAME: &'static str = "DeleteInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInputRequest {
        DeleteInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInputRequest {
        static instance: DeleteInputRequest = DeleteInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteInputsRequest)
pub struct DeleteInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInputsRequest {
    fn default() -> &'a DeleteInputsRequest {
        <DeleteInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputsRequest {
    pub fn new() -> DeleteInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInputsRequest| { &m.user_app_id },
            |m: &mut DeleteInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteInputsRequest| { &m.ids },
            |m: &mut DeleteInputsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInputsRequest>(
            "DeleteInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInputsRequest {
    const NAME: &'static str = "DeleteInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInputsRequest {
        DeleteInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInputsRequest {
        static instance: DeleteInputsRequest = DeleteInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleInputResponse)
pub struct SingleInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputResponse.input)
    pub input: ::protobuf::MessageField<super::resources::Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputResponse {
    fn default() -> &'a SingleInputResponse {
        <SingleInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputResponse {
    pub fn new() -> SingleInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputResponse| { &m.status },
            |m: &mut SingleInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Input>(
            "input",
            |m: &SingleInputResponse| { &m.input },
            |m: &mut SingleInputResponse| { &mut m.input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputResponse>(
            "SingleInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputResponse {
    const NAME: &'static str = "SingleInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputResponse {
        SingleInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputResponse {
        static instance: SingleInputResponse = SingleInputResponse {
            status: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetVideoManifestResponse)
pub struct GetVideoManifestResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  MPEG-dash manifest as data-URI, base64-encoded
    ///  Can be empty if status is FAILED
    ///  Can be fallback manifest if status is MIXED_STATUS
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestResponse.manifest_url)
    pub manifest_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetVideoManifestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVideoManifestResponse {
    fn default() -> &'a GetVideoManifestResponse {
        <GetVideoManifestResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetVideoManifestResponse {
    pub fn new() -> GetVideoManifestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &GetVideoManifestResponse| { &m.status },
            |m: &mut GetVideoManifestResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manifest_url",
            |m: &GetVideoManifestResponse| { &m.manifest_url },
            |m: &mut GetVideoManifestResponse| { &mut m.manifest_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVideoManifestResponse>(
            "GetVideoManifestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVideoManifestResponse {
    const NAME: &'static str = "GetVideoManifestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.manifest_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.manifest_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.manifest_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.manifest_url.is_empty() {
            os.write_string(2, &self.manifest_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVideoManifestResponse {
        GetVideoManifestResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.manifest_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVideoManifestResponse {
        static instance: GetVideoManifestResponse = GetVideoManifestResponse {
            status: ::protobuf::MessageField::none(),
            manifest_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVideoManifestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVideoManifestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVideoManifestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVideoManifestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiInputResponse)
pub struct MultiInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.inputs_add_job)
    pub inputs_add_job: ::protobuf::MessageField<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputResponse {
    fn default() -> &'a MultiInputResponse {
        <MultiInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputResponse {
    pub fn new() -> MultiInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputResponse| { &m.status },
            |m: &mut MultiInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &MultiInputResponse| { &m.inputs },
            |m: &mut MultiInputResponse| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsAddJob>(
            "inputs_add_job",
            |m: &MultiInputResponse| { &m.inputs_add_job },
            |m: &mut MultiInputResponse| { &mut m.inputs_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputResponse>(
            "MultiInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputResponse {
    const NAME: &'static str = "MultiInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inputs_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.inputs_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputResponse {
        MultiInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs.clear();
        self.inputs_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputResponse {
        static instance: MultiInputResponse = MultiInputResponse {
            status: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            inputs_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputAnnotationResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiInputAnnotationResponse)
pub struct MultiInputAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputAnnotationResponse.hits)
    pub hits: ::std::vec::Vec<super::resources::Hit>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputAnnotationResponse {
    fn default() -> &'a MultiInputAnnotationResponse {
        <MultiInputAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputAnnotationResponse {
    pub fn new() -> MultiInputAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputAnnotationResponse| { &m.status },
            |m: &mut MultiInputAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &MultiInputAnnotationResponse| { &m.hits },
            |m: &mut MultiInputAnnotationResponse| { &mut m.hits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputAnnotationResponse>(
            "MultiInputAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputAnnotationResponse {
    const NAME: &'static str = "MultiInputAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                26 => {
                    self.hits.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputAnnotationResponse {
        MultiInputAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.hits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputAnnotationResponse {
        static instance: MultiInputAnnotationResponse = MultiInputAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            hits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputCountResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleInputCountResponse)
pub struct SingleInputCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputCountResponse.counts)
    pub counts: ::protobuf::MessageField<super::resources::InputCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputCountResponse {
    fn default() -> &'a SingleInputCountResponse {
        <SingleInputCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputCountResponse {
    pub fn new() -> SingleInputCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputCountResponse| { &m.status },
            |m: &mut SingleInputCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputCount>(
            "counts",
            |m: &SingleInputCountResponse| { &m.counts },
            |m: &mut SingleInputCountResponse| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputCountResponse>(
            "SingleInputCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputCountResponse {
    const NAME: &'static str = "SingleInputCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.counts)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputCountResponse {
        SingleInputCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputCountResponse {
        static instance: SingleInputCountResponse = SingleInputCountResponse {
            status: ::protobuf::MessageField::none(),
            counts: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputCountRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetInputCountRequest)
pub struct GetInputCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputCountRequest {
    fn default() -> &'a GetInputCountRequest {
        <GetInputCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputCountRequest {
    pub fn new() -> GetInputCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputCountRequest| { &m.user_app_id },
            |m: &mut GetInputCountRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputCountRequest>(
            "GetInputCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputCountRequest {
    const NAME: &'static str = "GetInputCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputCountRequest {
        GetInputCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputCountRequest {
        static instance: GetInputCountRequest = GetInputCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListDatasetsRequest)
pub struct ListDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.starred_only)
    pub starred_only: bool,
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting opitons:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filter datasets by bookmark. If set, only return bookmarked datasets. Otherwise none bookmarked datasets only.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.bookmark)
    pub bookmark: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_datasets_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetsRequest {
    fn default() -> &'a ListDatasetsRequest {
        <ListDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetsRequest {
    pub fn new() -> ListDatasetsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_created_at = 7;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 8;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(v))
    }

    // bool sort_by_modified_at = 9;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_id = 11;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetsRequest| { &m.user_app_id },
            |m: &mut ListDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetsRequest| { &m.page },
            |m: &mut ListDatasetsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetsRequest| { &m.per_page },
            |m: &mut ListDatasetsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListDatasetsRequest| { &m.starred_only },
            |m: &mut ListDatasetsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListDatasetsRequest| { &m.additional_fields },
            |m: &mut ListDatasetsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListDatasetsRequest| { &m.sort_ascending },
            |m: &mut ListDatasetsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListDatasetsRequest::has_sort_by_created_at,
            ListDatasetsRequest::sort_by_created_at,
            ListDatasetsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListDatasetsRequest::has_sort_by_star_count,
            ListDatasetsRequest::sort_by_star_count,
            ListDatasetsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListDatasetsRequest::has_sort_by_modified_at,
            ListDatasetsRequest::sort_by_modified_at,
            ListDatasetsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListDatasetsRequest::has_sort_by_id,
            ListDatasetsRequest::sort_by_id,
            ListDatasetsRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListDatasetsRequest| { &m.bookmark },
            |m: &mut ListDatasetsRequest| { &mut m.bookmark },
        ));
        oneofs.push(list_datasets_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetsRequest>(
            "ListDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetsRequest {
    const NAME: &'static str = "ListDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.starred_only = is.read_bool()?;
                },
                42 => {
                    self.additional_fields.push(is.read_string()?);
                },
                48 => {
                    self.sort_ascending = is.read_bool()?;
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(is.read_bool()?));
                },
                80 => {
                    self.bookmark = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_datasets_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.starred_only != false {
            os.write_bool(4, self.starred_only)?;
        }
        for v in &self.additional_fields {
            os.write_string(5, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(6, self.sort_ascending)?;
        }
        if self.bookmark != false {
            os.write_bool(10, self.bookmark)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_datasets_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_datasets_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(8, v)?;
                },
                &list_datasets_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(9, v)?;
                },
                &list_datasets_request::Sort_by::SortById(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetsRequest {
        ListDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.starred_only = false;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.bookmark = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetsRequest {
        static instance: ListDatasetsRequest = ListDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            starred_only: false,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            bookmark: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListDatasetsRequest`
pub mod list_datasets_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListDatasetsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_star_count)
        SortByStarCount(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_id)
        SortById(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListDatasetsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  GetDatasetRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetDatasetRequest)
pub struct GetDatasetRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetRequest {
    fn default() -> &'a GetDatasetRequest {
        <GetDatasetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetRequest {
    pub fn new() -> GetDatasetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetRequest| { &m.user_app_id },
            |m: &mut GetDatasetRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetRequest| { &m.dataset_id },
            |m: &mut GetDatasetRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetDatasetRequest| { &m.additional_fields },
            |m: &mut GetDatasetRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetRequest>(
            "GetDatasetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetRequest {
    const NAME: &'static str = "GetDatasetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetRequest {
        GetDatasetRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetRequest {
        static instance: GetDatasetRequest = GetDatasetRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more datasets.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostDatasetsRequest)
pub struct PostDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of datasets that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetsRequest.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetsRequest {
    fn default() -> &'a PostDatasetsRequest {
        <PostDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetsRequest {
    pub fn new() -> PostDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetsRequest| { &m.user_app_id },
            |m: &mut PostDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &PostDatasetsRequest| { &m.datasets },
            |m: &mut PostDatasetsRequest| { &mut m.datasets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetsRequest>(
            "PostDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetsRequest {
    const NAME: &'static str = "PostDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetsRequest {
        PostDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.datasets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetsRequest {
        static instance: PostDatasetsRequest = PostDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several datasets.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchDatasetsRequest)
pub struct PatchDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of datasets that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    ///  The action to perform on the patched objects
    ///  Supported values: 'overwrite' and 'merge'
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchDatasetsRequest {
    fn default() -> &'a PatchDatasetsRequest {
        <PatchDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDatasetsRequest {
    pub fn new() -> PatchDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchDatasetsRequest| { &m.user_app_id },
            |m: &mut PatchDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &PatchDatasetsRequest| { &m.datasets },
            |m: &mut PatchDatasetsRequest| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchDatasetsRequest| { &m.action },
            |m: &mut PatchDatasetsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchDatasetsRequest>(
            "PatchDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchDatasetsRequest {
    const NAME: &'static str = "PatchDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchDatasetsRequest {
        PatchDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.datasets.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchDatasetsRequest {
        static instance: PatchDatasetsRequest = PatchDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several datasets by list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetsRequest)
pub struct DeleteDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetsRequest.dataset_ids)
    pub dataset_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetsRequest {
    fn default() -> &'a DeleteDatasetsRequest {
        <DeleteDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetsRequest {
    pub fn new() -> DeleteDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_ids",
            |m: &DeleteDatasetsRequest| { &m.dataset_ids },
            |m: &mut DeleteDatasetsRequest| { &mut m.dataset_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetsRequest>(
            "DeleteDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetsRequest {
    const NAME: &'static str = "DeleteDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetsRequest {
        DeleteDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetsRequest {
        static instance: DeleteDatasetsRequest = DeleteDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiDatasetResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetResponse)
pub struct MultiDatasetResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetResponse.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetResponse {
    fn default() -> &'a MultiDatasetResponse {
        <MultiDatasetResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetResponse {
    pub fn new() -> MultiDatasetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetResponse| { &m.status },
            |m: &mut MultiDatasetResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &MultiDatasetResponse| { &m.datasets },
            |m: &mut MultiDatasetResponse| { &mut m.datasets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetResponse>(
            "MultiDatasetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetResponse {
    const NAME: &'static str = "MultiDatasetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetResponse {
        MultiDatasetResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.datasets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetResponse {
        static instance: MultiDatasetResponse = MultiDatasetResponse {
            status: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleDatasetResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetResponse)
pub struct SingleDatasetResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetResponse.dataset)
    pub dataset: ::protobuf::MessageField<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetResponse {
    fn default() -> &'a SingleDatasetResponse {
        <SingleDatasetResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetResponse {
    pub fn new() -> SingleDatasetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetResponse| { &m.status },
            |m: &mut SingleDatasetResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Dataset>(
            "dataset",
            |m: &SingleDatasetResponse| { &m.dataset },
            |m: &mut SingleDatasetResponse| { &mut m.dataset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetResponse>(
            "SingleDatasetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetResponse {
    const NAME: &'static str = "SingleDatasetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetResponse {
        SingleDatasetResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetResponse {
        static instance: SingleDatasetResponse = SingleDatasetResponse {
            status: ::protobuf::MessageField::none(),
            dataset: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetInputsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListDatasetInputsRequest)
pub struct ListDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetInputsRequest {
    fn default() -> &'a ListDatasetInputsRequest {
        <ListDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetInputsRequest {
    pub fn new() -> ListDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetInputsRequest| { &m.user_app_id },
            |m: &mut ListDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetInputsRequest| { &m.dataset_id },
            |m: &mut ListDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetInputsRequest| { &m.page },
            |m: &mut ListDatasetInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetInputsRequest| { &m.per_page },
            |m: &mut ListDatasetInputsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetInputsRequest>(
            "ListDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetInputsRequest {
    const NAME: &'static str = "ListDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetInputsRequest {
        ListDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetInputsRequest {
        static instance: ListDatasetInputsRequest = ListDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetDatasetInputRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetDatasetInputRequest)
pub struct GetDatasetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset input by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetInputRequest {
    fn default() -> &'a GetDatasetInputRequest {
        <GetDatasetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetInputRequest {
    pub fn new() -> GetDatasetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetInputRequest| { &m.user_app_id },
            |m: &mut GetDatasetInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetInputRequest| { &m.dataset_id },
            |m: &mut GetDatasetInputRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetDatasetInputRequest| { &m.input_id },
            |m: &mut GetDatasetInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetInputRequest>(
            "GetDatasetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetInputRequest {
    const NAME: &'static str = "GetDatasetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetInputRequest {
        GetDatasetInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetInputRequest {
        static instance: GetDatasetInputRequest = GetDatasetInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more datasets.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostDatasetInputsRequest)
pub struct PostDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of inputs that are requested to be added to this dataset.
    ///  Identify each input by id field. All other inputs fields are ignored.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.dataset_inputs)
    pub dataset_inputs: ::std::vec::Vec<super::resources::DatasetInput>,
    ///  Query to search inputs to be added to this dataset.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.search)
    pub search: ::protobuf::MessageField<super::resources::Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetInputsRequest {
    fn default() -> &'a PostDatasetInputsRequest {
        <PostDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetInputsRequest {
    pub fn new() -> PostDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetInputsRequest| { &m.user_app_id },
            |m: &mut PostDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PostDatasetInputsRequest| { &m.dataset_id },
            |m: &mut PostDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_inputs",
            |m: &PostDatasetInputsRequest| { &m.dataset_inputs },
            |m: &mut PostDatasetInputsRequest| { &mut m.dataset_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search",
            |m: &PostDatasetInputsRequest| { &m.search },
            |m: &mut PostDatasetInputsRequest| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetInputsRequest>(
            "PostDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetInputsRequest {
    const NAME: &'static str = "PostDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetInputsRequest {
        PostDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_inputs.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetInputsRequest {
        static instance: PostDatasetInputsRequest = PostDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_inputs: ::std::vec::Vec::new(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several dataset inputs by list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetInputsRequest)
pub struct DeleteDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Specify which inputs to delete from dataset.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetInputsRequest {
    fn default() -> &'a DeleteDatasetInputsRequest {
        <DeleteDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetInputsRequest {
    pub fn new() -> DeleteDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetInputsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteDatasetInputsRequest| { &m.dataset_id },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &DeleteDatasetInputsRequest| { &m.input_ids },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetInputsRequest>(
            "DeleteDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetInputsRequest {
    const NAME: &'static str = "DeleteDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetInputsRequest {
        DeleteDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetInputsRequest {
        static instance: DeleteDatasetInputsRequest = DeleteDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiDatasetInputResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetInputResponse)
pub struct MultiDatasetInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.dataset_inputs)
    pub dataset_inputs: ::std::vec::Vec<super::resources::DatasetInput>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.dataset_inputs_search_add_job)
    pub dataset_inputs_search_add_job: ::protobuf::MessageField<super::resources::DatasetInputsSearchAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetInputResponse {
    fn default() -> &'a MultiDatasetInputResponse {
        <MultiDatasetInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetInputResponse {
    pub fn new() -> MultiDatasetInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetInputResponse| { &m.status },
            |m: &mut MultiDatasetInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_inputs",
            |m: &MultiDatasetInputResponse| { &m.dataset_inputs },
            |m: &mut MultiDatasetInputResponse| { &mut m.dataset_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetInputsSearchAddJob>(
            "dataset_inputs_search_add_job",
            |m: &MultiDatasetInputResponse| { &m.dataset_inputs_search_add_job },
            |m: &mut MultiDatasetInputResponse| { &mut m.dataset_inputs_search_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetInputResponse>(
            "MultiDatasetInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetInputResponse {
    const NAME: &'static str = "MultiDatasetInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_inputs.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_inputs_search_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dataset_inputs_search_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.dataset_inputs_search_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetInputResponse {
        MultiDatasetInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_inputs.clear();
        self.dataset_inputs_search_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetInputResponse {
        static instance: MultiDatasetInputResponse = MultiDatasetInputResponse {
            status: ::protobuf::MessageField::none(),
            dataset_inputs: ::std::vec::Vec::new(),
            dataset_inputs_search_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleDatasetInputResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetInputResponse)
pub struct SingleDatasetInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputResponse.dataset_input)
    pub dataset_input: ::protobuf::MessageField<super::resources::DatasetInput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetInputResponse {
    fn default() -> &'a SingleDatasetInputResponse {
        <SingleDatasetInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetInputResponse {
    pub fn new() -> SingleDatasetInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetInputResponse| { &m.status },
            |m: &mut SingleDatasetInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetInput>(
            "dataset_input",
            |m: &SingleDatasetInputResponse| { &m.dataset_input },
            |m: &mut SingleDatasetInputResponse| { &mut m.dataset_input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetInputResponse>(
            "SingleDatasetInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetInputResponse {
    const NAME: &'static str = "SingleDatasetInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetInputResponse {
        SingleDatasetInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetInputResponse {
        static instance: SingleDatasetInputResponse = SingleDatasetInputResponse {
            status: ::protobuf::MessageField::none(),
            dataset_input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListDatasetVersionsRequest)
pub struct ListDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetVersionsRequest {
    fn default() -> &'a ListDatasetVersionsRequest {
        <ListDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetVersionsRequest {
    pub fn new() -> ListDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut ListDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut ListDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetVersionsRequest| { &m.page },
            |m: &mut ListDatasetVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetVersionsRequest| { &m.per_page },
            |m: &mut ListDatasetVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetVersionsRequest>(
            "ListDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetVersionsRequest {
    const NAME: &'static str = "ListDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetVersionsRequest {
        ListDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetVersionsRequest {
        static instance: ListDatasetVersionsRequest = ListDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetDatasetVersionRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetDatasetVersionRequest)
pub struct GetDatasetVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetVersionRequest {
    fn default() -> &'a GetDatasetVersionRequest {
        <GetDatasetVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetVersionRequest {
    pub fn new() -> GetDatasetVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetVersionRequest| { &m.user_app_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetVersionRequest| { &m.dataset_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &GetDatasetVersionRequest| { &m.dataset_version_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.dataset_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetVersionRequest>(
            "GetDatasetVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetVersionRequest {
    const NAME: &'static str = "GetDatasetVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetVersionRequest {
        GetDatasetVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetVersionRequest {
        static instance: GetDatasetVersionRequest = GetDatasetVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetVersionMetricsGroupsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListDatasetVersionMetricsGroupsRequest)
pub struct ListDatasetVersionMetricsGroupsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.per_page)
    pub per_page: u32,
    ///  Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.parent_paths)
    pub parent_paths: ::std::vec::Vec<::std::string::String>,
    ///  Filter by parent type. Multiple types are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::resources::DatasetVersionMetricsGroupType>>,
    ///  Filter by value. Multiple values are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.values)
    pub values: ::std::vec::Vec<::protobuf::well_known_types::struct_::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetVersionMetricsGroupsRequest {
    fn default() -> &'a ListDatasetVersionMetricsGroupsRequest {
        <ListDatasetVersionMetricsGroupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetVersionMetricsGroupsRequest {
    pub fn new() -> ListDatasetVersionMetricsGroupsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.user_app_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.dataset_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.dataset_version_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.dataset_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.page },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.per_page },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parent_paths",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.parent_paths },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.parent_paths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.types },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.values },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetVersionMetricsGroupsRequest>(
            "ListDatasetVersionMetricsGroupsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetVersionMetricsGroupsRequest {
    const NAME: &'static str = "ListDatasetVersionMetricsGroupsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                50 => {
                    self.parent_paths.push(is.read_string()?);
                },
                56 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                66 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        for value in &self.parent_paths {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.types {
            my_size += ::protobuf::rt::int32_size(7, value.value());
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        for v in &self.parent_paths {
            os.write_string(6, &v)?;
        };
        for v in &self.types {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetVersionMetricsGroupsRequest {
        ListDatasetVersionMetricsGroupsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.parent_paths.clear();
        self.types.clear();
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetVersionMetricsGroupsRequest {
        static instance: ListDatasetVersionMetricsGroupsRequest = ListDatasetVersionMetricsGroupsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            parent_paths: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetVersionMetricsGroupsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetVersionMetricsGroupsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetVersionMetricsGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetVersionMetricsGroupsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more dataset versions.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostDatasetVersionsRequest)
pub struct PostDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of dataset versions that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetVersionsRequest {
    fn default() -> &'a PostDatasetVersionsRequest {
        <PostDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetVersionsRequest {
    pub fn new() -> PostDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut PostDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PostDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut PostDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &PostDatasetVersionsRequest| { &m.dataset_versions },
            |m: &mut PostDatasetVersionsRequest| { &mut m.dataset_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetVersionsRequest>(
            "PostDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetVersionsRequest {
    const NAME: &'static str = "PostDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetVersionsRequest {
        PostDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetVersionsRequest {
        static instance: PostDatasetVersionsRequest = PostDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several dataset versions.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchDatasetVersionsRequest)
pub struct PatchDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of dataset versions that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    ///  The action to perform on the patched objects
    ///  For now, only 'overwrite' action is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchDatasetVersionsRequest {
    fn default() -> &'a PatchDatasetVersionsRequest {
        <PatchDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDatasetVersionsRequest {
    pub fn new() -> PatchDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PatchDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &PatchDatasetVersionsRequest| { &m.dataset_versions },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.dataset_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchDatasetVersionsRequest| { &m.action },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchDatasetVersionsRequest>(
            "PatchDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchDatasetVersionsRequest {
    const NAME: &'static str = "PatchDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchDatasetVersionsRequest {
        PatchDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchDatasetVersionsRequest {
        static instance: PatchDatasetVersionsRequest = PatchDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several dataset versions by list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetVersionsRequest)
pub struct DeleteDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.dataset_version_ids)
    pub dataset_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetVersionsRequest {
    fn default() -> &'a DeleteDatasetVersionsRequest {
        <DeleteDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetVersionsRequest {
    pub fn new() -> DeleteDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_version_ids",
            |m: &DeleteDatasetVersionsRequest| { &m.dataset_version_ids },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.dataset_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetVersionsRequest>(
            "DeleteDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetVersionsRequest {
    const NAME: &'static str = "DeleteDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetVersionsRequest {
        DeleteDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetVersionsRequest {
        static instance: DeleteDatasetVersionsRequest = DeleteDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create exports of a dataset version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PutDatasetVersionExportsRequest)
pub struct PutDatasetVersionExportsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    ///  exports is the list of requested dataset version exports.
    ///  Only setting the 'format' field of the export is supported.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.exports)
    pub exports: ::std::vec::Vec<super::resources::DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutDatasetVersionExportsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutDatasetVersionExportsRequest {
    fn default() -> &'a PutDatasetVersionExportsRequest {
        <PutDatasetVersionExportsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutDatasetVersionExportsRequest {
    pub fn new() -> PutDatasetVersionExportsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutDatasetVersionExportsRequest| { &m.user_app_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PutDatasetVersionExportsRequest| { &m.dataset_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &PutDatasetVersionExportsRequest| { &m.dataset_version_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.dataset_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &PutDatasetVersionExportsRequest| { &m.exports },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.exports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutDatasetVersionExportsRequest>(
            "PutDatasetVersionExportsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutDatasetVersionExportsRequest {
    const NAME: &'static str = "PutDatasetVersionExportsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                34 => {
                    self.exports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutDatasetVersionExportsRequest {
        PutDatasetVersionExportsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.exports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutDatasetVersionExportsRequest {
        static instance: PutDatasetVersionExportsRequest = PutDatasetVersionExportsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            exports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutDatasetVersionExportsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutDatasetVersionExportsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutDatasetVersionExportsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutDatasetVersionExportsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionResponse)
pub struct MultiDatasetVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionResponse.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionResponse {
    fn default() -> &'a MultiDatasetVersionResponse {
        <MultiDatasetVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionResponse {
    pub fn new() -> MultiDatasetVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionResponse| { &m.status },
            |m: &mut MultiDatasetVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &MultiDatasetVersionResponse| { &m.dataset_versions },
            |m: &mut MultiDatasetVersionResponse| { &mut m.dataset_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionResponse>(
            "MultiDatasetVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionResponse {
    const NAME: &'static str = "MultiDatasetVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionResponse {
        MultiDatasetVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionResponse {
        static instance: MultiDatasetVersionResponse = MultiDatasetVersionResponse {
            status: ::protobuf::MessageField::none(),
            dataset_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionExportResponse)
pub struct MultiDatasetVersionExportResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionExportResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionExportResponse.exports)
    pub exports: ::std::vec::Vec<super::resources::DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionExportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionExportResponse {
    fn default() -> &'a MultiDatasetVersionExportResponse {
        <MultiDatasetVersionExportResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionExportResponse {
    pub fn new() -> MultiDatasetVersionExportResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionExportResponse| { &m.status },
            |m: &mut MultiDatasetVersionExportResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &MultiDatasetVersionExportResponse| { &m.exports },
            |m: &mut MultiDatasetVersionExportResponse| { &mut m.exports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionExportResponse>(
            "MultiDatasetVersionExportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionExportResponse {
    const NAME: &'static str = "MultiDatasetVersionExportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.exports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionExportResponse {
        MultiDatasetVersionExportResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.exports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionExportResponse {
        static instance: MultiDatasetVersionExportResponse = MultiDatasetVersionExportResponse {
            status: ::protobuf::MessageField::none(),
            exports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionExportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionExportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionExportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionExportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionMetricsGroupResponse)
pub struct MultiDatasetVersionMetricsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.dataset_version_metrics_groups)
    pub dataset_version_metrics_groups: ::std::vec::Vec<super::resources::DatasetVersionMetricsGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionMetricsGroupResponse {
    fn default() -> &'a MultiDatasetVersionMetricsGroupResponse {
        <MultiDatasetVersionMetricsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionMetricsGroupResponse {
    pub fn new() -> MultiDatasetVersionMetricsGroupResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionMetricsGroupResponse| { &m.status },
            |m: &mut MultiDatasetVersionMetricsGroupResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_version_metrics_groups",
            |m: &MultiDatasetVersionMetricsGroupResponse| { &m.dataset_version_metrics_groups },
            |m: &mut MultiDatasetVersionMetricsGroupResponse| { &mut m.dataset_version_metrics_groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionMetricsGroupResponse>(
            "MultiDatasetVersionMetricsGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionMetricsGroupResponse {
    const NAME: &'static str = "MultiDatasetVersionMetricsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_version_metrics_groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_version_metrics_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_version_metrics_groups {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionMetricsGroupResponse {
        MultiDatasetVersionMetricsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_version_metrics_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionMetricsGroupResponse {
        static instance: MultiDatasetVersionMetricsGroupResponse = MultiDatasetVersionMetricsGroupResponse {
            status: ::protobuf::MessageField::none(),
            dataset_version_metrics_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionMetricsGroupResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionMetricsGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionMetricsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionMetricsGroupResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetVersionResponse)
pub struct SingleDatasetVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetVersionResponse.dataset_version)
    pub dataset_version: ::protobuf::MessageField<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetVersionResponse {
    fn default() -> &'a SingleDatasetVersionResponse {
        <SingleDatasetVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetVersionResponse {
    pub fn new() -> SingleDatasetVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetVersionResponse| { &m.status },
            |m: &mut SingleDatasetVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetVersion>(
            "dataset_version",
            |m: &SingleDatasetVersionResponse| { &m.dataset_version },
            |m: &mut SingleDatasetVersionResponse| { &mut m.dataset_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetVersionResponse>(
            "SingleDatasetVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetVersionResponse {
    const NAME: &'static str = "SingleDatasetVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetVersionResponse {
        SingleDatasetVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetVersionResponse {
        static instance: SingleDatasetVersionResponse = SingleDatasetVersionResponse {
            status: ::protobuf::MessageField::none(),
            dataset_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetDatasetInputsSearchAddJobRequest)
pub struct GetDatasetInputsSearchAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputsSearchAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputsSearchAddJobRequest.job_id)
    pub job_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetInputsSearchAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetInputsSearchAddJobRequest {
    fn default() -> &'a GetDatasetInputsSearchAddJobRequest {
        <GetDatasetInputsSearchAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetInputsSearchAddJobRequest {
    pub fn new() -> GetDatasetInputsSearchAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetInputsSearchAddJobRequest| { &m.user_app_id },
            |m: &mut GetDatasetInputsSearchAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "job_id",
            |m: &GetDatasetInputsSearchAddJobRequest| { &m.job_id },
            |m: &mut GetDatasetInputsSearchAddJobRequest| { &mut m.job_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetInputsSearchAddJobRequest>(
            "GetDatasetInputsSearchAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetInputsSearchAddJobRequest {
    const NAME: &'static str = "GetDatasetInputsSearchAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.job_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.job_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.job_id.is_empty() {
            os.write_string(2, &self.job_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetInputsSearchAddJobRequest {
        GetDatasetInputsSearchAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.job_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetInputsSearchAddJobRequest {
        static instance: GetDatasetInputsSearchAddJobRequest = GetDatasetInputsSearchAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            job_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetInputsSearchAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetInputsSearchAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetInputsSearchAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetInputsSearchAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetInputsSearchAddJobResponse)
pub struct SingleDatasetInputsSearchAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputsSearchAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputsSearchAddJobResponse.job)
    pub job: ::protobuf::MessageField<super::resources::DatasetInputsSearchAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetInputsSearchAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetInputsSearchAddJobResponse {
    fn default() -> &'a SingleDatasetInputsSearchAddJobResponse {
        <SingleDatasetInputsSearchAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetInputsSearchAddJobResponse {
    pub fn new() -> SingleDatasetInputsSearchAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetInputsSearchAddJobResponse| { &m.status },
            |m: &mut SingleDatasetInputsSearchAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetInputsSearchAddJob>(
            "job",
            |m: &SingleDatasetInputsSearchAddJobResponse| { &m.job },
            |m: &mut SingleDatasetInputsSearchAddJobResponse| { &mut m.job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetInputsSearchAddJobResponse>(
            "SingleDatasetInputsSearchAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetInputsSearchAddJobResponse {
    const NAME: &'static str = "SingleDatasetInputsSearchAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetInputsSearchAddJobResponse {
        SingleDatasetInputsSearchAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetInputsSearchAddJobResponse {
        static instance: SingleDatasetInputsSearchAddJobResponse = SingleDatasetInputsSearchAddJobResponse {
            status: ::protobuf::MessageField::none(),
            job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetInputsSearchAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetInputsSearchAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetInputsSearchAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetInputsSearchAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// //////////////////////////////////////////////////
///  Model prediction related stuff needs inputs and produces outputs.
/// //////////////////////////////////////////////////
///  Model prediction.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelOutputsRequest)
pub struct PostModelOutputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  This allows you to specify config options for the model such as
    ///  the language which appear's in the model's output_info.
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelOutputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelOutputsRequest {
    fn default() -> &'a PostModelOutputsRequest {
        <PostModelOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelOutputsRequest {
    pub fn new() -> PostModelOutputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelOutputsRequest| { &m.user_app_id },
            |m: &mut PostModelOutputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelOutputsRequest| { &m.model_id },
            |m: &mut PostModelOutputsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostModelOutputsRequest| { &m.version_id },
            |m: &mut PostModelOutputsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostModelOutputsRequest| { &m.inputs },
            |m: &mut PostModelOutputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &PostModelOutputsRequest| { &m.model },
            |m: &mut PostModelOutputsRequest| { &mut m.model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelOutputsRequest>(
            "PostModelOutputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelOutputsRequest {
    const NAME: &'static str = "PostModelOutputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    self.inputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelOutputsRequest {
        PostModelOutputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelOutputsRequest {
        static instance: PostModelOutputsRequest = PostModelOutputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelOutputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelOutputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelOutputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Listing the inputs that went into training this model.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelInputsRequest)
pub struct ListModelInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelInputsRequest {
    fn default() -> &'a ListModelInputsRequest {
        <ListModelInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelInputsRequest {
    pub fn new() -> ListModelInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelInputsRequest| { &m.user_app_id },
            |m: &mut ListModelInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelInputsRequest| { &m.model_id },
            |m: &mut ListModelInputsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ListModelInputsRequest| { &m.version_id },
            |m: &mut ListModelInputsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelInputsRequest| { &m.page },
            |m: &mut ListModelInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelInputsRequest| { &m.per_page },
            |m: &mut ListModelInputsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelInputsRequest>(
            "ListModelInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelInputsRequest {
    const NAME: &'static str = "ListModelInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelInputsRequest {
        ListModelInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelInputsRequest {
        static instance: ListModelInputsRequest = ListModelInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetKeyRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetKeyRequest)
pub struct GetKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetKeyRequest.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetKeyRequest {
    fn default() -> &'a GetKeyRequest {
        <GetKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyRequest {
    pub fn new() -> GetKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetKeyRequest| { &m.user_app_id },
            |m: &mut GetKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &GetKeyRequest| { &m.key_id },
            |m: &mut GetKeyRequest| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetKeyRequest>(
            "GetKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetKeyRequest {
    const NAME: &'static str = "GetKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetKeyRequest {
        GetKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetKeyRequest {
        static instance: GetKeyRequest = GetKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListKeysRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListKeysRequest)
pub struct ListKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.not_expired)
    pub not_expired: bool,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListKeysRequest| { &m.user_app_id },
            |m: &mut ListKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListKeysRequest| { &m.page },
            |m: &mut ListKeysRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListKeysRequest| { &m.per_page },
            |m: &mut ListKeysRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "not_expired",
            |m: &ListKeysRequest| { &m.not_expired },
            |m: &mut ListKeysRequest| { &mut m.not_expired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &ListKeysRequest| { &m.scopes },
            |m: &mut ListKeysRequest| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &ListKeysRequest| { &m.endpoints },
            |m: &mut ListKeysRequest| { &mut m.endpoints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListKeysRequest>(
            "ListKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListKeysRequest {
    const NAME: &'static str = "ListKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.not_expired = is.read_bool()?;
                },
                42 => {
                    self.scopes.push(is.read_string()?);
                },
                50 => {
                    self.endpoints.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.not_expired != false {
            my_size += 1 + 1;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.not_expired != false {
            os.write_bool(4, self.not_expired)?;
        }
        for v in &self.scopes {
            os.write_string(5, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.not_expired = false;
        self.scopes.clear();
        self.endpoints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ListKeysRequest = ListKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            not_expired: false,
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAppKeysRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListAppKeysRequest)
pub struct ListAppKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppKeysRequest {
    fn default() -> &'a ListAppKeysRequest {
        <ListAppKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppKeysRequest {
    pub fn new() -> ListAppKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppKeysRequest| { &m.user_app_id },
            |m: &mut ListAppKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppKeysRequest| { &m.page },
            |m: &mut ListAppKeysRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppKeysRequest| { &m.per_page },
            |m: &mut ListAppKeysRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppKeysRequest>(
            "ListAppKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppKeysRequest {
    const NAME: &'static str = "ListAppKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppKeysRequest {
        ListAppKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppKeysRequest {
        static instance: ListAppKeysRequest = ListAppKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostKeysRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostKeysRequest)
pub struct PostKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostKeysRequest.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostKeysRequest {
    fn default() -> &'a PostKeysRequest {
        <PostKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKeysRequest {
    pub fn new() -> PostKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostKeysRequest| { &m.user_app_id },
            |m: &mut PostKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &PostKeysRequest| { &m.keys },
            |m: &mut PostKeysRequest| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostKeysRequest>(
            "PostKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostKeysRequest {
    const NAME: &'static str = "PostKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostKeysRequest {
        PostKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostKeysRequest {
        static instance: PostKeysRequest = PostKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteKeyRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteKeyRequest)
pub struct DeleteKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteKeyRequest.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteKeyRequest {
    fn default() -> &'a DeleteKeyRequest {
        <DeleteKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteKeyRequest {
    pub fn new() -> DeleteKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteKeyRequest| { &m.user_app_id },
            |m: &mut DeleteKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &DeleteKeyRequest| { &m.key_id },
            |m: &mut DeleteKeyRequest| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteKeyRequest>(
            "DeleteKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteKeyRequest {
    const NAME: &'static str = "DeleteKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteKeyRequest {
        DeleteKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteKeyRequest {
        static instance: DeleteKeyRequest = DeleteKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchKeysRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchKeysRequest)
pub struct PatchKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    ///  The action to perform on the patched objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchKeysRequest {
    fn default() -> &'a PatchKeysRequest {
        <PatchKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchKeysRequest {
    pub fn new() -> PatchKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchKeysRequest| { &m.user_app_id },
            |m: &mut PatchKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &PatchKeysRequest| { &m.keys },
            |m: &mut PatchKeysRequest| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchKeysRequest| { &m.action },
            |m: &mut PatchKeysRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchKeysRequest>(
            "PatchKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchKeysRequest {
    const NAME: &'static str = "PatchKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchKeysRequest {
        PatchKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchKeysRequest {
        static instance: PatchKeysRequest = PatchKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleKeyResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleKeyResponse)
pub struct SingleKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleKeyResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleKeyResponse.key)
    pub key: ::protobuf::MessageField<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleKeyResponse {
    fn default() -> &'a SingleKeyResponse {
        <SingleKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleKeyResponse {
    pub fn new() -> SingleKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleKeyResponse| { &m.status },
            |m: &mut SingleKeyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Key>(
            "key",
            |m: &SingleKeyResponse| { &m.key },
            |m: &mut SingleKeyResponse| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleKeyResponse>(
            "SingleKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleKeyResponse {
    const NAME: &'static str = "SingleKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleKeyResponse {
        SingleKeyResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleKeyResponse {
        static instance: SingleKeyResponse = SingleKeyResponse {
            status: ::protobuf::MessageField::none(),
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiKeyResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiKeyResponse)
pub struct MultiKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiKeyResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiKeyResponse.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiKeyResponse {
    fn default() -> &'a MultiKeyResponse {
        <MultiKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKeyResponse {
    pub fn new() -> MultiKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiKeyResponse| { &m.status },
            |m: &mut MultiKeyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &MultiKeyResponse| { &m.keys },
            |m: &mut MultiKeyResponse| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiKeyResponse>(
            "MultiKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiKeyResponse {
    const NAME: &'static str = "MultiKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiKeyResponse {
        MultiKeyResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiKeyResponse {
        static instance: MultiKeyResponse = MultiKeyResponse {
            status: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModelRequest)
pub struct GetModelRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.model_id)
    pub model_id: ::std::string::String,
    ///  This is included so that we can re-use this request for multiple
    ///  rpcs with and without the version_id.
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.language)
    pub language: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.trained_before)
    pub trained_before: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelRequest {
    fn default() -> &'a GetModelRequest {
        <GetModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelRequest {
    pub fn new() -> GetModelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelRequest| { &m.user_app_id },
            |m: &mut GetModelRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelRequest| { &m.model_id },
            |m: &mut GetModelRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelRequest| { &m.version_id },
            |m: &mut GetModelRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &GetModelRequest| { &m.language },
            |m: &mut GetModelRequest| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_before",
            |m: &GetModelRequest| { &m.trained_before },
            |m: &mut GetModelRequest| { &mut m.trained_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetModelRequest| { &m.additional_fields },
            |m: &mut GetModelRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelRequest>(
            "GetModelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelRequest {
    const NAME: &'static str = "GetModelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    self.language = is.read_string()?;
                },
                40 => {
                    self.trained_before = is.read_bool()?;
                },
                154 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if self.trained_before != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if self.trained_before != false {
            os.write_bool(5, self.trained_before)?;
        }
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelRequest {
        GetModelRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.language.clear();
        self.trained_before = false;
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelRequest {
        static instance: GetModelRequest = GetModelRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            trained_before: false,
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelsRequest)
pub struct ListModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.per_page)
    pub per_page: u32,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.name)
    pub name: ::std::string::String,
    ///  Extends the name filter to include the user_id of the application owner that the model belongs to.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.filter_by_user_id)
    pub filter_by_user_id: bool,
    ///  Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
    ///  supported.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.trained_only)
    pub trained_only: bool,
    ///  The list of input fields to the model.
    ///  For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.input_fields)
    pub input_fields: ::std::vec::Vec<::std::string::String>,
    ///  The list of output fields to the model.
    ///  For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.output_fields)
    pub output_fields: ::std::vec::Vec<::std::string::String>,
    ///  Filter by the license of the model version
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.license)
    pub license: ::std::string::String,
    ///  If true, we only return models that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return models that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.starred_only)
    pub starred_only: bool,
    ///  List of toolkit tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    ///  List of use_case tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.use_cases)
    pub use_cases: ::std::vec::Vec<::std::string::String>,
    ///  List of language tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Old API behavior resulted in returning clarifai main models when calling ListModels while scoped to an app. While we transition
    ///  away from that, we can use this flag to not always fetch clarifai main models, unless that is the app we are explicitly listing for.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.dont_fetch_from_main)
    pub dont_fetch_from_main: bool,
    ///  Filter models by bookmark. If set, only return bookmarked models. Otherwise none bookmarked models only.
    ///  Note: you can not filter `trained_only` and bookmark at the same time.
    ///  When filter by bookmark, we will return trained and untrained models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.bookmark)
    pub bookmark: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_models_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelsRequest {
    fn default() -> &'a ListModelsRequest {
        <ListModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelsRequest {
    pub fn new() -> ListModelsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_name = 11;

    pub fn sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByName(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByName(v))
    }

    // bool sort_by_num_inputs = 12;

    pub fn sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(v))
    }

    // bool sort_by_modified_at = 13;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 24;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 25;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelsRequest| { &m.user_app_id },
            |m: &mut ListModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelsRequest| { &m.page },
            |m: &mut ListModelsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelsRequest| { &m.per_page },
            |m: &mut ListModelsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModelsRequest| { &m.sort_ascending },
            |m: &mut ListModelsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_name",
            ListModelsRequest::has_sort_by_name,
            ListModelsRequest::sort_by_name,
            ListModelsRequest::set_sort_by_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_num_inputs",
            ListModelsRequest::has_sort_by_num_inputs,
            ListModelsRequest::sort_by_num_inputs,
            ListModelsRequest::set_sort_by_num_inputs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListModelsRequest::has_sort_by_modified_at,
            ListModelsRequest::sort_by_modified_at,
            ListModelsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModelsRequest::has_sort_by_created_at,
            ListModelsRequest::sort_by_created_at,
            ListModelsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListModelsRequest::has_sort_by_star_count,
            ListModelsRequest::sort_by_star_count,
            ListModelsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListModelsRequest| { &m.query },
            |m: &mut ListModelsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListModelsRequest| { &m.name },
            |m: &mut ListModelsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter_by_user_id",
            |m: &ListModelsRequest| { &m.filter_by_user_id },
            |m: &mut ListModelsRequest| { &mut m.filter_by_user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ListModelsRequest| { &m.model_type_id },
            |m: &mut ListModelsRequest| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_only",
            |m: &ListModelsRequest| { &m.trained_only },
            |m: &mut ListModelsRequest| { &mut m.trained_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_fields",
            |m: &ListModelsRequest| { &m.input_fields },
            |m: &mut ListModelsRequest| { &mut m.input_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_fields",
            |m: &ListModelsRequest| { &m.output_fields },
            |m: &mut ListModelsRequest| { &mut m.output_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &ListModelsRequest| { &m.license },
            |m: &mut ListModelsRequest| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListModelsRequest| { &m.featured_only },
            |m: &mut ListModelsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListModelsRequest| { &m.starred_only },
            |m: &mut ListModelsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &ListModelsRequest| { &m.toolkits },
            |m: &mut ListModelsRequest| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "use_cases",
            |m: &ListModelsRequest| { &m.use_cases },
            |m: &mut ListModelsRequest| { &mut m.use_cases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &ListModelsRequest| { &m.languages },
            |m: &mut ListModelsRequest| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListModelsRequest| { &m.additional_fields },
            |m: &mut ListModelsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dont_fetch_from_main",
            |m: &ListModelsRequest| { &m.dont_fetch_from_main },
            |m: &mut ListModelsRequest| { &mut m.dont_fetch_from_main },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListModelsRequest| { &m.bookmark },
            |m: &mut ListModelsRequest| { &mut m.bookmark },
        ));
        oneofs.push(list_models_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelsRequest>(
            "ListModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelsRequest {
    const NAME: &'static str = "ListModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                80 => {
                    self.sort_ascending = is.read_bool()?;
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByName(is.read_bool()?));
                },
                96 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                192 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                200 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                114 => {
                    self.query = is.read_string()?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                176 => {
                    self.filter_by_user_id = is.read_bool()?;
                },
                50 => {
                    self.model_type_id = is.read_string()?;
                },
                56 => {
                    self.trained_only = is.read_bool()?;
                },
                66 => {
                    self.input_fields.push(is.read_string()?);
                },
                74 => {
                    self.output_fields.push(is.read_string()?);
                },
                122 => {
                    self.license = is.read_string()?;
                },
                128 => {
                    self.featured_only = is.read_bool()?;
                },
                160 => {
                    self.starred_only = is.read_bool()?;
                },
                138 => {
                    self.toolkits.push(is.read_string()?);
                },
                146 => {
                    self.use_cases.push(is.read_string()?);
                },
                170 => {
                    self.languages.push(is.read_string()?);
                },
                154 => {
                    self.additional_fields.push(is.read_string()?);
                },
                184 => {
                    self.dont_fetch_from_main = is.read_bool()?;
                },
                208 => {
                    self.bookmark = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.filter_by_user_id != false {
            my_size += 2 + 1;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model_type_id);
        }
        if self.trained_only != false {
            my_size += 1 + 1;
        }
        for value in &self.input_fields {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.output_fields {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.license);
        }
        if self.featured_only != false {
            my_size += 2 + 1;
        }
        if self.starred_only != false {
            my_size += 2 + 1;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if self.dont_fetch_from_main != false {
            my_size += 2 + 1;
        }
        if self.bookmark != false {
            my_size += 2 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_models_request::Sort_by::SortByName(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByNumInputs(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 2 + 1;
                },
                &list_models_request::Sort_by::SortByStarCount(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(10, self.sort_ascending)?;
        }
        if !self.query.is_empty() {
            os.write_string(14, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.filter_by_user_id != false {
            os.write_bool(22, self.filter_by_user_id)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(6, &self.model_type_id)?;
        }
        if self.trained_only != false {
            os.write_bool(7, self.trained_only)?;
        }
        for v in &self.input_fields {
            os.write_string(8, &v)?;
        };
        for v in &self.output_fields {
            os.write_string(9, &v)?;
        };
        if !self.license.is_empty() {
            os.write_string(15, &self.license)?;
        }
        if self.featured_only != false {
            os.write_bool(16, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(20, self.starred_only)?;
        }
        for v in &self.toolkits {
            os.write_string(17, &v)?;
        };
        for v in &self.use_cases {
            os.write_string(18, &v)?;
        };
        for v in &self.languages {
            os.write_string(21, &v)?;
        };
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        if self.dont_fetch_from_main != false {
            os.write_bool(23, self.dont_fetch_from_main)?;
        }
        if self.bookmark != false {
            os.write_bool(26, self.bookmark)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_models_request::Sort_by::SortByName(v) => {
                    os.write_bool(11, v)?;
                },
                &list_models_request::Sort_by::SortByNumInputs(v) => {
                    os.write_bool(12, v)?;
                },
                &list_models_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(13, v)?;
                },
                &list_models_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(24, v)?;
                },
                &list_models_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(25, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelsRequest {
        ListModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.query.clear();
        self.name.clear();
        self.filter_by_user_id = false;
        self.model_type_id.clear();
        self.trained_only = false;
        self.input_fields.clear();
        self.output_fields.clear();
        self.license.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.toolkits.clear();
        self.use_cases.clear();
        self.languages.clear();
        self.additional_fields.clear();
        self.dont_fetch_from_main = false;
        self.bookmark = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelsRequest {
        static instance: ListModelsRequest = ListModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            sort_ascending: false,
            query: ::std::string::String::new(),
            name: ::std::string::String::new(),
            filter_by_user_id: false,
            model_type_id: ::std::string::String::new(),
            trained_only: false,
            input_fields: ::std::vec::Vec::new(),
            output_fields: ::std::vec::Vec::new(),
            license: ::std::string::String::new(),
            featured_only: false,
            starred_only: false,
            toolkits: ::std::vec::Vec::new(),
            use_cases: ::std::vec::Vec::new(),
            languages: ::std::vec::Vec::new(),
            additional_fields: ::std::vec::Vec::new(),
            dont_fetch_from_main: false,
            bookmark: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModelsRequest`
pub mod list_models_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModelsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_name)
        SortByName(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_num_inputs)
        SortByNumInputs(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModelsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  ResourceCountRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetResourceCountsRequest)
pub struct GetResourceCountsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetResourceCountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetResourceCountsRequest {
    fn default() -> &'a GetResourceCountsRequest {
        <GetResourceCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetResourceCountsRequest {
    pub fn new() -> GetResourceCountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetResourceCountsRequest| { &m.user_app_id },
            |m: &mut GetResourceCountsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetResourceCountsRequest>(
            "GetResourceCountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetResourceCountsRequest {
    const NAME: &'static str = "GetResourceCountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetResourceCountsRequest {
        GetResourceCountsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetResourceCountsRequest {
        static instance: GetResourceCountsRequest = GetResourceCountsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetResourceCountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetResourceCountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetResourceCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResourceCountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ResourceCountResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetResourceCountsResponse)
pub struct GetResourceCountsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.datasets)
    pub datasets: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.models)
    pub models: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.workflows)
    pub workflows: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.modules)
    pub modules: i64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetResourceCountsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetResourceCountsResponse {
    fn default() -> &'a GetResourceCountsResponse {
        <GetResourceCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetResourceCountsResponse {
    pub fn new() -> GetResourceCountsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &GetResourceCountsResponse| { &m.status },
            |m: &mut GetResourceCountsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datasets",
            |m: &GetResourceCountsResponse| { &m.datasets },
            |m: &mut GetResourceCountsResponse| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "models",
            |m: &GetResourceCountsResponse| { &m.models },
            |m: &mut GetResourceCountsResponse| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflows",
            |m: &GetResourceCountsResponse| { &m.workflows },
            |m: &mut GetResourceCountsResponse| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modules",
            |m: &GetResourceCountsResponse| { &m.modules },
            |m: &mut GetResourceCountsResponse| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetResourceCountsResponse>(
            "GetResourceCountsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetResourceCountsResponse {
    const NAME: &'static str = "GetResourceCountsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                16 => {
                    self.datasets = is.read_int64()?;
                },
                24 => {
                    self.models = is.read_int64()?;
                },
                32 => {
                    self.workflows = is.read_int64()?;
                },
                40 => {
                    self.modules = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.datasets != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.datasets);
        }
        if self.models != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.models);
        }
        if self.workflows != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.workflows);
        }
        if self.modules != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.modules);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.datasets != 0 {
            os.write_int64(2, self.datasets)?;
        }
        if self.models != 0 {
            os.write_int64(3, self.models)?;
        }
        if self.workflows != 0 {
            os.write_int64(4, self.workflows)?;
        }
        if self.modules != 0 {
            os.write_int64(5, self.modules)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetResourceCountsResponse {
        GetResourceCountsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.datasets = 0;
        self.models = 0;
        self.workflows = 0;
        self.modules = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetResourceCountsResponse {
        static instance: GetResourceCountsResponse = GetResourceCountsResponse {
            status: ::protobuf::MessageField::none(),
            datasets: 0,
            models: 0,
            workflows: 0,
            modules: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetResourceCountsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetResourceCountsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetResourceCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResourceCountsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelToolkitsRequest)
pub struct PatchModelToolkitsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelToolkitsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelToolkitsRequest {
    fn default() -> &'a PatchModelToolkitsRequest {
        <PatchModelToolkitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelToolkitsRequest {
    pub fn new() -> PatchModelToolkitsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelToolkitsRequest| { &m.user_app_id },
            |m: &mut PatchModelToolkitsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelToolkitsRequest| { &m.model_id },
            |m: &mut PatchModelToolkitsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &PatchModelToolkitsRequest| { &m.toolkits },
            |m: &mut PatchModelToolkitsRequest| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelToolkitsRequest| { &m.action },
            |m: &mut PatchModelToolkitsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelToolkitsRequest>(
            "PatchModelToolkitsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelToolkitsRequest {
    const NAME: &'static str = "PatchModelToolkitsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.toolkits.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.toolkits {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelToolkitsRequest {
        PatchModelToolkitsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.toolkits.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelToolkitsRequest {
        static instance: PatchModelToolkitsRequest = PatchModelToolkitsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            toolkits: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelToolkitsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelToolkitsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelToolkitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelToolkitsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelCheckConsentsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelCheckConsentsRequest)
pub struct PatchModelCheckConsentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the model id
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  the consents
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelCheckConsentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelCheckConsentsRequest {
    fn default() -> &'a PatchModelCheckConsentsRequest {
        <PatchModelCheckConsentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelCheckConsentsRequest {
    pub fn new() -> PatchModelCheckConsentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelCheckConsentsRequest| { &m.user_app_id },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelCheckConsentsRequest| { &m.model_id },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &PatchModelCheckConsentsRequest| { &m.check_consents },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.check_consents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelCheckConsentsRequest| { &m.action },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelCheckConsentsRequest>(
            "PatchModelCheckConsentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelCheckConsentsRequest {
    const NAME: &'static str = "PatchModelCheckConsentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.check_consents.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.check_consents {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelCheckConsentsRequest {
        PatchModelCheckConsentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.check_consents.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelCheckConsentsRequest {
        static instance: PatchModelCheckConsentsRequest = PatchModelCheckConsentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            check_consents: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelCheckConsentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelCheckConsentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelCheckConsentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelCheckConsentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelUseCasesRequest)
pub struct PatchModelUseCasesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.usecases)
    pub usecases: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelUseCasesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelUseCasesRequest {
    fn default() -> &'a PatchModelUseCasesRequest {
        <PatchModelUseCasesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelUseCasesRequest {
    pub fn new() -> PatchModelUseCasesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelUseCasesRequest| { &m.user_app_id },
            |m: &mut PatchModelUseCasesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelUseCasesRequest| { &m.model_id },
            |m: &mut PatchModelUseCasesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usecases",
            |m: &PatchModelUseCasesRequest| { &m.usecases },
            |m: &mut PatchModelUseCasesRequest| { &mut m.usecases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelUseCasesRequest| { &m.action },
            |m: &mut PatchModelUseCasesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelUseCasesRequest>(
            "PatchModelUseCasesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelUseCasesRequest {
    const NAME: &'static str = "PatchModelUseCasesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.usecases.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.usecases {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelUseCasesRequest {
        PatchModelUseCasesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.usecases.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelUseCasesRequest {
        static instance: PatchModelUseCasesRequest = PatchModelUseCasesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            usecases: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelUseCasesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelUseCasesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelUseCasesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelUseCasesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelLanguagesRequest)
pub struct PatchModelLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  Only overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelLanguagesRequest {
    fn default() -> &'a PatchModelLanguagesRequest {
        <PatchModelLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelLanguagesRequest {
    pub fn new() -> PatchModelLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelLanguagesRequest| { &m.user_app_id },
            |m: &mut PatchModelLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelLanguagesRequest| { &m.model_id },
            |m: &mut PatchModelLanguagesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &PatchModelLanguagesRequest| { &m.languages },
            |m: &mut PatchModelLanguagesRequest| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelLanguagesRequest| { &m.action },
            |m: &mut PatchModelLanguagesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelLanguagesRequest>(
            "PatchModelLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelLanguagesRequest {
    const NAME: &'static str = "PatchModelLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.languages.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.languages {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelLanguagesRequest {
        PatchModelLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.languages.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelLanguagesRequest {
        static instance: PatchModelLanguagesRequest = PatchModelLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            languages: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelToolkitResponse)
pub struct MultiModelToolkitResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelToolkitResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelToolkitResponse.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelToolkitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelToolkitResponse {
    fn default() -> &'a MultiModelToolkitResponse {
        <MultiModelToolkitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelToolkitResponse {
    pub fn new() -> MultiModelToolkitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelToolkitResponse| { &m.status },
            |m: &mut MultiModelToolkitResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &MultiModelToolkitResponse| { &m.toolkits },
            |m: &mut MultiModelToolkitResponse| { &mut m.toolkits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelToolkitResponse>(
            "MultiModelToolkitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelToolkitResponse {
    const NAME: &'static str = "MultiModelToolkitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.toolkits.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.toolkits {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelToolkitResponse {
        MultiModelToolkitResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.toolkits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelToolkitResponse {
        static instance: MultiModelToolkitResponse = MultiModelToolkitResponse {
            status: ::protobuf::MessageField::none(),
            toolkits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelToolkitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelToolkitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelToolkitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelToolkitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelCheckConsentResponse)
pub struct MultiModelCheckConsentResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelCheckConsentResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelCheckConsentResponse.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelCheckConsentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelCheckConsentResponse {
    fn default() -> &'a MultiModelCheckConsentResponse {
        <MultiModelCheckConsentResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelCheckConsentResponse {
    pub fn new() -> MultiModelCheckConsentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelCheckConsentResponse| { &m.status },
            |m: &mut MultiModelCheckConsentResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &MultiModelCheckConsentResponse| { &m.check_consents },
            |m: &mut MultiModelCheckConsentResponse| { &mut m.check_consents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelCheckConsentResponse>(
            "MultiModelCheckConsentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelCheckConsentResponse {
    const NAME: &'static str = "MultiModelCheckConsentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.check_consents.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.check_consents {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelCheckConsentResponse {
        MultiModelCheckConsentResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.check_consents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelCheckConsentResponse {
        static instance: MultiModelCheckConsentResponse = MultiModelCheckConsentResponse {
            status: ::protobuf::MessageField::none(),
            check_consents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelCheckConsentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelCheckConsentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelCheckConsentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelCheckConsentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelUseCaseResponse)
pub struct MultiModelUseCaseResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelUseCaseResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelUseCaseResponse.usecases)
    pub usecases: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelUseCaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelUseCaseResponse {
    fn default() -> &'a MultiModelUseCaseResponse {
        <MultiModelUseCaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelUseCaseResponse {
    pub fn new() -> MultiModelUseCaseResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelUseCaseResponse| { &m.status },
            |m: &mut MultiModelUseCaseResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usecases",
            |m: &MultiModelUseCaseResponse| { &m.usecases },
            |m: &mut MultiModelUseCaseResponse| { &mut m.usecases },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelUseCaseResponse>(
            "MultiModelUseCaseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelUseCaseResponse {
    const NAME: &'static str = "MultiModelUseCaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.usecases.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.usecases {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelUseCaseResponse {
        MultiModelUseCaseResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.usecases.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelUseCaseResponse {
        static instance: MultiModelUseCaseResponse = MultiModelUseCaseResponse {
            status: ::protobuf::MessageField::none(),
            usecases: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelUseCaseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelUseCaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelUseCaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelUseCaseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelLanguageResponse)
pub struct MultiModelLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelLanguageResponse.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelLanguageResponse {
    fn default() -> &'a MultiModelLanguageResponse {
        <MultiModelLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelLanguageResponse {
    pub fn new() -> MultiModelLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelLanguageResponse| { &m.status },
            |m: &mut MultiModelLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &MultiModelLanguageResponse| { &m.languages },
            |m: &mut MultiModelLanguageResponse| { &mut m.languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelLanguageResponse>(
            "MultiModelLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelLanguageResponse {
    const NAME: &'static str = "MultiModelLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.languages.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.languages {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelLanguageResponse {
        MultiModelLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelLanguageResponse {
        static instance: MultiModelLanguageResponse = MultiModelLanguageResponse {
            status: ::protobuf::MessageField::none(),
            languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelsRequest)
pub struct PostModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  NOTE: inconsistent since "model" is not plural, please use "models" below.
    ///  Previously you could only create one model at a time.
    ///  We still support this but you should pass it as models=[model] so
    ///  that this endpoint is consistent with the rest of our API.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    ///  This allows you to create one or more model by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelsRequest {
    fn default() -> &'a PostModelsRequest {
        <PostModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsRequest {
    pub fn new() -> PostModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelsRequest| { &m.user_app_id },
            |m: &mut PostModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &PostModelsRequest| { &m.model },
            |m: &mut PostModelsRequest| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &PostModelsRequest| { &m.models },
            |m: &mut PostModelsRequest| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelsRequest>(
            "PostModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelsRequest {
    const NAME: &'static str = "PostModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                26 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelsRequest {
        PostModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model.clear();
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelsRequest {
        static instance: PostModelsRequest = PostModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelsRequest)
pub struct PatchModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelsRequest {
    fn default() -> &'a PatchModelsRequest {
        <PatchModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelsRequest {
    pub fn new() -> PatchModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelsRequest| { &m.user_app_id },
            |m: &mut PatchModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &PatchModelsRequest| { &m.models },
            |m: &mut PatchModelsRequest| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelsRequest| { &m.action },
            |m: &mut PatchModelsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelsRequest>(
            "PatchModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelsRequest {
    const NAME: &'static str = "PatchModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.models.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelsRequest {
        PatchModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.models.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelsRequest {
        static instance: PatchModelsRequest = PatchModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.IdUpdateSource)
pub struct IdUpdateSource {
    // message fields
    /// old id
    // @@protoc_insertion_point(field:clarifai.api.IdUpdateSource.id)
    pub id: ::std::string::String,
    /// new id
    // @@protoc_insertion_point(field:clarifai.api.IdUpdateSource.new_id)
    pub new_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.IdUpdateSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdUpdateSource {
    fn default() -> &'a IdUpdateSource {
        <IdUpdateSource as ::protobuf::Message>::default_instance()
    }
}

impl IdUpdateSource {
    pub fn new() -> IdUpdateSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &IdUpdateSource| { &m.id },
            |m: &mut IdUpdateSource| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_id",
            |m: &IdUpdateSource| { &m.new_id },
            |m: &mut IdUpdateSource| { &mut m.new_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdUpdateSource>(
            "IdUpdateSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdUpdateSource {
    const NAME: &'static str = "IdUpdateSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.new_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.new_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.new_id.is_empty() {
            os.write_string(2, &self.new_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdUpdateSource {
        IdUpdateSource::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.new_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdUpdateSource {
        static instance: IdUpdateSource = IdUpdateSource {
            id: ::std::string::String::new(),
            new_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdUpdateSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdUpdateSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdUpdateSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdUpdateSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelIdsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelIdsRequest)
pub struct PatchModelIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelIdsRequest {
    fn default() -> &'a PatchModelIdsRequest {
        <PatchModelIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelIdsRequest {
    pub fn new() -> PatchModelIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelIdsRequest| { &m.user_app_id },
            |m: &mut PatchModelIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchModelIdsRequest| { &m.ids },
            |m: &mut PatchModelIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelIdsRequest| { &m.action },
            |m: &mut PatchModelIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelIdsRequest>(
            "PatchModelIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelIdsRequest {
    const NAME: &'static str = "PatchModelIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelIdsRequest {
        PatchModelIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelIdsRequest {
        static instance: PatchModelIdsRequest = PatchModelIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteModelRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteModelRequest)
pub struct DeleteModelRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelRequest.model_id)
    pub model_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelRequest {
    fn default() -> &'a DeleteModelRequest {
        <DeleteModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelRequest {
    pub fn new() -> DeleteModelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelRequest| { &m.user_app_id },
            |m: &mut DeleteModelRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DeleteModelRequest| { &m.model_id },
            |m: &mut DeleteModelRequest| { &mut m.model_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelRequest>(
            "DeleteModelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelRequest {
    const NAME: &'static str = "DeleteModelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelRequest {
        DeleteModelRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelRequest {
        static instance: DeleteModelRequest = DeleteModelRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteModelsRequest)
pub struct DeleteModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelsRequest {
    fn default() -> &'a DeleteModelsRequest {
        <DeleteModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelsRequest {
    pub fn new() -> DeleteModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelsRequest| { &m.user_app_id },
            |m: &mut DeleteModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModelsRequest| { &m.ids },
            |m: &mut DeleteModelsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteModelsRequest| { &m.delete_all },
            |m: &mut DeleteModelsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelsRequest>(
            "DeleteModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelsRequest {
    const NAME: &'static str = "DeleteModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelsRequest {
        DeleteModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelsRequest {
        static instance: DeleteModelsRequest = DeleteModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Search over the available models.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelsSearchesRequest)
pub struct PostModelsSearchesRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.model_query)
    pub model_query: ::protobuf::MessageField<super::resources::ModelQuery>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelsSearchesRequest {
    fn default() -> &'a PostModelsSearchesRequest {
        <PostModelsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsSearchesRequest {
    pub fn new() -> PostModelsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelsSearchesRequest| { &m.user_app_id },
            |m: &mut PostModelsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelQuery>(
            "model_query",
            |m: &PostModelsSearchesRequest| { &m.model_query },
            |m: &mut PostModelsSearchesRequest| { &mut m.model_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostModelsSearchesRequest| { &m.pagination },
            |m: &mut PostModelsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelsSearchesRequest>(
            "PostModelsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelsSearchesRequest {
    const NAME: &'static str = "PostModelsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_query)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelsSearchesRequest {
        PostModelsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_query.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelsSearchesRequest {
        static instance: PostModelsSearchesRequest = PostModelsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_query: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleModelResponse)
pub struct SingleModelResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelResponse.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelResponse {
    fn default() -> &'a SingleModelResponse {
        <SingleModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelResponse {
    pub fn new() -> SingleModelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelResponse| { &m.status },
            |m: &mut SingleModelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &SingleModelResponse| { &m.model },
            |m: &mut SingleModelResponse| { &mut m.model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelResponse>(
            "SingleModelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelResponse {
    const NAME: &'static str = "SingleModelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelResponse {
        SingleModelResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelResponse {
        static instance: SingleModelResponse = SingleModelResponse {
            status: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelResponse)
pub struct MultiModelResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelResponse.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelResponse {
    fn default() -> &'a MultiModelResponse {
        <MultiModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelResponse {
    pub fn new() -> MultiModelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelResponse| { &m.status },
            |m: &mut MultiModelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &MultiModelResponse| { &m.models },
            |m: &mut MultiModelResponse| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelResponse>(
            "MultiModelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelResponse {
    const NAME: &'static str = "MultiModelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelResponse {
        MultiModelResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelResponse {
        static instance: MultiModelResponse = MultiModelResponse {
            status: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModelVersionsRequest)
pub struct PatchModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelVersionsRequest {
    fn default() -> &'a PatchModelVersionsRequest {
        <PatchModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelVersionsRequest {
    pub fn new() -> PatchModelVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelVersionsRequest| { &m.user_app_id },
            |m: &mut PatchModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelVersionsRequest| { &m.model_id },
            |m: &mut PatchModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PatchModelVersionsRequest| { &m.model_versions },
            |m: &mut PatchModelVersionsRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelVersionsRequest| { &m.action },
            |m: &mut PatchModelVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelVersionsRequest>(
            "PatchModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelVersionsRequest {
    const NAME: &'static str = "PatchModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelVersionsRequest {
        PatchModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelVersionsRequest {
        static instance: PatchModelVersionsRequest = PatchModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  request for different endpoints currently.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionRequest)
pub struct GetModelVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionRequest {
    fn default() -> &'a GetModelVersionRequest {
        <GetModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionRequest {
    pub fn new() -> GetModelVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionRequest| { &m.user_app_id },
            |m: &mut GetModelVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionRequest| { &m.model_id },
            |m: &mut GetModelVersionRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionRequest| { &m.version_id },
            |m: &mut GetModelVersionRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionRequest>(
            "GetModelVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionRequest {
    const NAME: &'static str = "GetModelVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionRequest {
        GetModelVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionRequest {
        static instance: GetModelVersionRequest = GetModelVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionsRequest)
pub struct ListModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.per_page)
    pub per_page: u32,
    ///  Filtering options:
    ///  To list only the model versions that have these concept ids present in them.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    ///  To list only the model versions that have been trained.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.trained_only)
    pub trained_only: bool,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.sort_ascending)
    pub sort_ascending: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_model_versions_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionsRequest {
    fn default() -> &'a ListModelVersionsRequest {
        <ListModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionsRequest {
    pub fn new() -> ListModelVersionsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_status_code = 8;

    pub fn sort_by_status_code(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_status_code(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_status_code(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_status_code(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(v))
    }

    // bool sort_by_num_inputs = 9;

    pub fn sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(v))
    }

    // bool sort_by_description = 10;

    pub fn sort_by_description(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_description(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_description(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_description(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(v))
    }

    // bool sort_by_created_at = 11;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionsRequest| { &m.user_app_id },
            |m: &mut ListModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionsRequest| { &m.model_id },
            |m: &mut ListModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionsRequest| { &m.page },
            |m: &mut ListModelVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionsRequest| { &m.per_page },
            |m: &mut ListModelVersionsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ListModelVersionsRequest| { &m.concept_ids },
            |m: &mut ListModelVersionsRequest| { &mut m.concept_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_only",
            |m: &ListModelVersionsRequest| { &m.trained_only },
            |m: &mut ListModelVersionsRequest| { &mut m.trained_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModelVersionsRequest| { &m.sort_ascending },
            |m: &mut ListModelVersionsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_status_code",
            ListModelVersionsRequest::has_sort_by_status_code,
            ListModelVersionsRequest::sort_by_status_code,
            ListModelVersionsRequest::set_sort_by_status_code,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_num_inputs",
            ListModelVersionsRequest::has_sort_by_num_inputs,
            ListModelVersionsRequest::sort_by_num_inputs,
            ListModelVersionsRequest::set_sort_by_num_inputs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_description",
            ListModelVersionsRequest::has_sort_by_description,
            ListModelVersionsRequest::sort_by_description,
            ListModelVersionsRequest::set_sort_by_description,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModelVersionsRequest::has_sort_by_created_at,
            ListModelVersionsRequest::sort_by_created_at,
            ListModelVersionsRequest::set_sort_by_created_at,
        ));
        oneofs.push(list_model_versions_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionsRequest>(
            "ListModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionsRequest {
    const NAME: &'static str = "ListModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.concept_ids.push(is.read_string()?);
                },
                48 => {
                    self.trained_only = is.read_bool()?;
                },
                56 => {
                    self.sort_ascending = is.read_bool()?;
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(is.read_bool()?));
                },
                80 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.trained_only != false {
            my_size += 1 + 1;
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_model_versions_request::Sort_by::SortByStatusCode(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByNumInputs(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByDescription(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        for v in &self.concept_ids {
            os.write_string(5, &v)?;
        };
        if self.trained_only != false {
            os.write_bool(6, self.trained_only)?;
        }
        if self.sort_ascending != false {
            os.write_bool(7, self.sort_ascending)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_model_versions_request::Sort_by::SortByStatusCode(v) => {
                    os.write_bool(8, v)?;
                },
                &list_model_versions_request::Sort_by::SortByNumInputs(v) => {
                    os.write_bool(9, v)?;
                },
                &list_model_versions_request::Sort_by::SortByDescription(v) => {
                    os.write_bool(10, v)?;
                },
                &list_model_versions_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionsRequest {
        ListModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.concept_ids.clear();
        self.trained_only = false;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionsRequest {
        static instance: ListModelVersionsRequest = ListModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            concept_ids: ::std::vec::Vec::new(),
            trained_only: false,
            sort_ascending: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModelVersionsRequest`
pub mod list_model_versions_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModelVersionsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_status_code)
        SortByStatusCode(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_num_inputs)
        SortByNumInputs(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_description)
        SortByDescription(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModelVersionsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  DeleteModelVersionRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteModelVersionRequest)
pub struct DeleteModelVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelVersionRequest {
    fn default() -> &'a DeleteModelVersionRequest {
        <DeleteModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelVersionRequest {
    pub fn new() -> DeleteModelVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelVersionRequest| { &m.user_app_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DeleteModelVersionRequest| { &m.model_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &DeleteModelVersionRequest| { &m.version_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelVersionRequest>(
            "DeleteModelVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelVersionRequest {
    const NAME: &'static str = "DeleteModelVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.model_id = is.read_string()?;
                },
                34 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(4, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelVersionRequest {
        DeleteModelVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelVersionRequest {
        static instance: DeleteModelVersionRequest = DeleteModelVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionResponse)
pub struct SingleModelVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionResponse.model_version)
    pub model_version: ::protobuf::MessageField<super::resources::ModelVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionResponse {
    fn default() -> &'a SingleModelVersionResponse {
        <SingleModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionResponse {
    pub fn new() -> SingleModelVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionResponse| { &m.status },
            |m: &mut SingleModelVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersion>(
            "model_version",
            |m: &SingleModelVersionResponse| { &m.model_version },
            |m: &mut SingleModelVersionResponse| { &mut m.model_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionResponse>(
            "SingleModelVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionResponse {
    const NAME: &'static str = "SingleModelVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionResponse {
        SingleModelVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionResponse {
        static instance: SingleModelVersionResponse = SingleModelVersionResponse {
            status: ::protobuf::MessageField::none(),
            model_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelVersionResponse)
pub struct MultiModelVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionResponse.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionResponse {
    fn default() -> &'a MultiModelVersionResponse {
        <MultiModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionResponse {
    pub fn new() -> MultiModelVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelVersionResponse| { &m.status },
            |m: &mut MultiModelVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &MultiModelVersionResponse| { &m.model_versions },
            |m: &mut MultiModelVersionResponse| { &mut m.model_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelVersionResponse>(
            "MultiModelVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelVersionResponse {
    const NAME: &'static str = "MultiModelVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelVersionResponse {
        MultiModelVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelVersionResponse {
        static instance: MultiModelVersionResponse = MultiModelVersionResponse {
            status: ::protobuf::MessageField::none(),
            model_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Create (train) a new model version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsRequest)
pub struct PostModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    ///  Description about this training run
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.description)
    pub description: ::std::string::String,
    ///  When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
    ///  We will merge this with default_eval_info.
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.eval_info)
    pub eval_info: ::protobuf::MessageField<super::resources::EvalInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsRequest {
    fn default() -> &'a PostModelVersionsRequest {
        <PostModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsRequest {
    pub fn new() -> PostModelVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsRequest| { &m.model_id },
            |m: &mut PostModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PostModelVersionsRequest| { &m.model_versions },
            |m: &mut PostModelVersionsRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &PostModelVersionsRequest| { &m.description },
            |m: &mut PostModelVersionsRequest| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalInfo>(
            "eval_info",
            |m: &PostModelVersionsRequest| { &m.eval_info },
            |m: &mut PostModelVersionsRequest| { &mut m.eval_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsRequest>(
            "PostModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsRequest {
    const NAME: &'static str = "PostModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                66 => {
                    self.description = is.read_string()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsRequest {
        PostModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.description.clear();
        self.eval_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsRequest {
        static instance: PostModelVersionsRequest = PostModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            description: ::std::string::String::new(),
            eval_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowVersionsUnPublishRequest)
pub struct PostWorkflowVersionsUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.publications)
    pub publications: ::std::vec::Vec<WorkflowVersionUnPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowVersionsUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowVersionsUnPublishRequest {
    fn default() -> &'a PostWorkflowVersionsUnPublishRequest {
        <PostWorkflowVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowVersionsUnPublishRequest {
    pub fn new() -> PostWorkflowVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.user_app_id },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.workflow_id },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.publications },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowVersionsUnPublishRequest>(
            "PostWorkflowVersionsUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowVersionsUnPublishRequest {
    const NAME: &'static str = "PostWorkflowVersionsUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowVersionsUnPublishRequest {
        PostWorkflowVersionsUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowVersionsUnPublishRequest {
        static instance: PostWorkflowVersionsUnPublishRequest = PostWorkflowVersionsUnPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowVersionsUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowVersionsUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowVersionsUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowVersionsPublishRequest)
pub struct PostWorkflowVersionsPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.publications)
    pub publications: ::std::vec::Vec<WorkflowVersionPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowVersionsPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowVersionsPublishRequest {
    fn default() -> &'a PostWorkflowVersionsPublishRequest {
        <PostWorkflowVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowVersionsPublishRequest {
    pub fn new() -> PostWorkflowVersionsPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowVersionsPublishRequest| { &m.user_app_id },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowVersionsPublishRequest| { &m.workflow_id },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostWorkflowVersionsPublishRequest| { &m.publications },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowVersionsPublishRequest>(
            "PostWorkflowVersionsPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowVersionsPublishRequest {
    const NAME: &'static str = "PostWorkflowVersionsPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowVersionsPublishRequest {
        PostWorkflowVersionsPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowVersionsPublishRequest {
        static instance: PostWorkflowVersionsPublishRequest = PostWorkflowVersionsPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowVersionsPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowVersionsPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowVersionsPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.WorkflowVersionPublishRequest)
pub struct WorkflowVersionPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersionPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersionPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersionPublishRequest {
    fn default() -> &'a WorkflowVersionPublishRequest {
        <WorkflowVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersionPublishRequest {
    pub fn new() -> WorkflowVersionPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &WorkflowVersionPublishRequest| { &m.version_id },
            |m: &mut WorkflowVersionPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersionPublishRequest>(
            "WorkflowVersionPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersionPublishRequest {
    const NAME: &'static str = "WorkflowVersionPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersionPublishRequest {
        WorkflowVersionPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersionPublishRequest {
        static instance: WorkflowVersionPublishRequest = WorkflowVersionPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersionPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersionPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersionPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.WorkflowVersionUnPublishRequest)
pub struct WorkflowVersionUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersionUnPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersionUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersionUnPublishRequest {
    fn default() -> &'a WorkflowVersionUnPublishRequest {
        <WorkflowVersionUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersionUnPublishRequest {
    pub fn new() -> WorkflowVersionUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &WorkflowVersionUnPublishRequest| { &m.version_id },
            |m: &mut WorkflowVersionUnPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersionUnPublishRequest>(
            "WorkflowVersionUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersionUnPublishRequest {
    const NAME: &'static str = "WorkflowVersionUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersionUnPublishRequest {
        WorkflowVersionUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersionUnPublishRequest {
        static instance: WorkflowVersionUnPublishRequest = WorkflowVersionUnPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersionUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersionUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersionUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersionUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionPublishRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ModelVersionPublishRequest)
pub struct ModelVersionPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionPublishRequest {
    fn default() -> &'a ModelVersionPublishRequest {
        <ModelVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionPublishRequest {
    pub fn new() -> ModelVersionPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ModelVersionPublishRequest| { &m.version_id },
            |m: &mut ModelVersionPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionPublishRequest>(
            "ModelVersionPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionPublishRequest {
    const NAME: &'static str = "ModelVersionPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionPublishRequest {
        ModelVersionPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionPublishRequest {
        static instance: ModelVersionPublishRequest = ModelVersionPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelVersionsPublishRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsPublishRequest)
pub struct PostModelVersionsPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.publications)
    pub publications: ::std::vec::Vec<ModelVersionPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsPublishRequest {
    fn default() -> &'a PostModelVersionsPublishRequest {
        <PostModelVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsPublishRequest {
    pub fn new() -> PostModelVersionsPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsPublishRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsPublishRequest| { &m.model_id },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostModelVersionsPublishRequest| { &m.publications },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsPublishRequest>(
            "PostModelVersionsPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsPublishRequest {
    const NAME: &'static str = "PostModelVersionsPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsPublishRequest {
        PostModelVersionsPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsPublishRequest {
        static instance: PostModelVersionsPublishRequest = PostModelVersionsPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionUnpublishRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ModelVersionUnpublishRequest)
pub struct ModelVersionUnpublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionUnpublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionUnpublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionUnpublishRequest {
    fn default() -> &'a ModelVersionUnpublishRequest {
        <ModelVersionUnpublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionUnpublishRequest {
    pub fn new() -> ModelVersionUnpublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ModelVersionUnpublishRequest| { &m.version_id },
            |m: &mut ModelVersionUnpublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionUnpublishRequest>(
            "ModelVersionUnpublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionUnpublishRequest {
    const NAME: &'static str = "ModelVersionUnpublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionUnpublishRequest {
        ModelVersionUnpublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionUnpublishRequest {
        static instance: ModelVersionUnpublishRequest = ModelVersionUnpublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionUnpublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionUnpublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionUnpublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionUnpublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelVersionsUnPublishRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsUnPublishRequest)
pub struct PostModelVersionsUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.publications)
    pub publications: ::std::vec::Vec<ModelVersionUnpublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUnPublishRequest {
    fn default() -> &'a PostModelVersionsUnPublishRequest {
        <PostModelVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUnPublishRequest {
    pub fn new() -> PostModelVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsUnPublishRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsUnPublishRequest| { &m.model_id },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostModelVersionsUnPublishRequest| { &m.publications },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsUnPublishRequest>(
            "PostModelVersionsUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsUnPublishRequest {
    const NAME: &'static str = "PostModelVersionsUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsUnPublishRequest {
        PostModelVersionsUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsUnPublishRequest {
        static instance: PostModelVersionsUnPublishRequest = PostModelVersionsUnPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model vesion
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostEvaluationsRequest)
pub struct PostEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  eval_info, id, model, and ground_truth_dataset will be used when creating the evaluation
    ///  If no dataset is provided, all app data that is annotated with concepts from the model will be used.
    // @@protoc_insertion_point(field:clarifai.api.PostEvaluationsRequest.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostEvaluationsRequest {
    fn default() -> &'a PostEvaluationsRequest {
        <PostEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostEvaluationsRequest {
    pub fn new() -> PostEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostEvaluationsRequest| { &m.user_app_id },
            |m: &mut PostEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &PostEvaluationsRequest| { &m.eval_metrics },
            |m: &mut PostEvaluationsRequest| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostEvaluationsRequest>(
            "PostEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostEvaluationsRequest {
    const NAME: &'static str = "PostEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostEvaluationsRequest {
        PostEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostEvaluationsRequest {
        static instance: PostEvaluationsRequest = PostEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListEvaluationsRequest)
pub struct ListEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.per_page)
    pub per_page: u32,
    ///  If true, sort in ascending order, otherwise sort in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filter on model type id
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  Filter on dataset ID of the dataset version specified in the metric version
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.eval_dataset_ids)
    pub eval_dataset_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter on dataset ID of the dataset version specified by the model version
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.train_dataset_ids)
    pub train_dataset_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter on concept IDs specified in the modele version's output_info
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_evaluations_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEvaluationsRequest {
    fn default() -> &'a ListEvaluationsRequest {
        <ListEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEvaluationsRequest {
    pub fn new() -> ListEvaluationsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_app_id = 5;

    pub fn sort_by_app_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_app_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_app_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_app_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(v))
    }

    // bool sort_by_roc_auc = 6;

    pub fn sort_by_roc_auc(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_roc_auc(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_roc_auc(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_roc_auc(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(v))
    }

    // bool sort_by_f1 = 7;

    pub fn sort_by_f1(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_f1(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_f1(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_f1(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(v))
    }

    // bool sort_by_created_at = 8;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_mean_avg_precision = 9;

    pub fn sort_by_mean_avg_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_mean_avg_precision(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_mean_avg_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_mean_avg_precision(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v))
    }

    // bool sort_by_precision = 10;

    pub fn sort_by_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_precision(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_precision(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(v))
    }

    // bool sort_by_recall = 11;

    pub fn sort_by_recall(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_recall(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_recall(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_recall(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(v))
    }

    // bool sort_by_model_id = 16;

    pub fn sort_by_model_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_model_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_model_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_model_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(v))
    }

    // bool sort_by_eval_dataset_id = 17;

    pub fn sort_by_eval_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_eval_dataset_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_eval_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_eval_dataset_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(v))
    }

    // bool sort_by_train_dataset_id = 18;

    pub fn sort_by_train_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_train_dataset_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_train_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_train_dataset_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListEvaluationsRequest| { &m.user_app_id },
            |m: &mut ListEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListEvaluationsRequest| { &m.page },
            |m: &mut ListEvaluationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListEvaluationsRequest| { &m.per_page },
            |m: &mut ListEvaluationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListEvaluationsRequest| { &m.sort_ascending },
            |m: &mut ListEvaluationsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_app_id",
            ListEvaluationsRequest::has_sort_by_app_id,
            ListEvaluationsRequest::sort_by_app_id,
            ListEvaluationsRequest::set_sort_by_app_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_roc_auc",
            ListEvaluationsRequest::has_sort_by_roc_auc,
            ListEvaluationsRequest::sort_by_roc_auc,
            ListEvaluationsRequest::set_sort_by_roc_auc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_f1",
            ListEvaluationsRequest::has_sort_by_f1,
            ListEvaluationsRequest::sort_by_f1,
            ListEvaluationsRequest::set_sort_by_f1,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListEvaluationsRequest::has_sort_by_created_at,
            ListEvaluationsRequest::sort_by_created_at,
            ListEvaluationsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_mean_avg_precision",
            ListEvaluationsRequest::has_sort_by_mean_avg_precision,
            ListEvaluationsRequest::sort_by_mean_avg_precision,
            ListEvaluationsRequest::set_sort_by_mean_avg_precision,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_precision",
            ListEvaluationsRequest::has_sort_by_precision,
            ListEvaluationsRequest::sort_by_precision,
            ListEvaluationsRequest::set_sort_by_precision,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_recall",
            ListEvaluationsRequest::has_sort_by_recall,
            ListEvaluationsRequest::sort_by_recall,
            ListEvaluationsRequest::set_sort_by_recall,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_model_id",
            ListEvaluationsRequest::has_sort_by_model_id,
            ListEvaluationsRequest::sort_by_model_id,
            ListEvaluationsRequest::set_sort_by_model_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_eval_dataset_id",
            ListEvaluationsRequest::has_sort_by_eval_dataset_id,
            ListEvaluationsRequest::sort_by_eval_dataset_id,
            ListEvaluationsRequest::set_sort_by_eval_dataset_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_train_dataset_id",
            ListEvaluationsRequest::has_sort_by_train_dataset_id,
            ListEvaluationsRequest::sort_by_train_dataset_id,
            ListEvaluationsRequest::set_sort_by_train_dataset_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ListEvaluationsRequest| { &m.model_type_id },
            |m: &mut ListEvaluationsRequest| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_dataset_ids",
            |m: &ListEvaluationsRequest| { &m.eval_dataset_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.eval_dataset_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "train_dataset_ids",
            |m: &ListEvaluationsRequest| { &m.train_dataset_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.train_dataset_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ListEvaluationsRequest| { &m.concept_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.concept_ids },
        ));
        oneofs.push(list_evaluations_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEvaluationsRequest>(
            "ListEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEvaluationsRequest {
    const NAME: &'static str = "ListEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.sort_ascending = is.read_bool()?;
                },
                40 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(is.read_bool()?));
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(is.read_bool()?));
                },
                80 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(is.read_bool()?));
                },
                128 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(is.read_bool()?));
                },
                136 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(is.read_bool()?));
                },
                144 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(is.read_bool()?));
                },
                98 => {
                    self.model_type_id = is.read_string()?;
                },
                106 => {
                    self.eval_dataset_ids.push(is.read_string()?);
                },
                114 => {
                    self.train_dataset_ids.push(is.read_string()?);
                },
                122 => {
                    self.concept_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.model_type_id);
        }
        for value in &self.eval_dataset_ids {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.train_dataset_ids {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_evaluations_request::Sort_by::SortByAppId(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByRocAuc(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByF1(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByPrecision(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByRecall(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByModelId(v) => {
                    my_size += 2 + 1;
                },
                &list_evaluations_request::Sort_by::SortByEvalDatasetId(v) => {
                    my_size += 2 + 1;
                },
                &list_evaluations_request::Sort_by::SortByTrainDatasetId(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(4, self.sort_ascending)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(12, &self.model_type_id)?;
        }
        for v in &self.eval_dataset_ids {
            os.write_string(13, &v)?;
        };
        for v in &self.train_dataset_ids {
            os.write_string(14, &v)?;
        };
        for v in &self.concept_ids {
            os.write_string(15, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_evaluations_request::Sort_by::SortByAppId(v) => {
                    os.write_bool(5, v)?;
                },
                &list_evaluations_request::Sort_by::SortByRocAuc(v) => {
                    os.write_bool(6, v)?;
                },
                &list_evaluations_request::Sort_by::SortByF1(v) => {
                    os.write_bool(7, v)?;
                },
                &list_evaluations_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(8, v)?;
                },
                &list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v) => {
                    os.write_bool(9, v)?;
                },
                &list_evaluations_request::Sort_by::SortByPrecision(v) => {
                    os.write_bool(10, v)?;
                },
                &list_evaluations_request::Sort_by::SortByRecall(v) => {
                    os.write_bool(11, v)?;
                },
                &list_evaluations_request::Sort_by::SortByModelId(v) => {
                    os.write_bool(16, v)?;
                },
                &list_evaluations_request::Sort_by::SortByEvalDatasetId(v) => {
                    os.write_bool(17, v)?;
                },
                &list_evaluations_request::Sort_by::SortByTrainDatasetId(v) => {
                    os.write_bool(18, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEvaluationsRequest {
        ListEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.model_type_id.clear();
        self.eval_dataset_ids.clear();
        self.train_dataset_ids.clear();
        self.concept_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEvaluationsRequest {
        static instance: ListEvaluationsRequest = ListEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            sort_ascending: false,
            model_type_id: ::std::string::String::new(),
            eval_dataset_ids: ::std::vec::Vec::new(),
            train_dataset_ids: ::std::vec::Vec::new(),
            concept_ids: ::std::vec::Vec::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListEvaluationsRequest`
pub mod list_evaluations_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListEvaluationsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_app_id)
        SortByAppId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_roc_auc)
        SortByRocAuc(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_f1)
        SortByF1(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_mean_avg_precision)
        SortByMeanAvgPrecision(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_precision)
        SortByPrecision(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_recall)
        SortByRecall(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_model_id)
        SortByModelId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_eval_dataset_id)
        SortByEvalDatasetId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_train_dataset_id)
        SortByTrainDatasetId(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListEvaluationsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetEvaluationRequest)
pub struct GetEvaluationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.evaluation_id)
    pub evaluation_id: ::std::string::String,
    ///  Any of the fields you wish to return in the metrics
    ///  By default, only the summary is returned.
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetEvaluationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEvaluationRequest {
    fn default() -> &'a GetEvaluationRequest {
        <GetEvaluationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEvaluationRequest {
    pub fn new() -> GetEvaluationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetEvaluationRequest| { &m.user_app_id },
            |m: &mut GetEvaluationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_id",
            |m: &GetEvaluationRequest| { &m.evaluation_id },
            |m: &mut GetEvaluationRequest| { &mut m.evaluation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetEvaluationRequest| { &m.fields },
            |m: &mut GetEvaluationRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEvaluationRequest>(
            "GetEvaluationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEvaluationRequest {
    const NAME: &'static str = "GetEvaluationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.evaluation_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.evaluation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.evaluation_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.evaluation_id.is_empty() {
            os.write_string(2, &self.evaluation_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEvaluationRequest {
        GetEvaluationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.evaluation_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEvaluationRequest {
        static instance: GetEvaluationRequest = GetEvaluationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            evaluation_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEvaluationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEvaluationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEvaluationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEvaluationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model vesion
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionEvaluationsRequest)
pub struct PostModelVersionEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  EvalInfo and ID will be used when creating the evaluation
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionEvaluationsRequest {
    fn default() -> &'a PostModelVersionEvaluationsRequest {
        <PostModelVersionEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionEvaluationsRequest {
    pub fn new() -> PostModelVersionEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.model_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.model_version_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &PostModelVersionEvaluationsRequest| { &m.eval_metrics },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionEvaluationsRequest>(
            "PostModelVersionEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionEvaluationsRequest {
    const NAME: &'static str = "PostModelVersionEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionEvaluationsRequest {
        PostModelVersionEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionEvaluationsRequest {
        static instance: PostModelVersionEvaluationsRequest = PostModelVersionEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionEvaluationsRequest)
pub struct ListModelVersionEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionEvaluationsRequest {
    fn default() -> &'a ListModelVersionEvaluationsRequest {
        <ListModelVersionEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionEvaluationsRequest {
    pub fn new() -> ListModelVersionEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.user_app_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.model_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.model_version_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionEvaluationsRequest| { &m.page },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionEvaluationsRequest| { &m.per_page },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionEvaluationsRequest>(
            "ListModelVersionEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionEvaluationsRequest {
    const NAME: &'static str = "ListModelVersionEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionEvaluationsRequest {
        ListModelVersionEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionEvaluationsRequest {
        static instance: ListModelVersionEvaluationsRequest = ListModelVersionEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionEvaluationRequest)
pub struct GetModelVersionEvaluationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.evaluation_id)
    pub evaluation_id: ::std::string::String,
    ///  Any of the fields you wish to return from multiclass_metrics
    ///  By default, only the summary is returned.
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionEvaluationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionEvaluationRequest {
    fn default() -> &'a GetModelVersionEvaluationRequest {
        <GetModelVersionEvaluationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionEvaluationRequest {
    pub fn new() -> GetModelVersionEvaluationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionEvaluationRequest| { &m.user_app_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionEvaluationRequest| { &m.model_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &GetModelVersionEvaluationRequest| { &m.model_version_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_id",
            |m: &GetModelVersionEvaluationRequest| { &m.evaluation_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.evaluation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetModelVersionEvaluationRequest| { &m.fields },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionEvaluationRequest>(
            "GetModelVersionEvaluationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionEvaluationRequest {
    const NAME: &'static str = "GetModelVersionEvaluationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.evaluation_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.evaluation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.evaluation_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.evaluation_id.is_empty() {
            os.write_string(4, &self.evaluation_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionEvaluationRequest {
        GetModelVersionEvaluationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.evaluation_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionEvaluationRequest {
        static instance: GetModelVersionEvaluationRequest = GetModelVersionEvaluationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            evaluation_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionEvaluationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionEvaluationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionEvaluationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionEvaluationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleEvalMetricsResponse)
pub struct SingleEvalMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleEvalMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleEvalMetricsResponse.eval_metrics)
    pub eval_metrics: ::protobuf::MessageField<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleEvalMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleEvalMetricsResponse {
    fn default() -> &'a SingleEvalMetricsResponse {
        <SingleEvalMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleEvalMetricsResponse {
    pub fn new() -> SingleEvalMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleEvalMetricsResponse| { &m.status },
            |m: &mut SingleEvalMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalMetrics>(
            "eval_metrics",
            |m: &SingleEvalMetricsResponse| { &m.eval_metrics },
            |m: &mut SingleEvalMetricsResponse| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleEvalMetricsResponse>(
            "SingleEvalMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleEvalMetricsResponse {
    const NAME: &'static str = "SingleEvalMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eval_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.eval_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleEvalMetricsResponse {
        SingleEvalMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleEvalMetricsResponse {
        static instance: SingleEvalMetricsResponse = SingleEvalMetricsResponse {
            status: ::protobuf::MessageField::none(),
            eval_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleEvalMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleEvalMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleEvalMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleEvalMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiEvalMetricsResponse)
pub struct MultiEvalMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiEvalMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiEvalMetricsResponse.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiEvalMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiEvalMetricsResponse {
    fn default() -> &'a MultiEvalMetricsResponse {
        <MultiEvalMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiEvalMetricsResponse {
    pub fn new() -> MultiEvalMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiEvalMetricsResponse| { &m.status },
            |m: &mut MultiEvalMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &MultiEvalMetricsResponse| { &m.eval_metrics },
            |m: &mut MultiEvalMetricsResponse| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiEvalMetricsResponse>(
            "MultiEvalMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiEvalMetricsResponse {
    const NAME: &'static str = "MultiEvalMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiEvalMetricsResponse {
        MultiEvalMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiEvalMetricsResponse {
        static instance: MultiEvalMetricsResponse = MultiEvalMetricsResponse {
            status: ::protobuf::MessageField::none(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiEvalMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiEvalMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiEvalMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiEvalMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionMetricsRequest)
pub struct PostModelVersionMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  Use this to filter inputs that are used in evaluation
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.test_search)
    pub test_search: ::protobuf::MessageField<super::resources::Search>,
    ///  evaluation info. Such as dataset used for evaluation.
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.eval_info)
    pub eval_info: ::protobuf::MessageField<super::resources::EvalInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionMetricsRequest {
    fn default() -> &'a PostModelVersionMetricsRequest {
        <PostModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionMetricsRequest {
    pub fn new() -> PostModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionMetricsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionMetricsRequest| { &m.model_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostModelVersionMetricsRequest| { &m.version_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "test_search",
            |m: &PostModelVersionMetricsRequest| { &m.test_search },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.test_search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalInfo>(
            "eval_info",
            |m: &PostModelVersionMetricsRequest| { &m.eval_info },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.eval_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionMetricsRequest>(
            "PostModelVersionMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionMetricsRequest {
    const NAME: &'static str = "PostModelVersionMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.test_search)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(v) = self.test_search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionMetricsRequest {
        PostModelVersionMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.test_search.clear();
        self.eval_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionMetricsRequest {
        static instance: PostModelVersionMetricsRequest = PostModelVersionMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            test_search: ::protobuf::MessageField::none(),
            eval_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Get the already computed evaluation metrics for this model
///  version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionMetricsRequest)
pub struct GetModelVersionMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  Any of the fields you wish to return from multiclass_metrics
    ///  By default, only the summary will be returned
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionMetricsRequest {
    fn default() -> &'a GetModelVersionMetricsRequest {
        <GetModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionMetricsRequest {
    pub fn new() -> GetModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionMetricsRequest| { &m.user_app_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionMetricsRequest| { &m.model_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionMetricsRequest| { &m.version_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetModelVersionMetricsRequest| { &m.fields },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionMetricsRequest>(
            "GetModelVersionMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionMetricsRequest {
    const NAME: &'static str = "GetModelVersionMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionMetricsRequest {
        GetModelVersionMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionMetricsRequest {
        static instance: GetModelVersionMetricsRequest = GetModelVersionMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelTypeRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModelTypeRequest)
pub struct GetModelTypeRequest {
    // message fields
    ///  use and app combo. Not really used for this endpoint at this time so may go away in future.
    // @@protoc_insertion_point(field:clarifai.api.GetModelTypeRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The specific ModelType.Id you want to retrieve.
    // @@protoc_insertion_point(field:clarifai.api.GetModelTypeRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelTypeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelTypeRequest {
    fn default() -> &'a GetModelTypeRequest {
        <GetModelTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelTypeRequest {
    pub fn new() -> GetModelTypeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelTypeRequest| { &m.user_app_id },
            |m: &mut GetModelTypeRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &GetModelTypeRequest| { &m.model_type_id },
            |m: &mut GetModelTypeRequest| { &mut m.model_type_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelTypeRequest>(
            "GetModelTypeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelTypeRequest {
    const NAME: &'static str = "GetModelTypeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_type_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(2, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelTypeRequest {
        GetModelTypeRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_type_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelTypeRequest {
        static instance: GetModelTypeRequest = GetModelTypeRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_type_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelTypeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelTypeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelTypeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelTypesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelTypesRequest)
pub struct ListModelTypesRequest {
    // message fields
    ///  use and app combo. Not really used for this endpoint at this time so may go away in future.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelTypesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelTypesRequest {
    fn default() -> &'a ListModelTypesRequest {
        <ListModelTypesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelTypesRequest {
    pub fn new() -> ListModelTypesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelTypesRequest| { &m.user_app_id },
            |m: &mut ListModelTypesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelTypesRequest| { &m.page },
            |m: &mut ListModelTypesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelTypesRequest| { &m.per_page },
            |m: &mut ListModelTypesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelTypesRequest>(
            "ListModelTypesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelTypesRequest {
    const NAME: &'static str = "ListModelTypesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelTypesRequest {
        ListModelTypesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelTypesRequest {
        static instance: ListModelTypesRequest = ListModelTypesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelTypesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelTypesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelTypesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelTypesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListOpenSourceLicensesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListOpenSourceLicensesRequest)
pub struct ListOpenSourceLicensesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListOpenSourceLicensesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesRequest {
    fn default() -> &'a ListOpenSourceLicensesRequest {
        <ListOpenSourceLicensesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesRequest {
    pub fn new() -> ListOpenSourceLicensesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOpenSourceLicensesRequest>(
            "ListOpenSourceLicensesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesRequest {
    const NAME: &'static str = "ListOpenSourceLicensesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOpenSourceLicensesRequest {
        ListOpenSourceLicensesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOpenSourceLicensesRequest {
        static instance: ListOpenSourceLicensesRequest = ListOpenSourceLicensesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOpenSourceLicensesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOpenSourceLicensesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOpenSourceLicensesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListOpenSourceLicensesResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListOpenSourceLicensesResponse)
pub struct ListOpenSourceLicensesResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListOpenSourceLicensesResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ListOpenSourceLicensesResponse.licenses)
    pub licenses: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListOpenSourceLicensesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesResponse {
    fn default() -> &'a ListOpenSourceLicensesResponse {
        <ListOpenSourceLicensesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesResponse {
    pub fn new() -> ListOpenSourceLicensesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ListOpenSourceLicensesResponse| { &m.status },
            |m: &mut ListOpenSourceLicensesResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "licenses",
            |m: &ListOpenSourceLicensesResponse| { &m.licenses },
            |m: &mut ListOpenSourceLicensesResponse| { &mut m.licenses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOpenSourceLicensesResponse>(
            "ListOpenSourceLicensesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesResponse {
    const NAME: &'static str = "ListOpenSourceLicensesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.licenses.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.licenses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.licenses {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOpenSourceLicensesResponse {
        ListOpenSourceLicensesResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.licenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOpenSourceLicensesResponse {
        static instance: ListOpenSourceLicensesResponse = ListOpenSourceLicensesResponse {
            status: ::protobuf::MessageField::none(),
            licenses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOpenSourceLicensesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOpenSourceLicensesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOpenSourceLicensesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelTypeResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleModelTypeResponse)
pub struct SingleModelTypeResponse {
    // message fields
    ///  Status of the response.
    // @@protoc_insertion_point(field:clarifai.api.SingleModelTypeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The retrieved ModelType object. .
    // @@protoc_insertion_point(field:clarifai.api.SingleModelTypeResponse.model_type)
    pub model_type: ::protobuf::MessageField<super::resources::ModelType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelTypeResponse {
    fn default() -> &'a SingleModelTypeResponse {
        <SingleModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelTypeResponse {
    pub fn new() -> SingleModelTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelTypeResponse| { &m.status },
            |m: &mut SingleModelTypeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelType>(
            "model_type",
            |m: &SingleModelTypeResponse| { &m.model_type },
            |m: &mut SingleModelTypeResponse| { &mut m.model_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelTypeResponse>(
            "SingleModelTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelTypeResponse {
    const NAME: &'static str = "SingleModelTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_type)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelTypeResponse {
        SingleModelTypeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelTypeResponse {
        static instance: SingleModelTypeResponse = SingleModelTypeResponse {
            status: ::protobuf::MessageField::none(),
            model_type: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelTypeResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelTypeResponse)
pub struct MultiModelTypeResponse {
    // message fields
    ///  Status of the response.
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  List of ModelType objects.
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.model_types)
    pub model_types: ::std::vec::Vec<super::resources::ModelType>,
    ///  List of model importers
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.model_importers)
    pub model_importers: ::protobuf::MessageField<super::resources::ModelTypeField>,
    ///  Triton model envs that can be used for model upload
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.triton_conda_envs_info)
    pub triton_conda_envs_info: ::std::vec::Vec<super::resources::TritonCondaEnvInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelTypeResponse {
    fn default() -> &'a MultiModelTypeResponse {
        <MultiModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelTypeResponse {
    pub fn new() -> MultiModelTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelTypeResponse| { &m.status },
            |m: &mut MultiModelTypeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_types",
            |m: &MultiModelTypeResponse| { &m.model_types },
            |m: &mut MultiModelTypeResponse| { &mut m.model_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelTypeField>(
            "model_importers",
            |m: &MultiModelTypeResponse| { &m.model_importers },
            |m: &mut MultiModelTypeResponse| { &mut m.model_importers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "triton_conda_envs_info",
            |m: &MultiModelTypeResponse| { &m.triton_conda_envs_info },
            |m: &mut MultiModelTypeResponse| { &mut m.triton_conda_envs_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelTypeResponse>(
            "MultiModelTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelTypeResponse {
    const NAME: &'static str = "MultiModelTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_types.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_importers)?;
                },
                34 => {
                    self.triton_conda_envs_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.model_importers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.triton_conda_envs_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_types {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.model_importers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.triton_conda_envs_info {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelTypeResponse {
        MultiModelTypeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_types.clear();
        self.model_importers.clear();
        self.triton_conda_envs_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelTypeResponse {
        static instance: MultiModelTypeResponse = MultiModelTypeResponse {
            status: ::protobuf::MessageField::none(),
            model_types: ::std::vec::Vec::new(),
            model_importers: ::protobuf::MessageField::none(),
            triton_conda_envs_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelVersionInputExampleRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionInputExampleRequest)
pub struct GetModelVersionInputExampleRequest {
    // message fields
    ///  authorization field  (contains app/user id info)
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of model the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.model_id)
    pub model_id: ::std::string::String,
    ///  specific version the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Id of example to fetch
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.example_id)
    pub example_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionInputExampleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionInputExampleRequest {
    fn default() -> &'a GetModelVersionInputExampleRequest {
        <GetModelVersionInputExampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionInputExampleRequest {
    pub fn new() -> GetModelVersionInputExampleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionInputExampleRequest| { &m.user_app_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionInputExampleRequest| { &m.model_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &GetModelVersionInputExampleRequest| { &m.model_version_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "example_id",
            |m: &GetModelVersionInputExampleRequest| { &m.example_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.example_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionInputExampleRequest>(
            "GetModelVersionInputExampleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionInputExampleRequest {
    const NAME: &'static str = "GetModelVersionInputExampleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.example_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.example_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.example_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.example_id.is_empty() {
            os.write_string(4, &self.example_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionInputExampleRequest {
        GetModelVersionInputExampleRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.example_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionInputExampleRequest {
        static instance: GetModelVersionInputExampleRequest = GetModelVersionInputExampleRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            example_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionInputExampleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionInputExampleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionInputExampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionInputExampleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelVersionInputExamplesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionInputExamplesRequest)
pub struct ListModelVersionInputExamplesRequest {
    // message fields
    ///  authorization field  (contains app/user id info)
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of model the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.model_id)
    pub model_id: ::std::string::String,
    ///  specific version the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Optional, defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.page)
    pub page: u32,
    ///  Optional, defaults to 128 references per page.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionInputExamplesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionInputExamplesRequest {
    fn default() -> &'a ListModelVersionInputExamplesRequest {
        <ListModelVersionInputExamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionInputExamplesRequest {
    pub fn new() -> ListModelVersionInputExamplesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.user_app_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.model_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.model_version_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionInputExamplesRequest| { &m.page },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionInputExamplesRequest| { &m.per_page },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionInputExamplesRequest>(
            "ListModelVersionInputExamplesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionInputExamplesRequest {
    const NAME: &'static str = "ListModelVersionInputExamplesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionInputExamplesRequest {
        ListModelVersionInputExamplesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionInputExamplesRequest {
        static instance: ListModelVersionInputExamplesRequest = ListModelVersionInputExamplesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionInputExamplesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionInputExamplesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionInputExamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionInputExamplesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionInputExampleResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionInputExampleResponse)
pub struct SingleModelVersionInputExampleResponse {
    // message fields
    ///  status of response
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionInputExampleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  model input example message
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionInputExampleResponse.model_version_input_example)
    pub model_version_input_example: ::protobuf::MessageField<super::resources::ModelVersionInputExample>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionInputExampleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionInputExampleResponse {
    fn default() -> &'a SingleModelVersionInputExampleResponse {
        <SingleModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionInputExampleResponse {
    pub fn new() -> SingleModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionInputExampleResponse| { &m.status },
            |m: &mut SingleModelVersionInputExampleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersionInputExample>(
            "model_version_input_example",
            |m: &SingleModelVersionInputExampleResponse| { &m.model_version_input_example },
            |m: &mut SingleModelVersionInputExampleResponse| { &mut m.model_version_input_example },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionInputExampleResponse>(
            "SingleModelVersionInputExampleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionInputExampleResponse {
    const NAME: &'static str = "SingleModelVersionInputExampleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version_input_example)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version_input_example.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_version_input_example.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionInputExampleResponse {
        SingleModelVersionInputExampleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_example.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionInputExampleResponse {
        static instance: SingleModelVersionInputExampleResponse = SingleModelVersionInputExampleResponse {
            status: ::protobuf::MessageField::none(),
            model_version_input_example: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionInputExampleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionInputExampleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionInputExampleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelVersionInputExampleResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelVersionInputExampleResponse)
pub struct MultiModelVersionInputExampleResponse {
    // message fields
    ///  status of response
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionInputExampleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  model input example messages
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionInputExampleResponse.model_version_input_examples)
    pub model_version_input_examples: ::std::vec::Vec<super::resources::ModelVersionInputExample>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelVersionInputExampleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionInputExampleResponse {
    fn default() -> &'a MultiModelVersionInputExampleResponse {
        <MultiModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionInputExampleResponse {
    pub fn new() -> MultiModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelVersionInputExampleResponse| { &m.status },
            |m: &mut MultiModelVersionInputExampleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_input_examples",
            |m: &MultiModelVersionInputExampleResponse| { &m.model_version_input_examples },
            |m: &mut MultiModelVersionInputExampleResponse| { &mut m.model_version_input_examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelVersionInputExampleResponse>(
            "MultiModelVersionInputExampleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelVersionInputExampleResponse {
    const NAME: &'static str = "MultiModelVersionInputExampleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_version_input_examples.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_version_input_examples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_version_input_examples {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelVersionInputExampleResponse {
        MultiModelVersionInputExampleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelVersionInputExampleResponse {
        static instance: MultiModelVersionInputExampleResponse = MultiModelVersionInputExampleResponse {
            status: ::protobuf::MessageField::none(),
            model_version_input_examples: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelVersionInputExampleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelVersionInputExampleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionInputExampleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelReferencesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModelReferencesRequest)
pub struct ListModelReferencesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.model_id)
    pub model_id: ::std::string::String,
    ///  Optional, defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.page)
    pub page: u32,
    ///  Optional, defaults to 128 references per page.
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelReferencesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelReferencesRequest {
    fn default() -> &'a ListModelReferencesRequest {
        <ListModelReferencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelReferencesRequest {
    pub fn new() -> ListModelReferencesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelReferencesRequest| { &m.user_app_id },
            |m: &mut ListModelReferencesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelReferencesRequest| { &m.model_id },
            |m: &mut ListModelReferencesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelReferencesRequest| { &m.page },
            |m: &mut ListModelReferencesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelReferencesRequest| { &m.per_page },
            |m: &mut ListModelReferencesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelReferencesRequest>(
            "ListModelReferencesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelReferencesRequest {
    const NAME: &'static str = "ListModelReferencesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelReferencesRequest {
        ListModelReferencesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelReferencesRequest {
        static instance: ListModelReferencesRequest = ListModelReferencesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelReferencesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelReferencesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelReferencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelReferencesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelReferenceResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModelReferenceResponse)
pub struct MultiModelReferenceResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelReferenceResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelReferenceResponse.model_references)
    pub model_references: ::std::vec::Vec<super::resources::ModelReference>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelReferenceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelReferenceResponse {
    fn default() -> &'a MultiModelReferenceResponse {
        <MultiModelReferenceResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelReferenceResponse {
    pub fn new() -> MultiModelReferenceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelReferenceResponse| { &m.status },
            |m: &mut MultiModelReferenceResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_references",
            |m: &MultiModelReferenceResponse| { &m.model_references },
            |m: &mut MultiModelReferenceResponse| { &mut m.model_references },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelReferenceResponse>(
            "MultiModelReferenceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelReferenceResponse {
    const NAME: &'static str = "MultiModelReferenceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_references.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_references {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelReferenceResponse {
        MultiModelReferenceResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_references.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelReferenceResponse {
        static instance: MultiModelReferenceResponse = MultiModelReferenceResponse {
            status: ::protobuf::MessageField::none(),
            model_references: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelReferenceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelReferenceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelReferenceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelReferenceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiOutputResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiOutputResponse)
pub struct MultiOutputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiOutputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiOutputResponse.outputs)
    pub outputs: ::std::vec::Vec<super::resources::Output>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiOutputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiOutputResponse {
    fn default() -> &'a MultiOutputResponse {
        <MultiOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiOutputResponse {
    pub fn new() -> MultiOutputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiOutputResponse| { &m.status },
            |m: &mut MultiOutputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &MultiOutputResponse| { &m.outputs },
            |m: &mut MultiOutputResponse| { &mut m.outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiOutputResponse>(
            "MultiOutputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiOutputResponse {
    const NAME: &'static str = "MultiOutputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiOutputResponse {
        MultiOutputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiOutputResponse {
        static instance: MultiOutputResponse = MultiOutputResponse {
            status: ::protobuf::MessageField::none(),
            outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiOutputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiOutputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiOutputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListScopesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListScopesRequest)
pub struct ListScopesRequest {
    // message fields
    ///  If "personal_access_token" include scopes and endpoints available to personal access tokens.
    ///  If "api_key" include scopes and endpoints available to app-specific keys. (default)
    // @@protoc_insertion_point(field:clarifai.api.ListScopesRequest.key_type)
    pub key_type: ::std::string::String,
    ///  For all user specific information we include user_app_id to get the user_id in a consistent way
    // @@protoc_insertion_point(field:clarifai.api.ListScopesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListScopesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListScopesRequest {
    fn default() -> &'a ListScopesRequest {
        <ListScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListScopesRequest {
    pub fn new() -> ListScopesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_type",
            |m: &ListScopesRequest| { &m.key_type },
            |m: &mut ListScopesRequest| { &mut m.key_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListScopesRequest| { &m.user_app_id },
            |m: &mut ListScopesRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListScopesRequest>(
            "ListScopesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListScopesRequest {
    const NAME: &'static str = "ListScopesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_type = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_type);
        }
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key_type.is_empty() {
            os.write_string(1, &self.key_type)?;
        }
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListScopesRequest {
        ListScopesRequest::new()
    }

    fn clear(&mut self) {
        self.key_type.clear();
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListScopesRequest {
        static instance: ListScopesRequest = ListScopesRequest {
            key_type: ::std::string::String::new(),
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListScopesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListScopesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListScopesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MyScopesRequest)
pub struct MyScopesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MyScopesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesRequest {
    fn default() -> &'a MyScopesRequest {
        <MyScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRequest {
    pub fn new() -> MyScopesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &MyScopesRequest| { &m.user_app_id },
            |m: &mut MyScopesRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesRequest>(
            "MyScopesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesRequest {
    const NAME: &'static str = "MyScopesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesRequest {
        MyScopesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesRequest {
        static instance: MyScopesRequest = MyScopesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesUserRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MyScopesUserRequest)
pub struct MyScopesUserRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MyScopesUserRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesUserRequest {
    fn default() -> &'a MyScopesUserRequest {
        <MyScopesUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesUserRequest {
    pub fn new() -> MyScopesUserRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &MyScopesUserRequest| { &m.user_app_id },
            |m: &mut MyScopesUserRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesUserRequest>(
            "MyScopesUserRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesUserRequest {
    const NAME: &'static str = "MyScopesUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesUserRequest {
        MyScopesUserRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesUserRequest {
        static instance: MyScopesUserRequest = MyScopesUserRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesUserRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesUserRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesUserRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesRootRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MyScopesRootRequest)
pub struct MyScopesRootRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesRootRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesRootRequest {
    fn default() -> &'a MyScopesRootRequest {
        <MyScopesRootRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRootRequest {
    pub fn new() -> MyScopesRootRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesRootRequest>(
            "MyScopesRootRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesRootRequest {
    const NAME: &'static str = "MyScopesRootRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesRootRequest {
        MyScopesRootRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesRootRequest {
        static instance: MyScopesRootRequest = MyScopesRootRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesRootRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesRootRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesRootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRootRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeDepsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiScopeDepsResponse)
pub struct MultiScopeDepsResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  scopes is a list of low-level scopes and their dependencies.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.scope_deps)
    pub scope_deps: ::std::vec::Vec<super::resources::ScopeDeps>,
    ///  endpoint_scopes is a listof all the publicly available endponts which can be
    ///  used as scopes as well. A call to each of those endpoint depends on a subset
    ///  of the above "scopes"
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.endpoint_deps)
    pub endpoint_deps: ::std::vec::Vec<super::resources::EndpointDeps>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeDepsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeDepsResponse {
    fn default() -> &'a MultiScopeDepsResponse {
        <MultiScopeDepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeDepsResponse {
    pub fn new() -> MultiScopeDepsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeDepsResponse| { &m.status },
            |m: &mut MultiScopeDepsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scope_deps",
            |m: &MultiScopeDepsResponse| { &m.scope_deps },
            |m: &mut MultiScopeDepsResponse| { &mut m.scope_deps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoint_deps",
            |m: &MultiScopeDepsResponse| { &m.endpoint_deps },
            |m: &mut MultiScopeDepsResponse| { &mut m.endpoint_deps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeDepsResponse>(
            "MultiScopeDepsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeDepsResponse {
    const NAME: &'static str = "MultiScopeDepsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scope_deps.push(is.read_message()?);
                },
                26 => {
                    self.endpoint_deps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scope_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.endpoint_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scope_deps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.endpoint_deps {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeDepsResponse {
        MultiScopeDepsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scope_deps.clear();
        self.endpoint_deps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeDepsResponse {
        static instance: MultiScopeDepsResponse = MultiScopeDepsResponse {
            status: ::protobuf::MessageField::none(),
            scope_deps: ::std::vec::Vec::new(),
            endpoint_deps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeDepsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeDepsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeDepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeDepsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiScopeResponse)
pub struct MultiScopeResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  The app that the key has access to.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeResponse {
    fn default() -> &'a MultiScopeResponse {
        <MultiScopeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeResponse {
    pub fn new() -> MultiScopeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeResponse| { &m.status },
            |m: &mut MultiScopeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeResponse| { &m.scopes },
            |m: &mut MultiScopeResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &MultiScopeResponse| { &m.app },
            |m: &mut MultiScopeResponse| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeResponse| { &m.endpoints },
            |m: &mut MultiScopeResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeResponse>(
            "MultiScopeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeResponse {
    const NAME: &'static str = "MultiScopeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeResponse {
        MultiScopeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.app.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeResponse {
        static instance: MultiScopeResponse = MultiScopeResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            app: ::protobuf::MessageField::none(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeUserResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiScopeUserResponse)
pub struct MultiScopeUserResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeUserResponse {
    fn default() -> &'a MultiScopeUserResponse {
        <MultiScopeUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeUserResponse {
    pub fn new() -> MultiScopeUserResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeUserResponse| { &m.status },
            |m: &mut MultiScopeUserResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeUserResponse| { &m.scopes },
            |m: &mut MultiScopeUserResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeUserResponse| { &m.endpoints },
            |m: &mut MultiScopeUserResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeUserResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeUserResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeUserResponse>(
            "MultiScopeUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeUserResponse {
    const NAME: &'static str = "MultiScopeUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeUserResponse {
        MultiScopeUserResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeUserResponse {
        static instance: MultiScopeUserResponse = MultiScopeUserResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeRootResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiScopeRootResponse)
pub struct MultiScopeRootResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeRootResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeRootResponse {
    fn default() -> &'a MultiScopeRootResponse {
        <MultiScopeRootResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeRootResponse {
    pub fn new() -> MultiScopeRootResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeRootResponse| { &m.status },
            |m: &mut MultiScopeRootResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeRootResponse| { &m.scopes },
            |m: &mut MultiScopeRootResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeRootResponse| { &m.endpoints },
            |m: &mut MultiScopeRootResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeRootResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeRootResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeRootResponse>(
            "MultiScopeRootResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeRootResponse {
    const NAME: &'static str = "MultiScopeRootResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeRootResponse {
        MultiScopeRootResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeRootResponse {
        static instance: MultiScopeRootResponse = MultiScopeRootResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeRootResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeRootResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeRootResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeRootResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetSearchRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetSearchRequest)
pub struct GetSearchRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetSearchRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetSearchRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetSearchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSearchRequest {
    fn default() -> &'a GetSearchRequest {
        <GetSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSearchRequest {
    pub fn new() -> GetSearchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetSearchRequest| { &m.user_app_id },
            |m: &mut GetSearchRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetSearchRequest| { &m.id },
            |m: &mut GetSearchRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSearchRequest>(
            "GetSearchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSearchRequest {
    const NAME: &'static str = "GetSearchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSearchRequest {
        GetSearchRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSearchRequest {
        static instance: GetSearchRequest = GetSearchRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSearchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSearchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSearchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListSearchesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListSearchesRequest)
pub struct ListSearchesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSearchesRequest {
    fn default() -> &'a ListSearchesRequest {
        <ListSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSearchesRequest {
    pub fn new() -> ListSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListSearchesRequest| { &m.user_app_id },
            |m: &mut ListSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListSearchesRequest| { &m.page },
            |m: &mut ListSearchesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListSearchesRequest| { &m.per_page },
            |m: &mut ListSearchesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSearchesRequest>(
            "ListSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSearchesRequest {
    const NAME: &'static str = "ListSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSearchesRequest {
        ListSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSearchesRequest {
        static instance: ListSearchesRequest = ListSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostSearchesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostSearchesRequest)
pub struct PostSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The query; this specifies how the data to be searched
    ///  this will be replaced by "Searches"
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.query)
    pub query: ::protobuf::MessageField<super::resources::Query>,
    ///  The searched to be executed or saved
    ///  Eventually the request level fields will be deprecated in favor of this object
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostSearchesRequest {
    fn default() -> &'a PostSearchesRequest {
        <PostSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesRequest {
    pub fn new() -> PostSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostSearchesRequest| { &m.user_app_id },
            |m: &mut PostSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Query>(
            "query",
            |m: &PostSearchesRequest| { &m.query },
            |m: &mut PostSearchesRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostSearchesRequest| { &m.searches },
            |m: &mut PostSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostSearchesRequest| { &m.pagination },
            |m: &mut PostSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostSearchesRequest>(
            "PostSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostSearchesRequest {
    const NAME: &'static str = "PostSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                26 => {
                    self.searches.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostSearchesRequest {
        PostSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.query.clear();
        self.searches.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostSearchesRequest {
        static instance: PostSearchesRequest = PostSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            query: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchInputsSearchesRequest)
pub struct PatchInputsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchInputsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchInputsSearchesRequest {
    fn default() -> &'a PatchInputsSearchesRequest {
        <PatchInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsSearchesRequest {
    pub fn new() -> PatchInputsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchInputsSearchesRequest| { &m.user_app_id },
            |m: &mut PatchInputsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchInputsSearchesRequest| { &m.searches },
            |m: &mut PatchInputsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchInputsSearchesRequest| { &m.action },
            |m: &mut PatchInputsSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchInputsSearchesRequest>(
            "PatchInputsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchInputsSearchesRequest {
    const NAME: &'static str = "PatchInputsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchInputsSearchesRequest {
        PatchInputsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchInputsSearchesRequest {
        static instance: PatchInputsSearchesRequest = PatchInputsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchInputsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchInputsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsSearchesRequest)
pub struct PatchAnnotationsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsSearchesRequest {
    fn default() -> &'a PatchAnnotationsSearchesRequest {
        <PatchAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsSearchesRequest {
    pub fn new() -> PatchAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsSearchesRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchAnnotationsSearchesRequest| { &m.searches },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsSearchesRequest| { &m.action },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsSearchesRequest>(
            "PatchAnnotationsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsSearchesRequest {
    const NAME: &'static str = "PatchAnnotationsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsSearchesRequest {
        PatchAnnotationsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsSearchesRequest {
        static instance: PatchAnnotationsSearchesRequest = PatchAnnotationsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchSearchesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchSearchesRequest)
pub struct PatchSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchSearchesRequest {
    fn default() -> &'a PatchSearchesRequest {
        <PatchSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchSearchesRequest {
    pub fn new() -> PatchSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchSearchesRequest| { &m.user_app_id },
            |m: &mut PatchSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchSearchesRequest| { &m.searches },
            |m: &mut PatchSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchSearchesRequest| { &m.action },
            |m: &mut PatchSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchSearchesRequest>(
            "PatchSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchSearchesRequest {
    const NAME: &'static str = "PatchSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchSearchesRequest {
        PatchSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchSearchesRequest {
        static instance: PatchSearchesRequest = PatchSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostSearchesByIDRequest performs returns results of a saved search given its ID
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostSearchesByIDRequest)
pub struct PostSearchesByIDRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  ID for saves search to be executed
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.id)
    pub id: ::std::string::String,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostSearchesByIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostSearchesByIDRequest {
    fn default() -> &'a PostSearchesByIDRequest {
        <PostSearchesByIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesByIDRequest {
    pub fn new() -> PostSearchesByIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostSearchesByIDRequest| { &m.user_app_id },
            |m: &mut PostSearchesByIDRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PostSearchesByIDRequest| { &m.id },
            |m: &mut PostSearchesByIDRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostSearchesByIDRequest| { &m.pagination },
            |m: &mut PostSearchesByIDRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostSearchesByIDRequest>(
            "PostSearchesByIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostSearchesByIDRequest {
    const NAME: &'static str = "PostSearchesByIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostSearchesByIDRequest {
        PostSearchesByIDRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostSearchesByIDRequest {
        static instance: PostSearchesByIDRequest = PostSearchesByIDRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostSearchesByIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostSearchesByIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostSearchesByIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesByIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteSearchRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteSearchRequest)
pub struct DeleteSearchRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteSearchRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteSearchRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteSearchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSearchRequest {
    fn default() -> &'a DeleteSearchRequest {
        <DeleteSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSearchRequest {
    pub fn new() -> DeleteSearchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteSearchRequest| { &m.user_app_id },
            |m: &mut DeleteSearchRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteSearchRequest| { &m.id },
            |m: &mut DeleteSearchRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSearchRequest>(
            "DeleteSearchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSearchRequest {
    const NAME: &'static str = "DeleteSearchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSearchRequest {
        DeleteSearchRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSearchRequest {
        static instance: DeleteSearchRequest = DeleteSearchRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSearchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSearchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSearchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Execute a new annotation search and optionally save it
///  annotation search over annotations using rank and filter proto
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationsSearchesRequest)
pub struct PostAnnotationsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searched to be executed or saved
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsSearchesRequest {
    fn default() -> &'a PostAnnotationsSearchesRequest {
        <PostAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsSearchesRequest {
    pub fn new() -> PostAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationsSearchesRequest| { &m.user_app_id },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostAnnotationsSearchesRequest| { &m.searches },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostAnnotationsSearchesRequest| { &m.pagination },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationsSearchesRequest>(
            "PostAnnotationsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationsSearchesRequest {
    const NAME: &'static str = "PostAnnotationsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationsSearchesRequest {
        PostAnnotationsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationsSearchesRequest {
        static instance: PostAnnotationsSearchesRequest = PostAnnotationsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAnnotationSearchMetricsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationSearchMetricsRequest)
pub struct DeleteAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationSearchMetricsRequest {
    fn default() -> &'a DeleteAnnotationSearchMetricsRequest {
        <DeleteAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationSearchMetricsRequest {
    pub fn new() -> DeleteAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationSearchMetricsRequest>(
            "DeleteAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationSearchMetricsRequest {
    const NAME: &'static str = "DeleteAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationSearchMetricsRequest {
        DeleteAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationSearchMetricsRequest {
        static instance: DeleteAnnotationSearchMetricsRequest = DeleteAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Execute a new input search and optionally save it
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostInputsSearchesRequest)
pub struct PostInputsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searched to be executed or saved
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  If only_count is set, then the response will not contain hits,
    ///  but hit_counts instead.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.only_count)
    pub only_count: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsSearchesRequest {
    fn default() -> &'a PostInputsSearchesRequest {
        <PostInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsSearchesRequest {
    pub fn new() -> PostInputsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsSearchesRequest| { &m.user_app_id },
            |m: &mut PostInputsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostInputsSearchesRequest| { &m.searches },
            |m: &mut PostInputsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostInputsSearchesRequest| { &m.pagination },
            |m: &mut PostInputsSearchesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "only_count",
            |m: &PostInputsSearchesRequest| { &m.only_count },
            |m: &mut PostInputsSearchesRequest| { &mut m.only_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsSearchesRequest>(
            "PostInputsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsSearchesRequest {
    const NAME: &'static str = "PostInputsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                32 => {
                    self.only_count = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.only_count != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.only_count != false {
            os.write_bool(4, self.only_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsSearchesRequest {
        PostInputsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.only_count = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsSearchesRequest {
        static instance: PostInputsSearchesRequest = PostInputsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            only_count: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleSearchResponse returns saved search in response to GetSearchRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleSearchResponse)
pub struct SingleSearchResponse {
    // message fields
    ///  Status of whether the search was successful.
    // @@protoc_insertion_point(field:clarifai.api.SingleSearchResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleSearchResponse.search)
    pub search: ::protobuf::MessageField<super::resources::Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleSearchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleSearchResponse {
    fn default() -> &'a SingleSearchResponse {
        <SingleSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleSearchResponse {
    pub fn new() -> SingleSearchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleSearchResponse| { &m.status },
            |m: &mut SingleSearchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search",
            |m: &SingleSearchResponse| { &m.search },
            |m: &mut SingleSearchResponse| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleSearchResponse>(
            "SingleSearchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleSearchResponse {
    const NAME: &'static str = "SingleSearchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleSearchResponse {
        SingleSearchResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleSearchResponse {
        static instance: SingleSearchResponse = SingleSearchResponse {
            status: ::protobuf::MessageField::none(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleSearchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleSearchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSearchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiSearchResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiSearchResponse)
pub struct MultiSearchResponse {
    // message fields
    ///  Status of whether the search was successful.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  A unique id which uniquely identifies a search
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.id)
    pub id: ::std::string::String,
    ///  The list of search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.hits)
    pub hits: ::std::vec::Vec<super::resources::Hit>,
    ///  The original query provided in the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.query)
    pub query: ::protobuf::MessageField<super::resources::Query>,
    ///  The original Searches provided in the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The counts of hits for each search, in the same order as searches.
    ///  Only returned if the request set only_count.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.hit_counts)
    pub hit_counts: ::std::vec::Vec<super::resources::HitCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiSearchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiSearchResponse {
    fn default() -> &'a MultiSearchResponse {
        <MultiSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiSearchResponse {
    pub fn new() -> MultiSearchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiSearchResponse| { &m.status },
            |m: &mut MultiSearchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MultiSearchResponse| { &m.id },
            |m: &mut MultiSearchResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &MultiSearchResponse| { &m.hits },
            |m: &mut MultiSearchResponse| { &mut m.hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Query>(
            "query",
            |m: &MultiSearchResponse| { &m.query },
            |m: &mut MultiSearchResponse| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &MultiSearchResponse| { &m.searches },
            |m: &mut MultiSearchResponse| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hit_counts",
            |m: &MultiSearchResponse| { &m.hit_counts },
            |m: &mut MultiSearchResponse| { &mut m.hit_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiSearchResponse>(
            "MultiSearchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiSearchResponse {
    const NAME: &'static str = "MultiSearchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.hits.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                42 => {
                    self.searches.push(is.read_message()?);
                },
                50 => {
                    self.hit_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.hit_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.hit_counts {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiSearchResponse {
        MultiSearchResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.hits.clear();
        self.query.clear();
        self.searches.clear();
        self.hit_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiSearchResponse {
        static instance: MultiSearchResponse = MultiSearchResponse {
            status: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            hits: ::std::vec::Vec::new(),
            query: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            hit_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiSearchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiSearchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSearchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostAnnotationSearchMetricsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationSearchMetricsRequest)
pub struct PostAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  A unique customer facing id to identify this eval request
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    ///  The ground truth we are evaluating against
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.ground_truth)
    pub ground_truth: ::protobuf::MessageField<super::resources::Search>,
    ///  The set we are evaluating
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.search_to_eval)
    pub search_to_eval: ::protobuf::MessageField<super::resources::Search>,
    ///  List of concepts to evaluate are expected to be in data.concepts
    ///  If nil, then all app concepts are used
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.data)
    pub data: ::protobuf::MessageField<super::resources::Data>,
    ///  The type of evaluation to use
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.evaluation_type)
    pub evaluation_type: ::protobuf::EnumOrUnknown<super::resources::EvaluationType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationSearchMetricsRequest {
    fn default() -> &'a PostAnnotationSearchMetricsRequest {
        <PostAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationSearchMetricsRequest {
    pub fn new() -> PostAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PostAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "ground_truth",
            |m: &PostAnnotationSearchMetricsRequest| { &m.ground_truth },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.ground_truth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search_to_eval",
            |m: &PostAnnotationSearchMetricsRequest| { &m.search_to_eval },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.search_to_eval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Data>(
            "data",
            |m: &PostAnnotationSearchMetricsRequest| { &m.data },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_type",
            |m: &PostAnnotationSearchMetricsRequest| { &m.evaluation_type },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.evaluation_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationSearchMetricsRequest>(
            "PostAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationSearchMetricsRequest {
    const NAME: &'static str = "PostAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ground_truth)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search_to_eval)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                48 => {
                    self.evaluation_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined) {
            my_size += ::protobuf::rt::int32_size(6, self.evaluation_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.ground_truth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.evaluation_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationSearchMetricsRequest {
        PostAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.data.clear();
        self.evaluation_type = ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationSearchMetricsRequest {
        static instance: PostAnnotationSearchMetricsRequest = PostAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            ground_truth: ::protobuf::MessageField::none(),
            search_to_eval: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            evaluation_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationSearchMetricsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationSearchMetricsRequest)
pub struct GetAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Unique custom facing id that identifies the eval to get
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationSearchMetricsRequest {
    fn default() -> &'a GetAnnotationSearchMetricsRequest {
        <GetAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationSearchMetricsRequest {
    pub fn new() -> GetAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationSearchMetricsRequest>(
            "GetAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationSearchMetricsRequest {
    const NAME: &'static str = "GetAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationSearchMetricsRequest {
        GetAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationSearchMetricsRequest {
        static instance: GetAnnotationSearchMetricsRequest = GetAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationSearchMetricsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationSearchMetricsRequest)
pub struct ListAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationSearchMetricsRequest {
    fn default() -> &'a ListAnnotationSearchMetricsRequest {
        <ListAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationSearchMetricsRequest {
    pub fn new() -> ListAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut ListAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationSearchMetricsRequest>(
            "ListAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationSearchMetricsRequest {
    const NAME: &'static str = "ListAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationSearchMetricsRequest {
        ListAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationSearchMetricsRequest {
        static instance: ListAnnotationSearchMetricsRequest = ListAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationSearchMetricsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationSearchMetricsResponse)
pub struct MultiAnnotationSearchMetricsResponse {
    // message fields
    ///  Status of the request
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationSearchMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationSearchMetricsResponse.annotation_search_metrics)
    pub annotation_search_metrics: ::std::vec::Vec<super::resources::AnnotationSearchMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationSearchMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationSearchMetricsResponse {
    fn default() -> &'a MultiAnnotationSearchMetricsResponse {
        <MultiAnnotationSearchMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationSearchMetricsResponse {
    pub fn new() -> MultiAnnotationSearchMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationSearchMetricsResponse| { &m.status },
            |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_search_metrics",
            |m: &MultiAnnotationSearchMetricsResponse| { &m.annotation_search_metrics },
            |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.annotation_search_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationSearchMetricsResponse>(
            "MultiAnnotationSearchMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationSearchMetricsResponse {
    const NAME: &'static str = "MultiAnnotationSearchMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotation_search_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_search_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_search_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationSearchMetricsResponse {
        MultiAnnotationSearchMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_search_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationSearchMetricsResponse {
        static instance: MultiAnnotationSearchMetricsResponse = MultiAnnotationSearchMetricsResponse {
            status: ::protobuf::MessageField::none(),
            annotation_search_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationSearchMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationSearchMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationSearchMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationSearchMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationFiltersRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationFiltersRequest)
pub struct ListAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationFiltersRequest {
    fn default() -> &'a ListAnnotationFiltersRequest {
        <ListAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationFiltersRequest {
    pub fn new() -> ListAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationFiltersRequest| { &m.page },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationFiltersRequest| { &m.per_page },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationFiltersRequest>(
            "ListAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationFiltersRequest {
    const NAME: &'static str = "ListAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationFiltersRequest {
        ListAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationFiltersRequest {
        static instance: ListAnnotationFiltersRequest = ListAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationFilterRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationFilterRequest)
pub struct GetAnnotationFilterRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationFilterRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify annotation filter by id.
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationFilterRequest.annotation_filter_id)
    pub annotation_filter_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationFilterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationFilterRequest {
    fn default() -> &'a GetAnnotationFilterRequest {
        <GetAnnotationFilterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationFilterRequest {
    pub fn new() -> GetAnnotationFilterRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationFilterRequest| { &m.user_app_id },
            |m: &mut GetAnnotationFilterRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_filter_id",
            |m: &GetAnnotationFilterRequest| { &m.annotation_filter_id },
            |m: &mut GetAnnotationFilterRequest| { &mut m.annotation_filter_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationFilterRequest>(
            "GetAnnotationFilterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationFilterRequest {
    const NAME: &'static str = "GetAnnotationFilterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filter_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.annotation_filter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_filter_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.annotation_filter_id.is_empty() {
            os.write_string(2, &self.annotation_filter_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationFilterRequest {
        GetAnnotationFilterRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filter_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationFilterRequest {
        static instance: GetAnnotationFilterRequest = GetAnnotationFilterRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filter_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationFilterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationFilterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationFilterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationFilterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more annotation filters.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationFiltersRequest)
pub struct PostAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of annotation filters that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationFiltersRequest.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationFiltersRequest {
    fn default() -> &'a PostAnnotationFiltersRequest {
        <PostAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationFiltersRequest {
    pub fn new() -> PostAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut PostAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &PostAnnotationFiltersRequest| { &m.annotation_filters },
            |m: &mut PostAnnotationFiltersRequest| { &mut m.annotation_filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationFiltersRequest>(
            "PostAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationFiltersRequest {
    const NAME: &'static str = "PostAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationFiltersRequest {
        PostAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationFiltersRequest {
        static instance: PostAnnotationFiltersRequest = PostAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several annotation filters.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationFiltersRequest)
pub struct PatchAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of annotation filters that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    ///  The action to perform on the patched objects
    ///  For now, only 'overwrite' action is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationFiltersRequest {
    fn default() -> &'a PatchAnnotationFiltersRequest {
        <PatchAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationFiltersRequest {
    pub fn new() -> PatchAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &PatchAnnotationFiltersRequest| { &m.annotation_filters },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.annotation_filters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationFiltersRequest| { &m.action },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationFiltersRequest>(
            "PatchAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationFiltersRequest {
    const NAME: &'static str = "PatchAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationFiltersRequest {
        PatchAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filters.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationFiltersRequest {
        static instance: PatchAnnotationFiltersRequest = PatchAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several annotation filters by list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationFiltersRequest)
pub struct DeleteAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Specify which filters to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationFiltersRequest.annotation_filter_ids)
    pub annotation_filter_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationFiltersRequest {
    fn default() -> &'a DeleteAnnotationFiltersRequest {
        <DeleteAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationFiltersRequest {
    pub fn new() -> DeleteAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filter_ids",
            |m: &DeleteAnnotationFiltersRequest| { &m.annotation_filter_ids },
            |m: &mut DeleteAnnotationFiltersRequest| { &mut m.annotation_filter_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationFiltersRequest>(
            "DeleteAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationFiltersRequest {
    const NAME: &'static str = "DeleteAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filter_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filter_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filter_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationFiltersRequest {
        DeleteAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filter_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationFiltersRequest {
        static instance: DeleteAnnotationFiltersRequest = DeleteAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filter_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationFilterResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationFilterResponse)
pub struct MultiAnnotationFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationFilterResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationFilterResponse.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationFilterResponse {
    fn default() -> &'a MultiAnnotationFilterResponse {
        <MultiAnnotationFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationFilterResponse {
    pub fn new() -> MultiAnnotationFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationFilterResponse| { &m.status },
            |m: &mut MultiAnnotationFilterResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &MultiAnnotationFilterResponse| { &m.annotation_filters },
            |m: &mut MultiAnnotationFilterResponse| { &mut m.annotation_filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationFilterResponse>(
            "MultiAnnotationFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationFilterResponse {
    const NAME: &'static str = "MultiAnnotationFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationFilterResponse {
        MultiAnnotationFilterResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationFilterResponse {
        static instance: MultiAnnotationFilterResponse = MultiAnnotationFilterResponse {
            status: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAnnotationFilterResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleAnnotationFilterResponse)
pub struct SingleAnnotationFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationFilterResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationFilterResponse.annotation_filter)
    pub annotation_filter: ::protobuf::MessageField<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAnnotationFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationFilterResponse {
    fn default() -> &'a SingleAnnotationFilterResponse {
        <SingleAnnotationFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationFilterResponse {
    pub fn new() -> SingleAnnotationFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAnnotationFilterResponse| { &m.status },
            |m: &mut SingleAnnotationFilterResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AnnotationFilter>(
            "annotation_filter",
            |m: &SingleAnnotationFilterResponse| { &m.annotation_filter },
            |m: &mut SingleAnnotationFilterResponse| { &mut m.annotation_filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAnnotationFilterResponse>(
            "SingleAnnotationFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAnnotationFilterResponse {
    const NAME: &'static str = "SingleAnnotationFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.annotation_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAnnotationFilterResponse {
        SingleAnnotationFilterResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAnnotationFilterResponse {
        static instance: SingleAnnotationFilterResponse = SingleAnnotationFilterResponse {
            status: ::protobuf::MessageField::none(),
            annotation_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAnnotationFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAnnotationFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAnnotationFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetUserRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetUserRequest)
pub struct GetUserRequest {
    // message fields
    ///  we used to have user_id but moved to the standard convention. Since this endpoint
    ///  hasn't been exposed and only used by portal as a url this won't effect anything external.
    // @@protoc_insertion_point(field:clarifai.api.GetUserRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetUserRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserRequest {
    fn default() -> &'a GetUserRequest {
        <GetUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUserRequest {
    pub fn new() -> GetUserRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetUserRequest| { &m.user_app_id },
            |m: &mut GetUserRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetUserRequest| { &m.additional_fields },
            |m: &mut GetUserRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserRequest>(
            "GetUserRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserRequest {
    const NAME: &'static str = "GetUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserRequest {
        GetUserRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserRequest {
        static instance: GetUserRequest = GetUserRequest {
            user_app_id: ::protobuf::MessageField::none(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleUserResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleUserResponse)
pub struct SingleUserResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleUserResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleUserResponse.user)
    pub user: ::protobuf::MessageField<super::resources::User>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleUserResponse {
    fn default() -> &'a SingleUserResponse {
        <SingleUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleUserResponse {
    pub fn new() -> SingleUserResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleUserResponse| { &m.status },
            |m: &mut SingleUserResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::User>(
            "user",
            |m: &SingleUserResponse| { &m.user },
            |m: &mut SingleUserResponse| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleUserResponse>(
            "SingleUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleUserResponse {
    const NAME: &'static str = "SingleUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleUserResponse {
        SingleUserResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleUserResponse {
        static instance: SingleUserResponse = SingleUserResponse {
            status: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostValidatePasswordRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostValidatePasswordRequest)
pub struct PostValidatePasswordRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostValidatePasswordRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  password to be validated
    // @@protoc_insertion_point(field:clarifai.api.PostValidatePasswordRequest.password)
    pub password: ::protobuf::MessageField<super::resources::Password>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostValidatePasswordRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostValidatePasswordRequest {
    fn default() -> &'a PostValidatePasswordRequest {
        <PostValidatePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostValidatePasswordRequest {
    pub fn new() -> PostValidatePasswordRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostValidatePasswordRequest| { &m.user_app_id },
            |m: &mut PostValidatePasswordRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Password>(
            "password",
            |m: &PostValidatePasswordRequest| { &m.password },
            |m: &mut PostValidatePasswordRequest| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostValidatePasswordRequest>(
            "PostValidatePasswordRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostValidatePasswordRequest {
    const NAME: &'static str = "PostValidatePasswordRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.password)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.password.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.password.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostValidatePasswordRequest {
        PostValidatePasswordRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostValidatePasswordRequest {
        static instance: PostValidatePasswordRequest = PostValidatePasswordRequest {
            user_app_id: ::protobuf::MessageField::none(),
            password: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostValidatePasswordRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostValidatePasswordRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostValidatePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostValidatePasswordRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SinglePasswordValidationResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SinglePasswordValidationResponse)
pub struct SinglePasswordValidationResponse {
    // message fields
    ///  Standard clarifai status code
    // @@protoc_insertion_point(field:clarifai.api.SinglePasswordValidationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SinglePasswordValidationResponse.password_violations)
    pub password_violations: ::protobuf::MessageField<super::resources::PasswordViolations>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SinglePasswordValidationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SinglePasswordValidationResponse {
    fn default() -> &'a SinglePasswordValidationResponse {
        <SinglePasswordValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SinglePasswordValidationResponse {
    pub fn new() -> SinglePasswordValidationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SinglePasswordValidationResponse| { &m.status },
            |m: &mut SinglePasswordValidationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PasswordViolations>(
            "password_violations",
            |m: &SinglePasswordValidationResponse| { &m.password_violations },
            |m: &mut SinglePasswordValidationResponse| { &mut m.password_violations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SinglePasswordValidationResponse>(
            "SinglePasswordValidationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SinglePasswordValidationResponse {
    const NAME: &'static str = "SinglePasswordValidationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.password_violations)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.password_violations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.password_violations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SinglePasswordValidationResponse {
        SinglePasswordValidationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.password_violations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SinglePasswordValidationResponse {
        static instance: SinglePasswordValidationResponse = SinglePasswordValidationResponse {
            status: ::protobuf::MessageField::none(),
            password_violations: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SinglePasswordValidationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SinglePasswordValidationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SinglePasswordValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePasswordValidationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetWorkflowRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetWorkflowRequest)
pub struct GetWorkflowRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Workflow ID to retrieve
    ///  If no ID is specified we return default workflow of the application
    ///  If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  if true will not expand search to clarifai workflows
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.exclude_clarifai_workflows)
    pub exclude_clarifai_workflows: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetWorkflowRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWorkflowRequest {
    fn default() -> &'a GetWorkflowRequest {
        <GetWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowRequest {
    pub fn new() -> GetWorkflowRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetWorkflowRequest| { &m.user_app_id },
            |m: &mut GetWorkflowRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &GetWorkflowRequest| { &m.workflow_id },
            |m: &mut GetWorkflowRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &GetWorkflowRequest| { &m.favor_clarifai_workflows },
            |m: &mut GetWorkflowRequest| { &mut m.favor_clarifai_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetWorkflowRequest| { &m.additional_fields },
            |m: &mut GetWorkflowRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exclude_clarifai_workflows",
            |m: &GetWorkflowRequest| { &m.exclude_clarifai_workflows },
            |m: &mut GetWorkflowRequest| { &mut m.exclude_clarifai_workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetWorkflowRequest>(
            "GetWorkflowRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetWorkflowRequest {
    const NAME: &'static str = "GetWorkflowRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                24 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                34 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.exclude_clarifai_workflows = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.exclude_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(3, self.favor_clarifai_workflows)?;
        }
        for v in &self.additional_fields {
            os.write_string(4, &v)?;
        };
        if self.exclude_clarifai_workflows != false {
            os.write_bool(5, self.exclude_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWorkflowRequest {
        GetWorkflowRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.favor_clarifai_workflows = false;
        self.additional_fields.clear();
        self.exclude_clarifai_workflows = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWorkflowRequest {
        static instance: GetWorkflowRequest = GetWorkflowRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            favor_clarifai_workflows: false,
            additional_fields: ::std::vec::Vec::new(),
            exclude_clarifai_workflows: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetWorkflowRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetWorkflowRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListWorkflowsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListWorkflowsRequest)
pub struct ListWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.per_page)
    pub per_page: u32,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Query various text fields that can contain the words in the query string.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated in favor of query
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.id)
    pub id: ::std::string::String,
    ///  If true, we only return workflows that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return workflows that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.starred_only)
    pub starred_only: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  (optional) search_term. Full text and prefix matching on description, id, owner id. Searchable fields may be added
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.search_term)
    pub search_term: ::std::string::String,
    ///  Filter workflows by bookmark. If set, only return bookmarked workflows. Otherwise none bookmarked workflows only.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.bookmark)
    pub bookmark: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_workflows_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListWorkflowsRequest {
    fn default() -> &'a ListWorkflowsRequest {
        <ListWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowsRequest {
    pub fn new() -> ListWorkflowsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_id = 6;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(v))
    }

    // bool sort_by_modified_at = 7;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 13;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 14;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListWorkflowsRequest| { &m.user_app_id },
            |m: &mut ListWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListWorkflowsRequest| { &m.page },
            |m: &mut ListWorkflowsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListWorkflowsRequest| { &m.per_page },
            |m: &mut ListWorkflowsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListWorkflowsRequest| { &m.sort_ascending },
            |m: &mut ListWorkflowsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListWorkflowsRequest::has_sort_by_id,
            ListWorkflowsRequest::sort_by_id,
            ListWorkflowsRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListWorkflowsRequest::has_sort_by_modified_at,
            ListWorkflowsRequest::sort_by_modified_at,
            ListWorkflowsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListWorkflowsRequest::has_sort_by_created_at,
            ListWorkflowsRequest::sort_by_created_at,
            ListWorkflowsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListWorkflowsRequest::has_sort_by_star_count,
            ListWorkflowsRequest::sort_by_star_count,
            ListWorkflowsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListWorkflowsRequest| { &m.query },
            |m: &mut ListWorkflowsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListWorkflowsRequest| { &m.id },
            |m: &mut ListWorkflowsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListWorkflowsRequest| { &m.featured_only },
            |m: &mut ListWorkflowsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListWorkflowsRequest| { &m.starred_only },
            |m: &mut ListWorkflowsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListWorkflowsRequest| { &m.additional_fields },
            |m: &mut ListWorkflowsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search_term",
            |m: &ListWorkflowsRequest| { &m.search_term },
            |m: &mut ListWorkflowsRequest| { &mut m.search_term },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListWorkflowsRequest| { &m.bookmark },
            |m: &mut ListWorkflowsRequest| { &mut m.bookmark },
        ));
        oneofs.push(list_workflows_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListWorkflowsRequest>(
            "ListWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListWorkflowsRequest {
    const NAME: &'static str = "ListWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                40 => {
                    self.sort_ascending = is.read_bool()?;
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                112 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                66 => {
                    self.query = is.read_string()?;
                },
                34 => {
                    self.id = is.read_string()?;
                },
                72 => {
                    self.featured_only = is.read_bool()?;
                },
                88 => {
                    self.starred_only = is.read_bool()?;
                },
                82 => {
                    self.additional_fields.push(is.read_string()?);
                },
                98 => {
                    self.search_term = is.read_string()?;
                },
                120 => {
                    self.bookmark = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id);
        }
        if self.featured_only != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if !self.search_term.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.search_term);
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_workflows_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.id.is_empty() {
            os.write_string(4, &self.id)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if !self.search_term.is_empty() {
            os.write_string(12, &self.search_term)?;
        }
        if self.bookmark != false {
            os.write_bool(15, self.bookmark)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_workflows_request::Sort_by::SortById(v) => {
                    os.write_bool(6, v)?;
                },
                &list_workflows_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_workflows_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(13, v)?;
                },
                &list_workflows_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(14, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListWorkflowsRequest {
        ListWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.query.clear();
        self.id.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.additional_fields.clear();
        self.search_term.clear();
        self.bookmark = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListWorkflowsRequest {
        static instance: ListWorkflowsRequest = ListWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            sort_ascending: false,
            query: ::std::string::String::new(),
            id: ::std::string::String::new(),
            featured_only: false,
            starred_only: false,
            additional_fields: ::std::vec::Vec::new(),
            search_term: ::std::string::String::new(),
            bookmark: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListWorkflowsRequest`
pub mod list_workflows_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListWorkflowsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_id)
        SortById(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListWorkflowsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostWorkflowsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowsRequest)
pub struct PostWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowsRequest.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowsRequest {
    fn default() -> &'a PostWorkflowsRequest {
        <PostWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowsRequest {
    pub fn new() -> PostWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowsRequest| { &m.user_app_id },
            |m: &mut PostWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &PostWorkflowsRequest| { &m.workflows },
            |m: &mut PostWorkflowsRequest| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowsRequest>(
            "PostWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowsRequest {
    const NAME: &'static str = "PostWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowsRequest {
        PostWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowsRequest {
        static instance: PostWorkflowsRequest = PostWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowsRequest)
pub struct PatchWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowsRequest {
    fn default() -> &'a PatchWorkflowsRequest {
        <PatchWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowsRequest {
    pub fn new() -> PatchWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &PatchWorkflowsRequest| { &m.workflows },
            |m: &mut PatchWorkflowsRequest| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowsRequest| { &m.action },
            |m: &mut PatchWorkflowsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowsRequest>(
            "PatchWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowsRequest {
    const NAME: &'static str = "PatchWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowsRequest {
        PatchWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowsRequest {
        static instance: PatchWorkflowsRequest = PatchWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowIdsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowIdsRequest)
pub struct PatchWorkflowIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowIdsRequest {
    fn default() -> &'a PatchWorkflowIdsRequest {
        <PatchWorkflowIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowIdsRequest {
    pub fn new() -> PatchWorkflowIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowIdsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchWorkflowIdsRequest| { &m.ids },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowIdsRequest| { &m.action },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowIdsRequest>(
            "PatchWorkflowIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowIdsRequest {
    const NAME: &'static str = "PatchWorkflowIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowIdsRequest {
        PatchWorkflowIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowIdsRequest {
        static instance: PatchWorkflowIdsRequest = PatchWorkflowIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteWorkflowRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowRequest)
pub struct DeleteWorkflowRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowRequest {
    fn default() -> &'a DeleteWorkflowRequest {
        <DeleteWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowRequest {
    pub fn new() -> DeleteWorkflowRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &DeleteWorkflowRequest| { &m.workflow_id },
            |m: &mut DeleteWorkflowRequest| { &mut m.workflow_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowRequest>(
            "DeleteWorkflowRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowRequest {
    const NAME: &'static str = "DeleteWorkflowRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowRequest {
        DeleteWorkflowRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowRequest {
        static instance: DeleteWorkflowRequest = DeleteWorkflowRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowsRequest)
pub struct DeleteWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowsRequest {
    fn default() -> &'a DeleteWorkflowsRequest {
        <DeleteWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowsRequest {
    pub fn new() -> DeleteWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowsRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteWorkflowsRequest| { &m.ids },
            |m: &mut DeleteWorkflowsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteWorkflowsRequest| { &m.delete_all },
            |m: &mut DeleteWorkflowsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowsRequest>(
            "DeleteWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowsRequest {
    const NAME: &'static str = "DeleteWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowsRequest {
        DeleteWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowsRequest {
        static instance: DeleteWorkflowsRequest = DeleteWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleWorkflowResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleWorkflowResponse)
pub struct SingleWorkflowResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowResponse.workflow)
    pub workflow: ::protobuf::MessageField<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleWorkflowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowResponse {
    fn default() -> &'a SingleWorkflowResponse {
        <SingleWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowResponse {
    pub fn new() -> SingleWorkflowResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleWorkflowResponse| { &m.status },
            |m: &mut SingleWorkflowResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Workflow>(
            "workflow",
            |m: &SingleWorkflowResponse| { &m.workflow },
            |m: &mut SingleWorkflowResponse| { &mut m.workflow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleWorkflowResponse>(
            "SingleWorkflowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleWorkflowResponse {
    const NAME: &'static str = "SingleWorkflowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleWorkflowResponse {
        SingleWorkflowResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleWorkflowResponse {
        static instance: SingleWorkflowResponse = SingleWorkflowResponse {
            status: ::protobuf::MessageField::none(),
            workflow: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleWorkflowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleWorkflowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkflowResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiWorkflowResponse)
pub struct MultiWorkflowResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowResponse.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkflowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowResponse {
    fn default() -> &'a MultiWorkflowResponse {
        <MultiWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowResponse {
    pub fn new() -> MultiWorkflowResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkflowResponse| { &m.status },
            |m: &mut MultiWorkflowResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &MultiWorkflowResponse| { &m.workflows },
            |m: &mut MultiWorkflowResponse| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkflowResponse>(
            "MultiWorkflowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkflowResponse {
    const NAME: &'static str = "MultiWorkflowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkflowResponse {
        MultiWorkflowResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkflowResponse {
        static instance: MultiWorkflowResponse = MultiWorkflowResponse {
            status: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkflowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkflowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsRequest)
pub struct PostWorkflowResultsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Workflow ID to retrieve
    ///  If no ID is specified we return default workflow of the application
    ///  If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Workflow version ID to retrieve
    ///  If no ID is specified, latest workflow version is used
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
    ///  to be within models. This is not consistent with setting this on the request for post model
    ///  outputs where it is inside a model object. To make this consistent we would send in the
    ///  workflow object so that each model can have it's own output config. If nobody is setting
    ///  this OutputConfig it would probably be easier to just remove it for now to keep things simpler
    ///  and then it's more consistent we just don't support the OutputConfig on workflows.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.output_config)
    pub output_config: ::protobuf::MessageField<super::resources::OutputConfig>,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    ///  A workflow state to be maintained across PostWorkflowResults requests/responses.
    ///  If it is not sent in the initial request with workflow_state.id = "init" then no
    ///  state will be saved or returned in PostWorkflowResultsResponse.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.workflow_state)
    pub workflow_state: ::protobuf::MessageField<super::resources::WorkflowState>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsRequest {
    fn default() -> &'a PostWorkflowResultsRequest {
        <PostWorkflowResultsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsRequest {
    pub fn new() -> PostWorkflowResultsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowResultsRequest| { &m.user_app_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowResultsRequest| { &m.workflow_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostWorkflowResultsRequest| { &m.version_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostWorkflowResultsRequest| { &m.inputs },
            |m: &mut PostWorkflowResultsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::OutputConfig>(
            "output_config",
            |m: &PostWorkflowResultsRequest| { &m.output_config },
            |m: &mut PostWorkflowResultsRequest| { &mut m.output_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &PostWorkflowResultsRequest| { &m.favor_clarifai_workflows },
            |m: &mut PostWorkflowResultsRequest| { &mut m.favor_clarifai_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowState>(
            "workflow_state",
            |m: &PostWorkflowResultsRequest| { &m.workflow_state },
            |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsRequest>(
            "PostWorkflowResultsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsRequest {
    const NAME: &'static str = "PostWorkflowResultsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                58 => {
                    self.version_id = is.read_string()?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_config)?;
                },
                40 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.output_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(5, self.favor_clarifai_workflows)?;
        }
        if let Some(v) = self.workflow_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsRequest {
        PostWorkflowResultsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.output_config.clear();
        self.favor_clarifai_workflows = false;
        self.workflow_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsRequest {
        static instance: PostWorkflowResultsRequest = PostWorkflowResultsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            output_config: ::protobuf::MessageField::none(),
            favor_clarifai_workflows: false,
            workflow_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsResponse)
pub struct PostWorkflowResultsResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The workflow that was used in predictions with PostWorkflowResults
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.workflow)
    pub workflow: ::protobuf::MessageField<super::resources::Workflow>,
    ///  The resulting predictions of all models in the workflow.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.results)
    pub results: ::std::vec::Vec<super::resources::WorkflowResult>,
    ///  A workflow state to be maintained across PostWorkflowResults requests/responses.
    ///  This WorkflowState should be passed in to subsequent PostWorkflowResults calls
    ///  if you want to keep track of state across requests.
    ///  If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
    ///  response.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.workflow_state)
    pub workflow_state: ::protobuf::MessageField<super::resources::WorkflowState>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsResponse {
    fn default() -> &'a PostWorkflowResultsResponse {
        <PostWorkflowResultsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsResponse {
    pub fn new() -> PostWorkflowResultsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostWorkflowResultsResponse| { &m.status },
            |m: &mut PostWorkflowResultsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Workflow>(
            "workflow",
            |m: &PostWorkflowResultsResponse| { &m.workflow },
            |m: &mut PostWorkflowResultsResponse| { &mut m.workflow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PostWorkflowResultsResponse| { &m.results },
            |m: &mut PostWorkflowResultsResponse| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowState>(
            "workflow_state",
            |m: &PostWorkflowResultsResponse| { &m.workflow_state },
            |m: &mut PostWorkflowResultsResponse| { &mut m.workflow_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsResponse>(
            "PostWorkflowResultsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsResponse {
    const NAME: &'static str = "PostWorkflowResultsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow)?;
                },
                26 => {
                    self.results.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.workflow_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsResponse {
        PostWorkflowResultsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.results.clear();
        self.workflow_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsResponse {
        static instance: PostWorkflowResultsResponse = PostWorkflowResultsResponse {
            status: ::protobuf::MessageField::none(),
            workflow: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            workflow_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsSimilarityRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsSimilarityRequest)
pub struct PostWorkflowResultsSimilarityRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Workflow version ID to retrieve
    ///  If no ID is specified, latest workflow version is used
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.version_id)
    pub version_id: ::std::string::String,
    ///  The specific model version whose outputs we are comparing
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Each probe is compared against every pool input
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.probe_inputs)
    pub probe_inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Each pool input is compared against ever probe input
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.pool_inputs)
    pub pool_inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsSimilarityRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityRequest {
    fn default() -> &'a PostWorkflowResultsSimilarityRequest {
        <PostWorkflowResultsSimilarityRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityRequest {
    pub fn new() -> PostWorkflowResultsSimilarityRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.user_app_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.workflow_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.version_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.model_version_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "probe_inputs",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.probe_inputs },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.probe_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pool_inputs",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.pool_inputs },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.pool_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.favor_clarifai_workflows },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.favor_clarifai_workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsSimilarityRequest>(
            "PostWorkflowResultsSimilarityRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityRequest {
    const NAME: &'static str = "PostWorkflowResultsSimilarityRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                58 => {
                    self.version_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.probe_inputs.push(is.read_message()?);
                },
                42 => {
                    self.pool_inputs.push(is.read_message()?);
                },
                48 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.probe_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pool_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.probe_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.pool_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.favor_clarifai_workflows != false {
            os.write_bool(6, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsSimilarityRequest {
        PostWorkflowResultsSimilarityRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.model_version_id.clear();
        self.probe_inputs.clear();
        self.pool_inputs.clear();
        self.favor_clarifai_workflows = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityRequest {
        static instance: PostWorkflowResultsSimilarityRequest = PostWorkflowResultsSimilarityRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            probe_inputs: ::std::vec::Vec::new(),
            pool_inputs: ::std::vec::Vec::new(),
            favor_clarifai_workflows: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsSimilarityRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsSimilarityRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsSimilarityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsSimilarityResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsSimilarityResponse)
pub struct PostWorkflowResultsSimilarityResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityResponse.results)
    pub results: ::std::vec::Vec<super::resources::WorkflowResultsSimilarity>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsSimilarityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityResponse {
    fn default() -> &'a PostWorkflowResultsSimilarityResponse {
        <PostWorkflowResultsSimilarityResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityResponse {
    pub fn new() -> PostWorkflowResultsSimilarityResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostWorkflowResultsSimilarityResponse| { &m.status },
            |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PostWorkflowResultsSimilarityResponse| { &m.results },
            |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsSimilarityResponse>(
            "PostWorkflowResultsSimilarityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityResponse {
    const NAME: &'static str = "PostWorkflowResultsSimilarityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsSimilarityResponse {
        PostWorkflowResultsSimilarityResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityResponse {
        static instance: PostWorkflowResultsSimilarityResponse = PostWorkflowResultsSimilarityResponse {
            status: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsSimilarityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsSimilarityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsSimilarityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListWorkflowVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListWorkflowVersionsRequest)
pub struct ListWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List versions for the workflow identified by this id
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListWorkflowVersionsRequest {
    fn default() -> &'a ListWorkflowVersionsRequest {
        <ListWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowVersionsRequest {
    pub fn new() -> ListWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &ListWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListWorkflowVersionsRequest| { &m.page },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListWorkflowVersionsRequest| { &m.per_page },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListWorkflowVersionsRequest>(
            "ListWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListWorkflowVersionsRequest {
    const NAME: &'static str = "ListWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListWorkflowVersionsRequest {
        ListWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListWorkflowVersionsRequest {
        static instance: ListWorkflowVersionsRequest = ListWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetWorkflowVersionRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetWorkflowVersionRequest)
pub struct GetWorkflowVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested version.
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Get the identified by this id
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.workflow_version_id)
    pub workflow_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetWorkflowVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWorkflowVersionRequest {
    fn default() -> &'a GetWorkflowVersionRequest {
        <GetWorkflowVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowVersionRequest {
    pub fn new() -> GetWorkflowVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetWorkflowVersionRequest| { &m.user_app_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &GetWorkflowVersionRequest| { &m.workflow_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_version_id",
            |m: &GetWorkflowVersionRequest| { &m.workflow_version_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetWorkflowVersionRequest>(
            "GetWorkflowVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetWorkflowVersionRequest {
    const NAME: &'static str = "GetWorkflowVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.workflow_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.workflow_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.workflow_version_id.is_empty() {
            os.write_string(3, &self.workflow_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWorkflowVersionRequest {
        GetWorkflowVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWorkflowVersionRequest {
        static instance: GetWorkflowVersionRequest = GetWorkflowVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetWorkflowVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetWorkflowVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetWorkflowVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteWorkflowVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowVersionsRequest)
pub struct DeleteWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested versions to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Delete the versions identified by these ids
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.workflow_version_ids)
    pub workflow_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowVersionsRequest {
    fn default() -> &'a DeleteWorkflowVersionsRequest {
        <DeleteWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowVersionsRequest {
    pub fn new() -> DeleteWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &DeleteWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_version_ids",
            |m: &DeleteWorkflowVersionsRequest| { &m.workflow_version_ids },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowVersionsRequest>(
            "DeleteWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowVersionsRequest {
    const NAME: &'static str = "DeleteWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowVersionsRequest {
        DeleteWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowVersionsRequest {
        static instance: DeleteWorkflowVersionsRequest = DeleteWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowVersionsRequest)
pub struct PatchWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested versions to patch.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Patch these versions.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.workflow_versions)
    pub workflow_versions: ::std::vec::Vec<super::resources::WorkflowVersion>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowVersionsRequest {
    fn default() -> &'a PatchWorkflowVersionsRequest {
        <PatchWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowVersionsRequest {
    pub fn new() -> PatchWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PatchWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_versions",
            |m: &PatchWorkflowVersionsRequest| { &m.workflow_versions },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowVersionsRequest| { &m.action },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowVersionsRequest>(
            "PatchWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowVersionsRequest {
    const NAME: &'static str = "PatchWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowVersionsRequest {
        PatchWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowVersionsRequest {
        static instance: PatchWorkflowVersionsRequest = PatchWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkflowVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiWorkflowVersionResponse)
pub struct MultiWorkflowVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowVersionResponse.workflow_versions)
    pub workflow_versions: ::std::vec::Vec<super::resources::WorkflowVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkflowVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowVersionResponse {
    fn default() -> &'a MultiWorkflowVersionResponse {
        <MultiWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowVersionResponse {
    pub fn new() -> MultiWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkflowVersionResponse| { &m.status },
            |m: &mut MultiWorkflowVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_versions",
            |m: &MultiWorkflowVersionResponse| { &m.workflow_versions },
            |m: &mut MultiWorkflowVersionResponse| { &mut m.workflow_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkflowVersionResponse>(
            "MultiWorkflowVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkflowVersionResponse {
    const NAME: &'static str = "MultiWorkflowVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workflow_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflow_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkflowVersionResponse {
        MultiWorkflowVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkflowVersionResponse {
        static instance: MultiWorkflowVersionResponse = MultiWorkflowVersionResponse {
            status: ::protobuf::MessageField::none(),
            workflow_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkflowVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkflowVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleWorkflowVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleWorkflowVersionResponse)
pub struct SingleWorkflowVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowVersionResponse.workflow_version)
    pub workflow_version: ::protobuf::MessageField<super::resources::WorkflowVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleWorkflowVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowVersionResponse {
    fn default() -> &'a SingleWorkflowVersionResponse {
        <SingleWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowVersionResponse {
    pub fn new() -> SingleWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleWorkflowVersionResponse| { &m.status },
            |m: &mut SingleWorkflowVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowVersion>(
            "workflow_version",
            |m: &SingleWorkflowVersionResponse| { &m.workflow_version },
            |m: &mut SingleWorkflowVersionResponse| { &mut m.workflow_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleWorkflowVersionResponse>(
            "SingleWorkflowVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleWorkflowVersionResponse {
    const NAME: &'static str = "SingleWorkflowVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleWorkflowVersionResponse {
        SingleWorkflowVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleWorkflowVersionResponse {
        static instance: SingleWorkflowVersionResponse = SingleWorkflowVersionResponse {
            status: ::protobuf::MessageField::none(),
            workflow_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleWorkflowVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleWorkflowVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Request to start a app duplication process
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostAppDuplicationsRequest)
pub struct PostAppDuplicationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppDuplicationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAppDuplicationsRequest.app_duplications)
    pub app_duplications: ::std::vec::Vec<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppDuplicationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppDuplicationsRequest {
    fn default() -> &'a PostAppDuplicationsRequest {
        <PostAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppDuplicationsRequest {
    pub fn new() -> PostAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppDuplicationsRequest| { &m.user_app_id },
            |m: &mut PostAppDuplicationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_duplications",
            |m: &PostAppDuplicationsRequest| { &m.app_duplications },
            |m: &mut PostAppDuplicationsRequest| { &mut m.app_duplications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppDuplicationsRequest>(
            "PostAppDuplicationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppDuplicationsRequest {
    const NAME: &'static str = "PostAppDuplicationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.app_duplications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.app_duplications {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppDuplicationsRequest {
        PostAppDuplicationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppDuplicationsRequest {
        static instance: PostAppDuplicationsRequest = PostAppDuplicationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_duplications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppDuplicationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppDuplicationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppDuplicationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Request to check app duplication status
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetAppDuplicationRequest)
pub struct GetAppDuplicationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAppDuplicationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    /// The app duplication id
    // @@protoc_insertion_point(field:clarifai.api.GetAppDuplicationRequest.app_duplication_id)
    pub app_duplication_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAppDuplicationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAppDuplicationRequest {
    fn default() -> &'a GetAppDuplicationRequest {
        <GetAppDuplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppDuplicationRequest {
    pub fn new() -> GetAppDuplicationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAppDuplicationRequest| { &m.user_app_id },
            |m: &mut GetAppDuplicationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_duplication_id",
            |m: &GetAppDuplicationRequest| { &m.app_duplication_id },
            |m: &mut GetAppDuplicationRequest| { &mut m.app_duplication_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAppDuplicationRequest>(
            "GetAppDuplicationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAppDuplicationRequest {
    const NAME: &'static str = "GetAppDuplicationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.app_duplication_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_duplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_duplication_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_duplication_id.is_empty() {
            os.write_string(2, &self.app_duplication_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAppDuplicationRequest {
        GetAppDuplicationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplication_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAppDuplicationRequest {
        static instance: GetAppDuplicationRequest = GetAppDuplicationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_duplication_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAppDuplicationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAppDuplicationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAppDuplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppDuplicationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Request to list all the app duplication that user triggered.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListAppDuplicationsRequest)
pub struct ListAppDuplicationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppDuplicationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppDuplicationsRequest {
    fn default() -> &'a ListAppDuplicationsRequest {
        <ListAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppDuplicationsRequest {
    pub fn new() -> ListAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppDuplicationsRequest| { &m.user_app_id },
            |m: &mut ListAppDuplicationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppDuplicationsRequest| { &m.page },
            |m: &mut ListAppDuplicationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppDuplicationsRequest| { &m.per_page },
            |m: &mut ListAppDuplicationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppDuplicationsRequest>(
            "ListAppDuplicationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppDuplicationsRequest {
    const NAME: &'static str = "ListAppDuplicationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppDuplicationsRequest {
        ListAppDuplicationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppDuplicationsRequest {
        static instance: ListAppDuplicationsRequest = ListAppDuplicationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppDuplicationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppDuplicationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppDuplicationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAppDuplicationsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiAppDuplicationsResponse)
pub struct MultiAppDuplicationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAppDuplicationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAppDuplicationsResponse.app_duplications)
    pub app_duplications: ::std::vec::Vec<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAppDuplicationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAppDuplicationsResponse {
    fn default() -> &'a MultiAppDuplicationsResponse {
        <MultiAppDuplicationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppDuplicationsResponse {
    pub fn new() -> MultiAppDuplicationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAppDuplicationsResponse| { &m.status },
            |m: &mut MultiAppDuplicationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_duplications",
            |m: &MultiAppDuplicationsResponse| { &m.app_duplications },
            |m: &mut MultiAppDuplicationsResponse| { &mut m.app_duplications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAppDuplicationsResponse>(
            "MultiAppDuplicationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAppDuplicationsResponse {
    const NAME: &'static str = "MultiAppDuplicationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.app_duplications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.app_duplications {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAppDuplicationsResponse {
        MultiAppDuplicationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_duplications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAppDuplicationsResponse {
        static instance: MultiAppDuplicationsResponse = MultiAppDuplicationsResponse {
            status: ::protobuf::MessageField::none(),
            app_duplications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAppDuplicationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAppDuplicationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAppDuplicationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppDuplicationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAppDuplicationResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleAppDuplicationResponse)
pub struct SingleAppDuplicationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAppDuplicationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAppDuplicationResponse.app_duplication)
    pub app_duplication: ::protobuf::MessageField<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAppDuplicationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAppDuplicationResponse {
    fn default() -> &'a SingleAppDuplicationResponse {
        <SingleAppDuplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppDuplicationResponse {
    pub fn new() -> SingleAppDuplicationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAppDuplicationResponse| { &m.status },
            |m: &mut SingleAppDuplicationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AppDuplication>(
            "app_duplication",
            |m: &SingleAppDuplicationResponse| { &m.app_duplication },
            |m: &mut SingleAppDuplicationResponse| { &mut m.app_duplication },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAppDuplicationResponse>(
            "SingleAppDuplicationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAppDuplicationResponse {
    const NAME: &'static str = "SingleAppDuplicationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_duplication)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_duplication.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_duplication.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAppDuplicationResponse {
        SingleAppDuplicationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_duplication.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAppDuplicationResponse {
        static instance: SingleAppDuplicationResponse = SingleAppDuplicationResponse {
            status: ::protobuf::MessageField::none(),
            app_duplication: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAppDuplicationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAppDuplicationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAppDuplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppDuplicationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create Tasks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostTasksRequest)
pub struct PostTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostTasksRequest.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostTasksRequest {
    fn default() -> &'a PostTasksRequest {
        <PostTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTasksRequest {
    pub fn new() -> PostTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostTasksRequest| { &m.user_app_id },
            |m: &mut PostTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &PostTasksRequest| { &m.tasks },
            |m: &mut PostTasksRequest| { &mut m.tasks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostTasksRequest>(
            "PostTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostTasksRequest {
    const NAME: &'static str = "PostTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostTasksRequest {
        PostTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostTasksRequest {
        static instance: PostTasksRequest = PostTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get one task.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetTaskRequest)
pub struct GetTaskRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.task_id)
    pub task_id: ::std::string::String,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported: all, worker.users, review.users.
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetTaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTaskRequest {
    fn default() -> &'a GetTaskRequest {
        <GetTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskRequest {
    pub fn new() -> GetTaskRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetTaskRequest| { &m.user_app_id },
            |m: &mut GetTaskRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetTaskRequest| { &m.task_id },
            |m: &mut GetTaskRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetTaskRequest| { &m.additional_fields },
            |m: &mut GetTaskRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTaskRequest>(
            "GetTaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTaskRequest {
    const NAME: &'static str = "GetTaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTaskRequest {
        GetTaskRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTaskRequest {
        static instance: GetTaskRequest = GetTaskRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list multiple tasks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListTasksRequest)
pub struct ListTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.per_page)
    pub per_page: u32,
    ///  Get tasks that have ANY user from this list assigned as worker.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.worker_user_ids)
    pub worker_user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get tasks that have ANY user from this list assigned as reviewer.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.review_user_ids)
    pub review_user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get tasks that are associated to ANY label order from this list.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.label_order_ids)
    pub label_order_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get label order tasks as well
    ///  It is automatically set to true if label_order_ids is set.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.including_label_order_tasks)
    pub including_label_order_tasks: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported: all, worker.users, review.users.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTasksRequest {
    fn default() -> &'a ListTasksRequest {
        <ListTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTasksRequest {
    pub fn new() -> ListTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListTasksRequest| { &m.user_app_id },
            |m: &mut ListTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListTasksRequest| { &m.page },
            |m: &mut ListTasksRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListTasksRequest| { &m.per_page },
            |m: &mut ListTasksRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "worker_user_ids",
            |m: &ListTasksRequest| { &m.worker_user_ids },
            |m: &mut ListTasksRequest| { &mut m.worker_user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "review_user_ids",
            |m: &ListTasksRequest| { &m.review_user_ids },
            |m: &mut ListTasksRequest| { &mut m.review_user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_order_ids",
            |m: &ListTasksRequest| { &m.label_order_ids },
            |m: &mut ListTasksRequest| { &mut m.label_order_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "including_label_order_tasks",
            |m: &ListTasksRequest| { &m.including_label_order_tasks },
            |m: &mut ListTasksRequest| { &mut m.including_label_order_tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListTasksRequest| { &m.additional_fields },
            |m: &mut ListTasksRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTasksRequest>(
            "ListTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTasksRequest {
    const NAME: &'static str = "ListTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.worker_user_ids.push(is.read_string()?);
                },
                42 => {
                    self.review_user_ids.push(is.read_string()?);
                },
                66 => {
                    self.label_order_ids.push(is.read_string()?);
                },
                48 => {
                    self.including_label_order_tasks = is.read_bool()?;
                },
                58 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.worker_user_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.review_user_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.label_order_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.including_label_order_tasks != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.worker_user_ids {
            os.write_string(4, &v)?;
        };
        for v in &self.review_user_ids {
            os.write_string(5, &v)?;
        };
        for v in &self.label_order_ids {
            os.write_string(8, &v)?;
        };
        if self.including_label_order_tasks != false {
            os.write_bool(6, self.including_label_order_tasks)?;
        }
        for v in &self.additional_fields {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTasksRequest {
        ListTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.worker_user_ids.clear();
        self.review_user_ids.clear();
        self.label_order_ids.clear();
        self.including_label_order_tasks = false;
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTasksRequest {
        static instance: ListTasksRequest = ListTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            worker_user_ids: ::std::vec::Vec::new(),
            review_user_ids: ::std::vec::Vec::new(),
            label_order_ids: ::std::vec::Vec::new(),
            including_label_order_tasks: false,
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch a list of tasks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchTasksRequest)
pub struct PatchTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchTasksRequest {
    fn default() -> &'a PatchTasksRequest {
        <PatchTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchTasksRequest {
    pub fn new() -> PatchTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchTasksRequest| { &m.user_app_id },
            |m: &mut PatchTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &PatchTasksRequest| { &m.tasks },
            |m: &mut PatchTasksRequest| { &mut m.tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchTasksRequest| { &m.action },
            |m: &mut PatchTasksRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchTasksRequest>(
            "PatchTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchTasksRequest {
    const NAME: &'static str = "PatchTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchTasksRequest {
        PatchTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchTasksRequest {
        static instance: PatchTasksRequest = PatchTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete a list of tasks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteTasksRequest)
pub struct DeleteTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteTasksRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTasksRequest {
    fn default() -> &'a DeleteTasksRequest {
        <DeleteTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTasksRequest {
    pub fn new() -> DeleteTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteTasksRequest| { &m.user_app_id },
            |m: &mut DeleteTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteTasksRequest| { &m.ids },
            |m: &mut DeleteTasksRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTasksRequest>(
            "DeleteTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTasksRequest {
    const NAME: &'static str = "DeleteTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTasksRequest {
        DeleteTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTasksRequest {
        static instance: DeleteTasksRequest = DeleteTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple Tasks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiTaskResponse)
pub struct MultiTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskResponse.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTaskResponse {
    fn default() -> &'a MultiTaskResponse {
        <MultiTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTaskResponse {
    pub fn new() -> MultiTaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTaskResponse| { &m.status },
            |m: &mut MultiTaskResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &MultiTaskResponse| { &m.tasks },
            |m: &mut MultiTaskResponse| { &mut m.tasks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTaskResponse>(
            "MultiTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTaskResponse {
    const NAME: &'static str = "MultiTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTaskResponse {
        MultiTaskResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.tasks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTaskResponse {
        static instance: MultiTaskResponse = MultiTaskResponse {
            status: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a single Task.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleTaskResponse)
pub struct SingleTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskResponse.task)
    pub task: ::protobuf::MessageField<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleTaskResponse {
    fn default() -> &'a SingleTaskResponse {
        <SingleTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskResponse {
    pub fn new() -> SingleTaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleTaskResponse| { &m.status },
            |m: &mut SingleTaskResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Task>(
            "task",
            |m: &SingleTaskResponse| { &m.task },
            |m: &mut SingleTaskResponse| { &mut m.task },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTaskResponse>(
            "SingleTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleTaskResponse {
    const NAME: &'static str = "SingleTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.task)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.task.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleTaskResponse {
        SingleTaskResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.task.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleTaskResponse {
        static instance: SingleTaskResponse = SingleTaskResponse {
            status: ::protobuf::MessageField::none(),
            task: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetTaskCountRequest can be used for fetching -
///  1. Task annotation count per user, per status
///  1. Task input (anchor annotations) count per user, per status
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetTaskCountRequest)
pub struct GetTaskCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  task_id for which count per user per status is needed
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.task_id)
    pub task_id: ::std::string::String,
    ///  for given task_id, user_ids to filter on (optional)
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetTaskCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTaskCountRequest {
    fn default() -> &'a GetTaskCountRequest {
        <GetTaskCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskCountRequest {
    pub fn new() -> GetTaskCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetTaskCountRequest| { &m.user_app_id },
            |m: &mut GetTaskCountRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetTaskCountRequest| { &m.task_id },
            |m: &mut GetTaskCountRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &GetTaskCountRequest| { &m.user_ids },
            |m: &mut GetTaskCountRequest| { &mut m.user_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTaskCountRequest>(
            "GetTaskCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTaskCountRequest {
    const NAME: &'static str = "GetTaskCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTaskCountRequest {
        GetTaskCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTaskCountRequest {
        static instance: GetTaskCountRequest = GetTaskCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            user_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTaskCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTaskCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTaskCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleTaskCountResponse represent counts of annotations or inputs(anchor annotations) for labelers in given task
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleTaskCountResponse)
pub struct SingleTaskCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.app_id)
    pub app_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.task_id)
    pub task_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.counts)
    pub counts: ::std::vec::Vec<super::resources::TaskStatusCountPerUser>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleTaskCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleTaskCountResponse {
    fn default() -> &'a SingleTaskCountResponse {
        <SingleTaskCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskCountResponse {
    pub fn new() -> SingleTaskCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleTaskCountResponse| { &m.status },
            |m: &mut SingleTaskCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &SingleTaskCountResponse| { &m.app_id },
            |m: &mut SingleTaskCountResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &SingleTaskCountResponse| { &m.task_id },
            |m: &mut SingleTaskCountResponse| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "counts",
            |m: &SingleTaskCountResponse| { &m.counts },
            |m: &mut SingleTaskCountResponse| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTaskCountResponse>(
            "SingleTaskCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleTaskCountResponse {
    const NAME: &'static str = "SingleTaskCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                26 => {
                    self.task_id = is.read_string()?;
                },
                34 => {
                    self.counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.task_id);
        }
        for value in &self.counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(3, &self.task_id)?;
        }
        for v in &self.counts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleTaskCountResponse {
        SingleTaskCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_id.clear();
        self.task_id.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleTaskCountResponse {
        static instance: SingleTaskCountResponse = SingleTaskCountResponse {
            status: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            task_id: ::std::string::String::new(),
            counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleTaskCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleTaskCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleTaskCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create label orders.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostLabelOrdersRequest)
pub struct PostLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostLabelOrdersRequest.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostLabelOrdersRequest {
    fn default() -> &'a PostLabelOrdersRequest {
        <PostLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostLabelOrdersRequest {
    pub fn new() -> PostLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostLabelOrdersRequest| { &m.user_app_id },
            |m: &mut PostLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &PostLabelOrdersRequest| { &m.label_orders },
            |m: &mut PostLabelOrdersRequest| { &mut m.label_orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostLabelOrdersRequest>(
            "PostLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostLabelOrdersRequest {
    const NAME: &'static str = "PostLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostLabelOrdersRequest {
        PostLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostLabelOrdersRequest {
        static instance: PostLabelOrdersRequest = PostLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get one label order.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetLabelOrderRequest)
pub struct GetLabelOrderRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetLabelOrderRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetLabelOrderRequest.label_order_id)
    pub label_order_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetLabelOrderRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLabelOrderRequest {
    fn default() -> &'a GetLabelOrderRequest {
        <GetLabelOrderRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLabelOrderRequest {
    pub fn new() -> GetLabelOrderRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetLabelOrderRequest| { &m.user_app_id },
            |m: &mut GetLabelOrderRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label_order_id",
            |m: &GetLabelOrderRequest| { &m.label_order_id },
            |m: &mut GetLabelOrderRequest| { &mut m.label_order_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLabelOrderRequest>(
            "GetLabelOrderRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLabelOrderRequest {
    const NAME: &'static str = "GetLabelOrderRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_order_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.label_order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label_order_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.label_order_id.is_empty() {
            os.write_string(2, &self.label_order_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLabelOrderRequest {
        GetLabelOrderRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_order_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLabelOrderRequest {
        static instance: GetLabelOrderRequest = GetLabelOrderRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_order_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLabelOrderRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLabelOrderRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLabelOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLabelOrderRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list multiple label orders.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListLabelOrdersRequest)
pub struct ListLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListLabelOrdersRequest {
    fn default() -> &'a ListLabelOrdersRequest {
        <ListLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListLabelOrdersRequest {
    pub fn new() -> ListLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListLabelOrdersRequest| { &m.user_app_id },
            |m: &mut ListLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListLabelOrdersRequest| { &m.page },
            |m: &mut ListLabelOrdersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListLabelOrdersRequest| { &m.per_page },
            |m: &mut ListLabelOrdersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListLabelOrdersRequest>(
            "ListLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListLabelOrdersRequest {
    const NAME: &'static str = "ListLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListLabelOrdersRequest {
        ListLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListLabelOrdersRequest {
        static instance: ListLabelOrdersRequest = ListLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch a list of label orders.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchLabelOrdersRequest)
pub struct PatchLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchLabelOrdersRequest {
    fn default() -> &'a PatchLabelOrdersRequest {
        <PatchLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchLabelOrdersRequest {
    pub fn new() -> PatchLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchLabelOrdersRequest| { &m.user_app_id },
            |m: &mut PatchLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &PatchLabelOrdersRequest| { &m.label_orders },
            |m: &mut PatchLabelOrdersRequest| { &mut m.label_orders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchLabelOrdersRequest| { &m.action },
            |m: &mut PatchLabelOrdersRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchLabelOrdersRequest>(
            "PatchLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchLabelOrdersRequest {
    const NAME: &'static str = "PatchLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchLabelOrdersRequest {
        PatchLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchLabelOrdersRequest {
        static instance: PatchLabelOrdersRequest = PatchLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete a list of label orders.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteLabelOrdersRequest)
pub struct DeleteLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteLabelOrdersRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteLabelOrdersRequest {
    fn default() -> &'a DeleteLabelOrdersRequest {
        <DeleteLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteLabelOrdersRequest {
    pub fn new() -> DeleteLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteLabelOrdersRequest| { &m.user_app_id },
            |m: &mut DeleteLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteLabelOrdersRequest| { &m.ids },
            |m: &mut DeleteLabelOrdersRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteLabelOrdersRequest>(
            "DeleteLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteLabelOrdersRequest {
    const NAME: &'static str = "DeleteLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteLabelOrdersRequest {
        DeleteLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteLabelOrdersRequest {
        static instance: DeleteLabelOrdersRequest = DeleteLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple label order.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiLabelOrderResponse)
pub struct MultiLabelOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiLabelOrderResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiLabelOrderResponse.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiLabelOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiLabelOrderResponse {
    fn default() -> &'a MultiLabelOrderResponse {
        <MultiLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiLabelOrderResponse {
    pub fn new() -> MultiLabelOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiLabelOrderResponse| { &m.status },
            |m: &mut MultiLabelOrderResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &MultiLabelOrderResponse| { &m.label_orders },
            |m: &mut MultiLabelOrderResponse| { &mut m.label_orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiLabelOrderResponse>(
            "MultiLabelOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiLabelOrderResponse {
    const NAME: &'static str = "MultiLabelOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiLabelOrderResponse {
        MultiLabelOrderResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.label_orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiLabelOrderResponse {
        static instance: MultiLabelOrderResponse = MultiLabelOrderResponse {
            status: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiLabelOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiLabelOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiLabelOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a label order.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleLabelOrderResponse)
pub struct SingleLabelOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleLabelOrderResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleLabelOrderResponse.label_order)
    pub label_order: ::protobuf::MessageField<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleLabelOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleLabelOrderResponse {
    fn default() -> &'a SingleLabelOrderResponse {
        <SingleLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleLabelOrderResponse {
    pub fn new() -> SingleLabelOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleLabelOrderResponse| { &m.status },
            |m: &mut SingleLabelOrderResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::LabelOrder>(
            "label_order",
            |m: &SingleLabelOrderResponse| { &m.label_order },
            |m: &mut SingleLabelOrderResponse| { &mut m.label_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleLabelOrderResponse>(
            "SingleLabelOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleLabelOrderResponse {
    const NAME: &'static str = "SingleLabelOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.label_order)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.label_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.label_order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleLabelOrderResponse {
        SingleLabelOrderResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.label_order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleLabelOrderResponse {
        static instance: SingleLabelOrderResponse = SingleLabelOrderResponse {
            status: ::protobuf::MessageField::none(),
            label_order: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleLabelOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleLabelOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleLabelOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create Collectors.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostCollectorsRequest)
pub struct PostCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostCollectorsRequest.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCollectorsRequest {
    fn default() -> &'a PostCollectorsRequest {
        <PostCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollectorsRequest {
    pub fn new() -> PostCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostCollectorsRequest| { &m.user_app_id },
            |m: &mut PostCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &PostCollectorsRequest| { &m.collectors },
            |m: &mut PostCollectorsRequest| { &mut m.collectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCollectorsRequest>(
            "PostCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCollectorsRequest {
    const NAME: &'static str = "PostCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCollectorsRequest {
        PostCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCollectorsRequest {
        static instance: PostCollectorsRequest = PostCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchCollectorsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchCollectorsRequest)
pub struct PatchCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchCollectorsRequest {
    fn default() -> &'a PatchCollectorsRequest {
        <PatchCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollectorsRequest {
    pub fn new() -> PatchCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchCollectorsRequest| { &m.user_app_id },
            |m: &mut PatchCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &PatchCollectorsRequest| { &m.collectors },
            |m: &mut PatchCollectorsRequest| { &mut m.collectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchCollectorsRequest| { &m.action },
            |m: &mut PatchCollectorsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchCollectorsRequest>(
            "PatchCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchCollectorsRequest {
    const NAME: &'static str = "PatchCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchCollectorsRequest {
        PatchCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchCollectorsRequest {
        static instance: PatchCollectorsRequest = PatchCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteCollectorsRequest)
pub struct DeleteCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollectorsRequest {
    fn default() -> &'a DeleteCollectorsRequest {
        <DeleteCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectorsRequest {
    pub fn new() -> DeleteCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteCollectorsRequest| { &m.user_app_id },
            |m: &mut DeleteCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteCollectorsRequest| { &m.ids },
            |m: &mut DeleteCollectorsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteCollectorsRequest| { &m.delete_all },
            |m: &mut DeleteCollectorsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollectorsRequest>(
            "DeleteCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollectorsRequest {
    const NAME: &'static str = "DeleteCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollectorsRequest {
        DeleteCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollectorsRequest {
        static instance: DeleteCollectorsRequest = DeleteCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to GET a single Collector.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetCollectorRequest)
pub struct GetCollectorRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetCollectorRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    /// The collecgtor id
    // @@protoc_insertion_point(field:clarifai.api.GetCollectorRequest.collector_id)
    pub collector_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetCollectorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCollectorRequest {
    fn default() -> &'a GetCollectorRequest {
        <GetCollectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCollectorRequest {
    pub fn new() -> GetCollectorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetCollectorRequest| { &m.user_app_id },
            |m: &mut GetCollectorRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collector_id",
            |m: &GetCollectorRequest| { &m.collector_id },
            |m: &mut GetCollectorRequest| { &mut m.collector_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCollectorRequest>(
            "GetCollectorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCollectorRequest {
    const NAME: &'static str = "GetCollectorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collector_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.collector_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collector_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.collector_id.is_empty() {
            os.write_string(2, &self.collector_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCollectorRequest {
        GetCollectorRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collector_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCollectorRequest {
        static instance: GetCollectorRequest = GetCollectorRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collector_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCollectorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCollectorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCollectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCollectorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to GET all the Collectors.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListCollectorsRequest)
pub struct ListCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollectorsRequest {
    fn default() -> &'a ListCollectorsRequest {
        <ListCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollectorsRequest {
    pub fn new() -> ListCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollectorsRequest| { &m.user_app_id },
            |m: &mut ListCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollectorsRequest| { &m.page },
            |m: &mut ListCollectorsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollectorsRequest| { &m.per_page },
            |m: &mut ListCollectorsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollectorsRequest>(
            "ListCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollectorsRequest {
    const NAME: &'static str = "ListCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollectorsRequest {
        ListCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollectorsRequest {
        static instance: ListCollectorsRequest = ListCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple Collectors.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiCollectorResponse)
pub struct MultiCollectorResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollectorResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollectorResponse.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollectorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollectorResponse {
    fn default() -> &'a MultiCollectorResponse {
        <MultiCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollectorResponse {
    pub fn new() -> MultiCollectorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollectorResponse| { &m.status },
            |m: &mut MultiCollectorResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &MultiCollectorResponse| { &m.collectors },
            |m: &mut MultiCollectorResponse| { &mut m.collectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollectorResponse>(
            "MultiCollectorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollectorResponse {
    const NAME: &'static str = "MultiCollectorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollectorResponse {
        MultiCollectorResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollectorResponse {
        static instance: MultiCollectorResponse = MultiCollectorResponse {
            status: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollectorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollectorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollectorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a single Collector.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleCollectorResponse)
pub struct SingleCollectorResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleCollectorResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleCollectorResponse.collector)
    pub collector: ::protobuf::MessageField<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleCollectorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleCollectorResponse {
    fn default() -> &'a SingleCollectorResponse {
        <SingleCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleCollectorResponse {
    pub fn new() -> SingleCollectorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleCollectorResponse| { &m.status },
            |m: &mut SingleCollectorResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Collector>(
            "collector",
            |m: &SingleCollectorResponse| { &m.collector },
            |m: &mut SingleCollectorResponse| { &mut m.collector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleCollectorResponse>(
            "SingleCollectorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleCollectorResponse {
    const NAME: &'static str = "SingleCollectorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.collector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.collector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.collector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleCollectorResponse {
        SingleCollectorResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleCollectorResponse {
        static instance: SingleCollectorResponse = SingleCollectorResponse {
            status: ::protobuf::MessageField::none(),
            collector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleCollectorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleCollectorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleCollectorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostStatValuesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostStatValuesRequest)
pub struct PostStatValuesRequest {
    // message fields
    ///  The user and app information for the request.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The stats to post, can post more than one at a time.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesRequest.stat_values)
    pub stat_values: ::std::vec::Vec<super::resources::StatValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostStatValuesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostStatValuesRequest {
    fn default() -> &'a PostStatValuesRequest {
        <PostStatValuesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesRequest {
    pub fn new() -> PostStatValuesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostStatValuesRequest| { &m.user_app_id },
            |m: &mut PostStatValuesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_values",
            |m: &PostStatValuesRequest| { &m.stat_values },
            |m: &mut PostStatValuesRequest| { &mut m.stat_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostStatValuesRequest>(
            "PostStatValuesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostStatValuesRequest {
    const NAME: &'static str = "PostStatValuesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.stat_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostStatValuesRequest {
        PostStatValuesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostStatValuesRequest {
        static instance: PostStatValuesRequest = PostStatValuesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            stat_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostStatValuesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostStatValuesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostStatValuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatValueResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiStatValueResponse)
pub struct MultiStatValueResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned stats values.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueResponse.stat_values)
    pub stat_values: ::std::vec::Vec<super::resources::StatValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatValueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatValueResponse {
    fn default() -> &'a MultiStatValueResponse {
        <MultiStatValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueResponse {
    pub fn new() -> MultiStatValueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatValueResponse| { &m.status },
            |m: &mut MultiStatValueResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_values",
            |m: &MultiStatValueResponse| { &m.stat_values },
            |m: &mut MultiStatValueResponse| { &mut m.stat_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatValueResponse>(
            "MultiStatValueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatValueResponse {
    const NAME: &'static str = "MultiStatValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.stat_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatValueResponse {
        MultiStatValueResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.stat_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatValueResponse {
        static instance: MultiStatValueResponse = MultiStatValueResponse {
            status: ::protobuf::MessageField::none(),
            stat_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatValueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatValueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostStatValuesAggregateRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostStatValuesAggregateRequest)
pub struct PostStatValuesAggregateRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesAggregateRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Query to retrieve aggregate values.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesAggregateRequest.stat_value_aggregate_queries)
    pub stat_value_aggregate_queries: ::std::vec::Vec<super::resources::StatValueAggregateQuery>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostStatValuesAggregateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostStatValuesAggregateRequest {
    fn default() -> &'a PostStatValuesAggregateRequest {
        <PostStatValuesAggregateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesAggregateRequest {
    pub fn new() -> PostStatValuesAggregateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostStatValuesAggregateRequest| { &m.user_app_id },
            |m: &mut PostStatValuesAggregateRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregate_queries",
            |m: &PostStatValuesAggregateRequest| { &m.stat_value_aggregate_queries },
            |m: &mut PostStatValuesAggregateRequest| { &mut m.stat_value_aggregate_queries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostStatValuesAggregateRequest>(
            "PostStatValuesAggregateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostStatValuesAggregateRequest {
    const NAME: &'static str = "PostStatValuesAggregateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.stat_value_aggregate_queries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_value_aggregate_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_value_aggregate_queries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostStatValuesAggregateRequest {
        PostStatValuesAggregateRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_value_aggregate_queries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostStatValuesAggregateRequest {
        static instance: PostStatValuesAggregateRequest = PostStatValuesAggregateRequest {
            user_app_id: ::protobuf::MessageField::none(),
            stat_value_aggregate_queries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostStatValuesAggregateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostStatValuesAggregateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostStatValuesAggregateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesAggregateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatValueAggregateResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiStatValueAggregateResponse)
pub struct MultiStatValueAggregateResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueAggregateResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The aggregate results for each query passedin.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueAggregateResponse.stat_value_aggregate_results)
    pub stat_value_aggregate_results: ::std::vec::Vec<super::resources::StatValueAggregateResult>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatValueAggregateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatValueAggregateResponse {
    fn default() -> &'a MultiStatValueAggregateResponse {
        <MultiStatValueAggregateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueAggregateResponse {
    pub fn new() -> MultiStatValueAggregateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatValueAggregateResponse| { &m.status },
            |m: &mut MultiStatValueAggregateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregate_results",
            |m: &MultiStatValueAggregateResponse| { &m.stat_value_aggregate_results },
            |m: &mut MultiStatValueAggregateResponse| { &mut m.stat_value_aggregate_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatValueAggregateResponse>(
            "MultiStatValueAggregateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatValueAggregateResponse {
    const NAME: &'static str = "MultiStatValueAggregateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.stat_value_aggregate_results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_value_aggregate_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_value_aggregate_results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatValueAggregateResponse {
        MultiStatValueAggregateResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.stat_value_aggregate_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatValueAggregateResponse {
        static instance: MultiStatValueAggregateResponse = MultiStatValueAggregateResponse {
            status: ::protobuf::MessageField::none(),
            stat_value_aggregate_results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatValueAggregateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatValueAggregateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatValueAggregateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueAggregateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostTrendingMetricsViewRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostTrendingMetricsViewRequest)
pub struct PostTrendingMetricsViewRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  For now view types 'apps', 'workflows', and 'models' are supported.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.view_type)
    pub view_type: ::std::string::String,
    ///  ID of the views object.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.object_id)
    pub object_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostTrendingMetricsViewRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostTrendingMetricsViewRequest {
    fn default() -> &'a PostTrendingMetricsViewRequest {
        <PostTrendingMetricsViewRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTrendingMetricsViewRequest {
    pub fn new() -> PostTrendingMetricsViewRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostTrendingMetricsViewRequest| { &m.user_app_id },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_type",
            |m: &PostTrendingMetricsViewRequest| { &m.view_type },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.view_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &PostTrendingMetricsViewRequest| { &m.object_id },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.object_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostTrendingMetricsViewRequest>(
            "PostTrendingMetricsViewRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostTrendingMetricsViewRequest {
    const NAME: &'static str = "PostTrendingMetricsViewRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.view_type = is.read_string()?;
                },
                26 => {
                    self.object_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if !self.object_id.is_empty() {
            os.write_string(3, &self.object_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostTrendingMetricsViewRequest {
        PostTrendingMetricsViewRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.object_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostTrendingMetricsViewRequest {
        static instance: PostTrendingMetricsViewRequest = PostTrendingMetricsViewRequest {
            user_app_id: ::protobuf::MessageField::none(),
            view_type: ::std::string::String::new(),
            object_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostTrendingMetricsViewRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostTrendingMetricsViewRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostTrendingMetricsViewRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTrendingMetricsViewRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListTrendingMetricsViewsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListTrendingMetricsViewsRequest)
pub struct ListTrendingMetricsViewsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  For now view types 'apps', 'workflows', and 'models' are supported.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.view_type)
    pub view_type: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListTrendingMetricsViewsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTrendingMetricsViewsRequest {
    fn default() -> &'a ListTrendingMetricsViewsRequest {
        <ListTrendingMetricsViewsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTrendingMetricsViewsRequest {
    pub fn new() -> ListTrendingMetricsViewsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListTrendingMetricsViewsRequest| { &m.user_app_id },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_type",
            |m: &ListTrendingMetricsViewsRequest| { &m.view_type },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.view_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListTrendingMetricsViewsRequest| { &m.page },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListTrendingMetricsViewsRequest| { &m.per_page },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTrendingMetricsViewsRequest>(
            "ListTrendingMetricsViewsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTrendingMetricsViewsRequest {
    const NAME: &'static str = "ListTrendingMetricsViewsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.view_type = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTrendingMetricsViewsRequest {
        ListTrendingMetricsViewsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTrendingMetricsViewsRequest {
        static instance: ListTrendingMetricsViewsRequest = ListTrendingMetricsViewsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            view_type: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTrendingMetricsViewsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTrendingMetricsViewsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTrendingMetricsViewsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTrendingMetricsViewsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiTrendingMetricsViewResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiTrendingMetricsViewResponse)
pub struct MultiTrendingMetricsViewResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTrendingMetricsViewResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTrendingMetricsViewResponse.metrics)
    pub metrics: ::std::vec::Vec<super::resources::TrendingMetric>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTrendingMetricsViewResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTrendingMetricsViewResponse {
    fn default() -> &'a MultiTrendingMetricsViewResponse {
        <MultiTrendingMetricsViewResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTrendingMetricsViewResponse {
    pub fn new() -> MultiTrendingMetricsViewResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTrendingMetricsViewResponse| { &m.status },
            |m: &mut MultiTrendingMetricsViewResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &MultiTrendingMetricsViewResponse| { &m.metrics },
            |m: &mut MultiTrendingMetricsViewResponse| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTrendingMetricsViewResponse>(
            "MultiTrendingMetricsViewResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTrendingMetricsViewResponse {
    const NAME: &'static str = "MultiTrendingMetricsViewResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTrendingMetricsViewResponse {
        MultiTrendingMetricsViewResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTrendingMetricsViewResponse {
        static instance: MultiTrendingMetricsViewResponse = MultiTrendingMetricsViewResponse {
            status: ::protobuf::MessageField::none(),
            metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTrendingMetricsViewResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTrendingMetricsViewResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTrendingMetricsViewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTrendingMetricsViewResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModuleRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModuleRequest)
pub struct GetModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleRequest {
    fn default() -> &'a GetModuleRequest {
        <GetModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleRequest {
    pub fn new() -> GetModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleRequest| { &m.user_app_id },
            |m: &mut GetModuleRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleRequest| { &m.module_id },
            |m: &mut GetModuleRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetModuleRequest| { &m.additional_fields },
            |m: &mut GetModuleRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleRequest>(
            "GetModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleRequest {
    const NAME: &'static str = "GetModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleRequest {
        GetModuleRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleRequest {
        static instance: GetModuleRequest = GetModuleRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModulesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModulesRequest)
pub struct ListModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.starred_only)
    pub starred_only: bool,
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting opitons:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filter modules by bookmark. If set, only return bookmarked modules. Otherwise none bookmarked modules only.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.bookmark)
    pub bookmark: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_modules_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesRequest {
    fn default() -> &'a ListModulesRequest {
        <ListModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesRequest {
    pub fn new() -> ListModulesRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_created_at = 7;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 8;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(v))
    }

    // bool sort_by_modified_at = 9;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_id = 11;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortById(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModulesRequest| { &m.user_app_id },
            |m: &mut ListModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModulesRequest| { &m.page },
            |m: &mut ListModulesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModulesRequest| { &m.per_page },
            |m: &mut ListModulesRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListModulesRequest| { &m.starred_only },
            |m: &mut ListModulesRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListModulesRequest| { &m.additional_fields },
            |m: &mut ListModulesRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModulesRequest| { &m.sort_ascending },
            |m: &mut ListModulesRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModulesRequest::has_sort_by_created_at,
            ListModulesRequest::sort_by_created_at,
            ListModulesRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListModulesRequest::has_sort_by_star_count,
            ListModulesRequest::sort_by_star_count,
            ListModulesRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListModulesRequest::has_sort_by_modified_at,
            ListModulesRequest::sort_by_modified_at,
            ListModulesRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListModulesRequest::has_sort_by_id,
            ListModulesRequest::sort_by_id,
            ListModulesRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListModulesRequest| { &m.bookmark },
            |m: &mut ListModulesRequest| { &mut m.bookmark },
        ));
        oneofs.push(list_modules_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesRequest>(
            "ListModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesRequest {
    const NAME: &'static str = "ListModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.starred_only = is.read_bool()?;
                },
                42 => {
                    self.additional_fields.push(is.read_string()?);
                },
                48 => {
                    self.sort_ascending = is.read_bool()?;
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortById(is.read_bool()?));
                },
                80 => {
                    self.bookmark = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_modules_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.starred_only != false {
            os.write_bool(4, self.starred_only)?;
        }
        for v in &self.additional_fields {
            os.write_string(5, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(6, self.sort_ascending)?;
        }
        if self.bookmark != false {
            os.write_bool(10, self.bookmark)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_modules_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_modules_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(8, v)?;
                },
                &list_modules_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(9, v)?;
                },
                &list_modules_request::Sort_by::SortById(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesRequest {
        ListModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.starred_only = false;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.bookmark = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesRequest {
        static instance: ListModulesRequest = ListModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            starred_only: false,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            bookmark: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModulesRequest`
pub mod list_modules_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModulesRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_star_count)
        SortByStarCount(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_id)
        SortById(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModulesRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostModulesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModulesRequest)
pub struct PostModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModulesRequest.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModulesRequest {
    fn default() -> &'a PostModulesRequest {
        <PostModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModulesRequest {
    pub fn new() -> PostModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModulesRequest| { &m.user_app_id },
            |m: &mut PostModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &PostModulesRequest| { &m.modules },
            |m: &mut PostModulesRequest| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModulesRequest>(
            "PostModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModulesRequest {
    const NAME: &'static str = "PostModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModulesRequest {
        PostModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModulesRequest {
        static instance: PostModulesRequest = PostModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModulesRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PatchModulesRequest)
pub struct PatchModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModulesRequest {
    fn default() -> &'a PatchModulesRequest {
        <PatchModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModulesRequest {
    pub fn new() -> PatchModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModulesRequest| { &m.user_app_id },
            |m: &mut PatchModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &PatchModulesRequest| { &m.modules },
            |m: &mut PatchModulesRequest| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModulesRequest| { &m.action },
            |m: &mut PatchModulesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModulesRequest>(
            "PatchModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModulesRequest {
    const NAME: &'static str = "PatchModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.modules.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModulesRequest {
        PatchModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.modules.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModulesRequest {
        static instance: PatchModulesRequest = PatchModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteModulesRequest)
pub struct DeleteModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModulesRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesRequest {
    fn default() -> &'a DeleteModulesRequest {
        <DeleteModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesRequest {
    pub fn new() -> DeleteModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModulesRequest| { &m.user_app_id },
            |m: &mut DeleteModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModulesRequest| { &m.ids },
            |m: &mut DeleteModulesRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesRequest>(
            "DeleteModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesRequest {
    const NAME: &'static str = "DeleteModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesRequest {
        DeleteModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesRequest {
        static instance: DeleteModulesRequest = DeleteModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleModuleResponse)
pub struct SingleModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleResponse.module)
    pub module: ::protobuf::MessageField<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleResponse {
    fn default() -> &'a SingleModuleResponse {
        <SingleModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleResponse {
    pub fn new() -> SingleModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleResponse| { &m.status },
            |m: &mut SingleModuleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Module>(
            "module",
            |m: &SingleModuleResponse| { &m.module },
            |m: &mut SingleModuleResponse| { &mut m.module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleResponse>(
            "SingleModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleResponse {
    const NAME: &'static str = "SingleModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleResponse {
        SingleModuleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleResponse {
        static instance: SingleModuleResponse = SingleModuleResponse {
            status: ::protobuf::MessageField::none(),
            module: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModuleResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModuleResponse)
pub struct MultiModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleResponse.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModuleResponse {
    fn default() -> &'a MultiModuleResponse {
        <MultiModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModuleResponse {
    pub fn new() -> MultiModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModuleResponse| { &m.status },
            |m: &mut MultiModuleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &MultiModuleResponse| { &m.modules },
            |m: &mut MultiModuleResponse| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModuleResponse>(
            "MultiModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModuleResponse {
    const NAME: &'static str = "MultiModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModuleResponse {
        MultiModuleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModuleResponse {
        static instance: MultiModuleResponse = MultiModuleResponse {
            status: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  request for different endpoints currently.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetModuleVersionRequest)
pub struct GetModuleVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.module_version_id)
    pub module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleVersionRequest {
    fn default() -> &'a GetModuleVersionRequest {
        <GetModuleVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleVersionRequest {
    pub fn new() -> GetModuleVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleVersionRequest| { &m.user_app_id },
            |m: &mut GetModuleVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleVersionRequest| { &m.module_id },
            |m: &mut GetModuleVersionRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_version_id",
            |m: &GetModuleVersionRequest| { &m.module_version_id },
            |m: &mut GetModuleVersionRequest| { &mut m.module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleVersionRequest>(
            "GetModuleVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleVersionRequest {
    const NAME: &'static str = "GetModuleVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if !self.module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if !self.module_version_id.is_empty() {
            os.write_string(3, &self.module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleVersionRequest {
        GetModuleVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleVersionRequest {
        static instance: GetModuleVersionRequest = GetModuleVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModuleVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListModuleVersionsRequest)
pub struct ListModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModuleVersionsRequest {
    fn default() -> &'a ListModuleVersionsRequest {
        <ListModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModuleVersionsRequest {
    pub fn new() -> ListModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModuleVersionsRequest| { &m.user_app_id },
            |m: &mut ListModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &ListModuleVersionsRequest| { &m.module_id },
            |m: &mut ListModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModuleVersionsRequest| { &m.page },
            |m: &mut ListModuleVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModuleVersionsRequest| { &m.per_page },
            |m: &mut ListModuleVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModuleVersionsRequest>(
            "ListModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModuleVersionsRequest {
    const NAME: &'static str = "ListModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModuleVersionsRequest {
        ListModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModuleVersionsRequest {
        static instance: ListModuleVersionsRequest = ListModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModuleVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostModuleVersionsRequest)
pub struct PostModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModuleVersionsRequest {
    fn default() -> &'a PostModuleVersionsRequest {
        <PostModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModuleVersionsRequest {
    pub fn new() -> PostModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PostModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &PostModuleVersionsRequest| { &m.module_id },
            |m: &mut PostModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &PostModuleVersionsRequest| { &m.module_versions },
            |m: &mut PostModuleVersionsRequest| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModuleVersionsRequest>(
            "PostModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModuleVersionsRequest {
    const NAME: &'static str = "PostModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModuleVersionsRequest {
        PostModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModuleVersionsRequest {
        static instance: PostModuleVersionsRequest = PostModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several module versions by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteModuleVersionsRequest)
pub struct DeleteModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModuleVersionsRequest {
    fn default() -> &'a DeleteModuleVersionsRequest {
        <DeleteModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModuleVersionsRequest {
    pub fn new() -> DeleteModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModuleVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &DeleteModuleVersionsRequest| { &m.module_id },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModuleVersionsRequest| { &m.ids },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModuleVersionsRequest>(
            "DeleteModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModuleVersionsRequest {
    const NAME: &'static str = "DeleteModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModuleVersionsRequest {
        DeleteModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModuleVersionsRequest {
        static instance: DeleteModuleVersionsRequest = DeleteModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleModuleVersionResponse)
pub struct SingleModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionResponse.module_version)
    pub module_version: ::protobuf::MessageField<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleVersionResponse {
    fn default() -> &'a SingleModuleVersionResponse {
        <SingleModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleVersionResponse {
    pub fn new() -> SingleModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleVersionResponse| { &m.status },
            |m: &mut SingleModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModuleVersion>(
            "module_version",
            |m: &SingleModuleVersionResponse| { &m.module_version },
            |m: &mut SingleModuleVersionResponse| { &mut m.module_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleVersionResponse>(
            "SingleModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleVersionResponse {
    const NAME: &'static str = "SingleModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleVersionResponse {
        SingleModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleVersionResponse {
        static instance: SingleModuleVersionResponse = SingleModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            module_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModuleVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiModuleVersionResponse)
pub struct MultiModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleVersionResponse.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModuleVersionResponse {
    fn default() -> &'a MultiModuleVersionResponse {
        <MultiModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModuleVersionResponse {
    pub fn new() -> MultiModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModuleVersionResponse| { &m.status },
            |m: &mut MultiModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &MultiModuleVersionResponse| { &m.module_versions },
            |m: &mut MultiModuleVersionResponse| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModuleVersionResponse>(
            "MultiModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModuleVersionResponse {
    const NAME: &'static str = "MultiModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModuleVersionResponse {
        MultiModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModuleVersionResponse {
        static instance: MultiModuleVersionResponse = MultiModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInstalledModuleVersionRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetInstalledModuleVersionRequest)
pub struct GetInstalledModuleVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInstalledModuleVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the ID to get of the install module version.
    // @@protoc_insertion_point(field:clarifai.api.GetInstalledModuleVersionRequest.installed_module_version_id)
    pub installed_module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInstalledModuleVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInstalledModuleVersionRequest {
    fn default() -> &'a GetInstalledModuleVersionRequest {
        <GetInstalledModuleVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInstalledModuleVersionRequest {
    pub fn new() -> GetInstalledModuleVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInstalledModuleVersionRequest| { &m.user_app_id },
            |m: &mut GetInstalledModuleVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installed_module_version_id",
            |m: &GetInstalledModuleVersionRequest| { &m.installed_module_version_id },
            |m: &mut GetInstalledModuleVersionRequest| { &mut m.installed_module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInstalledModuleVersionRequest>(
            "GetInstalledModuleVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInstalledModuleVersionRequest {
    const NAME: &'static str = "GetInstalledModuleVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.installed_module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.installed_module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.installed_module_version_id.is_empty() {
            os.write_string(2, &self.installed_module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInstalledModuleVersionRequest {
        GetInstalledModuleVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInstalledModuleVersionRequest {
        static instance: GetInstalledModuleVersionRequest = GetInstalledModuleVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInstalledModuleVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInstalledModuleVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInstalledModuleVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInstalledModuleVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListInstalledModuleVersionsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListInstalledModuleVersionsRequest)
pub struct ListInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInstalledModuleVersionsRequest {
    fn default() -> &'a ListInstalledModuleVersionsRequest {
        <ListInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInstalledModuleVersionsRequest {
    pub fn new() -> ListInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInstalledModuleVersionsRequest| { &m.page },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInstalledModuleVersionsRequest| { &m.per_page },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInstalledModuleVersionsRequest>(
            "ListInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInstalledModuleVersionsRequest {
    const NAME: &'static str = "ListInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInstalledModuleVersionsRequest {
        ListInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInstalledModuleVersionsRequest {
        static instance: ListInstalledModuleVersionsRequest = ListInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInstalledModuleVersionsRequest to install a module version into the app in the URL
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostInstalledModuleVersionsRequest)
pub struct PostInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsRequest.installed_module_versions)
    pub installed_module_versions: ::std::vec::Vec<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInstalledModuleVersionsRequest {
    fn default() -> &'a PostInstalledModuleVersionsRequest {
        <PostInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInstalledModuleVersionsRequest {
    pub fn new() -> PostInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PostInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_module_versions",
            |m: &PostInstalledModuleVersionsRequest| { &m.installed_module_versions },
            |m: &mut PostInstalledModuleVersionsRequest| { &mut m.installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInstalledModuleVersionsRequest>(
            "PostInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInstalledModuleVersionsRequest {
    const NAME: &'static str = "PostInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.installed_module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.installed_module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInstalledModuleVersionsRequest {
        PostInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInstalledModuleVersionsRequest {
        static instance: PostInstalledModuleVersionsRequest = PostInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
///  version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostInstalledModuleVersionsKeyRequest)
pub struct PostInstalledModuleVersionsKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the ID to get of the install module version.
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsKeyRequest.installed_module_version_id)
    pub installed_module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInstalledModuleVersionsKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInstalledModuleVersionsKeyRequest {
    fn default() -> &'a PostInstalledModuleVersionsKeyRequest {
        <PostInstalledModuleVersionsKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInstalledModuleVersionsKeyRequest {
    pub fn new() -> PostInstalledModuleVersionsKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInstalledModuleVersionsKeyRequest| { &m.user_app_id },
            |m: &mut PostInstalledModuleVersionsKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installed_module_version_id",
            |m: &PostInstalledModuleVersionsKeyRequest| { &m.installed_module_version_id },
            |m: &mut PostInstalledModuleVersionsKeyRequest| { &mut m.installed_module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInstalledModuleVersionsKeyRequest>(
            "PostInstalledModuleVersionsKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInstalledModuleVersionsKeyRequest {
    const NAME: &'static str = "PostInstalledModuleVersionsKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.installed_module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.installed_module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.installed_module_version_id.is_empty() {
            os.write_string(2, &self.installed_module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInstalledModuleVersionsKeyRequest {
        PostInstalledModuleVersionsKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInstalledModuleVersionsKeyRequest {
        static instance: PostInstalledModuleVersionsKeyRequest = PostInstalledModuleVersionsKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInstalledModuleVersionsKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInstalledModuleVersionsKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInstalledModuleVersionsKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInstalledModuleVersionsKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several installed module versions by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteInstalledModuleVersionsRequest)
pub struct DeleteInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInstalledModuleVersionsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInstalledModuleVersionsRequest {
    fn default() -> &'a DeleteInstalledModuleVersionsRequest {
        <DeleteInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInstalledModuleVersionsRequest {
    pub fn new() -> DeleteInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteInstalledModuleVersionsRequest| { &m.ids },
            |m: &mut DeleteInstalledModuleVersionsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInstalledModuleVersionsRequest>(
            "DeleteInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInstalledModuleVersionsRequest {
    const NAME: &'static str = "DeleteInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInstalledModuleVersionsRequest {
        DeleteInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInstalledModuleVersionsRequest {
        static instance: DeleteInstalledModuleVersionsRequest = DeleteInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInstalledModuleVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleInstalledModuleVersionResponse)
pub struct SingleInstalledModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInstalledModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInstalledModuleVersionResponse.installed_module_version)
    pub installed_module_version: ::protobuf::MessageField<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInstalledModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInstalledModuleVersionResponse {
    fn default() -> &'a SingleInstalledModuleVersionResponse {
        <SingleInstalledModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInstalledModuleVersionResponse {
    pub fn new() -> SingleInstalledModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInstalledModuleVersionResponse| { &m.status },
            |m: &mut SingleInstalledModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InstalledModuleVersion>(
            "installed_module_version",
            |m: &SingleInstalledModuleVersionResponse| { &m.installed_module_version },
            |m: &mut SingleInstalledModuleVersionResponse| { &mut m.installed_module_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInstalledModuleVersionResponse>(
            "SingleInstalledModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInstalledModuleVersionResponse {
    const NAME: &'static str = "SingleInstalledModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.installed_module_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.installed_module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.installed_module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInstalledModuleVersionResponse {
        SingleInstalledModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.installed_module_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInstalledModuleVersionResponse {
        static instance: SingleInstalledModuleVersionResponse = SingleInstalledModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            installed_module_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInstalledModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInstalledModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInstalledModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInstalledModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInstalledModuleVersionResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiInstalledModuleVersionResponse)
pub struct MultiInstalledModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInstalledModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInstalledModuleVersionResponse.installed_module_versions)
    pub installed_module_versions: ::std::vec::Vec<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInstalledModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInstalledModuleVersionResponse {
    fn default() -> &'a MultiInstalledModuleVersionResponse {
        <MultiInstalledModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInstalledModuleVersionResponse {
    pub fn new() -> MultiInstalledModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInstalledModuleVersionResponse| { &m.status },
            |m: &mut MultiInstalledModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_module_versions",
            |m: &MultiInstalledModuleVersionResponse| { &m.installed_module_versions },
            |m: &mut MultiInstalledModuleVersionResponse| { &mut m.installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInstalledModuleVersionResponse>(
            "MultiInstalledModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInstalledModuleVersionResponse {
    const NAME: &'static str = "MultiInstalledModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.installed_module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.installed_module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.installed_module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInstalledModuleVersionResponse {
        MultiInstalledModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.installed_module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInstalledModuleVersionResponse {
        static instance: MultiInstalledModuleVersionResponse = MultiInstalledModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            installed_module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInstalledModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInstalledModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInstalledModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInstalledModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListNextTaskAssignmentsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListNextTaskAssignmentsRequest)
pub struct ListNextTaskAssignmentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListNextTaskAssignmentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListNextTaskAssignmentsRequest.task_id)
    pub task_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListNextTaskAssignmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListNextTaskAssignmentsRequest {
    fn default() -> &'a ListNextTaskAssignmentsRequest {
        <ListNextTaskAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListNextTaskAssignmentsRequest {
    pub fn new() -> ListNextTaskAssignmentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListNextTaskAssignmentsRequest| { &m.user_app_id },
            |m: &mut ListNextTaskAssignmentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &ListNextTaskAssignmentsRequest| { &m.task_id },
            |m: &mut ListNextTaskAssignmentsRequest| { &mut m.task_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListNextTaskAssignmentsRequest>(
            "ListNextTaskAssignmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListNextTaskAssignmentsRequest {
    const NAME: &'static str = "ListNextTaskAssignmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListNextTaskAssignmentsRequest {
        ListNextTaskAssignmentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListNextTaskAssignmentsRequest {
        static instance: ListNextTaskAssignmentsRequest = ListNextTaskAssignmentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListNextTaskAssignmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListNextTaskAssignmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListNextTaskAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNextTaskAssignmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to perform bulk operations on a list of inputs based on input source.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostBulkOperationsRequest)
pub struct PostBulkOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostBulkOperationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc.
    // @@protoc_insertion_point(field:clarifai.api.PostBulkOperationsRequest.bulk_operations)
    pub bulk_operations: ::std::vec::Vec<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostBulkOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostBulkOperationsRequest {
    fn default() -> &'a PostBulkOperationsRequest {
        <PostBulkOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostBulkOperationsRequest {
    pub fn new() -> PostBulkOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostBulkOperationsRequest| { &m.user_app_id },
            |m: &mut PostBulkOperationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bulk_operations",
            |m: &PostBulkOperationsRequest| { &m.bulk_operations },
            |m: &mut PostBulkOperationsRequest| { &mut m.bulk_operations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostBulkOperationsRequest>(
            "PostBulkOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostBulkOperationsRequest {
    const NAME: &'static str = "PostBulkOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.bulk_operations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bulk_operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.bulk_operations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostBulkOperationsRequest {
        PostBulkOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.bulk_operations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostBulkOperationsRequest {
        static instance: PostBulkOperationsRequest = PostBulkOperationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            bulk_operations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostBulkOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostBulkOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostBulkOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostBulkOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list all the bulk operations.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListBulkOperationsRequest)
pub struct ListBulkOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListBulkOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListBulkOperationsRequest {
    fn default() -> &'a ListBulkOperationsRequest {
        <ListBulkOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBulkOperationsRequest {
    pub fn new() -> ListBulkOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListBulkOperationsRequest| { &m.user_app_id },
            |m: &mut ListBulkOperationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListBulkOperationsRequest| { &m.page },
            |m: &mut ListBulkOperationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListBulkOperationsRequest| { &m.per_page },
            |m: &mut ListBulkOperationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListBulkOperationsRequest>(
            "ListBulkOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListBulkOperationsRequest {
    const NAME: &'static str = "ListBulkOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListBulkOperationsRequest {
        ListBulkOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListBulkOperationsRequest {
        static instance: ListBulkOperationsRequest = ListBulkOperationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListBulkOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListBulkOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListBulkOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBulkOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get the details of a bulk operation by ID.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetBulkOperationRequest)
pub struct GetBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The bulk operation id
    // @@protoc_insertion_point(field:clarifai.api.GetBulkOperationRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBulkOperationRequest {
    fn default() -> &'a GetBulkOperationRequest {
        <GetBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBulkOperationRequest {
    pub fn new() -> GetBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetBulkOperationRequest| { &m.user_app_id },
            |m: &mut GetBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetBulkOperationRequest| { &m.id },
            |m: &mut GetBulkOperationRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBulkOperationRequest>(
            "GetBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBulkOperationRequest {
    const NAME: &'static str = "GetBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBulkOperationRequest {
        GetBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBulkOperationRequest {
        static instance: GetBulkOperationRequest = GetBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cancel a list of bulk operation ids
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.CancelBulkOperationRequest)
pub struct CancelBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation ids to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelBulkOperationRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelBulkOperationRequest {
    fn default() -> &'a CancelBulkOperationRequest {
        <CancelBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelBulkOperationRequest {
    pub fn new() -> CancelBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelBulkOperationRequest| { &m.user_app_id },
            |m: &mut CancelBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CancelBulkOperationRequest| { &m.ids },
            |m: &mut CancelBulkOperationRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelBulkOperationRequest>(
            "CancelBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelBulkOperationRequest {
    const NAME: &'static str = "CancelBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelBulkOperationRequest {
        CancelBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelBulkOperationRequest {
        static instance: CancelBulkOperationRequest = CancelBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete the terminated bulk operations by ID
///  Only operations in terminated state can be deleted.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteBulkOperationRequest)
pub struct DeleteBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation ids to be deleted
    // @@protoc_insertion_point(field:clarifai.api.DeleteBulkOperationRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteBulkOperationRequest {
    fn default() -> &'a DeleteBulkOperationRequest {
        <DeleteBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBulkOperationRequest {
    pub fn new() -> DeleteBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteBulkOperationRequest| { &m.user_app_id },
            |m: &mut DeleteBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteBulkOperationRequest| { &m.ids },
            |m: &mut DeleteBulkOperationRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteBulkOperationRequest>(
            "DeleteBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteBulkOperationRequest {
    const NAME: &'static str = "DeleteBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteBulkOperationRequest {
        DeleteBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteBulkOperationRequest {
        static instance: DeleteBulkOperationRequest = DeleteBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleBulkOperationsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleBulkOperationsResponse)
pub struct SingleBulkOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleBulkOperationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleBulkOperationsResponse.bulk_operation)
    pub bulk_operation: ::protobuf::MessageField<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleBulkOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleBulkOperationsResponse {
    fn default() -> &'a SingleBulkOperationsResponse {
        <SingleBulkOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleBulkOperationsResponse {
    pub fn new() -> SingleBulkOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleBulkOperationsResponse| { &m.status },
            |m: &mut SingleBulkOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::BulkOperation>(
            "bulk_operation",
            |m: &SingleBulkOperationsResponse| { &m.bulk_operation },
            |m: &mut SingleBulkOperationsResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleBulkOperationsResponse>(
            "SingleBulkOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleBulkOperationsResponse {
    const NAME: &'static str = "SingleBulkOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bulk_operation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bulk_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bulk_operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleBulkOperationsResponse {
        SingleBulkOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleBulkOperationsResponse {
        static instance: SingleBulkOperationsResponse = SingleBulkOperationsResponse {
            status: ::protobuf::MessageField::none(),
            bulk_operation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleBulkOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleBulkOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleBulkOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleBulkOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiBulkOperationsResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiBulkOperationsResponse)
pub struct MultiBulkOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiBulkOperationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiBulkOperationsResponse.bulk_operation)
    pub bulk_operation: ::std::vec::Vec<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiBulkOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiBulkOperationsResponse {
    fn default() -> &'a MultiBulkOperationsResponse {
        <MultiBulkOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiBulkOperationsResponse {
    pub fn new() -> MultiBulkOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiBulkOperationsResponse| { &m.status },
            |m: &mut MultiBulkOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bulk_operation",
            |m: &MultiBulkOperationsResponse| { &m.bulk_operation },
            |m: &mut MultiBulkOperationsResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiBulkOperationsResponse>(
            "MultiBulkOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiBulkOperationsResponse {
    const NAME: &'static str = "MultiBulkOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.bulk_operation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bulk_operation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.bulk_operation {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiBulkOperationsResponse {
        MultiBulkOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiBulkOperationsResponse {
        static instance: MultiBulkOperationsResponse = MultiBulkOperationsResponse {
            status: ::protobuf::MessageField::none(),
            bulk_operation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiBulkOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiBulkOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiBulkOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiBulkOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PutTaskAssignmentsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PutTaskAssignmentsRequest)
pub struct PutTaskAssignmentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.task_id)
    pub task_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutTaskAssignmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutTaskAssignmentsRequest {
    fn default() -> &'a PutTaskAssignmentsRequest {
        <PutTaskAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutTaskAssignmentsRequest {
    pub fn new() -> PutTaskAssignmentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutTaskAssignmentsRequest| { &m.user_app_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &PutTaskAssignmentsRequest| { &m.task_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &PutTaskAssignmentsRequest| { &m.input_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutTaskAssignmentsRequest>(
            "PutTaskAssignmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutTaskAssignmentsRequest {
    const NAME: &'static str = "PutTaskAssignmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutTaskAssignmentsRequest {
        PutTaskAssignmentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutTaskAssignmentsRequest {
        static instance: PutTaskAssignmentsRequest = PutTaskAssignmentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutTaskAssignmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutTaskAssignmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutTaskAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutTaskAssignmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  List all the input ingestion jobs
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListInputsAddJobsRequest)
pub struct ListInputsAddJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsAddJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsAddJobsRequest {
    fn default() -> &'a ListInputsAddJobsRequest {
        <ListInputsAddJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsAddJobsRequest {
    pub fn new() -> ListInputsAddJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsAddJobsRequest| { &m.user_app_id },
            |m: &mut ListInputsAddJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsAddJobsRequest| { &m.page },
            |m: &mut ListInputsAddJobsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsAddJobsRequest| { &m.per_page },
            |m: &mut ListInputsAddJobsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsAddJobsRequest>(
            "ListInputsAddJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsAddJobsRequest {
    const NAME: &'static str = "ListInputsAddJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsAddJobsRequest {
        ListInputsAddJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsAddJobsRequest {
        static instance: ListInputsAddJobsRequest = ListInputsAddJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsAddJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsAddJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsAddJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsAddJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetInputsAddJobRequest)
pub struct GetInputsAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputsAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of add inputs job
    // @@protoc_insertion_point(field:clarifai.api.GetInputsAddJobRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputsAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputsAddJobRequest {
    fn default() -> &'a GetInputsAddJobRequest {
        <GetInputsAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputsAddJobRequest {
    pub fn new() -> GetInputsAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputsAddJobRequest| { &m.user_app_id },
            |m: &mut GetInputsAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetInputsAddJobRequest| { &m.id },
            |m: &mut GetInputsAddJobRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputsAddJobRequest>(
            "GetInputsAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputsAddJobRequest {
    const NAME: &'static str = "GetInputsAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputsAddJobRequest {
        GetInputsAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputsAddJobRequest {
        static instance: GetInputsAddJobRequest = GetInputsAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputsAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputsAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputsAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputsAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.CancelInputsAddJobRequest)
pub struct CancelInputsAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of add inputs job to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsAddJobRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelInputsAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInputsAddJobRequest {
    fn default() -> &'a CancelInputsAddJobRequest {
        <CancelInputsAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelInputsAddJobRequest {
    pub fn new() -> CancelInputsAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelInputsAddJobRequest| { &m.user_app_id },
            |m: &mut CancelInputsAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CancelInputsAddJobRequest| { &m.id },
            |m: &mut CancelInputsAddJobRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInputsAddJobRequest>(
            "CancelInputsAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInputsAddJobRequest {
    const NAME: &'static str = "CancelInputsAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInputsAddJobRequest {
        CancelInputsAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInputsAddJobRequest {
        static instance: CancelInputsAddJobRequest = CancelInputsAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInputsAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInputsAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInputsAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInputsAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputsAddJobResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiInputsAddJobResponse)
pub struct MultiInputsAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsAddJobResponse.inputs_add_jobs)
    pub inputs_add_jobs: ::std::vec::Vec<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputsAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputsAddJobResponse {
    fn default() -> &'a MultiInputsAddJobResponse {
        <MultiInputsAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputsAddJobResponse {
    pub fn new() -> MultiInputsAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputsAddJobResponse| { &m.status },
            |m: &mut MultiInputsAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_add_jobs",
            |m: &MultiInputsAddJobResponse| { &m.inputs_add_jobs },
            |m: &mut MultiInputsAddJobResponse| { &mut m.inputs_add_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputsAddJobResponse>(
            "MultiInputsAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputsAddJobResponse {
    const NAME: &'static str = "MultiInputsAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs_add_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_add_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_add_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputsAddJobResponse {
        MultiInputsAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_add_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputsAddJobResponse {
        static instance: MultiInputsAddJobResponse = MultiInputsAddJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_add_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputsAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputsAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputsAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputsAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputsAddJobResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleInputsAddJobResponse)
pub struct SingleInputsAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsAddJobResponse.inputs_add_job)
    pub inputs_add_job: ::protobuf::MessageField<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputsAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputsAddJobResponse {
    fn default() -> &'a SingleInputsAddJobResponse {
        <SingleInputsAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputsAddJobResponse {
    pub fn new() -> SingleInputsAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputsAddJobResponse| { &m.status },
            |m: &mut SingleInputsAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsAddJob>(
            "inputs_add_job",
            |m: &SingleInputsAddJobResponse| { &m.inputs_add_job },
            |m: &mut SingleInputsAddJobResponse| { &mut m.inputs_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputsAddJobResponse>(
            "SingleInputsAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputsAddJobResponse {
    const NAME: &'static str = "SingleInputsAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inputs_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputsAddJobResponse {
        SingleInputsAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputsAddJobResponse {
        static instance: SingleInputsAddJobResponse = SingleInputsAddJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputsAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputsAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputsAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputsAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start a multipart upload
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostUploadsRequest)
pub struct PostUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostUploadsRequest.uploads)
    pub uploads: ::std::vec::Vec<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostUploadsRequest {
    fn default() -> &'a PostUploadsRequest {
        <PostUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostUploadsRequest {
    pub fn new() -> PostUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostUploadsRequest| { &m.user_app_id },
            |m: &mut PostUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &PostUploadsRequest| { &m.uploads },
            |m: &mut PostUploadsRequest| { &mut m.uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostUploadsRequest>(
            "PostUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostUploadsRequest {
    const NAME: &'static str = "PostUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostUploadsRequest {
        PostUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostUploadsRequest {
        static instance: PostUploadsRequest = PostUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Stops or deletes multipart upload
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteUploadsRequest)
pub struct DeleteUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteUploadsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteUploadsRequest {
    fn default() -> &'a DeleteUploadsRequest {
        <DeleteUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteUploadsRequest {
    pub fn new() -> DeleteUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteUploadsRequest| { &m.user_app_id },
            |m: &mut DeleteUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteUploadsRequest| { &m.ids },
            |m: &mut DeleteUploadsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteUploadsRequest>(
            "DeleteUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteUploadsRequest {
    const NAME: &'static str = "DeleteUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteUploadsRequest {
        DeleteUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteUploadsRequest {
        static instance: DeleteUploadsRequest = DeleteUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListUploadsRequest)
pub struct ListUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUploadsRequest {
    fn default() -> &'a ListUploadsRequest {
        <ListUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUploadsRequest {
    pub fn new() -> ListUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListUploadsRequest| { &m.user_app_id },
            |m: &mut ListUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListUploadsRequest| { &m.page },
            |m: &mut ListUploadsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListUploadsRequest| { &m.per_page },
            |m: &mut ListUploadsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUploadsRequest>(
            "ListUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUploadsRequest {
    const NAME: &'static str = "ListUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUploadsRequest {
        ListUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUploadsRequest {
        static instance: ListUploadsRequest = ListUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetUploadRequest)
pub struct GetUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetUploadRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Upload ID
    // @@protoc_insertion_point(field:clarifai.api.GetUploadRequest.upload_id)
    pub upload_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUploadRequest {
    fn default() -> &'a GetUploadRequest {
        <GetUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUploadRequest {
    pub fn new() -> GetUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetUploadRequest| { &m.user_app_id },
            |m: &mut GetUploadRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &GetUploadRequest| { &m.upload_id },
            |m: &mut GetUploadRequest| { &mut m.upload_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUploadRequest>(
            "GetUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUploadRequest {
    const NAME: &'static str = "GetUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.upload_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.upload_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(2, &self.upload_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUploadRequest {
        GetUploadRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.upload_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUploadRequest {
        static instance: GetUploadRequest = GetUploadRequest {
            user_app_id: ::protobuf::MessageField::none(),
            upload_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleUploadResponse)
pub struct SingleUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleUploadResponse.upload)
    pub upload: ::protobuf::MessageField<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleUploadResponse {
    fn default() -> &'a SingleUploadResponse {
        <SingleUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleUploadResponse {
    pub fn new() -> SingleUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleUploadResponse| { &m.status },
            |m: &mut SingleUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Upload>(
            "upload",
            |m: &SingleUploadResponse| { &m.upload },
            |m: &mut SingleUploadResponse| { &mut m.upload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleUploadResponse>(
            "SingleUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleUploadResponse {
    const NAME: &'static str = "SingleUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upload)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.upload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.upload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleUploadResponse {
        SingleUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.upload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleUploadResponse {
        static instance: SingleUploadResponse = SingleUploadResponse {
            status: ::protobuf::MessageField::none(),
            upload: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiUploadResponse)
pub struct MultiUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiUploadResponse.uploads)
    pub uploads: ::std::vec::Vec<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiUploadResponse {
    fn default() -> &'a MultiUploadResponse {
        <MultiUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiUploadResponse {
    pub fn new() -> MultiUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiUploadResponse| { &m.status },
            |m: &mut MultiUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &MultiUploadResponse| { &m.uploads },
            |m: &mut MultiUploadResponse| { &mut m.uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiUploadResponse>(
            "MultiUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiUploadResponse {
    const NAME: &'static str = "MultiUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiUploadResponse {
        MultiUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiUploadResponse {
        static instance: MultiUploadResponse = MultiUploadResponse {
            status: ::protobuf::MessageField::none(),
            uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Upload a part of a multipart upload.
///  Behaviour on completion depends on the endpoint that was used to initiate the upload.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PutUploadContentPartsRequest)
pub struct PutUploadContentPartsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.upload_id)
    pub upload_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.content_parts)
    pub content_parts: ::std::vec::Vec<super::resources::UploadContentPart>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutUploadContentPartsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutUploadContentPartsRequest {
    fn default() -> &'a PutUploadContentPartsRequest {
        <PutUploadContentPartsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutUploadContentPartsRequest {
    pub fn new() -> PutUploadContentPartsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutUploadContentPartsRequest| { &m.user_app_id },
            |m: &mut PutUploadContentPartsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &PutUploadContentPartsRequest| { &m.upload_id },
            |m: &mut PutUploadContentPartsRequest| { &mut m.upload_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_parts",
            |m: &PutUploadContentPartsRequest| { &m.content_parts },
            |m: &mut PutUploadContentPartsRequest| { &mut m.content_parts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutUploadContentPartsRequest>(
            "PutUploadContentPartsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutUploadContentPartsRequest {
    const NAME: &'static str = "PutUploadContentPartsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.upload_id = is.read_string()?;
                },
                26 => {
                    self.content_parts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.upload_id);
        }
        for value in &self.content_parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(2, &self.upload_id)?;
        }
        for v in &self.content_parts {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutUploadContentPartsRequest {
        PutUploadContentPartsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.upload_id.clear();
        self.content_parts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutUploadContentPartsRequest {
        static instance: PutUploadContentPartsRequest = PutUploadContentPartsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            upload_id: ::std::string::String::new(),
            content_parts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutUploadContentPartsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutUploadContentPartsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutUploadContentPartsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutUploadContentPartsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Initiates retrieval of inputs from cloud storage from a user provided data source.
///  Will create and return an inputs-add-job for tracking progress.
///  Archives will be extracted and their contents will be processed as inputs.
///
///  The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
///  files in the images_folder beginning with abc or in a subfolder beginning with abc.
///  For example:
///  bucket/images_folder/abcImage.png
///  bucket/images_folder/abc-1/Data.zip
///
///  If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
///  Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
///  in which case it only requires rights to access that particular file.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostInputsDataSourcesRequest)
pub struct PostInputsDataSourcesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.data_sources)
    pub data_sources: ::std::vec::Vec<super::resources::InputsDataSource>,
    ///  If call back url is set, we will send a Post request to this endpoint with job status.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.call_back_url)
    pub call_back_url: ::std::string::String,
    ///  Personal Access Token to the application to which inputs are added
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.app_pat)
    pub app_pat: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsDataSourcesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsDataSourcesRequest {
    fn default() -> &'a PostInputsDataSourcesRequest {
        <PostInputsDataSourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsDataSourcesRequest {
    pub fn new() -> PostInputsDataSourcesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsDataSourcesRequest| { &m.user_app_id },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_sources",
            |m: &PostInputsDataSourcesRequest| { &m.data_sources },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.data_sources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_back_url",
            |m: &PostInputsDataSourcesRequest| { &m.call_back_url },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.call_back_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_pat",
            |m: &PostInputsDataSourcesRequest| { &m.app_pat },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.app_pat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsDataSourcesRequest>(
            "PostInputsDataSourcesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsDataSourcesRequest {
    const NAME: &'static str = "PostInputsDataSourcesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.data_sources.push(is.read_message()?);
                },
                26 => {
                    self.call_back_url = is.read_string()?;
                },
                34 => {
                    self.app_pat = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.data_sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.call_back_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.call_back_url);
        }
        if !self.app_pat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_pat);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.data_sources {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.call_back_url.is_empty() {
            os.write_string(3, &self.call_back_url)?;
        }
        if !self.app_pat.is_empty() {
            os.write_string(4, &self.app_pat)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsDataSourcesRequest {
        PostInputsDataSourcesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.data_sources.clear();
        self.call_back_url.clear();
        self.app_pat.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsDataSourcesRequest {
        static instance: PostInputsDataSourcesRequest = PostInputsDataSourcesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            data_sources: ::std::vec::Vec::new(),
            call_back_url: ::std::string::String::new(),
            app_pat: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsDataSourcesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsDataSourcesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsDataSourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsDataSourcesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetInputsExtractionJobRequest)
pub struct GetInputsExtractionJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputsExtractionJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputsExtractionJobRequest.inputs_extraction_job_id)
    pub inputs_extraction_job_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputsExtractionJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputsExtractionJobRequest {
    fn default() -> &'a GetInputsExtractionJobRequest {
        <GetInputsExtractionJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputsExtractionJobRequest {
    pub fn new() -> GetInputsExtractionJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputsExtractionJobRequest| { &m.user_app_id },
            |m: &mut GetInputsExtractionJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_extraction_job_id",
            |m: &GetInputsExtractionJobRequest| { &m.inputs_extraction_job_id },
            |m: &mut GetInputsExtractionJobRequest| { &mut m.inputs_extraction_job_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputsExtractionJobRequest>(
            "GetInputsExtractionJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputsExtractionJobRequest {
    const NAME: &'static str = "GetInputsExtractionJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs_extraction_job_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.inputs_extraction_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.inputs_extraction_job_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.inputs_extraction_job_id.is_empty() {
            os.write_string(2, &self.inputs_extraction_job_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputsExtractionJobRequest {
        GetInputsExtractionJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs_extraction_job_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputsExtractionJobRequest {
        static instance: GetInputsExtractionJobRequest = GetInputsExtractionJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs_extraction_job_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputsExtractionJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputsExtractionJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputsExtractionJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputsExtractionJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListInputsExtractionJobsRequest)
pub struct ListInputsExtractionJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsExtractionJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsExtractionJobsRequest {
    fn default() -> &'a ListInputsExtractionJobsRequest {
        <ListInputsExtractionJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsExtractionJobsRequest {
    pub fn new() -> ListInputsExtractionJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsExtractionJobsRequest| { &m.user_app_id },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsExtractionJobsRequest| { &m.page },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsExtractionJobsRequest| { &m.per_page },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsExtractionJobsRequest>(
            "ListInputsExtractionJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsExtractionJobsRequest {
    const NAME: &'static str = "ListInputsExtractionJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsExtractionJobsRequest {
        ListInputsExtractionJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsExtractionJobsRequest {
        static instance: ListInputsExtractionJobsRequest = ListInputsExtractionJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsExtractionJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsExtractionJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsExtractionJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsExtractionJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleInputsExtractionJobResponse)
pub struct SingleInputsExtractionJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsExtractionJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsExtractionJobResponse.inputs_extraction_job)
    pub inputs_extraction_job: ::protobuf::MessageField<super::resources::InputsExtractionJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputsExtractionJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputsExtractionJobResponse {
    fn default() -> &'a SingleInputsExtractionJobResponse {
        <SingleInputsExtractionJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputsExtractionJobResponse {
    pub fn new() -> SingleInputsExtractionJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputsExtractionJobResponse| { &m.status },
            |m: &mut SingleInputsExtractionJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsExtractionJob>(
            "inputs_extraction_job",
            |m: &SingleInputsExtractionJobResponse| { &m.inputs_extraction_job },
            |m: &mut SingleInputsExtractionJobResponse| { &mut m.inputs_extraction_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputsExtractionJobResponse>(
            "SingleInputsExtractionJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputsExtractionJobResponse {
    const NAME: &'static str = "SingleInputsExtractionJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_extraction_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_extraction_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inputs_extraction_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputsExtractionJobResponse {
        SingleInputsExtractionJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_extraction_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputsExtractionJobResponse {
        static instance: SingleInputsExtractionJobResponse = SingleInputsExtractionJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_extraction_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputsExtractionJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputsExtractionJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputsExtractionJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputsExtractionJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiInputsExtractionJobResponse)
pub struct MultiInputsExtractionJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsExtractionJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsExtractionJobResponse.inputs_extraction_jobs)
    pub inputs_extraction_jobs: ::std::vec::Vec<super::resources::InputsExtractionJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputsExtractionJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputsExtractionJobResponse {
    fn default() -> &'a MultiInputsExtractionJobResponse {
        <MultiInputsExtractionJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputsExtractionJobResponse {
    pub fn new() -> MultiInputsExtractionJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputsExtractionJobResponse| { &m.status },
            |m: &mut MultiInputsExtractionJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_extraction_jobs",
            |m: &MultiInputsExtractionJobResponse| { &m.inputs_extraction_jobs },
            |m: &mut MultiInputsExtractionJobResponse| { &mut m.inputs_extraction_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputsExtractionJobResponse>(
            "MultiInputsExtractionJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputsExtractionJobResponse {
    const NAME: &'static str = "MultiInputsExtractionJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs_extraction_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_extraction_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_extraction_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputsExtractionJobResponse {
        MultiInputsExtractionJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_extraction_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputsExtractionJobResponse {
        static instance: MultiInputsExtractionJobResponse = MultiInputsExtractionJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_extraction_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputsExtractionJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputsExtractionJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputsExtractionJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputsExtractionJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cancel a list of extraction job ids
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.CancelInputsExtractionJobsRequest)
pub struct CancelInputsExtractionJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsExtractionJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of extraction job ids to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsExtractionJobsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelInputsExtractionJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInputsExtractionJobsRequest {
    fn default() -> &'a CancelInputsExtractionJobsRequest {
        <CancelInputsExtractionJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelInputsExtractionJobsRequest {
    pub fn new() -> CancelInputsExtractionJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelInputsExtractionJobsRequest| { &m.user_app_id },
            |m: &mut CancelInputsExtractionJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CancelInputsExtractionJobsRequest| { &m.ids },
            |m: &mut CancelInputsExtractionJobsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInputsExtractionJobsRequest>(
            "CancelInputsExtractionJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInputsExtractionJobsRequest {
    const NAME: &'static str = "CancelInputsExtractionJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInputsExtractionJobsRequest {
        CancelInputsExtractionJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInputsExtractionJobsRequest {
        static instance: CancelInputsExtractionJobsRequest = CancelInputsExtractionJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInputsExtractionJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInputsExtractionJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInputsExtractionJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInputsExtractionJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start uploading a file archive containing inputs.
///  Will create and return an inputs-add-job for tracking progress.
///
///  Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
///  Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostInputsUploadsRequest)
pub struct PostInputsUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostInputsUploadsRequest.inputs_uploads)
    pub inputs_uploads: ::std::vec::Vec<super::resources::InputsUpload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsUploadsRequest {
    fn default() -> &'a PostInputsUploadsRequest {
        <PostInputsUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsUploadsRequest {
    pub fn new() -> PostInputsUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsUploadsRequest| { &m.user_app_id },
            |m: &mut PostInputsUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_uploads",
            |m: &PostInputsUploadsRequest| { &m.inputs_uploads },
            |m: &mut PostInputsUploadsRequest| { &mut m.inputs_uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsUploadsRequest>(
            "PostInputsUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsUploadsRequest {
    const NAME: &'static str = "PostInputsUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs_uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsUploadsRequest {
        PostInputsUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs_uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsUploadsRequest {
        static instance: PostInputsUploadsRequest = PostInputsUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs_uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetRunnerRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.GetRunnerRequest)
pub struct GetRunnerRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetRunnerRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetRunnerRequest.runner_id)
    pub runner_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetRunnerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRunnerRequest {
    fn default() -> &'a GetRunnerRequest {
        <GetRunnerRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRunnerRequest {
    pub fn new() -> GetRunnerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetRunnerRequest| { &m.user_app_id },
            |m: &mut GetRunnerRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &GetRunnerRequest| { &m.runner_id },
            |m: &mut GetRunnerRequest| { &mut m.runner_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetRunnerRequest>(
            "GetRunnerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetRunnerRequest {
    const NAME: &'static str = "GetRunnerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRunnerRequest {
        GetRunnerRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRunnerRequest {
        static instance: GetRunnerRequest = GetRunnerRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetRunnerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetRunnerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetRunnerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRunnerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListRunnersRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListRunnersRequest)
pub struct ListRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRunnersRequest {
    fn default() -> &'a ListRunnersRequest {
        <ListRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRunnersRequest {
    pub fn new() -> ListRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListRunnersRequest| { &m.user_app_id },
            |m: &mut ListRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListRunnersRequest| { &m.page },
            |m: &mut ListRunnersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListRunnersRequest| { &m.per_page },
            |m: &mut ListRunnersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRunnersRequest>(
            "ListRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRunnersRequest {
    const NAME: &'static str = "ListRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRunnersRequest {
        ListRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRunnersRequest {
        static instance: ListRunnersRequest = ListRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostRunnersRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostRunnersRequest)
pub struct PostRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more runner by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnersRequest.runners)
    pub runners: ::std::vec::Vec<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostRunnersRequest {
    fn default() -> &'a PostRunnersRequest {
        <PostRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostRunnersRequest {
    pub fn new() -> PostRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostRunnersRequest| { &m.user_app_id },
            |m: &mut PostRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runners",
            |m: &PostRunnersRequest| { &m.runners },
            |m: &mut PostRunnersRequest| { &mut m.runners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostRunnersRequest>(
            "PostRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostRunnersRequest {
    const NAME: &'static str = "PostRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.runners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runners {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostRunnersRequest {
        PostRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostRunnersRequest {
        static instance: PostRunnersRequest = PostRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.DeleteRunnersRequest)
pub struct DeleteRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteRunnersRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteRunnersRequest {
    fn default() -> &'a DeleteRunnersRequest {
        <DeleteRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRunnersRequest {
    pub fn new() -> DeleteRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteRunnersRequest| { &m.user_app_id },
            |m: &mut DeleteRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteRunnersRequest| { &m.ids },
            |m: &mut DeleteRunnersRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteRunnersRequest>(
            "DeleteRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteRunnersRequest {
    const NAME: &'static str = "DeleteRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteRunnersRequest {
        DeleteRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteRunnersRequest {
        static instance: DeleteRunnersRequest = DeleteRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleRunnerResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.SingleRunnerResponse)
pub struct SingleRunnerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleRunnerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleRunnerResponse.runner)
    pub runner: ::protobuf::MessageField<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleRunnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleRunnerResponse {
    fn default() -> &'a SingleRunnerResponse {
        <SingleRunnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleRunnerResponse {
    pub fn new() -> SingleRunnerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleRunnerResponse| { &m.status },
            |m: &mut SingleRunnerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Runner>(
            "runner",
            |m: &SingleRunnerResponse| { &m.runner },
            |m: &mut SingleRunnerResponse| { &mut m.runner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleRunnerResponse>(
            "SingleRunnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleRunnerResponse {
    const NAME: &'static str = "SingleRunnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runner)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.runner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleRunnerResponse {
        SingleRunnerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleRunnerResponse {
        static instance: SingleRunnerResponse = SingleRunnerResponse {
            status: ::protobuf::MessageField::none(),
            runner: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleRunnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleRunnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleRunnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleRunnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiRunnerResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerResponse)
pub struct MultiRunnerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerResponse.runners)
    pub runners: ::std::vec::Vec<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerResponse {
    fn default() -> &'a MultiRunnerResponse {
        <MultiRunnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerResponse {
    pub fn new() -> MultiRunnerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerResponse| { &m.status },
            |m: &mut MultiRunnerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runners",
            |m: &MultiRunnerResponse| { &m.runners },
            |m: &mut MultiRunnerResponse| { &mut m.runners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerResponse>(
            "MultiRunnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerResponse {
    const NAME: &'static str = "MultiRunnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runners {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerResponse {
        MultiRunnerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerResponse {
        static instance: MultiRunnerResponse = MultiRunnerResponse {
            status: ::protobuf::MessageField::none(),
            runners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.ListRunnerItemsRequest)
pub struct ListRunnerItemsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListRunnerItemsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListRunnerItemsRequest.runner_id)
    pub runner_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListRunnerItemsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRunnerItemsRequest {
    fn default() -> &'a ListRunnerItemsRequest {
        <ListRunnerItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRunnerItemsRequest {
    pub fn new() -> ListRunnerItemsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListRunnerItemsRequest| { &m.user_app_id },
            |m: &mut ListRunnerItemsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &ListRunnerItemsRequest| { &m.runner_id },
            |m: &mut ListRunnerItemsRequest| { &mut m.runner_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRunnerItemsRequest>(
            "ListRunnerItemsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRunnerItemsRequest {
    const NAME: &'static str = "ListRunnerItemsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRunnerItemsRequest {
        ListRunnerItemsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRunnerItemsRequest {
        static instance: ListRunnerItemsRequest = ListRunnerItemsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRunnerItemsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRunnerItemsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRunnerItemsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRunnerItemsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostRunnerItemOutputsRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.PostRunnerItemOutputsRequest)
pub struct PostRunnerItemOutputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_id)
    pub runner_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.item_id)
    pub item_id: ::std::string::String,
    ///  This allows you to create one or more runner by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_item_outputs)
    pub runner_item_outputs: ::std::vec::Vec<RunnerItemOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostRunnerItemOutputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostRunnerItemOutputsRequest {
    fn default() -> &'a PostRunnerItemOutputsRequest {
        <PostRunnerItemOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostRunnerItemOutputsRequest {
    pub fn new() -> PostRunnerItemOutputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostRunnerItemOutputsRequest| { &m.user_app_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "item_id",
            |m: &PostRunnerItemOutputsRequest| { &m.item_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_item_outputs",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_item_outputs },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_item_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostRunnerItemOutputsRequest>(
            "PostRunnerItemOutputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostRunnerItemOutputsRequest {
    const NAME: &'static str = "PostRunnerItemOutputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                26 => {
                    self.item_id = is.read_string()?;
                },
                34 => {
                    self.runner_item_outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        if !self.item_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.item_id);
        }
        for value in &self.runner_item_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        if !self.item_id.is_empty() {
            os.write_string(3, &self.item_id)?;
        }
        for v in &self.runner_item_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostRunnerItemOutputsRequest {
        PostRunnerItemOutputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.item_id.clear();
        self.runner_item_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostRunnerItemOutputsRequest {
        static instance: PostRunnerItemOutputsRequest = PostRunnerItemOutputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            item_id: ::std::string::String::new(),
            runner_item_outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostRunnerItemOutputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostRunnerItemOutputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostRunnerItemOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostRunnerItemOutputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiRunnerItemResponse
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerItemResponse)
pub struct MultiRunnerItemResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemResponse.items)
    pub items: ::std::vec::Vec<RunnerItem>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerItemResponse {
    fn default() -> &'a MultiRunnerItemResponse {
        <MultiRunnerItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerItemResponse {
    pub fn new() -> MultiRunnerItemResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerItemResponse| { &m.status },
            |m: &mut MultiRunnerItemResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &MultiRunnerItemResponse| { &m.items },
            |m: &mut MultiRunnerItemResponse| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerItemResponse>(
            "MultiRunnerItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerItemResponse {
    const NAME: &'static str = "MultiRunnerItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerItemResponse {
        MultiRunnerItemResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerItemResponse {
        static instance: MultiRunnerItemResponse = MultiRunnerItemResponse {
            status: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.RunnerItem)
pub struct RunnerItem {
    // message fields
    ///  A UUID hash for this work item.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.id)
    pub id: ::std::string::String,
    ///  A description of the work to be done in case needed for UIs.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.description)
    pub description: ::std::string::String,
    ///  TODO(zeiler): make these options a oneof.
    ///  first work to do would be an inference runner.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.post_model_outputs_request)
    pub post_model_outputs_request: ::protobuf::MessageField<PostModelOutputsRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerItem {
    fn default() -> &'a RunnerItem {
        <RunnerItem as ::protobuf::Message>::default_instance()
    }
}

impl RunnerItem {
    pub fn new() -> RunnerItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RunnerItem| { &m.id },
            |m: &mut RunnerItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &RunnerItem| { &m.description },
            |m: &mut RunnerItem| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PostModelOutputsRequest>(
            "post_model_outputs_request",
            |m: &RunnerItem| { &m.post_model_outputs_request },
            |m: &mut RunnerItem| { &mut m.post_model_outputs_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerItem>(
            "RunnerItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerItem {
    const NAME: &'static str = "RunnerItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.post_model_outputs_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(v) = self.post_model_outputs_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(v) = self.post_model_outputs_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerItem {
        RunnerItem::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.post_model_outputs_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerItem {
        static instance: RunnerItem = RunnerItem {
            id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            post_model_outputs_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.RunnerItemOutput)
pub struct RunnerItemOutput {
    // message fields
    ///  The output of the first task type.
    ///  TODO(zeiler): should the interface be more like pairs of things wiht request/response in one "item"?
    // @@protoc_insertion_point(field:clarifai.api.RunnerItemOutput.multi_output_response)
    pub multi_output_response: ::protobuf::MessageField<MultiOutputResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerItemOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerItemOutput {
    fn default() -> &'a RunnerItemOutput {
        <RunnerItemOutput as ::protobuf::Message>::default_instance()
    }
}

impl RunnerItemOutput {
    pub fn new() -> RunnerItemOutput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MultiOutputResponse>(
            "multi_output_response",
            |m: &RunnerItemOutput| { &m.multi_output_response },
            |m: &mut RunnerItemOutput| { &mut m.multi_output_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerItemOutput>(
            "RunnerItemOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerItemOutput {
    const NAME: &'static str = "RunnerItemOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.multi_output_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.multi_output_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.multi_output_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerItemOutput {
        RunnerItemOutput::new()
    }

    fn clear(&mut self) {
        self.multi_output_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerItemOutput {
        static instance: RunnerItemOutput = RunnerItemOutput {
            multi_output_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerItemOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerItemOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerItemOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerItemOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerItemOutputResponse)
pub struct MultiRunnerItemOutputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemOutputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemOutputResponse.runner_item_outputs)
    pub runner_item_outputs: ::std::vec::Vec<RunnerItemOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerItemOutputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerItemOutputResponse {
    fn default() -> &'a MultiRunnerItemOutputResponse {
        <MultiRunnerItemOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerItemOutputResponse {
    pub fn new() -> MultiRunnerItemOutputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerItemOutputResponse| { &m.status },
            |m: &mut MultiRunnerItemOutputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_item_outputs",
            |m: &MultiRunnerItemOutputResponse| { &m.runner_item_outputs },
            |m: &mut MultiRunnerItemOutputResponse| { &mut m.runner_item_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerItemOutputResponse>(
            "MultiRunnerItemOutputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerItemOutputResponse {
    const NAME: &'static str = "MultiRunnerItemOutputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runner_item_outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runner_item_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runner_item_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerItemOutputResponse {
        MultiRunnerItemOutputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner_item_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerItemOutputResponse {
        static instance: MultiRunnerItemOutputResponse = MultiRunnerItemOutputResponse {
            status: ::protobuf::MessageField::none(),
            runner_item_outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerItemOutputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerItemOutputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerItemOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerItemOutputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.OrganizationInvitationStatus)
pub enum OrganizationInvitationStatus {
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.NOT_SET)
    NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.PENDING)
    PENDING = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.ACCEPTED)
    ACCEPTED = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.CANCELLED)
    CANCELLED = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.DECLINED)
    DECLINED = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.EXPIRED)
    EXPIRED = 5,
}

impl ::protobuf::Enum for OrganizationInvitationStatus {
    const NAME: &'static str = "OrganizationInvitationStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrganizationInvitationStatus> {
        match value {
            0 => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            1 => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            2 => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            3 => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            4 => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            5 => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OrganizationInvitationStatus] = &[
        OrganizationInvitationStatus::NOT_SET,
        OrganizationInvitationStatus::PENDING,
        OrganizationInvitationStatus::ACCEPTED,
        OrganizationInvitationStatus::CANCELLED,
        OrganizationInvitationStatus::DECLINED,
        OrganizationInvitationStatus::EXPIRED,
    ];
}

impl ::protobuf::EnumFull for OrganizationInvitationStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OrganizationInvitationStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OrganizationInvitationStatus {
    fn default() -> Self {
        OrganizationInvitationStatus::NOT_SET
    }
}

impl OrganizationInvitationStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrganizationInvitationStatus>("OrganizationInvitationStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20proto/clarifai/api/service.proto\x12\x0cclarifai.api\x1a\"proto/cl\
    arifai/api/resources.proto\x1a&proto/clarifai/api/status/status.proto\
    \x1a)proto/clarifai/api/utils/extensions.proto\x1a%proto/clarifai/auth/s\
    cope/scope.proto\x1a(proto/clarifai/auth/util/extension.proto\x1a+proto/\
    clarifai/api/status/status_code.proto\x1a\x1cgoogle/api/annotations.prot\
    o\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.pr\
    oto\x1a\x1fgoogle/protobuf/timestamp.proto\";\n\nPagination\x12\x12\n\
    \x04page\x18\x01\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x02\x20\
    \x01(\rR\x07perPage\"\x92\x01\n\x14GetAnnotationRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12#\n\rannotation_id\x18\x02\x20\x01(\tR\x0cannotationId\x12\x19\n\x08\
    input_id\x18\x03\x20\x01(\tR\x07inputId\"\xb3\x03\n\x16ListAnnotationsRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1b\
    \n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\x12\x19\n\x08user_ids\x18\
    \t\x20\x03(\tR\x07userIds\x12*\n\x11model_version_ids\x18\n\x20\x03(\tR\
    \x0fmodelVersionIds\x127\n\x08statuses\x18\x05\x20\x03(\x0b2\x1b.clarifa\
    i.api.status.StatusR\x08statuses\x120\n\x14list_all_annotations\x18\x06\
    \x20\x01(\x08R\x12listAllAnnotations\x12.\n\x13return_model_output\x18\
    \x0c\x20\x01(\x08R\x11returnModelOutput\x12\x12\n\x04page\x18\x07\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x08\x20\x01(\rR\x07perPage\
    \x12\x17\n\x07task_id\x18\x0b\x20\x01(\tR\x06taskIdJ\x04\x08\x04\x10\x05\
    \"\x90\x01\n\x16PostAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\"\
    \xda\x01\n\x17PatchAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\x12/\n\x14delete_if_empty\
    _data\x18\x04\x20\x01(\x08R\x11deleteIfEmptyData\"\xe9\x01\n\x1dPatchAnn\
    otationsStatusRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12@\n\x0bstatus_code\x18\x02\x20\
    \x01(\x0e2\x1f.clarifai.api.status.StatusCodeR\nstatusCode\x12\x19\n\x08\
    user_ids\x18\x03\x20\x03(\tR\x07userIds\x12\x17\n\x07task_id\x18\x04\x20\
    \x01(\tR\x06taskId\x12\x16\n\x06action\x18\x05\x20\x01(\tR\x06action\"\
    \x95\x01\n\x1ePatchAnnotationsStatusResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x19\n\x08us\
    er_ids\x18\x02\x20\x03(\tR\x07userIds\x12#\n\rupdated_count\x18\x03\x20\
    \x01(\rR\x0cupdatedCount\"\x95\x01\n\x17DeleteAnnotationRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\x12#\n\rann\
    otation_id\x18\x03\x20\x01(\tR\x0cannotationId\"\x85\x01\n\x18DeleteAnno\
    tationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\
    \x12\x1b\n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\"\x89\x01\n\x18Sin\
    gleAnnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifa\
    i.api.status.StatusR\x06status\x128\n\nannotation\x18\x02\x20\x01(\x0b2\
    \x18.clarifai.api.AnnotationR\nannotation\"\x90\x01\n\x17MultiAnnotation\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x12@\n\x0bannotations\x18\x02\x20\x03(\x0b2\x18.clarif\
    ai.api.AnnotationR\x0bannotationsB\x04\x80\xb5\x18\x01\"x\n\rGetAppReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12+\n\x11additional_fields\x18\x02\x20\x03(\tR\x10addi\
    tionalFields\"\x94\x04\n\x0fListAppsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\x12%\n\x0esort_ascending\x18\x05\x20\x01(\x08R\rsort\
    Ascending\x12\"\n\x0csort_by_name\x18\x06\x20\x01(\x08H\0R\nsortByName\
    \x12/\n\x13sort_by_modified_at\x18\x07\x20\x01(\x08H\0R\x10sortByModifie\
    dAt\x12-\n\x12sort_by_created_at\x18\x0c\x20\x01(\x08H\0R\x0fsortByCreat\
    edAt\x12-\n\x12sort_by_star_count\x18\r\x20\x01(\x08H\0R\x0fsortByStarCo\
    unt\x12\x14\n\x05query\x18\x08\x20\x01(\tR\x05query\x12\x16\n\x04name\
    \x18\x04\x20\x01(\tR\x04nameB\x02\x18\x01\x12\x0e\n\x02id\x18\x0e\x20\
    \x01(\tR\x02id\x12#\n\rfeatured_only\x18\t\x20\x01(\x08R\x0cfeaturedOnly\
    \x12!\n\x0cstarred_only\x18\x0b\x20\x01(\x08R\x0bstarredOnly\x12+\n\x11a\
    dditional_fields\x18\n\x20\x03(\tR\x10additionalFieldsB\t\n\x07sort_by\"\
    t\n\x0fPostAppsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04apps\x18\x02\x20\x03(\x0b\
    2\x11.clarifai.api.AppR\x04apps\"N\n\x10DeleteAppRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\
    \xeb\x01\n\x10PatchAppsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04apps\x18\x02\
    \x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\x12\x16\n\x06action\x18\x03\
    \x20\x01(\tR\x06action\x12B\n\x0fmetadata_action\x18\x04\x20\x01(\x0b2\
    \x19.clarifai.api.PatchActionR\x0emetadataAction\x12\x18\n\x07reindex\
    \x18\x05\x20\x01(\x08R\x07reindex\"\xe8\x01\n\x0fPatchAppRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\x12B\n\x0fmetadata_ac\
    tion\x18\x04\x20\x01(\x0b2\x19.clarifai.api.PatchActionR\x0emetadataActi\
    on\x12\x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reindex\"\x99\x01\n\x13\
    PatchAppsIdsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12.\n\x03ids\x18\x03\x20\x03(\x0b2\
    \x1c.clarifai.api.IdUpdateSourceR\x03ids\x12\x16\n\x06action\x18\x04\x20\
    \x01(\tR\x06action\"\xc4\x01\n\x17PostAppsSearchesRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x123\n\tapp_query\x18\x02\x20\x01(\x0b2\x16.clarifai.api.AppQueryR\x08a\
    ppQuery\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.Pagina\
    tionR\npagination\"m\n\x11SingleAppResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12#\n\x03app\x18\
    \x02\x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\"t\n\x10MultiAppResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12+\n\x04apps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\
    \x04appsB\x04\x80\xb5\x18\x01\"\xbb\x01\n\x18ListCollaboratorsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x124\n\x16list_all_collaborators\x18\x02\x20\x01(\x08R\
    \x14listAllCollaborators\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x98\x01\n\x18Pos\
    tCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\x18\x02\x20\
    \x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\"\xb1\x01\n\x19\
    PatchCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\xa4\x01\n\x1aDeleteCollaborat\
    orsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12)\n\x10collaborator_ids\x18\x02\x20\x03(\tR\
    \x0fcollaboratorIds\x12\x1f\n\x0buser_emails\x18\x03\x20\x03(\tR\nuserEm\
    ails\"\x99\x01\n\x1aMultiCollaboratorsResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12F\n\rcollabo\
    rators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborato\
    rsB\x04\x80\xb5\x18\x01\"\x86\x01\n\x19ListCollaborationsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_p\
    age\x18\x03\x20\x01(\rR\x07perPage\"\x9d\x01\n\x1bMultiCollaborationsRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12I\n\x0ecollaborations\x18\x02\x20\x03(\x0b2\x1b.clarif\
    ai.api.CollaborationR\x0ecollaborationsB\x04\x80\xb5\x18\x01\"<\n\x14Get\
    StatusCodeRequest\x12$\n\x0estatus_code_id\x18\x01\x20\x01(\tR\x0cstatus\
    CodeId\"\x18\n\x16ListStatusCodesRequest\"O\n\x18SingleStatusCodeRespons\
    e\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\"\x87\x01\n\x17MultiStatusCodeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\x08s\
    tatuses\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.status.StatusR\x08statuse\
    s\"n\n\x11GetConceptRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\
    \x20\x01(\tR\tconceptId\"\x80\x01\n\x13ListConceptsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"\xbf\x01\n\x18ListModelConceptsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\
    \nversion_id\x18\x03\x20\x01(\tR\tversionId\x12\x12\n\x04page\x18\x04\
    \x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPag\
    e\"\x9a\x02\n\x1bPostConceptsSearchesRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12?\n\rcon\
    cept_query\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.ConceptQueryR\x0cconce\
    ptQuery\x12D\n\nextra_info\x18\x04\x20\x01(\x0b2%.clarifai.api.ConceptEx\
    traInfoRequestR\textraInfo\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.\
    clarifai.api.PaginationR\npagination\"U\n\x17ConceptExtraInfoRequest\x12\
    :\n\x0erankable_model\x18\x01\x20\x01(\x0b2\x13.clarifai.api.ModelR\rran\
    kableModel\"\x84\x01\n\x13PostConceptsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x121\n\x08c\
    oncepts\x18\x02\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x08concepts\"\
    \x9d\x01\n\x14PatchConceptsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x121\n\x08concepts\x18\
    \x02\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x08concepts\x12\x16\n\x06ac\
    tion\x18\x03\x20\x01(\tR\x06action\"\x84\x01\n\x17GetConceptCountsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"}\n\x15SingleConceptRespons\
    e\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12/\n\x07concept\x18\x02\x20\x01(\x0b2\x15.clarifai.api.Conc\
    eptR\x07concept\"\x84\x01\n\x14MultiConceptResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\x08c\
    oncepts\x18\x02\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x08conceptsB\x04\
    \x80\xb5\x18\x01\"\x99\x01\n\x19MultiConceptCountResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12G\
    \n\x0econcept_counts\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.ConceptCount\
    R\rconceptCountsB\x04\x80\xb5\x18\x01\"\xf3\x01\n\x1bListConceptRelation\
    sRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconcep\
    tId\x12\x1c\n\tpredicate\x18\x03\x20\x01(\tR\tpredicate\x12,\n\x12knowle\
    dge_graph_id\x18\x04\x20\x01(\tR\x10knowledgeGraphId\x12\x12\n\x04page\
    \x18\x05\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x06\x20\x01(\rR\
    \x07perPage\"\xc4\x01\n\x1bPostConceptRelationsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_rela\
    tions\x18\x03\x20\x03(\x0b2\x1d.clarifai.api.ConceptRelationR\x10concept\
    Relations\"\x8c\x01\n\x1dDeleteConceptRelationsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x10\n\x03ids\x18\
    \x03\x20\x03(\tR\x03ids\"X\n\x1aListKnowledgeGraphsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \"\xa1\x01\n\x1aPostKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\x10knowl\
    edge_graphs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fkn\
    owledgeGraphs\"\xae\x01\n\x1dPostConceptMappingJobsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12Q\n\x14concept_mapping_jobs\x18\x02\x20\x03(\x0b2\x1f.clarifai.api.C\
    onceptMappingJobR\x12conceptMappingJobs\"\xa5\x01\n\x1cMultiConceptRelat\
    ionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x12P\n\x11concept_relations\x18\x02\x20\x03(\x0b2\
    \x1d.clarifai.api.ConceptRelationR\x10conceptRelationsB\x04\x80\xb5\x18\
    \x01\"\xa1\x01\n\x1bMultiKnowledgeGraphResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10knowl\
    edge_graphs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fkn\
    owledgeGraphsB\x04\x80\xb5\x18\x01\"g\n\x1eMultiConceptMappingJobRespons\
    e\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x92\x01\n\x19Ge\
    tConceptLanguageRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\
    \x01(\tR\tconceptId\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08languag\
    e\"\xa7\x01\n\x1bListConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\n\
    concept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x12\n\x04page\x18\x03\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\
    \xdd\x01\n\x1cPatchConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconc\
    ept_id\x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_languages\x18\
    \x03\x20\x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguages\
    \x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x1bPostCo\
    nceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\
    \x01(\tR\tconceptId\x12J\n\x11concept_languages\x18\x03\x20\x03(\x0b2\
    \x1d.clarifai.api.ConceptLanguageR\x10conceptLanguages\"\x9e\x01\n\x1dSi\
    ngleConceptLanguageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.c\
    larifai.api.status.StatusR\x06status\x12H\n\x10concept_language\x18\x02\
    \x20\x01(\x0b2\x1d.clarifai.api.ConceptLanguageR\x0fconceptLanguage\"\
    \xa5\x01\n\x1cMultiConceptLanguageResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12P\n\x11concept_l\
    anguages\x18\x02\x20\x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conc\
    eptLanguagesB\x04\x80\xb5\x18\x01\"h\n\x0fGetInputRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\"p\n\x17GetVideoMa\
    nifestRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\
    \x07inputId\"\x88\x01\n\x16GetInputSamplesRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\
    \n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\x12\x19\n\x08user_ids\x18\
    \x03\x20\x03(\tR\x07userIds\"\xc5\x01\n\x11ListInputsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\x123\n\x06status\x18\x05\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12\x10\n\x03ids\x18\x04\x20\
    \x03(\tR\x03ids\"\xc5\x01\n\x13StreamInputsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\
    \n\x08per_page\x18\x02\x20\x01(\rR\x07perPage\x12\x17\n\x07last_id\x18\
    \x03\x20\x01(\tR\x06lastId\x12\x1e\n\x0border_by_id\x18\x05\x20\x01(\x08\
    R\torderById\x12\x1e\n\ndescending\x18\x04\x20\x01(\x08R\ndescending\"\
    \x91\x02\n\x11PostInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x06inputs\x18\x02\
    \x20\x03(\x0b2\x13.clarifai.api.InputR\x06inputs\x12)\n\x11inputs_add_jo\
    b_id\x18\x03\x20\x01(\tR\x0einputsAddJobId\x12h\n\x1cinput_id_conflict_r\
    esolution\x18\x04\x20\x01(\x0e2'.clarifai.api.InputIDConflictResolutionR\
    \x19inputIdConflictResolution\"\x95\x01\n\x12PatchInputsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12+\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\
    \x06inputs\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"k\n\x12Del\
    eteInputRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\
    \x07inputId\"i\n\x13DeleteInputsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03id\
    s\x18\x02\x20\x03(\tR\x03idsJ\x04\x08\x03\x10\x04\"u\n\x13SingleInputRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12)\n\x05input\x18\x02\x20\x01(\x0b2\x13.clarifai.api.In\
    putR\x05input\"r\n\x18GetVideoManifestResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12!\n\x0cmanif\
    est_url\x18\x02\x20\x01(\tR\x0bmanifestUrl\"\xbe\x01\n\x12MultiInputResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x121\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.In\
    putR\x06inputsB\x04\x80\xb5\x18\x01\x12@\n\x0einputs_add_job\x18\x03\x20\
    \x01(\x0b2\x1a.clarifai.api.InputsAddJobR\x0cinputsAddJob\"\x80\x01\n\
    \x1cMultiInputAnnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04hits\x18\x03\x20\
    \x03(\x0b2\x11.clarifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\"\x81\x01\
    \n\x18SingleInputCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x120\n\x06counts\x18\x02\x20\
    \x01(\x0b2\x18.clarifai.api.InputCountR\x06counts\"R\n\x14GetInputCountR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\"\xcd\x03\n\x13ListDatasetsRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\x12!\n\x0cstarred_only\x18\x04\x20\x01(\x08R\
    \x0bstarredOnly\x12+\n\x11additional_fields\x18\x05\x20\x03(\tR\x10addit\
    ionalFields\x12%\n\x0esort_ascending\x18\x06\x20\x01(\x08R\rsortAscendin\
    g\x12-\n\x12sort_by_created_at\x18\x07\x20\x01(\x08H\0R\x0fsortByCreated\
    At\x12-\n\x12sort_by_star_count\x18\x08\x20\x01(\x08H\0R\x0fsortByStarCo\
    unt\x12/\n\x13sort_by_modified_at\x18\t\x20\x01(\x08H\0R\x10sortByModifi\
    edAt\x12\x1e\n\nsort_by_id\x18\x0b\x20\x01(\x08H\0R\x08sortById\x12\x1a\
    \n\x08bookmark\x18\n\x20\x01(\x08R\x08bookmarkB\t\n\x07sort_by\"\x9b\x01\
    \n\x11GetDatasetRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\
    \x01(\tR\tdatasetId\x12+\n\x11additional_fields\x18\x03\x20\x03(\tR\x10a\
    dditionalFields\"\x84\x01\n\x13PostDatasetsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x121\n\
    \x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\x08datasets\
    \"\x9d\x01\n\x14PatchDatasetsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x121\n\x08datasets\
    \x18\x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\x08datasets\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"t\n\x15DeleteDatasetsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x1f\n\x0bdataset_ids\x18\x02\x20\x03(\tR\ndatasetIds\
    \"\x84\x01\n\x14MultiDatasetResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\x08datasets\x18\
    \x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\x08datasetsB\x04\x80\xb5\
    \x18\x01\"}\n\x15SingleDatasetResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07dataset\x18\
    \x02\x20\x01(\x0b2\x15.clarifai.api.DatasetR\x07dataset\"\xa4\x01\n\x18L\
    istDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\
    \x01(\tR\tdatasetId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\
    \x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x8e\x01\n\x16GetData\
    setInputRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\
    \tdatasetId\x12\x19\n\x08input_id\x18\x03\x20\x01(\tR\x07inputId\"\xe6\
    \x01\n\x18PostDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12A\n\x0edataset_inputs\x18\x03\x20\x03\
    (\x0b2\x1a.clarifai.api.DatasetInputR\rdatasetInputs\x12,\n\x06search\
    \x18\x04\x20\x01(\x0b2\x14.clarifai.api.SearchR\x06search\"\x94\x01\n\
    \x1aDeleteDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12\x1b\n\tinput_ids\x18\x03\x20\x03(\tR\
    \x08inputIds\"\x84\x02\n\x19MultiDatasetInputResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12G\n\
    \x0edataset_inputs\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.DatasetInputR\
    \rdatasetInputsB\x04\x80\xb5\x18\x01\x12i\n\x1ddataset_inputs_search_add\
    _job\x18\x03\x20\x01(\x0b2'.clarifai.api.DatasetInputsSearchAddJobR\x19d\
    atasetInputsSearchAddJob\"\x92\x01\n\x1aSingleDatasetInputResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12?\n\rdataset_input\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.Datase\
    tInputR\x0cdatasetInput\"\xa6\x01\n\x1aListDatasetVersionsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12\x12\n\
    \x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\
    \x01(\rR\x07perPage\"\xa3\x01\n\x18GetDatasetVersionRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12,\n\x12dataset\
    _version_id\x18\x03\x20\x01(\tR\x10datasetVersionId\"\xf7\x02\n&ListData\
    setVersionMetricsGroupsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12,\n\x12dataset_version_id\x18\x03\x20\
    \x01(\tR\x10datasetVersionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04pa\
    ge\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\x12!\n\x0cparent\
    _paths\x18\x06\x20\x03(\tR\x0bparentPaths\x12B\n\x05types\x18\x07\x20\
    \x03(\x0e2,.clarifai.api.DatasetVersionMetricsGroupTypeR\x05types\x12.\n\
    \x06values\x18\x08\x20\x03(\x0b2\x16.google.protobuf.ValueR\x06values\"\
    \xc0\x01\n\x1aPostDatasetVersionsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndata\
    set_id\x18\x02\x20\x01(\tR\tdatasetId\x12G\n\x10dataset_versions\x18\x03\
    \x20\x03(\x0b2\x1c.clarifai.api.DatasetVersionR\x0fdatasetVersions\"\xd9\
    \x01\n\x1bPatchDatasetVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_\
    id\x18\x02\x20\x01(\tR\tdatasetId\x12G\n\x10dataset_versions\x18\x03\x20\
    \x03(\x0b2\x1c.clarifai.api.DatasetVersionR\x0fdatasetVersions\x12\x16\n\
    \x06action\x18\x04\x20\x01(\tR\x06action\"\xa9\x01\n\x1cDeleteDatasetVer\
    sionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tda\
    tasetId\x12.\n\x13dataset_version_ids\x18\x03\x20\x03(\tR\x11datasetVers\
    ionIds\"\xe8\x01\n\x1fPutDatasetVersionExportsRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12,\n\x12dataset_vers\
    ion_id\x18\x03\x20\x01(\tR\x10datasetVersionId\x12<\n\x07exports\x18\x04\
    \x20\x03(\x0b2\".clarifai.api.DatasetVersionExportR\x07exports\"\xa1\x01\
    \n\x1bMultiDatasetVersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10dataset_versions\
    \x18\x02\x20\x03(\x0b2\x1c.clarifai.api.DatasetVersionR\x0fdatasetVersio\
    nsB\x04\x80\xb5\x18\x01\"\x9c\x01\n!MultiDatasetVersionExportResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12B\n\x07exports\x18\x02\x20\x03(\x0b2\".clarifai.api.Datase\
    tVersionExportR\x07exportsB\x04\x80\xb5\x18\x01\"\xd3\x01\n'MultiDataset\
    VersionMetricsGroupResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.c\
    larifai.api.status.StatusR\x06status\x12s\n\x1edataset_version_metrics_g\
    roups\x18\x02\x20\x03(\x0b2(.clarifai.api.DatasetVersionMetricsGroupR\
    \x1bdatasetVersionMetricsGroupsB\x04\x80\xb5\x18\x01\"\x9a\x01\n\x1cSing\
    leDatasetVersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clar\
    ifai.api.status.StatusR\x06status\x12E\n\x0fdataset_version\x18\x02\x20\
    \x01(\x0b2\x1c.clarifai.api.DatasetVersionR\x0edatasetVersion\"x\n#GetDa\
    tasetInputsSearchAddJobRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x15\n\x06job_id\x18\
    \x02\x20\x01(\tR\x05jobId\"\x99\x01\n'SingleDatasetInputsSearchAddJobRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x129\n\x03job\x18\x02\x20\x01(\x0b2'.clarifai.api.Dataset\
    InputsSearchAddJobR\x03job\"\xe7\x01\n\x17PostModelOutputsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\n\
    version_id\x18\x03\x20\x01(\tR\tversionId\x12+\n\x06inputs\x18\x04\x20\
    \x03(\x0b2\x13.clarifai.api.InputR\x06inputs\x12)\n\x05model\x18\x05\x20\
    \x01(\x0b2\x13.clarifai.api.ModelR\x05model\"\xbd\x01\n\x16ListModelInpu\
    tsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mod\
    elId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\x12\x12\n\x04p\
    age\x18\x04\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\r\
    R\x07perPage\"b\n\rGetKeyRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x15\n\x06key_id\x18\
    \x02\x20\x01(\tR\x05keyId\"\xd3\x01\n\x0fListKeysRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\x12\x1f\n\x0bnot_expired\x18\x04\x20\x01(\
    \x08R\nnotExpired\x12\x16\n\x06scopes\x18\x05\x20\x03(\tR\x06scopes\x12\
    \x1c\n\tendpoints\x18\x06\x20\x03(\tR\tendpoints\"\x7f\n\x12ListAppKeysR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\
    \x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"t\n\x0fPostKeysReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\x11.clarifai.api.Ke\
    yR\x04keys\"e\n\x10DeleteKeyRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x15\n\x06key_id\
    \x18\x02\x20\x01(\tR\x05keyId\"\x8d\x01\n\x10PatchKeysRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\x11.clarifai.api.KeyR\x04keys\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"m\n\x11SingleKeyResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12#\n\x03key\x18\x02\x20\x01(\x0b2\x11.clarifai.api.KeyR\
    \x03key\"t\n\x10MultiKeyResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04keys\x18\x02\x20\
    \x03(\x0b2\x11.clarifai.api.KeyR\x04keysB\x04\x80\xb5\x18\x01\"\xf7\x01\
    \n\x0fGetModelRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\
    \x12\x1a\n\x08language\x18\x04\x20\x01(\tR\x08language\x12%\n\x0etrained\
    _before\x18\x05\x20\x01(\x08R\rtrainedBefore\x12+\n\x11additional_fields\
    \x18\x13\x20\x03(\tR\x10additionalFields\"\xaf\x07\n\x11ListModelsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12%\n\x0esort_ascending\x18\
    \n\x20\x01(\x08R\rsortAscending\x12\"\n\x0csort_by_name\x18\x0b\x20\x01(\
    \x08H\0R\nsortByName\x12-\n\x12sort_by_num_inputs\x18\x0c\x20\x01(\x08H\
    \0R\x0fsortByNumInputs\x12/\n\x13sort_by_modified_at\x18\r\x20\x01(\x08H\
    \0R\x10sortByModifiedAt\x12-\n\x12sort_by_created_at\x18\x18\x20\x01(\
    \x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_star_count\x18\x19\x20\x01\
    (\x08H\0R\x0fsortByStarCount\x12\x14\n\x05query\x18\x0e\x20\x01(\tR\x05q\
    uery\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\x12)\n\x11filter_by_u\
    ser_id\x18\x16\x20\x01(\x08R\x0efilterByUserId\x12\"\n\rmodel_type_id\
    \x18\x06\x20\x01(\tR\x0bmodelTypeId\x12!\n\x0ctrained_only\x18\x07\x20\
    \x01(\x08R\x0btrainedOnly\x12!\n\x0cinput_fields\x18\x08\x20\x03(\tR\x0b\
    inputFields\x12#\n\routput_fields\x18\t\x20\x03(\tR\x0coutputFields\x12\
    \x18\n\x07license\x18\x0f\x20\x01(\tR\x07license\x12#\n\rfeatured_only\
    \x18\x10\x20\x01(\x08R\x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x14\
    \x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08toolkits\x18\x11\x20\x03(\tR\
    \x08toolkits\x12\x1b\n\tuse_cases\x18\x12\x20\x03(\tR\x08useCases\x12\
    \x1c\n\tlanguages\x18\x15\x20\x03(\tR\tlanguages\x12+\n\x11additional_fi\
    elds\x18\x13\x20\x03(\tR\x10additionalFields\x12/\n\x14dont_fetch_from_m\
    ain\x18\x17\x20\x01(\x08R\x11dontFetchFromMain\x12\x1a\n\x08bookmark\x18\
    \x1a\x20\x01(\x08R\x08bookmarkB\t\n\x07sort_byJ\x04\x08\x04\x10\x05\"V\n\
    \x18GetResourceCountsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xbc\x01\n\x19GetResourceCou\
    ntsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x12\x1a\n\x08datasets\x18\x02\x20\x01(\x03R\x08data\
    sets\x12\x16\n\x06models\x18\x03\x20\x01(\x03R\x06models\x12\x1c\n\twork\
    flows\x18\x04\x20\x01(\x03R\tworkflows\x12\x18\n\x07modules\x18\x05\x20\
    \x01(\x03R\x07modules\"\xa6\x01\n\x19PatchModelToolkitsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1a\n\
    \x08toolkits\x18\x03\x20\x03(\tR\x08toolkits\x12\x16\n\x06action\x18\x04\
    \x20\x01(\tR\x06action\"\xb6\x01\n\x1ePatchModelCheckConsentsRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12%\n\
    \x0echeck_consents\x18\x03\x20\x03(\tR\rcheckConsents\x12\x16\n\x06actio\
    n\x18\x04\x20\x01(\tR\x06action\"\xa6\x01\n\x19PatchModelUseCasesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\
    \x1a\n\x08usecases\x18\x03\x20\x03(\tR\x08usecases\x12\x16\n\x06action\
    \x18\x04\x20\x01(\tR\x06action\"\xa9\x01\n\x1aPatchModelLanguagesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\
    \x1c\n\tlanguages\x18\x03\x20\x03(\tR\tlanguages\x12\x16\n\x06action\x18\
    \x04\x20\x01(\tR\x06action\"l\n\x19MultiModelToolkitResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12\x1a\n\x08toolkits\x18\x02\x20\x03(\tR\x08toolkits\"|\n\x1eMultiMode\
    lCheckConsentResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifa\
    i.api.status.StatusR\x06status\x12%\n\x0echeck_consents\x18\x02\x20\x03(\
    \tR\rcheckConsents\"l\n\x19MultiModelUseCaseResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\
    \n\x08usecases\x18\x02\x20\x03(\tR\x08usecases\"o\n\x1aMultiModelLanguag\
    eResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status\
    .StatusR\x06status\x12\x1c\n\tlanguages\x18\x02\x20\x03(\tR\tlanguages\"\
    \xab\x01\n\x11PostModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12-\n\x05model\x18\x02\
    \x20\x01(\x0b2\x13.clarifai.api.ModelR\x05modelB\x02\x18\x01\x12+\n\x06m\
    odels\x18\x03\x20\x03(\x0b2\x13.clarifai.api.ModelR\x06models\"\x95\x01\
    \n\x12PatchModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x06models\x18\x02\x20\x03(\
    \x0b2\x13.clarifai.api.ModelR\x06models\x12\x16\n\x06action\x18\x03\x20\
    \x01(\tR\x06action\"7\n\x0eIdUpdateSource\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x15\n\x06new_id\x18\x02\x20\x01(\tR\x05newId\"\x9a\
    \x01\n\x14PatchModelIdsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x03ids\x18\x03\
    \x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSourceR\x03ids\x12\x16\n\x06acti\
    on\x18\x04\x20\x01(\tR\x06action\"k\n\x12DeleteModelRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\"\x82\x01\n\x13De\
    leteModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03\
    ids\x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"\xcc\x01\n\
    \x19PostModelsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x129\n\x0bmodel_query\x18\
    \x02\x20\x01(\x0b2\x18.clarifai.api.ModelQueryR\nmodelQuery\x128\n\npagi\
    nation\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"u\
    \n\x13SingleModelResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12)\n\x05model\x18\x02\x20\x01(\x0b2\
    \x13.clarifai.api.ModelR\x05model\"|\n\x12MultiModelResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x121\n\x06models\x18\x02\x20\x03(\x0b2\x13.clarifai.api.ModelR\x06model\
    sB\x04\x80\xb5\x18\x01\"\xcd\x01\n\x19PatchModelVersionsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12A\n\x0em\
    odel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\rmode\
    lVersions\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"\x8e\x01\n\
    \x16GetModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\
    \x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversi\
    onId\"\xd7\x03\n\x18ListModelVersionsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\x04page\x18\x03\
    \x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPag\
    e\x12\x1f\n\x0bconcept_ids\x18\x05\x20\x03(\tR\nconceptIds\x12!\n\x0ctra\
    ined_only\x18\x06\x20\x01(\x08R\x0btrainedOnly\x12%\n\x0esort_ascending\
    \x18\x07\x20\x01(\x08R\rsortAscending\x12/\n\x13sort_by_status_code\x18\
    \x08\x20\x01(\x08H\0R\x10sortByStatusCode\x12-\n\x12sort_by_num_inputs\
    \x18\t\x20\x01(\x08H\0R\x0fsortByNumInputs\x120\n\x13sort_by_description\
    \x18\n\x20\x01(\x08H\0R\x11sortByDescription\x12-\n\x12sort_by_created_a\
    t\x18\x0b\x20\x01(\x08H\0R\x0fsortByCreatedAtB\t\n\x07sort_by\"\x91\x01\
    \n\x19DeleteModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x03\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x04\x20\x01(\t\
    R\tversionId\"\x92\x01\n\x1aSingleModelVersionResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12?\n\
    \rmodel_version\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.ModelVersionR\x0c\
    modelVersion\"\x99\x01\n\x19MultiModelVersionResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12G\n\
    \x0emodel_versions\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\
    \rmodelVersionsB\x04\x80\xb5\x18\x01\"\xa9\x02\n\x18PostModelVersionsReq\
    uest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAp\
    pIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\
    \x12A\n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVe\
    rsionR\rmodelVersions\x12\x20\n\x0bdescription\x18\x08\x20\x01(\tR\x0bde\
    scription\x123\n\teval_info\x18\n\x20\x01(\x0b2\x16.clarifai.api.EvalInf\
    oR\x08evalInfoJ\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\
    \x10\x07J\x04\x08\x07\x10\x08J\x04\x08\t\x10\n\"\xd6\x01\n$PostWorkflowV\
    ersionsUnPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\
    \x20\x01(\tR\nworkflowId\x12Q\n\x0cpublications\x18\x03\x20\x03(\x0b2-.c\
    larifai.api.WorkflowVersionUnPublishRequestR\x0cpublications\"\xd2\x01\n\
    \"PostWorkflowVersionsPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkfl\
    ow_id\x18\x02\x20\x01(\tR\nworkflowId\x12O\n\x0cpublications\x18\x03\x20\
    \x03(\x0b2+.clarifai.api.WorkflowVersionPublishRequestR\x0cpublications\
    \">\n\x1dWorkflowVersionPublishRequest\x12\x1d\n\nversion_id\x18\x01\x20\
    \x01(\tR\tversionId\"@\n\x1fWorkflowVersionUnPublishRequest\x12\x1d\n\nv\
    ersion_id\x18\x01\x20\x01(\tR\tversionId\";\n\x1aModelVersionPublishRequ\
    est\x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\tversionId\"\xc6\x01\n\x1f\
    PostModelVersionsPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\tR\x07modelId\x12L\n\x0cpublications\x18\x03\x20\x03(\
    \x0b2(.clarifai.api.ModelVersionPublishRequestR\x0cpublications\"=\n\x1c\
    ModelVersionUnpublishRequest\x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\t\
    versionId\"\xca\x01\n!PostModelVersionsUnPublishRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12N\n\x0cpublicat\
    ions\x18\x03\x20\x03(\x0b2*.clarifai.api.ModelVersionUnpublishRequestR\
    \x0cpublications\"\x92\x01\n\x16PostEvaluationsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    <\n\x0ceval_metrics\x18\x02\x20\x03(\x0b2\x19.clarifai.api.EvalMetricsR\
    \x0bevalMetrics\"\xa0\x06\n\x16ListEvaluationsRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\x12%\n\x0esort_ascending\x18\x04\x20\x01(\x08R\r\
    sortAscending\x12%\n\x0esort_by_app_id\x18\x05\x20\x01(\x08H\0R\x0bsortB\
    yAppId\x12'\n\x0fsort_by_roc_auc\x18\x06\x20\x01(\x08H\0R\x0csortByRocAu\
    c\x12\x1e\n\nsort_by_f1\x18\x07\x20\x01(\x08H\0R\x08sortByF1\x12-\n\x12s\
    ort_by_created_at\x18\x08\x20\x01(\x08H\0R\x0fsortByCreatedAt\x12<\n\x1a\
    sort_by_mean_avg_precision\x18\t\x20\x01(\x08H\0R\x16sortByMeanAvgPrecis\
    ion\x12,\n\x11sort_by_precision\x18\n\x20\x01(\x08H\0R\x0fsortByPrecisio\
    n\x12&\n\x0esort_by_recall\x18\x0b\x20\x01(\x08H\0R\x0csortByRecall\x12)\
    \n\x10sort_by_model_id\x18\x10\x20\x01(\x08H\0R\rsortByModelId\x126\n\
    \x17sort_by_eval_dataset_id\x18\x11\x20\x01(\x08H\0R\x13sortByEvalDatase\
    tId\x128\n\x18sort_by_train_dataset_id\x18\x12\x20\x01(\x08H\0R\x14sortB\
    yTrainDatasetId\x12\"\n\rmodel_type_id\x18\x0c\x20\x01(\tR\x0bmodelTypeI\
    d\x12(\n\x10eval_dataset_ids\x18\r\x20\x03(\tR\x0eevalDatasetIds\x12*\n\
    \x11train_dataset_ids\x18\x0e\x20\x03(\tR\x0ftrainDatasetIds\x12\x1f\n\
    \x0bconcept_ids\x18\x0f\x20\x03(\tR\nconceptIdsB\t\n\x07sort_by\"\xaa\
    \x01\n\x14GetEvaluationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12#\n\revaluation_id\
    \x18\x02\x20\x01(\tR\x0cevaluationId\x121\n\x06fields\x18\x03\x20\x01(\
    \x0b2\x19.clarifai.api.FieldsValueR\x06fields\"\xe3\x01\n\"PostModelVers\
    ionEvaluationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emo\
    delVersionId\x12<\n\x0ceval_metrics\x18\x04\x20\x03(\x0b2\x19.clarifai.a\
    pi.EvalMetricsR\x0bevalMetrics\"\xd4\x01\n\"ListModelVersionEvaluationsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x12\
    \x12\n\x04page\x18\x04\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x05\
    \x20\x01(\rR\x07perPage\"\xfb\x01\n\x20GetModelVersionEvaluationRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\
    \n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x12#\n\reva\
    luation_id\x18\x04\x20\x01(\tR\x0cevaluationId\x121\n\x06fields\x18\x05\
    \x20\x01(\x0b2\x19.clarifai.api.FieldsValueR\x06fields\"\x8e\x01\n\x19Si\
    ngleEvalMetricsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12<\n\x0ceval_metrics\x18\x02\x20\x01(\
    \x0b2\x19.clarifai.api.EvalMetricsR\x0bevalMetrics\"\x8d\x01\n\x18MultiE\
    valMetricsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.a\
    pi.status.StatusR\x06status\x12<\n\x0ceval_metrics\x18\x02\x20\x03(\x0b2\
    \x19.clarifai.api.EvalMetricsR\x0bevalMetrics\"\x88\x02\n\x1ePostModelVe\
    rsionMetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\
    \tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\x125\
    \n\x0btest_search\x18\x05\x20\x01(\x0b2\x14.clarifai.api.SearchR\ntestSe\
    arch\x123\n\teval_info\x18\n\x20\x01(\x0b2\x16.clarifai.api.EvalInfoR\
    \x08evalInfoJ\x04\x08\x04\x10\x05\"\xc8\x01\n\x1dGetModelVersionMetricsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\x121\n\x06fields\
    \x18\x04\x20\x01(\x0b2\x19.clarifai.api.FieldsValueR\x06fields\"u\n\x13G\
    etModelTypeRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clari\
    fai.api.UserAppIDSetR\tuserAppId\x12\"\n\rmodel_type_id\x18\x02\x20\x01(\
    \tR\x0bmodelTypeId\"\x82\x01\n\x15ListModelTypesRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"\x1f\n\x1dListOpenSourceLicensesRequest\"q\
    \n\x1eListOpenSourceLicensesResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\n\x08licenses\
    \x18\x02\x20\x03(\tR\x08licenses\"\x8c\x01\n\x17SingleModelTypeResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12<\n\nmodel_type\x18\x02\x20\x01(\x0b2\x17.clarifai.api.Mod\
    elTypeR\tmodelTypeB\x04\x80\xb5\x18\x01\"\xab\x02\n\x16MultiModelTypeRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12>\n\x0bmodel_types\x18\x02\x20\x03(\x0b2\x17.clarifai.\
    api.ModelTypeR\nmodelTypesB\x04\x80\xb5\x18\x01\x12E\n\x0fmodel_importer\
    s\x18\x03\x20\x01(\x0b2\x1c.clarifai.api.ModelTypeFieldR\x0emodelImporte\
    rs\x12U\n\x16triton_conda_envs_info\x18\x04\x20\x03(\x0b2\x20.clarifai.a\
    pi.TritonCondaEnvInfoR\x13tritonCondaEnvsInfo\"\xc4\x01\n\"GetModelVersi\
    onInputExampleRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emo\
    delVersionId\x12\x1d\n\nexample_id\x18\x04\x20\x01(\tR\texampleId\"\xd6\
    \x01\n$ListModelVersionInputExamplesRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\
    \x18\x03\x20\x01(\tR\x0emodelVersionId\x12\x12\n\x04page\x18\x04\x20\x01\
    (\rR\x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\"\xc4\
    \x01\n&SingleModelVersionInputExampleResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12e\n\x1bmodel\
    _version_input_example\x18\x02\x20\x01(\x0b2&.clarifai.api.ModelVersionI\
    nputExampleR\x18modelVersionInputExample\"\xc5\x01\n%MultiModelVersionIn\
    putExampleResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.a\
    pi.status.StatusR\x06status\x12g\n\x1cmodel_version_input_examples\x18\
    \x02\x20\x03(\x0b2&.clarifai.api.ModelVersionInputExampleR\x19modelVersi\
    onInputExamples\"\xa2\x01\n\x1aListModelReferencesRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\x04page\
    \x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\
    \x07perPage\"\x9b\x01\n\x1bMultiModelReferenceResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12G\n\
    \x10model_references\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.ModelReferen\
    ceR\x0fmodelReferences\"\x80\x01\n\x13MultiOutputResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x124\
    \n\x07outputs\x18\x02\x20\x03(\x0b2\x14.clarifai.api.OutputR\x07outputsB\
    \x04\x80\xb5\x18\x01\"j\n\x11ListScopesRequest\x12\x19\n\x08key_type\x18\
    \x01\x20\x01(\tR\x07keyType\x12:\n\x0buser_app_id\x18\x02\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\"M\n\x0fMyScopesRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\"Q\n\x13MyScopesUserRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\x15\n\x13MyScopes\
    RootRequest\"\xc6\x01\n\x16MultiScopeDepsResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x126\n\nsco\
    pe_deps\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ScopeDepsR\tscopeDeps\x12\
    ?\n\rendpoint_deps\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.EndpointDepsR\
    \x0cendpointDeps\"\xd2\x01\n\x12MultiScopeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x16\n\
    \x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12#\n\x03app\x18\x03\x20\x01(\
    \x0b2\x11.clarifai.api.AppR\x03app\x12\x1c\n\tendpoints\x18\x04\x20\x03(\
    \tR\tendpoints\x12,\n\x12user_feature_flags\x18\x05\x20\x01(\tR\x10userF\
    eatureFlags\"\xb1\x01\n\x16MultiScopeUserResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x16\n\
    \x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x04\
    \x20\x03(\tR\tendpoints\x12,\n\x12user_feature_flags\x18\x05\x20\x01(\tR\
    \x10userFeatureFlags\"\xb1\x01\n\x16MultiScopeRootResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\
    \x04\x20\x03(\tR\tendpoints\x12,\n\x12user_feature_flags\x18\x05\x20\x01\
    (\tR\x10userFeatureFlags\"^\n\x10GetSearchRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\
    \n\x02id\x18\x02\x20\x01(\tR\x02id\"\x80\x01\n\x13ListSearchesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xec\x01\n\x13PostSearchesR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12-\n\x05query\x18\x02\x20\x01(\x0b2\x13.clarifai.\
    api.QueryR\x05queryB\x02\x18\x01\x120\n\x08searches\x18\x03\x20\x03(\x0b\
    2\x14.clarifai.api.SearchR\x08searches\x128\n\npagination\x18\x04\x20\
    \x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"\xa2\x01\n\x1aPatch\
    InputsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\
    \x0b2\x14.clarifai.api.SearchR\x08searches\x12\x16\n\x06action\x18\x03\
    \x20\x01(\tR\x06action\"\xa7\x01\n\x1fPatchAnnotationsSearchesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api\
    .SearchR\x08searches\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\
    \x9c\x01\n\x14PatchSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\
    \x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x12\x16\n\x06act\
    ion\x18\x03\x20\x01(\tR\x06action\"\x9f\x01\n\x17PostSearchesByIDRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x128\n\npaginat\
    ion\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"a\n\
    \x13DeleteSearchRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\t\
    R\x02id\"\xc8\x01\n\x1ePostAnnotationsSearchesRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\
    \n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searche\
    s\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\
    \npagination\"r\n$DeleteAnnotationSearchMetricsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\xe2\x01\n\x19PostInputsSearches\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clari\
    fai.api.SearchR\x08searches\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18\
    .clarifai.api.PaginationR\npagination\x12\x1d\n\nonly_count\x18\x04\x20\
    \x01(\x08R\tonlyCount\"y\n\x14SingleSearchResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12,\n\x06s\
    earch\x18\x05\x20\x01(\x0b2\x14.clarifai.api.SearchR\x06search\"\x9b\x02\
    \n\x13MultiSearchResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\x11.clarifai.api.HitR\x04hit\
    sB\x04\x80\xb5\x18\x01\x12)\n\x05query\x18\x04\x20\x01(\x0b2\x13.clarifa\
    i.api.QueryR\x05query\x120\n\x08searches\x18\x05\x20\x03(\x0b2\x14.clari\
    fai.api.SearchR\x08searches\x125\n\nhit_counts\x18\x06\x20\x03(\x0b2\x16\
    .clarifai.api.HitCountR\thitCounts\"\xd4\x02\n\"PostAnnotationSearchMetr\
    icsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x127\
    \n\x0cground_truth\x18\x03\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0bgro\
    undTruth\x12:\n\x0esearch_to_eval\x18\x04\x20\x01(\x0b2\x14.clarifai.api\
    .SearchR\x0csearchToEval\x12&\n\x04data\x18\x05\x20\x01(\x0b2\x12.clarif\
    ai.api.DataR\x04data\x12E\n\x0fevaluation_type\x18\x06\x20\x01(\x0e2\x1c\
    .clarifai.api.EvaluationTypeR\x0eevaluationType\"o\n!GetAnnotationSearch\
    MetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\
    `\n\"ListAnnotationSearchMetricsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xbe\x01\n$Mul\
    tiAnnotationSearchMetricsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12a\n\x19annotation_search_m\
    etrics\x18\x02\x20\x03(\x0b2%.clarifai.api.AnnotationSearchMetricsR\x17a\
    nnotationSearchMetrics\"\x89\x01\n\x1cListAnnotationFiltersRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per\
    _page\x18\x03\x20\x01(\rR\x07perPage\"\x8a\x01\n\x1aGetAnnotationFilterR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x120\n\x14annotation_filter_id\x18\x02\x20\x01(\tR\
    \x12annotationFilterId\"\xa9\x01\n\x1cPostAnnotationFiltersRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12M\n\x12annotation_filters\x18\x02\x20\x03(\x0b2\x1e.clarifa\
    i.api.AnnotationFilterR\x11annotationFilters\"\xc2\x01\n\x1dPatchAnnotat\
    ionFiltersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12M\n\x12annotation_filters\x18\x02\x20\
    \x03(\x0b2\x1e.clarifai.api.AnnotationFilterR\x11annotationFilters\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x90\x01\n\x1eDeleteAnno\
    tationFiltersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x122\n\x15annotation_filter_ids\x18\
    \x02\x20\x03(\tR\x13annotationFilterIds\"\xa9\x01\n\x1dMultiAnnotationFi\
    lterResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12S\n\x12annotation_filters\x18\x02\x20\x03(\x0b2\
    \x1e.clarifai.api.AnnotationFilterR\x11annotationFiltersB\x04\x80\xb5\
    \x18\x01\"\xa2\x01\n\x1eSingleAnnotationFilterResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12K\n\
    \x11annotation_filter\x18\x02\x20\x01(\x0b2\x1e.clarifai.api.AnnotationF\
    ilterR\x10annotationFilter\"y\n\x0eGetUserRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\
    \x11additional_fields\x18\x02\x20\x03(\tR\x10additionalFields\"q\n\x12Si\
    ngleUserResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api\
    .status.StatusR\x06status\x12&\n\x04user\x18\x02\x20\x01(\x0b2\x12.clari\
    fai.api.UserR\x04user\"\x8d\x01\n\x1bPostValidatePasswordRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x122\n\x08password\x18\x02\x20\x01(\x0b2\x16.clarifai.api.Passwo\
    rdR\x08password\"\xaa\x01\n\x20SinglePasswordValidationResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12Q\n\x13password_violations\x18\x02\x20\x01(\x0b2\x20.clarifai.api.\
    PasswordViolationsR\x12passwordViolations\"\x96\x02\n\x12GetWorkflowRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflow\
    Id\x128\n\x18favor_clarifai_workflows\x18\x03\x20\x01(\x08R\x16favorClar\
    ifaiWorkflows\x12+\n\x11additional_fields\x18\x04\x20\x03(\tR\x10additio\
    nalFields\x12<\n\x1aexclude_clarifai_workflows\x18\x05\x20\x01(\x08R\x18\
    excludeClarifaiWorkflows\"\xbe\x04\n\x14ListWorkflowsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\x12%\n\x0esort_ascending\x18\x05\x20\x01\
    (\x08R\rsortAscending\x12\x1e\n\nsort_by_id\x18\x06\x20\x01(\x08H\0R\x08\
    sortById\x12/\n\x13sort_by_modified_at\x18\x07\x20\x01(\x08H\0R\x10sortB\
    yModifiedAt\x12-\n\x12sort_by_created_at\x18\r\x20\x01(\x08H\0R\x0fsortB\
    yCreatedAt\x12-\n\x12sort_by_star_count\x18\x0e\x20\x01(\x08H\0R\x0fsort\
    ByStarCount\x12\x14\n\x05query\x18\x08\x20\x01(\tR\x05query\x12\x12\n\
    \x02id\x18\x04\x20\x01(\tR\x02idB\x02\x18\x01\x12#\n\rfeatured_only\x18\
    \t\x20\x01(\x08R\x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x0b\x20\x01(\
    \x08R\x0bstarredOnly\x12+\n\x11additional_fields\x18\n\x20\x03(\tR\x10ad\
    ditionalFields\x12\x1f\n\x0bsearch_term\x18\x0c\x20\x01(\tR\nsearchTerm\
    \x12\x1a\n\x08bookmark\x18\x0f\x20\x01(\x08R\x08bookmarkB\t\n\x07sort_by\
    \"\x88\x01\n\x14PostWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflows\
    \x18\x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflows\"\xa1\x01\n\
    \x15PatchWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflows\x18\x02\x20\
    \x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflows\x12\x16\n\x06action\x18\
    \x03\x20\x01(\tR\x06action\"\x9d\x01\n\x17PatchWorkflowIdsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12.\n\x03ids\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSou\
    rceR\x03ids\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"t\n\x15De\
    leteWorkflowRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\
    \x01(\tR\nworkflowId\"\x85\x01\n\x16DeleteWorkflowsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\
    \x03\x20\x01(\x08R\tdeleteAll\"\x81\x01\n\x16SingleWorkflowResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x122\n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\
    \x08workflow\"\x88\x01\n\x15MultiWorkflowResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12:\n\twor\
    kflows\x18\x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflowsB\x04\
    \x80\xb5\x18\x01\"\x84\x03\n\x1aPostWorkflowResultsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12\x1d\n\nver\
    sion_id\x18\x07\x20\x01(\tR\tversionId\x12+\n\x06inputs\x18\x03\x20\x03(\
    \x0b2\x13.clarifai.api.InputR\x06inputs\x12?\n\routput_config\x18\x04\
    \x20\x01(\x0b2\x1a.clarifai.api.OutputConfigR\x0coutputConfig\x128\n\x18\
    favor_clarifai_workflows\x18\x05\x20\x01(\x08R\x16favorClarifaiWorkflows\
    \x12B\n\x0eworkflow_state\x18\x06\x20\x01(\x0b2\x1b.clarifai.api.Workflo\
    wStateR\rworkflowState\"\x82\x02\n\x1bPostWorkflowResultsResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x122\n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\
    \x08workflow\x126\n\x07results\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.Wo\
    rkflowResultR\x07results\x12B\n\x0eworkflow_state\x18\x04\x20\x01(\x0b2\
    \x1b.clarifai.api.WorkflowStateR\rworkflowState\"\xf4\x02\n$PostWorkflow\
    ResultsSimilarityRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\
    \x20\x01(\tR\nworkflowId\x12\x1d\n\nversion_id\x18\x07\x20\x01(\tR\tvers\
    ionId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\
    \x126\n\x0cprobe_inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.InputR\
    \x0bprobeInputs\x124\n\x0bpool_inputs\x18\x05\x20\x03(\x0b2\x13.clarifai\
    .api.InputR\npoolInputs\x128\n\x18favor_clarifai_workflows\x18\x06\x20\
    \x01(\x08R\x16favorClarifaiWorkflows\"\x9f\x01\n%PostWorkflowResultsSimi\
    larityResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.clarifa\
    i.api.WorkflowResultsSimilarityR\x07results\"\xa9\x01\n\x1bListWorkflowV\
    ersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\t\
    R\nworkflowId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xa8\x01\n\x19GetWorkflowVe\
    rsionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\
    \nworkflowId\x12.\n\x13workflow_version_id\x18\x03\x20\x01(\tR\x11workfl\
    owVersionId\"\xae\x01\n\x1dDeleteWorkflowVersionsRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x120\n\x14work\
    flow_version_ids\x18\x03\x20\x03(\tR\x12workflowVersionIds\"\xdf\x01\n\
    \x1cPatchWorkflowVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\
    \x18\x02\x20\x01(\tR\nworkflowId\x12J\n\x11workflow_versions\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.WorkflowVersionR\x10workflowVersions\x12\x16\
    \n\x06action\x18\x04\x20\x01(\tR\x06action\"\xa5\x01\n\x1cMultiWorkflowV\
    ersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x12P\n\x11workflow_versions\x18\x02\x20\x03(\x0b\
    2\x1d.clarifai.api.WorkflowVersionR\x10workflowVersionsB\x04\x80\xb5\x18\
    \x01\"\x9e\x01\n\x1dSingleWorkflowVersionResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12H\n\x10w\
    orkflow_version\x18\x02\x20\x01(\x0b2\x1d.clarifai.api.WorkflowVersionR\
    \x0fworkflowVersion\"\xa1\x01\n\x1aPostAppDuplicationsRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12G\n\x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.Ap\
    pDuplicationR\x0fappDuplications\"\x84\x01\n\x18GetAppDuplicationRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12,\n\x12app_duplication_id\x18\x02\x20\x01(\tR\x10appDu\
    plicationId\"\x87\x01\n\x1aListAppDuplicationsRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\"\x9c\x01\n\x1cMultiAppDuplicationsResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12G\n\x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.A\
    ppDuplicationR\x0fappDuplications\"\x9a\x01\n\x1cSingleAppDuplicationRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12E\n\x0fapp_duplication\x18\x02\x20\x01(\x0b2\x1c.clari\
    fai.api.AppDuplicationR\x0eappDuplication\"x\n\x10PostTasksRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12(\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\
    \x05tasks\"\x92\x01\n\x0eGetTaskRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07ta\
    sk_id\x18\x02\x20\x01(\tR\x06taskId\x12+\n\x11additional_fields\x18\x03\
    \x20\x03(\tR\x10additionalFields\"\xe1\x02\n\x10ListTasksRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_p\
    age\x18\x03\x20\x01(\rR\x07perPage\x12&\n\x0fworker_user_ids\x18\x04\x20\
    \x03(\tR\rworkerUserIds\x12&\n\x0freview_user_ids\x18\x05\x20\x03(\tR\rr\
    eviewUserIds\x12&\n\x0flabel_order_ids\x18\x08\x20\x03(\tR\rlabelOrderId\
    s\x12=\n\x1bincluding_label_order_tasks\x18\x06\x20\x01(\x08R\x18includi\
    ngLabelOrderTasks\x12+\n\x11additional_fields\x18\x07\x20\x03(\tR\x10add\
    itionalFields\"\x91\x01\n\x11PatchTasksRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12(\n\x05t\
    asks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05tasks\x12\x16\n\x06\
    action\x18\x03\x20\x01(\tR\x06action\"b\n\x12DeleteTasksRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"x\n\x11MultiTaskRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12.\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.Ta\
    skR\x05tasksB\x04\x80\xb5\x18\x01\"q\n\x12SingleTaskResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12&\n\x04task\x18\x02\x20\x01(\x0b2\x12.clarifai.api.TaskR\x04task\"\
    \x85\x01\n\x13GetTaskCountRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\
    \x02\x20\x01(\tR\x06taskId\x12\x19\n\x08user_ids\x18\x03\x20\x03(\tR\x07\
    userIds\"\xbc\x01\n\x17SingleTaskCountResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x15\n\x06ap\
    p_id\x18\x02\x20\x01(\tR\x05appId\x12\x17\n\x07task_id\x18\x03\x20\x01(\
    \tR\x06taskId\x12<\n\x06counts\x18\x04\x20\x03(\x0b2$.clarifai.api.TaskS\
    tatusCountPerUserR\x06counts\"\x91\x01\n\x16PostLabelOrdersRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12;\n\x0clabel_orders\x18\x02\x20\x03(\x0b2\x18.clarifai.api.\
    LabelOrderR\x0blabelOrders\"x\n\x14GetLabelOrderRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12$\n\x0elabel_order_id\x18\x02\x20\x01(\tR\x0clabelOrderId\"\x83\x01\
    \n\x16ListLabelOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\
    \xaa\x01\n\x17PatchLabelOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12;\n\x0clabel_ord\
    ers\x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelOrders\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"h\n\x18DeleteLabelOr\
    dersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\
    \x91\x01\n\x17MultiLabelOrderResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12A\n\x0clabel_orders\
    \x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelOrdersB\x04\
    \x80\xb5\x18\x01\"\x8a\x01\n\x18SingleLabelOrderResponse\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\
    \x0blabel_order\x18\x02\x20\x01(\x0b2\x18.clarifai.api.LabelOrderR\nlabe\
    lOrder\"\x8c\x01\n\x15PostCollectorsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncol\
    lectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\"\
    \xa5\x01\n\x16PatchCollectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncollectors\
    \x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\x86\x01\n\x17DeleteCollectors\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\
    \x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"t\n\x13GetCollector\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12!\n\x0ccollector_id\x18\x02\x20\x01(\tR\x0bcoll\
    ectorId\"\x82\x01\n\x15ListCollectorsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\x86\x01\n\x16MultiCollectorResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\
    \n\ncollectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollec\
    tors\"\x85\x01\n\x17SingleCollectorResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x125\n\tcollector\
    \x18\x02\x20\x01(\x0b2\x17.clarifai.api.CollectorR\tcollector\"\x8d\x01\
    \n\x15PostStatValuesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x128\n\x0bstat_values\x18\x02\
    \x20\x03(\x0b2\x17.clarifai.api.StatValueR\nstatValues\"\x8d\x01\n\x16Mu\
    ltiStatValueResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12>\n\x0bstat_values\x18\x02\x20\x03(\x0b\
    2\x17.clarifai.api.StatValueR\nstatValuesB\x04\x80\xb5\x18\x01\"\xc4\x01\
    \n\x1ePostStatValuesAggregateRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12f\n\x1cstat_valu\
    e_aggregate_queries\x18\x02\x20\x03(\x0b2%.clarifai.api.StatValueAggrega\
    teQueryR\x19statValueAggregateQueries\"\xbf\x01\n\x1fMultiStatValueAggre\
    gateResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12g\n\x1cstat_value_aggregate_results\x18\x02\x20\
    \x03(\x0b2&.clarifai.api.StatValueAggregateResultR\x19statValueAggregate\
    Results\"\x96\x01\n\x1ePostTrendingMetricsViewRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1b\n\tview_type\x18\x02\x20\x01(\tR\x08viewType\x12\x1b\n\tobject_id\
    \x18\x03\x20\x01(\tR\x08objectId\"\xa9\x01\n\x1fListTrendingMetricsViews\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x1b\n\tview_type\x18\x02\x20\x01(\tR\x08viewTy\
    pe\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x04\x20\x01(\rR\x07perPage\"\x8f\x01\n\x20MultiTrendingMetricsViewR\
    esponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.S\
    tatusR\x06status\x126\n\x07metrics\x18\x02\x20\x03(\x0b2\x1c.clarifai.ap\
    i.TrendingMetricR\x07metrics\"\x98\x01\n\x10GetModuleRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\x12+\n\x11additi\
    onal_fields\x18\x03\x20\x03(\tR\x10additionalFields\"\xcc\x03\n\x12ListM\
    odulesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04pag\
    e\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12!\n\x0cstarred\
    _only\x18\x04\x20\x01(\x08R\x0bstarredOnly\x12+\n\x11additional_fields\
    \x18\x05\x20\x03(\tR\x10additionalFields\x12%\n\x0esort_ascending\x18\
    \x06\x20\x01(\x08R\rsortAscending\x12-\n\x12sort_by_created_at\x18\x07\
    \x20\x01(\x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_star_count\x18\
    \x08\x20\x01(\x08H\0R\x0fsortByStarCount\x12/\n\x13sort_by_modified_at\
    \x18\t\x20\x01(\x08H\0R\x10sortByModifiedAt\x12\x1e\n\nsort_by_id\x18\
    \x0b\x20\x01(\x08H\0R\x08sortById\x12\x1a\n\x08bookmark\x18\n\x20\x01(\
    \x08R\x08bookmarkB\t\n\x07sort_by\"\x80\x01\n\x12PostModulesRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12.\n\x07modules\x18\x03\x20\x03(\x0b2\x14.clarifai.api.Modul\
    eR\x07modules\"\x99\x01\n\x13PatchModulesRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\
    \x07modules\x18\x02\x20\x03(\x0b2\x14.clarifai.api.ModuleR\x07modules\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"d\n\x14DeleteModules\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"y\n\
    \x14SingleModuleResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clar\
    ifai.api.status.StatusR\x06status\x12,\n\x06module\x18\x02\x20\x01(\x0b2\
    \x14.clarifai.api.ModuleR\x06module\"\x80\x01\n\x13MultiModuleResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x124\n\x07modules\x18\x02\x20\x03(\x0b2\x14.clarifai.api.Modu\
    leR\x07modulesB\x04\x80\xb5\x18\x01\"\x9e\x01\n\x17GetModuleVersionReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\
    \x12*\n\x11module_version_id\x18\x03\x20\x01(\tR\x0fmoduleVersionId\"\
    \xa3\x01\n\x19ListModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodu\
    le_id\x18\x02\x20\x01(\tR\x08moduleId\x12\x12\n\x04page\x18\x03\x20\x01(\
    \rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xba\
    \x01\n\x19PostModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodule_i\
    d\x18\x02\x20\x01(\tR\x08moduleId\x12D\n\x0fmodule_versions\x18\x03\x20\
    \x03(\x0b2\x1b.clarifai.api.ModuleVersionR\x0emoduleVersions\"\x88\x01\n\
    \x1bDeleteModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\
    \x02\x20\x01(\tR\x08moduleId\x12\x10\n\x03ids\x18\x03\x20\x03(\tR\x03ids\
    \"\x96\x01\n\x1bSingleModuleVersionResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12B\n\x0emodule_ve\
    rsion\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.ModuleVersionR\rmoduleVersi\
    on\"\x9d\x01\n\x1aMultiModuleVersionResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12J\n\x0fmodul\
    e_versions\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.ModuleVersionR\x0emodu\
    leVersionsB\x04\x80\xb5\x18\x01\"\x9d\x01\n\x20GetInstalledModuleVersion\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12=\n\x1binstalled_module_version_id\x18\x02\x20\
    \x01(\tR\x18installedModuleVersionId\"\x8f\x01\n\"ListInstalledModuleVer\
    sionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xc2\x01\n\"PostI\
    nstalledModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12`\n\x19installed_module_v\
    ersions\x18\x02\x20\x03(\x0b2$.clarifai.api.InstalledModuleVersionR\x17i\
    nstalledModuleVersions\"\xa2\x01\n%PostInstalledModuleVersionsKeyRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12=\n\x1binstalled_module_version_id\x18\x02\x20\x01(\tR\
    \x18installedModuleVersionId\"t\n$DeleteInstalledModuleVersionsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\xbb\x01\n$S\
    ingleInstalledModuleVersionResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12^\n\x18installed_modu\
    le_version\x18\x02\x20\x01(\x0b2$.clarifai.api.InstalledModuleVersionR\
    \x16installedModuleVersion\"\xc2\x01\n#MultiInstalledModuleVersionRespon\
    se\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Status\
    R\x06status\x12f\n\x19installed_module_versions\x18\x02\x20\x03(\x0b2$.c\
    larifai.api.InstalledModuleVersionR\x17installedModuleVersionsB\x04\x80\
    \xb5\x18\x01\"u\n\x1eListNextTaskAssignmentsRequest\x12:\n\x0buser_app_i\
    d\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\"\x9d\x01\n\x19PostBulkO\
    perationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12D\n\x0fbulk_operations\x18\x02\x20\x03\
    (\x0b2\x1b.clarifai.api.BulkOperationR\x0ebulkOperations\"\x86\x01\n\x19\
    ListBulkOperationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"e\
    \n\x17GetBulkOperationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\
    \x01(\tR\x02id\"j\n\x1aCancelBulkOperationRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\
    \n\x03ids\x18\x02\x20\x03(\tR\x03ids\"j\n\x1aDeleteBulkOperationRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x97\x01\n\
    \x1cSingleBulkOperationsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12B\n\x0ebulk_operation\x18\
    \x02\x20\x01(\x0b2\x1b.clarifai.api.BulkOperationR\rbulkOperation\"\x96\
    \x01\n\x1bMultiBulkOperationsResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12B\n\x0ebulk_operation\
    \x18\x02\x20\x03(\x0b2\x1b.clarifai.api.BulkOperationR\rbulkOperation\"\
    \x8b\x01\n\x19PutTaskAssignmentsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07ta\
    sk_id\x18\x02\x20\x01(\tR\x06taskId\x12\x19\n\x08input_id\x18\x03\x20\
    \x01(\tR\x07inputId\"\x85\x01\n\x18ListInputsAddJobsRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\"d\n\x16GetInputsAddJobRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"g\n\x19CancelInputsAd\
    dJobRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\
    \x9a\x01\n\x19MultiInputsAddJobResponse\x123\n\x06status\x18\x01\x20\x01\
    (\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12H\n\x0finputs_add_jo\
    bs\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.InputsAddJobR\rinputsAddJobsB\
    \x04\x80\xb5\x18\x01\"\x93\x01\n\x1aSingleInputsAddJobResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12@\n\x0einputs_add_job\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.Input\
    sAddJobR\x0cinputsAddJob\"\x80\x01\n\x12PostUploadsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12.\n\x07uploads\x18\x02\x20\x03(\x0b2\x14.clarifai.api.UploadR\x07upl\
    oads\"d\n\x14DeleteUploadsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\
    \x20\x03(\tR\x03ids\"\x7f\n\x12ListUploadsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\
    \n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"k\n\x10GetUploadRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\t\
    upload_id\x18\x02\x20\x01(\tR\x08uploadId\"y\n\x14SingleUploadResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12,\n\x06upload\x18\x02\x20\x01(\x0b2\x14.clarifai.api.Uploa\
    dR\x06upload\"z\n\x13MultiUploadResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12.\n\x07uploads\
    \x18\x02\x20\x03(\x0b2\x14.clarifai.api.UploadR\x07uploads\"\xbd\x01\n\
    \x1cPutUploadContentPartsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tupload_id\x18\
    \x02\x20\x01(\tR\x08uploadId\x12D\n\rcontent_parts\x18\x03\x20\x03(\x0b2\
    \x1f.clarifai.api.UploadContentPartR\x0ccontentParts\"\xda\x01\n\x1cPost\
    InputsDataSourcesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12A\n\x0cdata_sources\x18\x02\
    \x20\x03(\x0b2\x1e.clarifai.api.InputsDataSourceR\x0bdataSources\x12\"\n\
    \rcall_back_url\x18\x03\x20\x01(\tR\x0bcallBackUrl\x12\x17\n\x07app_pat\
    \x18\x04\x20\x01(\tR\x06appPat\"\x94\x01\n\x1dGetInputsExtractionJobRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x127\n\x18inputs_extraction_job_id\x18\x02\x20\x01(\tR\
    \x15inputsExtractionJobId\"\x8c\x01\n\x1fListInputsExtractionJobsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xaf\x01\n!SingleInputsExtr\
    actionJobResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x12U\n\x15inputs_extraction_job\x18\x02\x20\
    \x01(\x0b2!.clarifai.api.InputsExtractionJobR\x13inputsExtractionJob\"\
    \xb0\x01\n\x20MultiInputsExtractionJobResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12W\n\x16input\
    s_extraction_jobs\x18\x02\x20\x03(\x0b2!.clarifai.api.InputsExtractionJo\
    bR\x14inputsExtractionJobs\"q\n!CancelInputsExtractionJobsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x99\x01\n\x18PostI\
    nputsUploadsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12A\n\x0einputs_uploads\x18\x02\x20\
    \x03(\x0b2\x1a.clarifai.api.InputsUploadR\rinputsUploads\"k\n\x10GetRunn\
    erRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x1b\n\trunner_id\x18\x02\x20\x01(\tR\x08runn\
    erId\"\x7f\n\x12ListRunnersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"\x80\x01\n\x12PostRunnersRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x07runne\
    rs\x18\x03\x20\x03(\x0b2\x14.clarifai.api.RunnerR\x07runners\"d\n\x14Del\
    eteRunnersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03\
    ids\"y\n\x14SingleRunnerResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12,\n\x06runner\x18\x02\x20\
    \x01(\x0b2\x14.clarifai.api.RunnerR\x06runner\"\x80\x01\n\x13MultiRunner\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x124\n\x07runners\x18\x02\x20\x03(\x0b2\x14.clarifai.a\
    pi.RunnerR\x07runnersB\x04\x80\xb5\x18\x01\"q\n\x16ListRunnerItemsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12\x1b\n\trunner_id\x18\x02\x20\x01(\tR\x08runnerId\"\
    \xe0\x01\n\x1cPostRunnerItemOutputsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\trunn\
    er_id\x18\x02\x20\x01(\tR\x08runnerId\x12\x17\n\x07item_id\x18\x03\x20\
    \x01(\tR\x06itemId\x12N\n\x13runner_item_outputs\x18\x04\x20\x03(\x0b2\
    \x1e.clarifai.api.RunnerItemOutputR\x11runnerItemOutputs\"\x84\x01\n\x17\
    MultiRunnerItemResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x124\n\x05items\x18\x02\x20\x03(\x0b2\
    \x18.clarifai.api.RunnerItemR\x05itemsB\x04\x80\xb5\x18\x01\"\xa2\x01\n\
    \nRunnerItem\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x20\n\x0bdesc\
    ription\x18\x02\x20\x01(\tR\x0bdescription\x12b\n\x1apost_model_outputs_\
    request\x18\x03\x20\x01(\x0b2%.clarifai.api.PostModelOutputsRequestR\x17\
    postModelOutputsRequest\"i\n\x10RunnerItemOutput\x12U\n\x15multi_output_\
    response\x18\x01\x20\x01(\x0b2!.clarifai.api.MultiOutputResponseR\x13mul\
    tiOutputResponse\"\xaa\x01\n\x1dMultiRunnerItemOutputResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12T\n\x13runner_item_outputs\x18\x02\x20\x03(\x0b2\x1e.clarifai.api.Ru\
    nnerItemOutputR\x11runnerItemOutputsB\x04\x80\xb5\x18\x01*p\n\x1cOrganiz\
    ationInvitationStatus\x12\x0b\n\x07NOT_SET\x10\0\x12\x0b\n\x07PENDING\
    \x10\x01\x12\x0c\n\x08ACCEPTED\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\
    \x0c\n\x08DECLINED\x10\x04\x12\x0b\n\x07EXPIRED\x10\x052\xc1\x8b\x03\n\
    \x02V2\x12\xae\x02\n\x14ListConceptRelations\x12).clarifai.api.ListConce\
    ptRelationsRequest\x1a*.clarifai.api.MultiConceptRelationResponse\"\xbe\
    \x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\xab\x01\x12\
    Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{con\
    cept_id}/relationsZN\x12L/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/concepts/relations\x12\xe3\x01\n\x14PostConceptRelations\x12)\
    .clarifai.api.PostConceptRelationsRequest\x1a*.clarifai.api.MultiConcept\
    RelationResponse\"t\x98\x9c'\x05\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\
    \xd3\xe4\x93\x02^\"Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/concepts/{concept_id}/relations:\x01*\x12\xe2\x01\n\x16DeleteConce\
    ptRelations\x12+.clarifai.api.DeleteConceptRelationsRequest\x1a!.clarifa\
    i.api.status.BaseResponse\"x\x98\x9c'\x05\x90\x9c'-\x90\x9c'\r\x90\x9c'\
    \n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02^*Y/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/concepts/{concept_id}/relations:\x01*\x12\xe0\
    \x01\n\x10GetConceptCounts\x12%.clarifai.api.GetConceptCountsRequest\x1a\
    '.clarifai.api.MultiConceptCountResponse\"|\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02b\x12I/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/concepts/statusZ\x15\x12\x13\
    /v2/concepts/status\x12\xd5\x01\n\nGetConcept\x12\x1f.clarifai.api.GetCo\
    nceptRequest\x1a#.clarifai.api.SingleConceptResponse\"\x80\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02n\x12O/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}Z\x1b\x12\
    \x19/v2/concepts/{concept_id}\x12\xbd\x01\n\x0cListConcepts\x12!.clarifa\
    i.api.ListConceptsRequest\x1a\".clarifai.api.MultiConceptResponse\"f\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02T\x12B/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/conceptsZ\x0e\x12\x0c/v2/con\
    cepts\x12\xbd\x02\n\x11ListModelConcepts\x12&.clarifai.api.ListModelConc\
    eptsRequest\x1a\".clarifai.api.MultiConceptResponse\"\xdb\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xc4\x01\x12\
    T/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model\
    _id}/conceptsZl\x12j/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/models/{model_id}/versions/{version_id}/concepts\x12\xee\x01\n\x14\
    PostConceptsSearches\x12).clarifai.api.PostConceptsSearchesRequest\x1a\"\
    .clarifai.api.MultiConceptResponse\"\x86\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02l\"K/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/concepts/searches:\x01*Z\
    \x1a\"\x15/v2/concepts/searches:\x01*\x12\xc7\x01\n\x0cPostConcepts\x12!\
    .clarifai.api.PostConceptsRequest\x1a\".clarifai.api.MultiConceptRespons\
    e\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02Z\
    \"B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts:\
    \x01*Z\x11\"\x0c/v2/concepts:\x01*\x12\xc9\x01\n\rPatchConcepts\x12\".cl\
    arifai.api.PatchConceptsRequest\x1a\".clarifai.api.MultiConceptResponse\
    \"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02Z2\
    B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts:\x01\
    *Z\x112\x0c/v2/concepts:\x01*\x12\x98\x02\n\x12GetConceptLanguage\x12'.c\
    larifai.api.GetConceptLanguageRequest\x1a+.clarifai.api.SingleConceptLan\
    guageResponse\"\xab\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\
    \x93\x02\x98\x01\x12d/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/concepts/{concept_id}/languages/{language}Z0\x12./v2/concepts/{co\
    ncept_id}/languages/{language}\x12\x85\x02\n\x14ListConceptLanguages\x12\
    ).clarifai.api.ListConceptLanguagesRequest\x1a*.clarifai.api.MultiConcep\
    tLanguageResponse\"\x95\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\
    \xe4\x93\x02\x82\x01\x12Y/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/concepts/{concept_id}/languagesZ%\x12#/v2/concepts/{concept_i\
    d}/languages\x12\x8f\x02\n\x14PostConceptLanguages\x12).clarifai.api.Pos\
    tConceptLanguagesRequest\x1a*.clarifai.api.MultiConceptLanguageResponse\
    \"\x9f\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\
    \x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/concepts/{concept_id}/languages:\x01*Z(\"#/v2/concepts/{concept_id}\
    /languages:\x01*\x12\x91\x02\n\x15PatchConceptLanguages\x12*.clarifai.ap\
    i.PatchConceptLanguagesRequest\x1a*.clarifai.api.MultiConceptLanguageRes\
    ponse\"\x9f\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\
    \xe4\x93\x02\x88\x012Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/concepts/{concept_id}/languages:\x01*Z(2#/v2/concepts/{concept_i\
    d}/languages:\x01*\x12\xf5\x01\n\x13ListKnowledgeGraphs\x12(.clarifai.ap\
    i.ListKnowledgeGraphsRequest\x1a).clarifai.api.MultiKnowledgeGraphRespon\
    se\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02v\
    \x12S/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/\
    knowledge_graphsZ\x1f\x12\x1d/v2/concepts/knowledge_graphs\x12\xff\x01\n\
    \x13PostKnowledgeGraphs\x12(.clarifai.api.PostKnowledgeGraphsRequest\x1a\
    ).clarifai.api.MultiKnowledgeGraphResponse\"\x92\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02|\"S/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs:\x01*Z\
    \"\"\x1d/v2/concepts/knowledge_graphs:\x01*\x12\x82\x02\n\x16PostConcept\
    MappingJobs\x12+.clarifai.api.PostConceptMappingJobsRequest\x1a,.clarifa\
    i.api.MultiConceptMappingJobResponse\"\x8c\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02v\"P/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/concepts/mappings/jobs:\x01*Z\x1f\"\
    \x1a/v2/concepts/mappings/jobs:\x01*\x12\x97\x02\n\rGetAnnotation\x12\".\
    clarifai.api.GetAnnotationRequest\x1a&.clarifai.api.SingleAnnotationResp\
    onse\"\xb9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\
    \x0f\x82\xd3\xe4\x93\x02\x9e\x01\x12g/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}Z3\
    \x121/v2/inputs/{input_id}/annotations/{annotation_id}\x12\xd4\x01\n\x0f\
    ListAnnotations\x12$.clarifai.api.ListAnnotationsRequest\x1a%.clarifai.a\
    pi.MultiAnnotationResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02Z\x12E/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/annotationsZ\x11\x12\x0f/v2/annotations\x12\
    \xe7\x01\n\x0fPostAnnotations\x12$.clarifai.api.PostAnnotationsRequest\
    \x1a%.clarifai.api.MultiAnnotationResponse\"\x86\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02`\"E/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/annotations:\x01*Z\x14\"\x0f/v2/annotations:\x01*\x12\
    \xe9\x01\n\x10PatchAnnotations\x12%.clarifai.api.PatchAnnotationsRequest\
    \x1a%.clarifai.api.MultiAnnotationResponse\"\x86\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x13\x90\
    \x9c'\x0f\x82\xd3\xe4\x93\x02`2E/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/annotations:\x01*Z\x142\x0f/v2/annotations:\x01*\x12\
    \xf8\x01\n\x16PatchAnnotationsStatus\x12+.clarifai.api.PatchAnnotationsS\
    tatusRequest\x1a,.clarifai.api.PatchAnnotationsStatusResponse\"\x82\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x13\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02`2[/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/task/{task_id}/annotations/status:\x01*\x12\xa0\
    \x02\n\x10DeleteAnnotation\x12%.clarifai.api.DeleteAnnotationRequest\x1a\
    !.clarifai.api.status.BaseResponse\"\xc1\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\
    \x9e\x01*g/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inpu\
    ts/{input_id}/annotations/{annotation_id}Z3*1/v2/inputs/{input_id}/annot\
    ations/{annotation_id}\x12\xd4\x02\n\x11DeleteAnnotations\x12&.clarifai.\
    api.DeleteAnnotationsRequest\x1a!.clarifai.api.status.BaseResponse\"\xf3\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xd0\x01*L/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/inputs/annotations:\x01*Z\x1b*\x16/v2/input\
    s/annotations:\x01*ZJ*E/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/annotations:\x01*Z\x14*\x0f/v2/annotations:\x01*\x12\xf7\x01\n\
    \x18PatchAnnotationsSearches\x12-.clarifai.api.PatchAnnotationsSearchesR\
    equest\x1a!.clarifai.api.MultiSearchResponse\"\x88\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\xe4\x93\x02r2N/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/annotations/searches:\x01*Z\x1d2\x18/\
    v2/annotations/searches:\x01*\x12\x85\x02\n\x17PostAnnotationsSearches\
    \x12,.clarifai.api.PostAnnotationsSearchesRequest\x1a!.clarifai.api.Mult\
    iSearchResponse\"\x98\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\x02\
    r\"N/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation\
    s/searches:\x01*Z\x1d\"\x18/v2/annotations/searches:\x01*\x12\xd5\x01\n\
    \rGetInputCount\x12\".clarifai.api.GetInputCountRequest\x1a&.clarifai.ap\
    i.SingleInputCountResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/inputs/statusZ\x13\x12\x11/v2/inputs/status\
    \x12\xcd\x01\n\x0cStreamInputs\x12!.clarifai.api.StreamInputsRequest\x1a\
    \x20.clarifai.api.MultiInputResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/inputs/streamZ\x13\x12\x11/v2/inpu\
    ts/stream\x12\x81\x02\n\x0fGetInputSamples\x12$.clarifai.api.GetInputSam\
    plesRequest\x1a*.clarifai.api.MultiInputAnnotationResponse\"\x9b\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\
    \x02\x80\x01\x12X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_i\
    d}/tasks/{task_id}/inputs/samplesZ$\x12\"/v2/tasks/{task_id}/inputs/samp\
    les\x12\xcf\x01\n\x08GetInput\x12\x1d.clarifai.api.GetInputRequest\x1a!.\
    clarifai.api.SingleInputResponse\"\x80\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02f\x12K/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}Z\x17\x12\
    \x15/v2/inputs/{input_id}\x12\x80\x02\n\x15GetInputVideoManifest\x12%.cl\
    arifai.api.GetVideoManifestRequest\x1a&.clarifai.api.GetVideoManifestRes\
    ponse\"\x97\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02\
    \x84\x01\x12Z/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/i\
    nputs/{input_id}/video_manifestZ&\x12$/v2/inputs/{input_id}/video_manife\
    st\x12\xbb\x01\n\nListInputs\x12\x1f.clarifai.api.ListInputsRequest\x1a\
    \x20.clarifai.api.MultiInputResponse\"j\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02P\x12@/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/inputsZ\x0c\x12\n/v2/inputs\x12\
    \xd6\x01\n\nPostInputs\x12\x1f.clarifai.api.PostInputsRequest\x1a\x20.cl\
    arifai.api.MultiInputResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\
    \x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02V\"@/v2/users/{user_app_id.user_id}\
    /apps/{user_app_id.app_id}/inputs:\x01*Z\x0f\"\n/v2/inputs:\x01*\x12\xcf\
    \x01\n\x0bPatchInputs\x12\x20.clarifai.api.PatchInputsRequest\x1a\x20.cl\
    arifai.api.MultiInputResponse\"|\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02V2@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inp\
    uts:\x01*Z\x0f2\n/v2/inputs:\x01*\x12\xe9\x01\n\x0bDeleteInput\x12\x20.c\
    larifai.api.DeleteInputRequest\x1a!.clarifai.api.status.BaseResponse\"\
    \x94\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\
    \x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02f*K/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/\
    {input_id}Z\x17*\x15/v2/inputs/{input_id}\x12\xdb\x01\n\x0cDeleteInputs\
    \x12!.clarifai.api.DeleteInputsRequest\x1a!.clarifai.api.status.BaseResp\
    onse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\
    \x9c'\x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\
    \xe4\x93\x02V*@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /inputs:\x01*Z\x0f*\n/v2/inputs:\x01*\x12\xe2\x01\n\x13PatchInputsSearch\
    es\x12(.clarifai.api.PatchInputsSearchesRequest\x1a!.clarifai.api.MultiS\
    earchResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\xe4\
    \x93\x02h2I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inp\
    uts/searches:\x01*Z\x182\x13/v2/inputs/searches:\x01*\x12\xf1\x01\n\x12P\
    ostInputsSearches\x12'.clarifai.api.PostInputsSearchesRequest\x1a!.clari\
    fai.api.MultiSearchResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/inputs/searches:\x01*Z\x18\"\x13/v2/inputs/searches:\x01*\x12\xa0\
    \x03\n\x10PostModelOutputs\x12%.clarifai.api.PostModelOutputsRequest\x1a\
    !.clarifai.api.MultiOutputResponse\"\xc1\x02\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x02\x82\xd3\xe4\x93\x02\xa6\x02\"i/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/ve\
    rsions/{version_id}/outputs:\x01*Z8\"3/v2/models/{model_id}/versions/{ve\
    rsion_id}/outputs:\x01*ZX\"S/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/models/{model_id}/outputs:\x01*Z\"\"\x1d/v2/models/{model_\
    id}/outputs:\x01*\x12\xef\x01\n\x0cListDatasets\x12!.clarifai.api.ListDa\
    tasetsRequest\x1a\".clarifai.api.MultiDatasetResponse\"\x97\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02\x80\x01\x12B/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasetsZ*\x12(/v2/\
    users/{user_app_id.user_id}/datasetsZ\x0e\x12\x0c/v2/datasets\x12\xd9\
    \x01\n\nGetDataset\x12\x1f.clarifai.api.GetDatasetRequest\x1a#.clarifai.\
    api.SingleDatasetResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\
    \x9c'r\x82\xd3\xe4\x93\x02n\x12O/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/datasets/{dataset_id}Z\x1b\x12\x19/v2/datasets/{datase\
    t_id}\x12\xcb\x01\n\x0cPostDatasets\x12!.clarifai.api.PostDatasetsReques\
    t\x1a\".clarifai.api.MultiDatasetResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'i\x90\x9c'j\x90\x9c'r\x82\xd3\xe4\x93\x02Z\"B/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/datasets:\x01*Z\x11\"\x0c/v2/dataset\
    s:\x01*\x12\xcd\x01\n\rPatchDatasets\x12\".clarifai.api.PatchDatasetsReq\
    uest\x1a\".clarifai.api.MultiDatasetResponse\"t\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'i\x90\x9c'j\x90\x9c'r\x82\xd3\xe4\x93\x02Z2B/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/datasets:\x01*Z\x112\x0c/v2/datas\
    ets:\x01*\x12\xce\x01\n\x0eDeleteDatasets\x12#.clarifai.api.DeleteDatase\
    tsRequest\x1a!.clarifai.api.status.BaseResponse\"t\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'i\x90\x9c'j\x90\x9c'k\x82\xd3\xe4\x93\x02Z*B/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/datasets:\x01*Z\x11*\x0c/v2/data\
    sets:\x01*\x12\x81\x02\n\x11ListDatasetInputs\x12&.clarifai.api.ListData\
    setInputsRequest\x1a'.clarifai.api.MultiDatasetInputResponse\"\x9a\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\x05\x90\x9c'&\x90\x9c'\x0b\
    \x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/datasets/{dataset_id}/inputsZ\"\x12\x20/v2/datasets/{dataset\
    _id}/inputs\x12\x95\x02\n\x0fGetDatasetInput\x12$.clarifai.api.GetDatase\
    tInputRequest\x1a(.clarifai.api.SingleDatasetInputResponse\"\xb1\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\x05\x90\x9c'&\x90\x9c'\x0b\x82\
    \xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/datasets/{dataset_id}/inputs/{input_id}Z-\x12+/v2/dataset\
    s/{dataset_id}/inputs/{input_id}\x12\x8c\x02\n\x11PostDatasetInputs\x12&\
    .clarifai.api.PostDatasetInputsRequest\x1a'.clarifai.api.MultiDatasetInp\
    utResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'\
    \x05\x90\x9c'&\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\x82\x01\"V/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs\
    :\x01*Z%\"\x20/v2/datasets/{dataset_id}/inputs:\x01*\x12\x86\x02\n\x13De\
    leteDatasetInputs\x12(.clarifai.api.DeleteDatasetInputsRequest\x1a!.clar\
    ifai.api.status.BaseResponse\"\xa1\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\
    \x90\x9c'j\x90\x9c'k\x90\x9c'\x05\x82\xd3\xe4\x93\x02\x82\x01*V/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/i\
    nputs:\x01*Z%*\x20/v2/datasets/{dataset_id}/inputs:\x01*\x12\x84\x02\n\
    \x13ListDatasetVersions\x12(.clarifai.api.ListDatasetVersionsRequest\x1a\
    ).clarifai.api.MultiDatasetVersionResponse\"\x97\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02\x80\x01\x12X/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versi\
    onsZ$\x12\"/v2/datasets/{dataset_id}/versions\x12\xab\x02\n\x11GetDatase\
    tVersion\x12&.clarifai.api.GetDatasetVersionRequest\x1a*.clarifai.api.Si\
    ngleDatasetVersionResponse\"\xc1\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\
    \x90\x9c'r\x82\xd3\xe4\x93\x02\xaa\x01\x12m/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_ver\
    sion_id}Z9\x127/v2/datasets/{dataset_id}/versions/{dataset_version_id}\
    \x12\xea\x02\n\x1fListDatasetVersionMetricsGroups\x124.clarifai.api.List\
    DatasetVersionMetricsGroupsRequest\x1a5.clarifai.api.MultiDatasetVersion\
    MetricsGroupResponse\"\xd9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\
    &\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02\xba\x01\x12u/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/vers\
    ions/{dataset_version_id}/metricsZA\x12?/v2/datasets/{dataset_id}/versio\
    ns/{dataset_version_id}/metrics\x12\x92\x02\n\x13PostDatasetVersions\x12\
    (.clarifai.api.PostDatasetVersionsRequest\x1a).clarifai.api.MultiDataset\
    VersionResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\
    \x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x86\x01\"X/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions:\
    \x01*Z'\"\"/v2/datasets/{dataset_id}/versions:\x01*\x12\x8c\x02\n\x14Pat\
    chDatasetVersions\x12).clarifai.api.PatchDatasetVersionsRequest\x1a).cla\
    rifai.api.MultiDatasetVersionResponse\"\x9d\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'i\x90\x9c'j\x82\xd3\xe4\x93\x02\x86\x012X/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions:\x01*\
    Z'2\"/v2/datasets/{dataset_id}/versions:\x01*\x12\x8a\x02\n\x15DeleteDat\
    asetVersions\x12*.clarifai.api.DeleteDatasetVersionsRequest\x1a!.clarifa\
    i.api.status.BaseResponse\"\xa1\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\
    \x9c'j\x90\x9c'k\x82\xd3\xe4\x93\x02\x86\x01*X/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions:\x01*Z'*\
    \"/v2/datasets/{dataset_id}/versions:\x01*\x12\xd4\x02\n\x18PutDatasetVe\
    rsionExports\x12-.clarifai.api.PutDatasetVersionExportsRequest\x1a/.clar\
    ifai.api.MultiDatasetVersionExportResponse\"\xd7\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'i\x90\x9c'j\x82\xd3\xe4\x93\x02\xc0\x01\x1au/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versi\
    ons/{dataset_version_id}/exports:\x01*ZD\x1a?/v2/datasets/{dataset_id}/v\
    ersions/{dataset_version_id}/exports:\x01*\x12\xe9\x01\n\x0cGetModelType\
    \x12!.clarifai.api.GetModelTypeRequest\x1a%.clarifai.api.SingleModelType\
    Response\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02|\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/mode\
    ls/types/{model_type_id}Z\"\x12\x20/v2/models/types/{model_type_id}\x12\
    \x99\x01\n\x16ListOpenSourceLicenses\x12+.clarifai.api.ListOpenSourceLic\
    ensesRequest\x1a,.clarifai.api.ListOpenSourceLicensesResponse\"$\x98\x9c\
    '\x01\x82\xd3\xe4\x93\x02\x1a\x12\x18/v2/open_source_licenses\x12\xcb\
    \x01\n\x0eListModelTypes\x12#.clarifai.api.ListModelTypesRequest\x1a$.cl\
    arifai.api.MultiModelTypeResponse\"n\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\
    \x82\xd3\xe4\x93\x02\\\x12F/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models/typesZ\x12\x12\x10/v2/models/types\x12\xca\x01\n\x08\
    GetModel\x12\x1d.clarifai.api.GetModelRequest\x1a!.clarifai.api.SingleMo\
    delResponse\"|\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\
    \xe4\x93\x02f\x12K/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/models/{model_id}Z\x17\x12\x15/v2/models/{model_id}\x12\x9a\x03\n\
    \x12GetModelOutputInfo\x12\x1d.clarifai.api.GetModelRequest\x1a!.clarifa\
    i.api.SingleModelResponse\"\xc1\x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xaa\x02\x12W/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/models/{model_id}/output_infoZ#\x12!/v2/\
    models/{model_id}/output_infoZo\x12m/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/models/{model_id}/versions/{version_id}/output_inf\
    oZ9\x127/v2/models/{model_id}/versions/{version_id}/output_info\x12\xe2\
    \x01\n\nListModels\x12\x1f.clarifai.api.ListModelsRequest\x1a\x20.clarif\
    ai.api.MultiModelResponse\"\x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02z\x12@/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/modelsZ(\x12&/v2/users/{user_app_id.user_id}/mo\
    delsZ\x0c\x12\n/v2/models\x12\xe7\x01\n\x11GetResourceCounts\x12&.clarif\
    ai.api.GetResourceCountsRequest\x1a'.clarifai.api.GetResourceCountsRespo\
    nse\"\x80\x01\x98\x9c'\x02\x90\x9c'i\x90\x9c'\x0f\x90\x9c'\x13\x90\x9c'm\
    \x90\x9c'-\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/resource_countsZ\x15\x12\x13/v2/resource_counts\
    \x12\xdf\x01\n\x12PostModelsSearches\x12'.clarifai.api.PostModelsSearche\
    sRequest\x1a\x20.clarifai.api.MultiModelResponse\"~\x98\x9c'\x02\x90\x9c\
    '-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/models/searches:\x01*Z\x18\"\x13/v\
    2/models/searches:\x01*\x12\xca\x01\n\nPostModels\x12\x1f.clarifai.api.P\
    ostModelsRequest\x1a!.clarifai.api.SingleModelResponse\"x\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x13\x82\xd3\xe4\x93\x02V\"@/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/models:\x01*Z\x0f\"\n/v2/models:\x01*\x12\xc7\x01\n\x0bPat\
    chModels\x12\x20.clarifai.api.PatchModelsRequest\x1a\x20.clarifai.api.Mu\
    ltiModelResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\
    \x9c'\x0f\x90\x9c'\x1a\x82\xd3\xe4\x93\x02V2@/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/models:\x01*Z\x0f2\n/v2/models:\x01*\x12\
    \xb6\x01\n\rPatchModelIds\x12\".clarifai.api.PatchModelIdsRequest\x1a\
    \x20.clarifai.api.MultiModelResponse\"_\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0e\x90\x9c'\x0f\x82\xd3\xe4\x93\x02I2D/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/models/ids:\x01*\x12\xdd\x01\n\x0bDeleteModel\
    \x12\x20.clarifai.api.DeleteModelRequest\x1a!.clarifai.api.status.BaseRe\
    sponse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\
    \x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02f*K/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}Z\x17*\x15/\
    v2/models/{model_id}\x12\xce\x01\n\x0cDeleteModels\x12!.clarifai.api.Del\
    eteModelsRequest\x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\
    \x13\x82\xd3\xe4\x93\x02V*@/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models:\x01*Z\x0f*\n/v2/models:\x01*\x12\x95\x02\n\x17Patch\
    ModelCheckConsents\x12,.clarifai.api.PatchModelCheckConsentsRequest\x1a,\
    .clarifai.api.MultiModelCheckConsentResponse\"\x9d\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x8a\x012Z/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/models/{model_id}/check_consents:\x01\
    *Z)2$/v2/models/{model_id}/check_consents:\x01*\x12\xf9\x01\n\x12PatchMo\
    delToolkits\x12'.clarifai.api.PatchModelToolkitsRequest\x1a'.clarifai.ap\
    i.MultiModelToolkitResponse\"\x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x82\xd3\xe4\x93\x02~2T/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models/{model_id}/toolkits:\x01*Z#2\x1e/v2/models/{model_id\
    }/toolkits:\x01*\x12\xf9\x01\n\x12PatchModelUseCases\x12'.clarifai.api.P\
    atchModelUseCasesRequest\x1a'.clarifai.api.MultiModelUseCaseResponse\"\
    \x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02~2T/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/u\
    secases:\x01*Z#2\x1e/v2/models/{model_id}/usecases:\x01*\x12\xff\x01\n\
    \x13PatchModelLanguages\x12(.clarifai.api.PatchModelLanguagesRequest\x1a\
    (.clarifai.api.MultiModelLanguageResponse\"\x93\x01\x98\x9c'\x02\x90\x9c\
    '-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x80\x012U/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/models/{model_id}/languages:\x01*Z$2\x1f/\
    v2/models/{model_id}/languages:\x01*\x12\x91\x03\n\x0fListModelInputs\
    \x12$.clarifai.api.ListModelInputsRequest\x1a\x20.clarifai.api.MultiInpu\
    tResponse\"\xb5\x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x96\x02\x12R/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/inputsZ\x1e\
    \x12\x1c/v2/models/{model_id}/inputsZj\x12h/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/inp\
    utsZ4\x122/v2/models/{model_id}/versions/{version_id}/inputs\x12\x8d\x02\
    \n\x0fGetModelVersion\x12$.clarifai.api.GetModelVersionRequest\x1a(.clar\
    ifai.api.SingleModelVersionResponse\"\xa9\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{ver\
    sion_id}Z-\x12+/v2/models/{model_id}/versions/{version_id}\x12\xf5\x01\n\
    \x11ListModelVersions\x12&.clarifai.api.ListModelVersionsRequest\x1a'.cl\
    arifai.api.MultiModelVersionResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02x\x12T/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versionsZ\x20\
    \x12\x1e/v2/models/{model_id}/versions\x12\xbc\x02\n\x1dPostWorkflowVers\
    ionsUnPublish\x122.clarifai.api.PostWorkflowVersionsUnPublishRequest\x1a\
    !.clarifai.api.status.BaseResponse\"\xc3\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'x\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x8c\x01\"\
    [/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{wo\
    rkflow_id}/unpublish:\x01*Z*\"%/v2/workflows/{workflow_id}/unpublish:\
    \x01*\x12\xb4\x02\n\x1bPostWorkflowVersionsPublish\x120.clarifai.api.Pos\
    tWorkflowVersionsPublishRequest\x1a!.clarifai.api.status.BaseResponse\"\
    \xbf\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'w\x90\x9c'&\x90\x9c'\x0b\x90\x9c\
    '\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\
    \x9c'6\x82\xd3\xe4\x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/workflows/{workflow_id}/publish:\x01*Z(\"#/v2/wor\
    kflows/{workflow_id}/publish:\x01*\x12\xa1\x02\n\x18PostModelVersionsPub\
    lish\x12-.clarifai.api.PostModelVersionsPublishRequest\x1a!.clarifai.api\
    .status.BaseResponse\"\xb2\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'u\x90\x9c'\
    &\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\
    \x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02|\"S/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/publish:\x01*Z\
    \"\"\x1d/v2/models/{model_id}/publish:\x01*\x12\xaa\x02\n\x1aPostModelVe\
    rsionsUnPublish\x12/.clarifai.api.PostModelVersionsUnPublishRequest\x1a!\
    .clarifai.api.status.BaseResponse\"\xb7\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'v\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x80\x01\"\
    U/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model\
    _id}/unpublish:\x01*Z$\"\x1f/v2/models/{model_id}/unpublish:\x01*\x12\
    \x91\x02\n\x11PostModelVersions\x12&.clarifai.api.PostModelVersionsReque\
    st\x1a!.clarifai.api.SingleModelResponse\"\xb0\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\
    \x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02~\"T/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/version\
    s:\x01*Z#\"\x1e/v2/models/{model_id}/versions:\x01*\x12\xdf\x01\n\x12Pat\
    chModelVersions\x12'.clarifai.api.PatchModelVersionsRequest\x1a'.clarifa\
    i.api.MultiModelVersionResponse\"w\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\
    \x90\x9c'\x0f\x90\x9c'\x0e\x90\x9c'\x1a\x82\xd3\xe4\x93\x02Y2T/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versio\
    ns:\x01*\x12\x98\x02\n\x12DeleteModelVersion\x12'.clarifai.api.DeleteMod\
    elVersionRequest\x1a!.clarifai.api.status.BaseResponse\"\xb5\x01\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02\x92\x01*a/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}Z-*+/v2/\
    models/{model_id}/versions/{version_id}\x12\xb7\x02\n\x16GetModelVersion\
    Metrics\x12+.clarifai.api.GetModelVersionMetricsRequest\x1a(.clarifai.ap\
    i.SingleModelVersionResponse\"\xc5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\
    \xa2\x01\x12i/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/m\
    odels/{model_id}/versions/{version_id}/metricsZ5\x123/v2/models/{model_i\
    d}/versions/{version_id}/metrics\x12\xd3\x02\n\x17PostModelVersionMetric\
    s\x12,.clarifai.api.PostModelVersionMetricsRequest\x1a(.clarifai.api.Sin\
    gleModelVersionResponse\"\xdf\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\xa8\x01\"i/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/\
    versions/{version_id}/metrics:\x01*Z8\"3/v2/models/{model_id}/versions/{\
    version_id}/metrics:\x01*\x12\xed\x02\n\x1bPostModelVersionEvaluations\
    \x120.clarifai.api.PostModelVersionEvaluationsRequest\x1a&.clarifai.api.\
    MultiEvalMetricsResponse\"\xf3\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\xbc\x01\"s/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/\
    versions/{model_version_id}/evaluations:\x01*ZB\"=/v2/models/{model_id}/\
    versions/{model_version_id}/evaluations:\x01*\x12\xd3\x02\n\x1bListModel\
    VersionEvaluations\x120.clarifai.api.ListModelVersionEvaluationsRequest\
    \x1a&.clarifai.api.MultiEvalMetricsResponse\"\xd9\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\
    \xd3\xe4\x93\x02\xb6\x01\x12s/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/models/{model_id}/versions/{model_version_id}/evaluations\
    Z?\x12=/v2/models/{model_id}/versions/{model_version_id}/evaluations\x12\
    \xf1\x02\n\x19GetModelVersionEvaluation\x12..clarifai.api.GetModelVersio\
    nEvaluationRequest\x1a'.clarifai.api.SingleEvalMetricsResponse\"\xfa\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\
    \x90\x9c'5\x82\xd3\xe4\x93\x02\xd7\x01\x12\x83\x01/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_ve\
    rsion_id}/evaluations/{evaluation_id}ZO\x12M/v2/models/{model_id}/versio\
    ns/{model_version_id}/evaluations/{evaluation_id}\x12\xf8\x01\n\x0fPostE\
    valuations\x12$.clarifai.api.PostEvaluationsRequest\x1a&.clarifai.api.Mu\
    ltiEvalMetricsResponse\"\x96\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02`\"E/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations:\x01*Z\x14\"\
    \x0f/v2/evaluations:\x01*\x12\x8e\x02\n\x0fListEvaluations\x12$.clarifai\
    .api.ListEvaluationsRequest\x1a&.clarifai.api.MultiEvalMetricsResponse\"\
    \xac\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\
    \x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\x89\x01\x12E/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/evaluationsZ-\x12+/v2/users/{user_\
    app_id.user_id}/evaluationsZ\x11\x12\x0f/v2/evaluations\x12\xfb\x01\n\rG\
    etEvaluation\x12\".clarifai.api.GetEvaluationRequest\x1a'.clarifai.api.S\
    ingleEvalMetricsResponse\"\x9c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02z\x12U/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations/{ev\
    aluation_id}Z!\x12\x1f/v2/evaluations/{evaluation_id}\x12\xfb\x01\n\x13L\
    istModelReferences\x12(.clarifai.api.ListModelReferencesRequest\x1a).cla\
    rifai.api.MultiModelReferenceResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/models/{model_id}/referencesZ\"\x12\x20/v2/mode\
    ls/{model_id}/references\x12\xf2\x02\n\x1bGetModelVersionInputExample\
    \x120.clarifai.api.GetModelVersionInputExampleRequest\x1a4.clarifai.api.\
    SingleModelVersionInputExampleResponse\"\xea\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xd7\x01\x12\x83\x01/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model\
    _version_id}/input_examples/{example_id}ZO\x12M/v2/models/{model_id}/ver\
    sions/{model_version_id}/input_examples/{example_id}\x12\xda\x02\n\x1dLi\
    stModelVersionInputExamples\x122.clarifai.api.ListModelVersionInputExamp\
    lesRequest\x1a3.clarifai.api.MultiModelVersionInputExampleResponse\"\xcf\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xbc\x01\x12\
    v/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model\
    _id}/versions/{model_version_id}/input_examplesZB\x12@/v2/models/{model_\
    id}/versions/{model_version_id}/input_examples\x12\xe0\x01\n\x0bGetWorkf\
    low\x12\x20.clarifai.api.GetWorkflowRequest\x1a$.clarifai.api.SingleWork\
    flowResponse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\
    \x82\xd3\xe4\x93\x02r\x12Q/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/workflows/{workflow_id}Z\x1d\x12\x1b/v2/workflows/{workflow_\
    id}\x12\xf5\x01\n\rListWorkflows\x12\".clarifai.api.ListWorkflowsRequest\
    \x1a#.clarifai.api.MultiWorkflowResponse\"\x9a\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x83\x01\x12C/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/workflowsZ+\x12)/v2/users/\
    {user_app_id.user_id}/workflowsZ\x0f\x12\r/v2/workflows\x12\xd0\x01\n\rP\
    ostWorkflows\x12\".clarifai.api.PostWorkflowsRequest\x1a#.clarifai.api.M\
    ultiWorkflowResponse\"v\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x12\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02\\\"C/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/workflows:\x01*Z\x12\"\r/v2/workflows:\x01*\x12\
    \xd2\x01\n\x0ePatchWorkflows\x12#.clarifai.api.PatchWorkflowsRequest\x1a\
    #.clarifai.api.MultiWorkflowResponse\"v\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\xe4\x93\x02\\2C/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/workflows:\x01*Z\x122\r/v2/workf\
    lows:\x01*\x12\xc2\x01\n\x10PatchWorkflowIds\x12%.clarifai.api.PatchWork\
    flowIdsRequest\x1a#.clarifai.api.MultiWorkflowResponse\"b\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\xe4\x93\x02L2G/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/workflows/ids:\x01*\x12\xe7\
    \x01\n\x0eDeleteWorkflow\x12#.clarifai.api.DeleteWorkflowRequest\x1a!.cl\
    arifai.api.status.BaseResponse\"\x8c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x12\x90\x9c'\x15\x90\x9c'\x13\x82\xd3\xe4\x93\x02r*Q/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}Z\x1d*\x1b\
    /v2/workflows/{workflow_id}\x12\xd2\x01\n\x0fDeleteWorkflows\x12$.clarif\
    ai.api.DeleteWorkflowsRequest\x1a!.clarifai.api.status.BaseResponse\"v\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x12\x90\x9c'\x15\x90\x9c'\x13\x82\xd3\
    \xe4\x93\x02\\*C/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/workflows:\x01*Z\x12*\r/v2/workflows:\x01*\x12\x8a\x03\n\x13PostWorkfl\
    owResults\x12(.clarifai.api.PostWorkflowResultsRequest\x1a).clarifai.api\
    .PostWorkflowResultsResponse\"\x9d\x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02\xfe\x01\
    \"o/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{\
    workflow_id}/versions/{version_id}/results:\x01*Z^\"Y/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results:\
    \x01*Z(\"#/v2/workflows/{workflow_id}/results:\x01*\x12\xc9\x03\n\x1dPos\
    tWorkflowResultsSimilarity\x122.clarifai.api.PostWorkflowResultsSimilari\
    tyRequest\x1a3.clarifai.api.PostWorkflowResultsSimilarityResponse\"\xbe\
    \x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02\x9f\x02\"z/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/\
    results/similarity:\x01*Zi\"d/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/workflows/{workflow_id}/results/similarity:\x01*Z3\"./v2/\
    workflows/{workflow_id}/results/similarity:\x01*\x12\x8b\x02\n\x14ListWo\
    rkflowVersions\x12).clarifai.api.ListWorkflowVersionsRequest\x1a*.clarif\
    ai.api.MultiWorkflowVersionResponse\"\x9b\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x84\x01\x12Z/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/version\
    sZ&\x12$/v2/workflows/{workflow_id}/versions\x12\xb4\x02\n\x12GetWorkflo\
    wVersion\x12'.clarifai.api.GetWorkflowVersionRequest\x1a+.clarifai.api.S\
    ingleWorkflowVersionResponse\"\xc7\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\xb0\x01\x12p/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{wo\
    rkflow_version_id}Z<\x12:/v2/workflows/{workflow_id}/versions/{workflow_\
    version_id}\x12\x90\x02\n\x16DeleteWorkflowVersions\x12+.clarifai.api.De\
    leteWorkflowVersionsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa5\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x13\x90\x9c'\x12\x90\x9c'\x15\x82\
    \xd3\xe4\x93\x02\x8a\x01*Z/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/workflows/{workflow_id}/versions:\x01*Z)*$/v2/workflows/{wor\
    kflow_id}/versions:\x01*\x12\x97\x02\n\x15PatchWorkflowVersions\x12*.cla\
    rifai.api.PatchWorkflowVersionsRequest\x1a*.clarifai.api.MultiWorkflowVe\
    rsionResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\
    \x90\x9c'\x12\x82\xd3\xe4\x93\x02\x8a\x012Z/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions:\x01*Z)2$/\
    v2/workflows/{workflow_id}/versions:\x01*\x12\x85\x01\n\x06GetKey\x12\
    \x1b.clarifai.api.GetKeyRequest\x1a\x1f.clarifai.api.SingleKeyResponse\"\
    =\x98\x9c'\x05\x90\x9c'0\x82\xd3\xe4\x93\x02/\x12-/v2/users/{user_app_id\
    .user_id}/keys/{key_id}\x12\x7f\n\x08ListKeys\x12\x1d.clarifai.api.ListK\
    eysRequest\x1a\x1e.clarifai.api.MultiKeyResponse\"4\x98\x9c'\x05\x90\x9c\
    '0\x82\xd3\xe4\x93\x02&\x12$/v2/users/{user_app_id.user_id}/keys\x12\xa3\
    \x01\n\x0bListAppKeys\x12\x20.clarifai.api.ListAppKeysRequest\x1a\x1e.cl\
    arifai.api.MultiKeyResponse\"R\x98\x9c'\x05\x90\x9c'-\x90\x9c'0\x82\xd3\
    \xe4\x93\x02@\x12>/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/keys\x12\x95\x01\n\tDeleteKey\x12\x1e.clarifai.api.DeleteKeyRequest\
    \x1a!.clarifai.api.status.BaseResponse\"E\x98\x9c'\x05\x90\x9c'/\x90\x9c\
    '1\x90\x9c'0\x82\xd3\xe4\x93\x02/*-/v2/users/{user_app_id.user_id}/keys/\
    {key_id}\x12\x8a\x01\n\x08PostKeys\x12\x1d.clarifai.api.PostKeysRequest\
    \x1a\x1e.clarifai.api.MultiKeyResponse\"?\x98\x9c'\x05\x90\x9c'-\x90\x9c\
    '/\x90\x9c'0\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_id}/keys\
    :\x01*\x12\x88\x01\n\tPatchKeys\x12\x1e.clarifai.api.PatchKeysRequest\
    \x1a\x1e.clarifai.api.MultiKeyResponse\";\x98\x9c'\x05\x90\x9c'/\x90\x9c\
    '0\x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/keys:\x01*\x12\
    \xbc\x01\n\x08MyScopes\x12\x1d.clarifai.api.MyScopesRequest\x1a\x20.clar\
    ifai.api.MultiScopeResponse\"o\x98\x9c'\x02\x82\xd3\xe4\x93\x02e\x12B/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopesZ\x0e\x12\
    \x0c/v2/myscopesZ\x0f\x12\r/v2/my_scopes\x12\x8d\x01\n\x0cMyScopesUser\
    \x12!.clarifai.api.MyScopesUserRequest\x1a$.clarifai.api.MultiScopeUserR\
    esponse\"4\x98\x9c'\x05\x82\xd3\xe4\x93\x02*\x12(/v2/users/{user_app_id.\
    user_id}/myscopes\x12u\n\x0cMyScopesRoot\x12!.clarifai.api.MyScopesRootR\
    equest\x1a$.clarifai.api.MultiScopeRootResponse\"\x1c\x98\x9c'\x05\x82\
    \xd3\xe4\x93\x02\x12\x12\x10/v2/myscopesroot\x12\x87\x01\n\nListScopes\
    \x12\x1f.clarifai.api.ListScopesRequest\x1a$.clarifai.api.MultiScopeDeps\
    Response\"2\x98\x9c'\x03\x82\xd3\xe4\x93\x02(\x12&/v2/users/{user_app_id\
    .user_id}/scopes\x12\x95\x01\n\x06GetApp\x12\x1b.clarifai.api.GetAppRequ\
    est\x1a\x1f.clarifai.api.SingleAppResponse\"M\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02;\x129/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}\x12\x8f\x01\n\x08ListApps\x12\x1d.clarifai.api.List\
    AppsRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\
    \x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x022\x12$/v2/users/{user_app_id.user\
    _id}/appsZ\n\x12\x08/v2/apps\x12\xa5\x01\n\tDeleteApp\x12\x1e.clarifai.a\
    pi.DeleteAppRequest\x1a!.clarifai.api.status.BaseResponse\"U\x98\x9c'\
    \x05\x90\x9c',\x90\x9c'.\x90\x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x02;*9/v\
    2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\x12\x92\x01\n\
    \x08PostApps\x12\x1d.clarifai.api.PostAppsRequest\x1a\x1e.clarifai.api.M\
    ultiAppResponse\"G\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x90\x9c'\x0f\x90\x9c\
    '\x13\x90\x9c'\x12\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_id\
    }/apps:\x01*\x12\x88\x01\n\tPatchApps\x12\x1e.clarifai.api.PatchAppsRequ\
    est\x1a\x1e.clarifai.api.MultiAppResponse\";\x98\x9c'\x05\x90\x9c',\x90\
    \x9c'-\x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/apps:\x01*\
    \x12\x92\x01\n\x0cPatchAppsIds\x12!.clarifai.api.PatchAppsIdsRequest\x1a\
    \x1e.clarifai.api.MultiAppResponse\"?\x98\x9c'\x05\x90\x9c',\x90\x9c'-\
    \x82\xd3\xe4\x93\x02-2(/v2/users/{user_app_id.user_id}/apps/ids:\x01*\
    \x12\x9c\x01\n\x08PatchApp\x12\x1d.clarifai.api.PatchAppRequest\x1a\x1f.\
    clarifai.api.SingleAppResponse\"P\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x82\
    \xd3\xe4\x93\x02>29/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}:\x01*\x12\x9f\x01\n\x10PostAppsSearches\x12%.clarifai.api.PostAppsS\
    earchesRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\
    \x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x022\"-/v2/users/{user_app_id.user_i\
    d}/apps/searches:\x01*\x12v\n\x07GetUser\x12\x1c.clarifai.api.GetUserReq\
    uest\x1a\x20.clarifai.api.SingleUserResponse\"+\x98\x9c'\x05\x82\xd3\xe4\
    \x93\x02!\x12\x1f/v2/users/{user_app_id.user_id}\x12\xcf\x01\n\x14PostVa\
    lidatePassword\x12).clarifai.api.PostValidatePasswordRequest\x1a..clarif\
    ai.api.SinglePasswordValidationResponse\"\\\x98\x9c'\x03\x82\xd3\xe4\x93\
    \x02R\"1/v2/users/{user_app_id.user_id}/validate_password:\x01*Z\x1a\"\
    \x15/v2/validate_password:\x01*\x12\xc1\x01\n\tGetSearch\x12\x1e.clarifa\
    i.api.GetSearchRequest\x1a\".clarifai.api.SingleSearchResponse\"p\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/searches/{id}Z\x13\x12\x11/v2/s\
    earches/{id}\x12\xbc\x01\n\x0cListSearches\x12!.clarifai.api.ListSearche\
    sRequest\x1a!.clarifai.api.MultiSearchResponse\"f\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'r\x82\xd3\xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/searchesZ\x0e\x12\x0c/v2/searches\x12\xc8\x01\n\rP\
    atchSearches\x12\".clarifai.api.PatchSearchesRequest\x1a!.clarifai.api.M\
    ultiSearchResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\
    \xe4\x93\x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /searches:\x01*Z\x112\x0c/v2/searches:\x01*\x12\xda\x01\n\x0cPostSearche\
    s\x12!.clarifai.api.PostSearchesRequest\x1a!.clarifai.api.MultiSearchRes\
    ponse\"\x83\x01\x88\x02\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02Z\"B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/search\
    es:\x01*Z\x11\"\x0c/v2/searches:\x01*\x12\xd8\x01\n\x10PostSearchesByID\
    \x12%.clarifai.api.PostSearchesByIDRequest\x1a!.clarifai.api.MultiSearch\
    Response\"z\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c'\x03\x82\xd3\xe4\
    \x93\x02d\"G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/se\
    arches/{id}:\x01*Z\x16\"\x11/v2/searches/{id}:\x01*\x12\xb3\x02\n\x1bPos\
    tAnnotationSearchMetrics\x120.clarifai.api.PostAnnotationSearchMetricsRe\
    quest\x1a2.clarifai.api.MultiAnnotationSearchMetricsResponse\"\xad\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\
    \x90\x9c'6\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x82\x01\"V/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searche\
    s/metrics:\x01*Z%\"\x20/v2/annotations/searches/metrics:\x01*\x12\xa9\
    \x02\n\x1aGetAnnotationSearchMetrics\x12/.clarifai.api.GetAnnotationSear\
    chMetricsRequest\x1a2.clarifai.api.MultiAnnotationSearchMetricsResponse\
    \"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\
    \x90\x9c'5\x82\xd3\xe4\x93\x02\x86\x01\x12[/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}Z'\x12%/v2\
    /annotations/searches/metrics/{id}\x12\xa0\x02\n\x1bListAnnotationSearch\
    Metrics\x120.clarifai.api.ListAnnotationSearchMetricsRequest\x1a2.clarif\
    ai.api.MultiAnnotationSearchMetricsResponse\"\x9a\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\
    |\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotati\
    ons/searches/metricsZ\"\x12\x20/v2/annotations/searches/metrics\x12\x9a\
    \x02\n\x1dDeleteAnnotationSearchMetrics\x122.clarifai.api.DeleteAnnotati\
    onSearchMetricsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'5\x90\x9c'6\x90\x9c'?\x82\xd3\xe4\x93\
    \x02\x86\x01*[/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    annotations/searches/metrics/{id}Z'*%/v2/annotations/searches/metrics/{i\
    d}\x12\xce\x01\n\x0cDeleteSearch\x12!.clarifai.api.DeleteSearchRequest\
    \x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c\
    'r\x90\x9c's\x90\x9c't\x82\xd3\xe4\x93\x02^*G/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/searches/{id}Z\x13*\x11/v2/searches/{id}\
    \x12\xec\x01\n\x15ListAnnotationFilters\x12*.clarifai.api.ListAnnotation\
    FiltersRequest\x1a+.clarifai.api.MultiAnnotationFilterResponse\"z\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02h\x12L/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/annotation_filtersZ\x18\x12\x16\
    /v2/annotation_filters\x12\x99\x02\n\x13GetAnnotationFilter\x12(.clarifa\
    i.api.GetAnnotationFilterRequest\x1a,.clarifai.api.SingleAnnotationFilte\
    rResponse\"\xa9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02\
    \x96\x01\x12c/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/a\
    nnotation_filters/{annotation_filter_id}Z/\x12-/v2/annotation_filters/{a\
    nnotation_filter_id}\x12\xf7\x01\n\x15PostAnnotationFilters\x12*.clarifa\
    i.api.PostAnnotationFiltersRequest\x1a+.clarifai.api.MultiAnnotationFilt\
    erResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x82\xd3\
    \xe4\x93\x02n\"L/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/annotation_filters:\x01*Z\x1b\"\x16/v2/annotation_filters:\x01*\x12\
    \xf9\x01\n\x16PatchAnnotationFilters\x12+.clarifai.api.PatchAnnotationFi\
    ltersRequest\x1a+.clarifai.api.MultiAnnotationFilterResponse\"\x84\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x82\xd3\xe4\x93\x02n2L/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters:\
    \x01*Z\x1b2\x16/v2/annotation_filters:\x01*\x12\xf1\x01\n\x17DeleteAnnot\
    ationFilters\x12,.clarifai.api.DeleteAnnotationFiltersRequest\x1a!.clari\
    fai.api.status.BaseResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\
    \x90\x9c's\x82\xd3\xe4\x93\x02n*L/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/annotation_filters:\x01*Z\x1b*\x16/v2/annotation_filt\
    ers:\x01*\x12|\n\x0fListStatusCodes\x12$.clarifai.api.ListStatusCodesReq\
    uest\x1a%.clarifai.api.MultiStatusCodeResponse\"\x1c\x98\x9c'\x01\x82\
    \xd3\xe4\x93\x02\x12\x12\x10/v2/status_codes\x12\x8a\x01\n\rGetStatusCod\
    e\x12\".clarifai.api.GetStatusCodeRequest\x1a&.clarifai.api.SingleStatus\
    CodeResponse\"-\x98\x9c'\x01\x82\xd3\xe4\x93\x02#\x12!/v2/status_codes/{\
    status_code_id}\x12\xc2\x01\n\x11ListCollaborators\x12&.clarifai.api.Lis\
    tCollaboratorsRequest\x1a(.clarifai.api.MultiCollaboratorsResponse\"[\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'2\x82\xd3\xe4\x93\x02I\x12G/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/collaborators\x12\xc9\x01\n\
    \x11PostCollaborators\x12&.clarifai.api.PostCollaboratorsRequest\x1a(.cl\
    arifai.api.MultiCollaboratorsResponse\"b\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    3\x90\x9c'2\x82\xd3\xe4\x93\x02L\"G/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/collaborators:\x01*\x12\xcf\x01\n\x12PatchCollabora\
    tors\x12'.clarifai.api.PatchCollaboratorsRequest\x1a(.clarifai.api.Multi\
    CollaboratorsResponse\"f\x98\x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x90\
    \x9c'4\x82\xd3\xe4\x93\x02L2G/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/collaborators:\x01*\x12\xd2\x01\n\x13DeleteCollaborators\
    \x12(.clarifai.api.DeleteCollaboratorsRequest\x1a!.clarifai.api.status.B\
    aseResponse\"n\x98\x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x90\x9c'4\x90\
    \x9c'7\x90\x9c'8\x82\xd3\xe4\x93\x02L*G/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/collaborators:\x01*\x12\xa4\x01\n\x12ListCollab\
    orations\x12'.clarifai.api.ListCollaborationsRequest\x1a).clarifai.api.M\
    ultiCollaborationsResponse\":\x98\x9c'\x03\x82\xd3\xe4\x93\x020\x12./v2/\
    users/{user_app_id.user_id}/collaborations\x12\xf3\x01\n\x13PostAppDupli\
    cations\x12(.clarifai.api.PostAppDuplicationsRequest\x1a*.clarifai.api.M\
    ultiAppDuplicationsResponse\"\x85\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\n\x90\x9c'\x0b\x90\x9c'\x04\x90\
    \x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02K\"F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/duplic\
    ations:\x01*\x12\xa5\x01\n\x13ListAppDuplications\x12(.clarifai.api.List\
    AppDuplicationsRequest\x1a*.clarifai.api.MultiAppDuplicationsResponse\"8\
    \x98\x9c'\x05\x82\xd3\xe4\x93\x02.\x12,/v2/users/{user_app_id.user_id}/d\
    uplications\x12\xb6\x01\n\x11GetAppDuplication\x12&.clarifai.api.GetAppD\
    uplicationRequest\x1a*.clarifai.api.SingleAppDuplicationResponse\"M\x98\
    \x9c'\x05\x82\xd3\xe4\x93\x02C\x12A/v2/users/{user_app_id.user_id}/dupli\
    cations/{app_duplication_id}\x12\xd9\x01\n\tPostTasks\x12\x1e.clarifai.a\
    pi.PostTasksRequest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x8a\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'\x03\x90\
    \x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x82\
    \xd3\xe4\x93\x02T\"?/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/tasks:\x01*Z\x0e\"\t/v2/tasks:\x01*\x12\xfe\x01\n\x16GetTaskAnnota\
    tionCount\x12!.clarifai.api.GetTaskCountRequest\x1a%.clarifai.api.Single\
    TaskCountResponse\"\x99\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x82\xd3\xe4\
    \x93\x02\x86\x01\x12[/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/tasks/{task_id}/annotations/countZ'\x12%/v2/tasks/{task_id}/annot\
    ations/count\x12\xee\x01\n\x11GetTaskInputCount\x12!.clarifai.api.GetTas\
    kCountRequest\x1a%.clarifai.api.SingleTaskCountResponse\"\x8e\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'8\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/countZ\"\
    \x12\x20/v2/tasks/{task_id}/inputs/count\x12\xd0\x01\n\x07GetTask\x12\
    \x1c.clarifai.api.GetTaskRequest\x1a\x20.clarifai.api.SingleTaskResponse\
    \"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x90\x9c'r\x90\x9c'\x0b\x90\
    \x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/tasks/{task_id}Z\x15\x12\x13/v2/tasks/\
    {task_id}\x12\xbe\x01\n\tListTasks\x12\x1e.clarifai.api.ListTasksRequest\
    \x1a\x1f.clarifai.api.MultiTaskResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'8\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02N\x12?/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task\
    sZ\x0b\x12\t/v2/tasks\x12\xd7\x01\n\nPatchTasks\x12\x1f.clarifai.api.Pat\
    chTasksRequest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x86\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'r\x90\x9c'\x0b\
    \x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x82\xd3\xe4\x93\x02T2?/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e2\
    \t/v2/tasks:\x01*\x12\xc2\x01\n\x0bDeleteTasks\x12\x20.clarifai.api.Dele\
    teTasksRequest\x1a!.clarifai.api.status.BaseResponse\"n\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02T*?/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e*\t/v2/task\
    s:\x01*\x12\xf5\x01\n\x0fPostLabelOrders\x12$.clarifai.api.PostLabelOrde\
    rsRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"\x94\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\
    \x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02b\"F/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders:\x01\
    *Z\x15\"\x10/v2/label_orders:\x01*\x12\xf6\x01\n\rGetLabelOrder\x12\".cl\
    arifai.api.GetLabelOrderRequest\x1a&.clarifai.api.SingleLabelOrderRespon\
    se\"\x98\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'\x0b\x90\x9c'8\x82\
    \xd3\xe4\x93\x02~\x12W/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/label_orders/{label_order_id}Z#\x12!/v2/label_orders/{label_orde\
    r_id}\x12\xd6\x01\n\x0fListLabelOrders\x12$.clarifai.api.ListLabelOrders\
    Request\x1a%.clarifai.api.MultiLabelOrderResponse\"v\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'C\x90\x9c'\x0b\x90\x9c'8\x82\xd3\xe4\x93\x02\\\x12F/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_ordersZ\x12\
    \x12\x10/v2/label_orders\x12\xeb\x01\n\x10PatchLabelOrders\x12%.clarifai\
    .api.PatchLabelOrdersRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"\
    \x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'D\x90\x9c'\x0b\x90\x9c\
    '7\x90\x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02b2F/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/label_orders:\x01*Z\x152\x10/v2/label_ord\
    ers:\x01*\x12\xe5\x01\n\x11DeleteLabelOrders\x12&.clarifai.api.DeleteLab\
    elOrdersRequest\x1a!.clarifai.api.status.BaseResponse\"\x84\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'E\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\x9c'8\x82\xd3\
    \xe4\x93\x02b*F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /label_orders:\x01*Z\x15*\x10/v2/label_orders:\x01*\x12\xf2\x01\n\x0ePos\
    tCollectors\x12#.clarifai.api.PostCollectorsRequest\x1a$.clarifai.api.Mu\
    ltiCollectorResponse\"\x94\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x04\x90\
    \x9c'%\x90\x9c'&\x90\x9c')\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\
    \x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02^\"D/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x13\"\x0e\
    /v2/collectors:\x01*\x12\xe3\x01\n\x0cGetCollector\x12!.clarifai.api.Get\
    CollectorRequest\x1a%.clarifai.api.SingleCollectorResponse\"\x88\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'*\x82\xd3\xe4\x93\x02v\x12S/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/collectors/{collector_id}Z\x1f\
    \x12\x1d/v2/collectors/{collector_id}\x12\xc7\x01\n\x0eListCollectors\
    \x12#.clarifai.api.ListCollectorsRequest\x1a$.clarifai.api.MultiCollecto\
    rResponse\"j\x98\x9c'\x02\x90\x9c'-\x90\x9c'*\x82\xd3\xe4\x93\x02X\x12D/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectorsZ\x10\
    \x12\x0e/v2/collectors\x12\xd3\x01\n\x0fPatchCollectors\x12$.clarifai.ap\
    i.PatchCollectorsRequest\x1a$.clarifai.api.MultiCollectorResponse\"t\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c')\x90\x9c'*\x82\xd3\xe4\x93\x02^2D/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x132\
    \x0e/v2/collectors:\x01*\x12\xd6\x01\n\x10DeleteCollectors\x12%.clarifai\
    .api.DeleteCollectorsRequest\x1a!.clarifai.api.status.BaseResponse\"x\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c')\x90\x9c'+\x90\x9c'*\x82\xd3\xe4\x93\
    \x02^*D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collect\
    ors:\x01*Z\x13*\x0e/v2/collectors:\x01*\x12\xc9\x01\n\x0ePostStatValues\
    \x12#.clarifai.api.PostStatValuesRequest\x1a$.clarifai.api.MultiStatValu\
    eResponse\"l\x98\x9c'\x02\x82\xd3\xe4\x93\x02b\"F/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/stats/values:\x01*Z\x15\"\x10/v2/stat\
    s/values:\x01*\x12\xfd\x01\n\x17PostStatValuesAggregate\x12,.clarifai.ap\
    i.PostStatValuesAggregateRequest\x1a-.clarifai.api.MultiStatValueAggrega\
    teResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x82\xd3\xe4\x93\x02v\"P/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values/aggreg\
    ate:\x01*Z\x1f\"\x1a/v2/stats/values/aggregate:\x01*\x12\xe3\x01\n\x17Po\
    stTrendingMetricsView\x12,.clarifai.api.PostTrendingMetricsViewRequest\
    \x1a!.clarifai.api.status.BaseResponse\"w\x98\x9c'\x02\x82\xd3\xe4\x93\
    \x02m\"h/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trendi\
    ng_metrics/views/{view_type}/{object_id}:\x01*\x12\x8f\x02\n\x18ListTren\
    dingMetricsViews\x12-.clarifai.api.ListTrendingMetricsViewsRequest\x1a..\
    clarifai.api.MultiTrendingMetricsViewResponse\"\x93\x01\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02\x88\x01\x12\\/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/trending_metrics/views/{view_type}Z(\x12&/v2/trending_me\
    trics/views/{view_type}\x12\xb2\x01\n\tGetModule\x12\x1e.clarifai.api.Ge\
    tModuleRequest\x1a\".clarifai.api.SingleModuleResponse\"a\x98\x9c'\x05\
    \x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\x02O\x12M/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/modules/{module_id}\x12\xe4\x01\n\x0bLis\
    tModules\x12\x20.clarifai.api.ListModulesRequest\x1a!.clarifai.api.Multi\
    ModuleResponse\"\x8f\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\
    \x93\x02}\x12A/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    modulesZ)\x12'/v2/users/{user_app_id.user_id}/modulesZ\r\x12\x0b/v2/modu\
    les\x12\xb0\x01\n\x0bPostModules\x12\x20.clarifai.api.PostModulesRequest\
    \x1a!.clarifai.api.MultiModuleResponse\"\\\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02F\"A/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/modules:\x01*\x12\xb2\x01\n\x0cPatchModules\
    \x12!.clarifai.api.PatchModulesRequest\x1a!.clarifai.api.MultiModuleResp\
    onse\"\\\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02F\
    2A/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules:\x01\
    *\x12\xd0\x01\n\rDeleteModules\x12\".clarifai.api.DeleteModulesRequest\
    \x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x05\x90\x9c'-\x90\x9c\
    'l\x90\x9c'n\x90\x9c'm\x90\x9c'p\x90\x9c'o\x90\x9c'q\x90\x9c'1\x90\x9c'0\
    \x90\x9c'/\x82\xd3\xe4\x93\x02F*A/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/modules:\x01*\x12\xe4\x01\n\x10GetModuleVersion\x12%.\
    clarifai.api.GetModuleVersionRequest\x1a).clarifai.api.SingleModuleVersi\
    onResponse\"~\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\x02l\x12j\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{modul\
    e_id}/versions/{module_version_id}\x12\xd3\x01\n\x12ListModuleVersions\
    \x12'.clarifai.api.ListModuleVersionsRequest\x1a(.clarifai.api.MultiModu\
    leVersionResponse\"j\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\
    \x02X\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modu\
    les/{module_id}/versions\x12\xda\x01\n\x12PostModuleVersions\x12'.clarif\
    ai.api.PostModuleVersionsRequest\x1a(.clarifai.api.MultiModuleVersionRes\
    ponse\"q\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02[\
    \"V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{mo\
    dule_id}/versions:\x01*\x12\xf4\x01\n\x14DeleteModuleVersions\x12).clari\
    fai.api.DeleteModuleVersionsRequest\x1a!.clarifai.api.status.BaseRespons\
    e\"\x8d\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'n\x90\x9c'm\x90\x9c\
    'p\x90\x9c'o\x90\x9c'q\x90\x9c'1\x90\x9c'0\x90\x9c'/\x82\xd3\xe4\x93\x02\
    [*V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{mo\
    dule_id}/versions:\x01*\x12\x8f\x02\n\x19GetInstalledModuleVersion\x12..\
    clarifai.api.GetInstalledModuleVersionRequest\x1a2.clarifai.api.SingleIn\
    stalledModuleVersionResponse\"\x8d\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'p\
    \x90\x9c'm\x90\x9c'0\x82\xd3\xe4\x93\x02s\x12q/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/installed_module_versions/{installed_mod\
    ule_version_id}\x12\xf3\x01\n\x1bListInstalledModuleVersions\x120.clarif\
    ai.api.ListInstalledModuleVersionsRequest\x1a1.clarifai.api.MultiInstall\
    edModuleVersionResponse\"o\x98\x9c'\x05\x90\x9c'-\x90\x9c'p\x90\x9c'm\
    \x90\x9c'0\x82\xd3\xe4\x93\x02U\x12S/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/installed_module_versions\x12\xf6\x01\n\x1bPostIns\
    talledModuleVersions\x120.clarifai.api.PostInstalledModuleVersionsReques\
    t\x1a1.clarifai.api.MultiInstalledModuleVersionResponse\"r\x98\x9c'\x05\
    \x90\x9c'o\x90\x9c'p\x90\x9c'm\x90\x9c'-\x82\xd3\xe4\x93\x02X\"S/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versi\
    ons:\x01*\x12\xfb\x01\n\x1dDeleteInstalledModuleVersions\x122.clarifai.a\
    pi.DeleteInstalledModuleVersionsRequest\x1a!.clarifai.api.status.BaseRes\
    ponse\"\x82\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x90\x9c'o\x90\x9c'p\x90\
    \x9c'q\x90\x9c'1\x90\x9c'/\x90\x9c'0\x82\xd3\xe4\x93\x02X*S/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions:\
    \x01*\x12\x95\x02\n\x1ePostInstalledModuleVersionsKey\x123.clarifai.api.\
    PostInstalledModuleVersionsKeyRequest\x1a\x1f.clarifai.api.SingleKeyResp\
    onse\"\x9c\x01\x98\x9c'\x05\x90\x9c'o\x90\x9c'p\x90\x9c'm\x90\x9c'-\x90\
    \x9c'/\x90\x9c'0\x82\xd3\xe4\x93\x02z\"u/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/installed_module_versions/{installed_module_ve\
    rsion_id}/key:\x01*\x12\xf5\x01\n\x12PostBulkOperations\x12'.clarifai.ap\
    i.PostBulkOperationsRequest\x1a).clarifai.api.MultiBulkOperationsRespons\
    e\"\x8a\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'z\x90\x9c'y\x90\x9c'%\x90\x9c\
    '&\x90\x9c'(\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/bulk_operations:\x01*Z\x18\"\x13/v2/bulk_operation\
    s:\x01*\x12\xde\x01\n\x12ListBulkOperations\x12'.clarifai.api.ListBulkOp\
    erationsRequest\x1a).clarifai.api.MultiBulkOperationsResponse\"t\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'z\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_i\
    d.user_id}/apps/{user_app_id.app_id}/bulk_operationsZ\x15\x12\x13/v2/bul\
    k_operations\x12\xe5\x01\n\x10GetBulkOperation\x12%.clarifai.api.GetBulk\
    OperationRequest\x1a*.clarifai.api.SingleBulkOperationsResponse\"~\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'z\x82\xd3\xe4\x93\x02l\x12N/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/bulk_operations/{id}Z\x1a\x12\
    \x18/v2/bulk_operations/{id}\x12\xeb\x01\n\x14CancelBulkOperations\x12(.\
    clarifai.api.CancelBulkOperationRequest\x1a).clarifai.api.MultiBulkOpera\
    tionsResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c'y\x90\x9c'z\x82\xd3\xe4\
    \x93\x02h2I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bul\
    k_operations:\x01*Z\x182\x13/v2/bulk_operations:\x01*\x12\xf4\x01\n\x14D\
    eleteBulkOperations\x12(.clarifai.api.DeleteBulkOperationRequest\x1a!.cl\
    arifai.api.status.BaseResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    &\x90\x9c'%\x90\x9c'(\x90\x9c'y\x90\x9c'z\x90\x9c'{\x82\xd3\xe4\x93\x02h\
    *I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operati\
    ons:\x01*Z\x18*\x13/v2/bulk_operations:\x01*\x12\xb2\x02\n\x1cGetDataset\
    InputsSearchAddJob\x121.clarifai.api.GetDatasetInputsSearchAddJobRequest\
    \x1a5.clarifai.api.SingleDatasetInputsSearchAddJobResponse\"\xa7\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'i\x82\xd3\xe4\x93\x02\x94\x01\x12b/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/inputs/search_a\
    dd/jobs/{job_id}Z.\x12,/v2/datasets/inputs/search_add/jobs/{job_id}\x12\
    \x88\x02\n\x17ListNextTaskAssignments\x12,.clarifai.api.ListNextTaskAssi\
    gnmentsRequest\x1a\x20.clarifai.api.MultiInputResponse\"\x9c\x01\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'8\x90\x9c'i\
    \x82\xd3\xe4\x93\x02z\x12U/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/tasks/{task_id}/assignmentsZ!\x12\x1f/v2/tasks/{task_id}/ass\
    ignments\x12\xe3\x01\n\x12PutTaskAssignments\x12'.clarifai.api.PutTaskAs\
    signmentsRequest\x1a!.clarifai.api.status.BaseResponse\"\x80\x01\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'8\
    \x90\x9c'i\x82\xd3\xe4\x93\x02Z\x1aU/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/tasks/{task_id}/assignments:\x01*\x12\xda\x01\n\
    \x11ListInputsAddJobs\x12&.clarifai.api.ListInputsAddJobsRequest\x1a'.cl\
    arifai.api.MultiInputsAddJobResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x05\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/inputs/jobs/addZ\x15\x12\x13/v2/inputs/jobs/add\x12\xe1\
    \x01\n\x0fGetInputsAddJob\x12$.clarifai.api.GetInputsAddJobRequest\x1a(.\
    clarifai.api.SingleInputsAddJobResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x05\x82\xd3\xe4\x93\x02l\x12N/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/inputs/jobs/add/{id}Z\x1a\x12\x18/v2/inputs/jobs/ad\
    d/{id}\x12\xf2\x01\n\x12CancelInputsAddJob\x12'.clarifai.api.CancelInput\
    sAddJobRequest\x1a(.clarifai.api.SingleInputsAddJobResponse\"\x88\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x04\x90\x9c'\x05\x82\xd3\xe4\x93\x02r2N\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/ad\
    d/{id}:\x01*Z\x1d2\x18/v2/inputs/jobs/add/{id}:\x01*\x12\xc4\x01\n\x0bPo\
    stUploads\x12\x20.clarifai.api.PostUploadsRequest\x1a!.clarifai.api.Mult\
    iUploadResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x81\x01\x90\x9c'\x80\
    \x01\x82\xd3\xe4\x93\x02X\"A/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/uploads:\x01*Z\x10\"\x0b/v2/uploads:\x01*\x12\x8c\x02\n\
    \x15PutUploadContentParts\x12*.clarifai.api.PutUploadContentPartsRequest\
    \x1a\".clarifai.api.SingleUploadResponse\"\xa2\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'\x81\x01\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02\x89\x01\x1a[/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id\
    }/content_parts:\x01*Z'\x1a%/v2/uploads/{upload_id}/content_parts\x12\
    \xce\x01\n\tGetUpload\x12\x1e.clarifai.api.GetUploadRequest\x1a\".clarif\
    ai.api.SingleUploadResponse\"}\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x80\x01\
    \x82\xd3\xe4\x93\x02j\x12M/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/uploads/{upload_id}Z\x19\x12\x17/v2/uploads/{upload_id}\x12\
    \xb9\x01\n\x0bListUploads\x12\x20.clarifai.api.ListUploadsRequest\x1a!.c\
    larifai.api.MultiUploadResponse\"e\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x80\
    \x01\x82\xd3\xe4\x93\x02R\x12A/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/uploadsZ\r\x12\x0b/v2/uploads\x12\xcd\x01\n\rDeleteUploa\
    ds\x12\".clarifai.api.DeleteUploadsRequest\x1a!.clarifai.api.status.Base\
    Response\"u\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x80\x01\x90\x9c'\x81\x01\x90\
    \x9c'\x82\x01\x82\xd3\xe4\x93\x02X*A/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/uploads:\x01*Z\x10*\x0b/v2/uploads:\x01*\x12\x8d\
    \x02\n\x15PostInputsDataSources\x12*.clarifai.api.PostInputsDataSourcesR\
    equest\x1a'.clarifai.api.MultiInputsAddJobResponse\"\x9e\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\
    \x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02p\"M/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/data_sources\
    :\x01*Z\x1c\"\x17/v2/inputs/data_sources:\x01*\x12\xb2\x02\n\x16GetInput\
    sExtractionJob\x12+.clarifai.api.GetInputsExtractionJobRequest\x1a/.clar\
    ifai.api.SingleInputsExtractionJobResponse\"\xb9\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02\xa6\x01\x12k/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extraction/{inputs_ext\
    raction_job_id}Z7\x125/v2/inputs/jobs/extraction/{inputs_extraction_job_\
    id}\x12\xfe\x01\n\x18ListInputsExtractionJobs\x12-.clarifai.api.ListInpu\
    tsExtractionJobsRequest\x1a..clarifai.api.MultiInputsExtractionJobRespon\
    se\"\x82\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02p\
    \x12P/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jo\
    bs/extractionZ\x1c\x12\x1a/v2/inputs/jobs/extraction\x12\x8c\x02\n\x1aCa\
    ncelInputsExtractionJobs\x12/.clarifai.api.CancelInputsExtractionJobsReq\
    uest\x1a..clarifai.api.MultiInputsExtractionJobResponse\"\x8c\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'\x04\x90\x9c'\x05\x82\xd3\xe4\x93\x02v2P/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extrac\
    tion:\x01*Z\x1f2\x1a/v2/inputs/jobs/extraction:\x01*\x12\x85\x02\n\x11Po\
    stInputsUploads\x12&.clarifai.api.PostInputsUploadsRequest\x1a'.clarifai\
    .api.MultiInputsAddJobResponse\"\x9e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    %\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\
    \x02\x90\x9c'\x13\x90\x9c'\x81\x01\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02f\
    \"H/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/uplo\
    ads:\x01*Z\x17\"\x12/v2/inputs/uploads:\x01*\x12\x99\x01\n\tGetRunner\
    \x12\x1e.clarifai.api.GetRunnerRequest\x1a\".clarifai.api.SingleRunnerRe\
    sponse\"H\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x82\xd3\xe4\x93\x025\
    \x123/v2/users/{user_app_id.user_id}/runners/{runner_id}\x12\x90\x01\n\
    \x0bListRunners\x12\x20.clarifai.api.ListRunnersRequest\x1a!.clarifai.ap\
    i.MultiRunnerResponse\"<\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x82\xd3\
    \xe4\x93\x02)\x12'/v2/users/{user_app_id.user_id}/runners\x12\x98\x01\n\
    \x0bPostRunners\x12\x20.clarifai.api.PostRunnersRequest\x1a!.clarifai.ap\
    i.MultiRunnerResponse\"D\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c\
    '\x84\x01\x82\xd3\xe4\x93\x02,\"'/v2/users/{user_app_id.user_id}/runners\
    :\x01*\x12\xa1\x01\n\rDeleteRunners\x12\".clarifai.api.DeleteRunnersRequ\
    est\x1a!.clarifai.api.status.BaseResponse\"I\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'\x83\x01\x90\x9c'\x84\x01\x90\x9c'\x85\x01\x82\xd3\xe4\x93\x02,*'/v\
    2/users/{user_app_id.user_id}/runners:\x01*\x12\xb3\x01\n\x0fListRunnerI\
    tems\x12$.clarifai.api.ListRunnerItemsRequest\x1a%.clarifai.api.MultiRun\
    nerItemResponse\"S\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x86\
    \x01\x82\xd3\xe4\x93\x02;\x129/v2/users/{user_app_id.user_id}/runners/{r\
    unner_id}/items\x12\xdf\x01\n\x15PostRunnerItemOutputs\x12*.clarifai.api\
    .PostRunnerItemOutputsRequest\x1a+.clarifai.api.MultiRunnerItemOutputRes\
    ponse\"m\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x86\x01\x90\
    \x9c'\x87\x01\x82\xd3\xe4\x93\x02P\"K/v2/users/{user_app_id.user_id}/run\
    ners/{runner_id}/items/{item_id}/outputs:\x01*BY\n\x15com.clarifai.grpc.\
    apiP\x01Z7github.com/Clarifai/clarifai-go-grpc/proto/clarifai/api\xa2\
    \x02\x04CAIPJ\xe8\x82\x0c\n\x07\x12\x05\x02\0\xe26\x01\n\x08\n\x01\x0c\
    \x12\x03\x02\0\x12\n\t\n\x02\x03\0\x12\x03\x04\0,\n\t\n\x02\x03\x01\x12\
    \x03\x05\00\n\t\n\x02\x03\x02\x12\x03\x06\03\n\t\n\x02\x03\x03\x12\x03\
    \x07\0/\n\t\n\x02\x03\x04\x12\x03\x08\02\n\t\n\x02\x03\x05\x12\x03\t\05\
    \n\t\n\x02\x03\x06\x12\x03\x0c\0&\n\t\n\x02\x03\x07\x12\x03\r\0(\n\t\n\
    \x02\x03\x08\x12\x03\x0e\0&\n\t\n\x02\x03\t\x12\x03\x0f\0)\n\x08\n\x01\
    \x02\x12\x03\x12\0\x15\n\x08\n\x01\x08\x12\x03\x14\0N\n\t\n\x02\x08\x0b\
    \x12\x03\x14\0N\n\x08\n\x01\x08\x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\x03\
    \x15\0\"\n\x08\n\x01\x08\x12\x03\x16\0.\n\t\n\x02\x08\x01\x12\x03\x16\0.\
    \n\x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\x08$\x12\x03\x17\0\"\n\xb4\
    \x06\n\x02\x06\0\x12\x05-\0\xf5\x1b\x042\xa6\x06\nNote:\x20this\x20is\
    \x20based\x20on\x20the\x20google\x20api\x20format\x20defined\x20here.\
    \x20Please\nread\x20this\x20before\x20contributing\x20to\x20this\x20file\
    \x20and\x20other\x20*.proto\x20files\nfor\x20the\x20API.\nhttps://cloud.\
    google.com/service-management/reference/rpc/google.api#google.api.HttpRu\
    le\n\nFor\x20the\x20cl_depending_scopes\x20in\x20this\x20file,\x20see\
    \x20the\x20docstring\x20that\x20explains\x20the\x20two\x20types\x20of\ns\
    cope\x20dependencies\x20in\x20clarifai/auth/scope/scope.proto\n\nFor\x20\
    new\x20endpoints\x20you\x20should\x20typically\x20only\x20add\x20the\x20\
    fully\x20qualified\x20url\x20that\x20includes\x20the\x20user_id\nand\x20\
    app_id.\n\nYou\x20should\x20typicaly\x20use\x20KeyAuth\x20(the\x20most\
    \x20restricted\x20auth\x20type)\x20for\x20new\x20endpoints\x20unless\x20\
    they\x20are\nfor\x20resources\x20not\x20contained\x20in\x20an\x20app\x20\
    or\x20need\x20access\x20from\x20things\x20across\x20apps.\x20See\x20more\
    \x20about\x20the\nauth\x20types\x20here:\nhttps://clarifai.atlassian.net\
    /wiki/spaces/TT/pages/1821409336/API+Authorizers+and+Resource+Access\n\n\
    \n\n\n\x03\x06\0\x01\x12\x03-\x08\n\n\xdd\x01\n\x04\x06\0\x02\0\x12\x044\
    \x02>\x03\x1a\xce\x01\x20List\x20concept\x20relations\x20between\x20conc\
    epts\x20in\x20the\x20platform.\n\x20MUST\x20be\x20above\x20ListConcepts\
    \x20so\x20that\x20if\x20concept_id\x20is\x20empty\x20this\x20will\x20sti\
    ll\x20match\n\x20/concepts/relations\x20to\x20list\x20all\x20the\x20conc\
    ept\x20relations\x20in\x20the\x20app.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\
    \x034\x06\x1a\n\x0c\n\x05\x06\0\x02\0\x02\x12\x034\x1c7\n\x0c\n\x05\x06\
    \0\x02\0\x03\x12\x034B^\n\r\n\x05\x06\0\x02\0\x04\x12\x045\x04:\x06\n\
    \x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x045\x04:\x06\n\x0c\n\x05\x06\
    \0\x02\0\x04\x12\x03;\x047\n\x0f\n\x08\x06\0\x02\0\x04\xc3\xf3\x04\x12\
    \x03;\x047\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03<\x04?\n\x10\n\t\x06\0\x02\
    \0\x04\xc2\xf3\x04\0\x12\x03<\x04?\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03=\
    \x04C\n\x10\n\t\x06\0\x02\0\x04\xc2\xf3\x04\x01\x12\x03=\x04C\n\\\n\x04\
    \x06\0\x02\x01\x12\x04C\x02L\x03\x1aN\x20Post\x20concept\x20relations\
    \x20to\x20create\x20relations\x20between\x20concepts\x20in\x20the\x20pla\
    tform.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03C\x06\x1a\n\x0c\n\x05\x06\
    \0\x02\x01\x02\x12\x03C\x1c7\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03CB^\n\
    \r\n\x05\x06\0\x02\x01\x04\x12\x04D\x04G\x06\n\x11\n\t\x06\0\x02\x01\x04\
    \xb0\xca\xbc\"\x12\x04D\x04G\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03H\
    \x047\n\x0f\n\x08\x06\0\x02\x01\x04\xc3\xf3\x04\x12\x03H\x047\n\x0c\n\
    \x05\x06\0\x02\x01\x04\x12\x03I\x04?\n\x10\n\t\x06\0\x02\x01\x04\xc2\xf3\
    \x04\0\x12\x03I\x04?\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03J\x04C\n\x10\n\
    \t\x06\0\x02\x01\x04\xc2\xf3\x04\x01\x12\x03J\x04C\n\x0c\n\x05\x06\0\x02\
    \x01\x04\x12\x03K\x04C\n\x10\n\t\x06\0\x02\x01\x04\xc2\xf3\x04\x02\x12\
    \x03K\x04C\n\\\n\x04\x06\0\x02\x02\x12\x04O\x02Y\x03\x1aN\x20Post\x20con\
    cept\x20relations\x20to\x20create\x20relations\x20between\x20concepts\
    \x20in\x20the\x20platform.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03O\x06\
    \x1c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03O\x1e;\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03OFf\n\r\n\x05\x06\0\x02\x02\x04\x12\x04P\x04S\x06\n\x11\
    \n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04P\x04S\x06\n\x0c\n\x05\x06\0\
    \x02\x02\x04\x12\x03T\x047\n\x0f\n\x08\x06\0\x02\x02\x04\xc3\xf3\x04\x12\
    \x03T\x047\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03U\x04?\n\x10\n\t\x06\0\
    \x02\x02\x04\xc2\xf3\x04\0\x12\x03U\x04?\n\x0c\n\x05\x06\0\x02\x02\x04\
    \x12\x03V\x04F\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x01\x12\x03V\x04F\
    \n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03W\x04C\n\x10\n\t\x06\0\x02\x02\x04\
    \xc2\xf3\x04\x02\x12\x03W\x04C\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03X\
    \x04C\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x03\x12\x03X\x04C\nM\n\x04\
    \x06\0\x02\x03\x12\x04\\\x02h\x03\x1a?\x20List\x20all\x20the\x20concepts\
    \x20with\x20their\x20positive\x20and\x20negative\x20counts\n\n\x0c\n\x05\
    \x06\0\x02\x03\x01\x12\x03\\\x06\x16\n\x0c\n\x05\x06\0\x02\x03\x02\x12\
    \x03\\\x18/\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\\:S\n\r\n\x05\x06\0\
    \x02\x03\x04\x12\x04]\x04b\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\
    \x12\x04]\x04b\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03c\x047\n\x0f\n\
    \x08\x06\0\x02\x03\x04\xc3\xf3\x04\x12\x03c\x047\n\x0c\n\x05\x06\0\x02\
    \x03\x04\x12\x03d\x04?\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\0\x12\x03\
    d\x04?\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03e\x04F\n\x10\n\t\x06\0\x02\
    \x03\x04\xc2\xf3\x04\x01\x12\x03e\x04F\n\x0c\n\x05\x06\0\x02\x03\x04\x12\
    \x03f\x04C\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x02\x12\x03f\x04C\n\
    \x0c\n\x05\x06\0\x02\x03\x04\x12\x03g\x04A\n\x10\n\t\x06\0\x02\x03\x04\
    \xc2\xf3\x04\x03\x12\x03g\x04A\n3\n\x04\x06\0\x02\x04\x12\x04k\x02u\x03\
    \x1a%\x20Get\x20a\x20specific\x20concept\x20from\x20an\x20app.\n\n\x0c\n\
    \x05\x06\0\x02\x04\x01\x12\x03k\x06\x10\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03k\x12#\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03k.C\n\r\n\x05\x06\0\
    \x02\x04\x04\x12\x04l\x04q\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x12\x04l\x04q\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03r\x047\n\x0f\n\
    \x08\x06\0\x02\x04\x04\xc3\xf3\x04\x12\x03r\x047\n\x0c\n\x05\x06\0\x02\
    \x04\x04\x12\x03s\x04?\n\x10\n\t\x06\0\x02\x04\x04\xc2\xf3\x04\0\x12\x03\
    s\x04?\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03t\x04C\n\x10\n\t\x06\0\x02\
    \x04\x04\xc2\xf3\x04\x01\x12\x03t\x04C\n'\n\x04\x06\0\x02\x05\x12\x05x\
    \x02\x82\x01\x03\x1a\x18\x20List\x20all\x20the\x20concepts.\n\n\x0c\n\
    \x05\x06\0\x02\x05\x01\x12\x03x\x06\x12\n\x0c\n\x05\x06\0\x02\x05\x02\
    \x12\x03x\x14'\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03x2F\n\r\n\x05\x06\0\
    \x02\x05\x04\x12\x04y\x04~\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\
    \x12\x04y\x04~\x06\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03\x7f\x047\n\x0f\
    \n\x08\x06\0\x02\x05\x04\xc3\xf3\x04\x12\x03\x7f\x047\n\r\n\x05\x06\0\
    \x02\x05\x04\x12\x04\x80\x01\x04?\n\x11\n\t\x06\0\x02\x05\x04\xc2\xf3\
    \x04\0\x12\x04\x80\x01\x04?\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\x81\x01\
    \x04C\n\x11\n\t\x06\0\x02\x05\x04\xc2\xf3\x04\x01\x12\x04\x81\x01\x04C\n\
    '\n\x04\x06\0\x02\x06\x12\x06\x85\x01\x02\x90\x01\x03\x1a\x17\x20List\
    \x20models\x20concepts.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\x85\x01\
    \x06\x17\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x85\x01\x191\n\r\n\x05\x06\
    \0\x02\x06\x03\x12\x04\x85\x01<P\n\x0f\n\x05\x06\0\x02\x06\x04\x12\x06\
    \x86\x01\x04\x8b\x01\x06\n\x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\
    \x06\x86\x01\x04\x8b\x01\x06\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x8c\x01\
    \x047\n\x10\n\x08\x06\0\x02\x06\x04\xc3\xf3\x04\x12\x04\x8c\x01\x047\n\r\
    \n\x05\x06\0\x02\x06\x04\x12\x04\x8d\x01\x04?\n\x11\n\t\x06\0\x02\x06\
    \x04\xc2\xf3\x04\0\x12\x04\x8d\x01\x04?\n\r\n\x05\x06\0\x02\x06\x04\x12\
    \x04\x8e\x01\x04C\n\x11\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\x01\x12\x04\
    \x8e\x01\x04C\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x8f\x01\x04A\n\x11\n\t\
    \x06\0\x02\x06\x04\xc2\xf3\x04\x02\x12\x04\x8f\x01\x04A\n\xcd\x01\n\x04\
    \x06\0\x02\x07\x12\x06\x95\x01\x02\xa3\x01\x03\x1a\xbc\x01\x20Search\x20\
    over\x20the\x20concepts\x20to\x20find\x20one\x20or\x20more\x20you're\x20\
    looking\x20for.\n\x20This\x20leverage\x20the\x20\"body\"\x20parameter\
    \x20because\x20we\x20also\x20have\x20page\x20and\n\x20per_page\x20as\x20\
    url\x20query\x20param\x20variables\x20in\x20this\x20request.\n\n\r\n\x05\
    \x06\0\x02\x07\x01\x12\x04\x95\x01\x06\x1a\n\r\n\x05\x06\0\x02\x07\x02\
    \x12\x04\x95\x01\x1c7\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\x95\x01BV\n\
    \x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x96\x01\x04\x9d\x01\x06\n\x13\n\t\
    \x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\x96\x01\x04\x9d\x01\x06\n\r\n\
    \x05\x06\0\x02\x07\x04\x12\x04\x9e\x01\x047\n\x10\n\x08\x06\0\x02\x07\
    \x04\xc3\xf3\x04\x12\x04\x9e\x01\x047\n\r\n\x05\x06\0\x02\x07\x04\x12\
    \x04\x9f\x01\x04?\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\0\x12\x04\x9f\
    \x01\x04?\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xa0\x01\x04C\n\x11\n\t\x06\
    \0\x02\x07\x04\xc2\xf3\x04\x01\x12\x04\xa0\x01\x04C\n\r\n\x05\x06\0\x02\
    \x07\x04\x12\x04\xa1\x01\x04A\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\
    \x02\x12\x04\xa1\x01\x04A\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xa2\x01\
    \x04D\nP\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\x03\x12\x04\xa2\x01\x04D\"=\
    \x20as\x20it\x20needs\x20to\x20know\x20the\x20concepts\x20in\x20your\x20\
    workflow's\x20models.\n\n*\n\x04\x06\0\x02\x08\x12\x06\xa6\x01\x02\xb3\
    \x01\x03\x1a\x1a\x20Add\x20a\x20concept\x20to\x20an\x20app.\n\n\r\n\x05\
    \x06\0\x02\x08\x01\x12\x04\xa6\x01\x06\x12\n\r\n\x05\x06\0\x02\x08\x02\
    \x12\x04\xa6\x01\x14'\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\xa6\x012F\n\
    \x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xa7\x01\x04\xae\x01\x06\n\x13\n\t\
    \x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xa7\x01\x04\xae\x01\x06\n\r\n\
    \x05\x06\0\x02\x08\x04\x12\x04\xaf\x01\x047\n\x10\n\x08\x06\0\x02\x08\
    \x04\xc3\xf3\x04\x12\x04\xaf\x01\x047\n\r\n\x05\x06\0\x02\x08\x04\x12\
    \x04\xb0\x01\x04?\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\x04\0\x12\x04\xb0\
    \x01\x04?\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xb1\x01\x04C\n\x11\n\t\x06\
    \0\x02\x08\x04\xc2\xf3\x04\x01\x12\x04\xb1\x01\x04C\n\r\n\x05\x06\0\x02\
    \x08\x04\x12\x04\xb2\x01\x04C\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\x04\
    \x02\x12\x04\xb2\x01\x04C\n-\n\x04\x06\0\x02\t\x12\x06\xb6\x01\x02\xc3\
    \x01\x03\x1a\x1d\x20Patch\x20one\x20or\x20more\x20concepts.\n\n\r\n\x05\
    \x06\0\x02\t\x01\x12\x04\xb6\x01\x06\x13\n\r\n\x05\x06\0\x02\t\x02\x12\
    \x04\xb6\x01\x15)\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xb6\x014H\n\x0f\n\
    \x05\x06\0\x02\t\x04\x12\x06\xb7\x01\x04\xbe\x01\x06\n\x13\n\t\x06\0\x02\
    \t\x04\xb0\xca\xbc\"\x12\x06\xb7\x01\x04\xbe\x01\x06\n\r\n\x05\x06\0\x02\
    \t\x04\x12\x04\xbf\x01\x047\n\x10\n\x08\x06\0\x02\t\x04\xc3\xf3\x04\x12\
    \x04\xbf\x01\x047\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc0\x01\x04?\n\x11\n\
    \t\x06\0\x02\t\x04\xc2\xf3\x04\0\x12\x04\xc0\x01\x04?\n\r\n\x05\x06\0\
    \x02\t\x04\x12\x04\xc1\x01\x04C\n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\
    \x01\x12\x04\xc1\x01\x04C\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc2\x01\x04C\
    \n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\x02\x12\x04\xc2\x01\x04C\n5\n\x04\
    \x06\0\x02\n\x12\x06\xd0\x01\x02\xda\x01\x03\x1a%\x20Get\x20a\x20specifi\
    c\x20concept\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\
    \xd0\x01\x06\x18\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xd0\x01\x1a3\n\r\n\
    \x05\x06\0\x02\n\x03\x12\x04\xd0\x01>[\n\x0f\n\x05\x06\0\x02\n\x04\x12\
    \x06\xd1\x01\x04\xd6\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\
    \x06\xd1\x01\x04\xd6\x01\x06\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xd7\x01\
    \x047\n\x10\n\x08\x06\0\x02\n\x04\xc3\xf3\x04\x12\x04\xd7\x01\x047\n\r\n\
    \x05\x06\0\x02\n\x04\x12\x04\xd8\x01\x04?\n\x11\n\t\x06\0\x02\n\x04\xc2\
    \xf3\x04\0\x12\x04\xd8\x01\x04?\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xd9\
    \x01\x04C\n\x11\n\t\x06\0\x02\n\x04\xc2\xf3\x04\x01\x12\x04\xd9\x01\x04C\
    \nC\n\x04\x06\0\x02\x0b\x12\x06\xdd\x01\x02\xe7\x01\x03\x1a3\x20List\x20\
    the\x20concept\x20in\x20all\x20the\x20translated\x20languages.\n\n\r\n\
    \x05\x06\0\x02\x0b\x01\x12\x04\xdd\x01\x06\x1a\n\r\n\x05\x06\0\x02\x0b\
    \x02\x12\x04\xdd\x01\x1c7\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xdd\x01B^\
    \n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xde\x01\x04\xe3\x01\x06\n\x13\n\t\
    \x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xde\x01\x04\xe3\x01\x06\n\r\n\
    \x05\x06\0\x02\x0b\x04\x12\x04\xe4\x01\x047\n\x10\n\x08\x06\0\x02\x0b\
    \x04\xc3\xf3\x04\x12\x04\xe4\x01\x047\n\r\n\x05\x06\0\x02\x0b\x04\x12\
    \x04\xe5\x01\x04?\n\x11\n\t\x06\0\x02\x0b\x04\xc2\xf3\x04\0\x12\x04\xe5\
    \x01\x04?\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xe6\x01\x04C\n\x11\n\t\x06\
    \0\x02\x0b\x04\xc2\xf3\x04\x01\x12\x04\xe6\x01\x04C\n9\n\x04\x06\0\x02\
    \x0c\x12\x06\xea\x01\x02\xf7\x01\x03\x1a)\x20Add\x20a\x20new\x20translat\
    ion\x20for\x20this\x20concept.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xea\
    \x01\x06\x1a\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xea\x01\x1c7\n\r\n\x05\
    \x06\0\x02\x0c\x03\x12\x04\xea\x01B^\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\
    \x06\xeb\x01\x04\xf2\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\
    \x12\x06\xeb\x01\x04\xf2\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf3\
    \x01\x047\n\x10\n\x08\x06\0\x02\x0c\x04\xc3\xf3\x04\x12\x04\xf3\x01\x047\
    \n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf4\x01\x04?\n\x11\n\t\x06\0\x02\
    \x0c\x04\xc2\xf3\x04\0\x12\x04\xf4\x01\x04?\n\r\n\x05\x06\0\x02\x0c\x04\
    \x12\x04\xf5\x01\x04C\n\x11\n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\x01\x12\
    \x04\xf5\x01\x04C\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf6\x01\x04C\n\x11\
    \n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\x02\x12\x04\xf6\x01\x04C\n\x83\x01\n\
    \x04\x06\0\x02\r\x12\x06\xfb\x01\x02\x88\x02\x03\x1as\x20Patch\x20the\
    \x20name\x20for\x20a\x20given\x20language\x20names\x20by\x20passing\x20i\
    n\x20a\x20list\x20of\x20concepts\x20with\x20the\x20new\x20names\n\x20for\
    \x20the\x20languages.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xfb\x01\x06\
    \x1b\n\r\n\x05\x06\0\x02\r\x02\x12\x04\xfb\x01\x1d9\n\r\n\x05\x06\0\x02\
    \r\x03\x12\x04\xfb\x01D`\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\xfc\x01\x04\
    \x83\x02\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\xfc\x01\x04\
    \x83\x02\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x84\x02\x047\n\x10\n\x08\
    \x06\0\x02\r\x04\xc3\xf3\x04\x12\x04\x84\x02\x047\n\r\n\x05\x06\0\x02\r\
    \x04\x12\x04\x85\x02\x04?\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\0\x12\
    \x04\x85\x02\x04?\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x86\x02\x04C\n\x11\n\
    \t\x06\0\x02\r\x04\xc2\xf3\x04\x01\x12\x04\x86\x02\x04C\n\r\n\x05\x06\0\
    \x02\r\x04\x12\x04\x87\x02\x04C\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\
    \x02\x12\x04\x87\x02\x04C\n)\n\x04\x06\0\x02\x0e\x12\x06\x8e\x02\x02\x98\
    \x02\x03\x1a\x19\x20List\x20all\x20domain\x20graphs.\n\n\r\n\x05\x06\0\
    \x02\x0e\x01\x12\x04\x8e\x02\x06\x19\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\
    \x8e\x02\x1b5\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x8e\x02@[\n\x0f\n\x05\
    \x06\0\x02\x0e\x04\x12\x06\x8f\x02\x04\x94\x02\x06\n\x13\n\t\x06\0\x02\
    \x0e\x04\xb0\xca\xbc\"\x12\x06\x8f\x02\x04\x94\x02\x06\n\r\n\x05\x06\0\
    \x02\x0e\x04\x12\x04\x95\x02\x047\n\x10\n\x08\x06\0\x02\x0e\x04\xc3\xf3\
    \x04\x12\x04\x95\x02\x047\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x96\x02\
    \x04?\n\x11\n\t\x06\0\x02\x0e\x04\xc2\xf3\x04\0\x12\x04\x96\x02\x04?\n\r\
    \n\x05\x06\0\x02\x0e\x04\x12\x04\x97\x02\x04C\n\x11\n\t\x06\0\x02\x0e\
    \x04\xc2\xf3\x04\x01\x12\x04\x97\x02\x04C\n%\n\x04\x06\0\x02\x0f\x12\x06\
    \x9b\x02\x02\xa8\x02\x03\x1a\x15\x20Post\x20domain\x20graphs.\n\n\r\n\
    \x05\x06\0\x02\x0f\x01\x12\x04\x9b\x02\x06\x19\n\r\n\x05\x06\0\x02\x0f\
    \x02\x12\x04\x9b\x02\x1b5\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\x9b\x02@[\
    \n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\x9c\x02\x04\xa3\x02\x06\n\x13\n\t\
    \x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\x9c\x02\x04\xa3\x02\x06\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\xa4\x02\x047\n\x10\n\x08\x06\0\x02\x0f\
    \x04\xc3\xf3\x04\x12\x04\xa4\x02\x047\n\r\n\x05\x06\0\x02\x0f\x04\x12\
    \x04\xa5\x02\x04?\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\0\x12\x04\xa5\
    \x02\x04?\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xa6\x02\x04C\n\x11\n\t\x06\
    \0\x02\x0f\x04\xc2\xf3\x04\x01\x12\x04\xa6\x02\x04C\n\r\n\x05\x06\0\x02\
    \x0f\x04\x12\x04\xa7\x02\x04C\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\
    \x02\x12\x04\xa7\x02\x04C\n-\n\x04\x06\0\x02\x10\x12\x06\xab\x02\x02\xb8\
    \x02\x03\x1a\x1d\x20Start\x20concept\x20mapping\x20jobs.\n\n\r\n\x05\x06\
    \0\x02\x10\x01\x12\x04\xab\x02\x06\x1c\n\r\n\x05\x06\0\x02\x10\x02\x12\
    \x04\xab\x02\x1e;\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xab\x02Fd\n\x0f\n\
    \x05\x06\0\x02\x10\x04\x12\x06\xac\x02\x04\xb3\x02\x06\n\x13\n\t\x06\0\
    \x02\x10\x04\xb0\xca\xbc\"\x12\x06\xac\x02\x04\xb3\x02\x06\n\r\n\x05\x06\
    \0\x02\x10\x04\x12\x04\xb4\x02\x047\n\x10\n\x08\x06\0\x02\x10\x04\xc3\
    \xf3\x04\x12\x04\xb4\x02\x047\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xb5\
    \x02\x04?\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\0\x12\x04\xb5\x02\x04?\
    \n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xb6\x02\x04C\n\x11\n\t\x06\0\x02\
    \x10\x04\xc2\xf3\x04\x01\x12\x04\xb6\x02\x04C\n\r\n\x05\x06\0\x02\x10\
    \x04\x12\x04\xb7\x02\x04C\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\x02\
    \x12\x04\xb7\x02\x04C\n8\n\x04\x06\0\x02\x11\x12\x06\xbd\x02\x02\xc9\x02\
    \x03\x1a(\x20Get\x20a\x20specific\x20annotation\x20from\x20an\x20app.\n\
    \n\r\n\x05\x06\0\x02\x11\x01\x12\x04\xbd\x02\x06\x13\n\r\n\x05\x06\0\x02\
    \x11\x02\x12\x04\xbd\x02\x15)\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\xbd\
    \x024L\n\x0f\n\x05\x06\0\x02\x11\x04\x12\x06\xbe\x02\x04\xc3\x02\x06\n\
    \x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\"\x12\x06\xbe\x02\x04\xc3\x02\x06\
    \n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc4\x02\x047\n\x10\n\x08\x06\0\x02\
    \x11\x04\xc3\xf3\x04\x12\x04\xc4\x02\x047\n\r\n\x05\x06\0\x02\x11\x04\
    \x12\x04\xc5\x02\x04?\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\0\x12\x04\
    \xc5\x02\x04?\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc6\x02\x04F\n\x11\n\t\
    \x06\0\x02\x11\x04\xc2\xf3\x04\x01\x12\x04\xc6\x02\x04F\n\r\n\x05\x06\0\
    \x02\x11\x04\x12\x04\xc7\x02\x04C\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\
    \x04\x02\x12\x04\xc7\x02\x04C\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc8\
    \x02\x04A\n5\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\x03\x12\x04\xc8\x02\x04A\
    \"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20worker.\n\n*\n\x04\
    \x06\0\x02\x12\x12\x06\xcc\x02\x02\xd8\x02\x03\x1a\x1a\x20List\x20all\
    \x20the\x20annotation.\n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xcc\x02\x06\
    \x15\n\r\n\x05\x06\0\x02\x12\x02\x12\x04\xcc\x02\x17-\n\r\n\x05\x06\0\
    \x02\x12\x03\x12\x04\xcc\x028O\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xcd\
    \x02\x04\xd2\x02\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\
    \xcd\x02\x04\xd2\x02\x06\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xd3\x02\x04\
    7\n\x10\n\x08\x06\0\x02\x12\x04\xc3\xf3\x04\x12\x04\xd3\x02\x047\n\r\n\
    \x05\x06\0\x02\x12\x04\x12\x04\xd4\x02\x04?\n\x11\n\t\x06\0\x02\x12\x04\
    \xc2\xf3\x04\0\x12\x04\xd4\x02\x04?\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\
    \xd5\x02\x04F\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x01\x12\x04\xd5\
    \x02\x04F\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xd6\x02\x04C\n\x11\n\t\x06\
    \0\x02\x12\x04\xc2\xf3\x04\x02\x12\x04\xd6\x02\x04C\n\r\n\x05\x06\0\x02\
    \x12\x04\x12\x04\xd7\x02\x04A\n5\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x03\
    \x12\x04\xd7\x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20\
    worker.\n\n#\n\x04\x06\0\x02\x13\x12\x06\xdb\x02\x02\xec\x02\x03\x1a\x13\
    \x20Post\x20annotations.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\xdb\x02\
    \x06\x15\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\xdb\x02\x17-\n\r\n\x05\x06\
    \0\x02\x13\x03\x12\x04\xdb\x028O\n\x0f\n\x05\x06\0\x02\x13\x04\x12\x06\
    \xdc\x02\x04\xe3\x02\x06\n\x13\n\t\x06\0\x02\x13\x04\xb0\xca\xbc\"\x12\
    \x06\xdc\x02\x04\xe3\x02\x06\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe4\x02\
    \x047\n\x10\n\x08\x06\0\x02\x13\x04\xc3\xf3\x04\x12\x04\xe4\x02\x047\n\r\
    \n\x05\x06\0\x02\x13\x04\x12\x04\xe5\x02\x04?\n\x11\n\t\x06\0\x02\x13\
    \x04\xc2\xf3\x04\0\x12\x04\xe5\x02\x04?\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xe6\x02\x04A\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x01\x12\x04\
    \xe6\x02\x04A\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe7\x02\x04F\n\x11\n\t\
    \x06\0\x02\x13\x04\xc2\xf3\x04\x02\x12\x04\xe7\x02\x04F\n\r\n\x05\x06\0\
    \x02\x13\x04\x12\x04\xe8\x02\x04F\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\
    \x04\x03\x12\x04\xe8\x02\x04F\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe9\
    \x02\x04C\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x04\x12\x04\xe9\x02\
    \x04C\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xea\x02\x04A\n\x11\n\t\x06\0\
    \x02\x13\x04\xc2\xf3\x04\x05\x12\x04\xea\x02\x04A\n\r\n\x05\x06\0\x02\
    \x13\x04\x12\x04\xeb\x02\x04D\nA\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x06\
    \x12\x04\xeb\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n0\n\x04\x06\0\x02\x14\x12\x06\xef\x02\x02\
    \x80\x03\x03\x1a\x20\x20Patch\x20one\x20or\x20more\x20annotations.\n\n\r\
    \n\x05\x06\0\x02\x14\x01\x12\x04\xef\x02\x06\x16\n\r\n\x05\x06\0\x02\x14\
    \x02\x12\x04\xef\x02\x18/\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xef\x02:Q\
    \n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\xf0\x02\x04\xf7\x02\x06\n\x13\n\t\
    \x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\xf0\x02\x04\xf7\x02\x06\n\r\n\
    \x05\x06\0\x02\x14\x04\x12\x04\xf8\x02\x047\n\x10\n\x08\x06\0\x02\x14\
    \x04\xc3\xf3\x04\x12\x04\xf8\x02\x047\n\r\n\x05\x06\0\x02\x14\x04\x12\
    \x04\xf9\x02\x04?\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\0\x12\x04\xf9\
    \x02\x04?\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xfa\x02\x04A\n\x11\n\t\x06\
    \0\x02\x14\x04\xc2\xf3\x04\x01\x12\x04\xfa\x02\x04A\n\r\n\x05\x06\0\x02\
    \x14\x04\x12\x04\xfb\x02\x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\
    \x02\x12\x04\xfb\x02\x04F\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xfc\x02\
    \x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x03\x12\x04\xfc\x02\x04F\n\
    \r\n\x05\x06\0\x02\x14\x04\x12\x04\xfd\x02\x04C\n\x11\n\t\x06\0\x02\x14\
    \x04\xc2\xf3\x04\x04\x12\x04\xfd\x02\x04C\n\r\n\x05\x06\0\x02\x14\x04\
    \x12\x04\xfe\x02\x04D\nA\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x05\x12\x04\
    \xfe\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\x20default\
    \x20workflow.\n\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xff\x02\x04A\n5\n\t\
    \x06\0\x02\x14\x04\xc2\xf3\x04\x06\x12\x04\xff\x02\x04A\"\"\x20to\x20get\
    \x20the\x20model\x20for\x20the\x20worker.\n\nD\n\x04\x06\0\x02\x15\x12\
    \x06\x83\x03\x02\x8f\x03\x03\x1a4\x20Patch\x20annotations\x20status\x20b\
    y\x20worker\x20id\x20and\x20task\x20id.\n\n\r\n\x05\x06\0\x02\x15\x01\
    \x12\x04\x83\x03\x06\x1c\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\x83\x03\x1e\
    ;\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\x83\x03Fd\n\x0f\n\x05\x06\0\x02\
    \x15\x04\x12\x06\x84\x03\x04\x87\x03\x06\n\x13\n\t\x06\0\x02\x15\x04\xb0\
    \xca\xbc\"\x12\x06\x84\x03\x04\x87\x03\x06\n\r\n\x05\x06\0\x02\x15\x04\
    \x12\x04\x88\x03\x047\n\x10\n\x08\x06\0\x02\x15\x04\xc3\xf3\x04\x12\x04\
    \x88\x03\x047\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x89\x03\x04?\n\x11\n\t\
    \x06\0\x02\x15\x04\xc2\xf3\x04\0\x12\x04\x89\x03\x04?\n\r\n\x05\x06\0\
    \x02\x15\x04\x12\x04\x8a\x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\
    \x04\x01\x12\x04\x8a\x03\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x8b\
    \x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x02\x12\x04\x8b\x03\
    \x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x8c\x03\x04C\n\x11\n\t\x06\0\
    \x02\x15\x04\xc2\xf3\x04\x03\x12\x04\x8c\x03\x04C\n\r\n\x05\x06\0\x02\
    \x15\x04\x12\x04\x8d\x03\x04D\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\
    \x04\x12\x04\x8d\x03\x04D\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x8e\x03\
    \x04A\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x05\x12\x04\x8e\x03\x04A\n\
    -\n\x04\x06\0\x02\x16\x12\x06\x92\x03\x02\xa0\x03\x03\x1a\x1d\x20Delete\
    \x20a\x20single\x20annotation.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\x92\
    \x03\x06\x16\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\x92\x03\x18/\n\r\n\x05\
    \x06\0\x02\x16\x03\x12\x04\x92\x03:Z\n\x0f\n\x05\x06\0\x02\x16\x04\x12\
    \x06\x93\x03\x04\x98\x03\x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\
    \x12\x06\x93\x03\x04\x98\x03\x06\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x99\
    \x03\x047\n\x10\n\x08\x06\0\x02\x16\x04\xc3\xf3\x04\x12\x04\x99\x03\x047\
    \n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x9a\x03\x04?\n\x11\n\t\x06\0\x02\
    \x16\x04\xc2\xf3\x04\0\x12\x04\x9a\x03\x04?\n\r\n\x05\x06\0\x02\x16\x04\
    \x12\x04\x9b\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x01\x12\
    \x04\x9b\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x9c\x03\x04I\n\x11\
    \n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x02\x12\x04\x9c\x03\x04I\n\r\n\x05\
    \x06\0\x02\x16\x04\x12\x04\x9d\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\xc2\
    \xf3\x04\x03\x12\x04\x9d\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\
    \x9e\x03\x04D\n\\\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x04\x12\x04\x9e\x03\
    \x04D\"I\x20for\x20cleaning\x20up\x20some\x20optimizations\x20we\x20have\
    \x20in\x20DB\x20layer\x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\x16\
    \x04\x12\x04\x9f\x03\x04A\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x05\
    \x12\x04\x9f\x03\x04A\n=\n\x04\x06\0\x02\x17\x12\x06\xa3\x03\x02\xbb\x03\
    \x03\x1a-\x20Delete\x20multiple\x20annotations\x20in\x20one\x20request.\
    \n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\xa3\x03\x06\x17\n\r\n\x05\x06\0\
    \x02\x17\x02\x12\x04\xa3\x03\x191\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\
    \xa3\x03<\\\n\x0f\n\x05\x06\0\x02\x17\x04\x12\x06\xa4\x03\x04\xb3\x03\
    \x06\n\x13\n\t\x06\0\x02\x17\x04\xb0\xca\xbc\"\x12\x06\xa4\x03\x04\xb3\
    \x03\x06\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xb4\x03\x047\n\x10\n\x08\
    \x06\0\x02\x17\x04\xc3\xf3\x04\x12\x04\xb4\x03\x047\n\r\n\x05\x06\0\x02\
    \x17\x04\x12\x04\xb5\x03\x04?\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\0\
    \x12\x04\xb5\x03\x04?\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xb6\x03\x04F\n\
    \x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x01\x12\x04\xb6\x03\x04F\n\r\n\
    \x05\x06\0\x02\x17\x04\x12\x04\xb7\x03\x04I\n\x11\n\t\x06\0\x02\x17\x04\
    \xc2\xf3\x04\x02\x12\x04\xb7\x03\x04I\n\r\n\x05\x06\0\x02\x17\x04\x12\
    \x04\xb8\x03\x04F\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x03\x12\x04\
    \xb8\x03\x04F\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xb9\x03\x04D\n\\\n\t\
    \x06\0\x02\x17\x04\xc2\xf3\x04\x04\x12\x04\xb9\x03\x04D\"I\x20for\x20cle\
    aning\x20up\x20some\x20optimizations\x20we\x20have\x20in\x20DB\x20layer\
    \x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xba\x03\
    \x04A\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x05\x12\x04\xba\x03\x04A\n\
    :\n\x04\x06\0\x02\x18\x12\x06\xbe\x03\x02\xcb\x03\x03\x1a*\x20Patch\x20s\
    aved\x20annotations\x20searches\x20by\x20ids.\n\n\r\n\x05\x06\0\x02\x18\
    \x01\x12\x04\xbe\x03\x06\x1e\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\xbe\x03\
    \x20?\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\xbe\x03J]\n\x0f\n\x05\x06\0\
    \x02\x18\x04\x12\x06\xbf\x03\x04\xc6\x03\x06\n\x13\n\t\x06\0\x02\x18\x04\
    \xb0\xca\xbc\"\x12\x06\xbf\x03\x04\xc6\x03\x06\n\r\n\x05\x06\0\x02\x18\
    \x04\x12\x04\xc7\x03\x047\n\x10\n\x08\x06\0\x02\x18\x04\xc3\xf3\x04\x12\
    \x04\xc7\x03\x047\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xc8\x03\x04?\n\x11\
    \n\t\x06\0\x02\x18\x04\xc2\xf3\x04\0\x12\x04\xc8\x03\x04?\n\r\n\x05\x06\
    \0\x02\x18\x04\x12\x04\xc9\x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\
    \x04\x01\x12\x04\xc9\x03\x04F\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xca\
    \x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\x04\x02\x12\x04\xca\x03\
    \x04F\n3\n\x04\x06\0\x02\x19\x12\x06\xce\x03\x02\xdf\x03\x03\x1a#\x20Exe\
    cute\x20a\x20search\x20over\x20annotations\n\n\r\n\x05\x06\0\x02\x19\x01\
    \x12\x04\xce\x03\x06\x1d\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xce\x03\x1e\
    <\n\r\n\x05\x06\0\x02\x19\x03\x12\x04\xce\x03GZ\n\x0f\n\x05\x06\0\x02\
    \x19\x04\x12\x06\xcf\x03\x04\xd6\x03\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\
    \xca\xbc\"\x12\x06\xcf\x03\x04\xd6\x03\x06\n\r\n\x05\x06\0\x02\x19\x04\
    \x12\x04\xd7\x03\x047\n\x10\n\x08\x06\0\x02\x19\x04\xc3\xf3\x04\x12\x04\
    \xd7\x03\x047\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xd8\x03\x04?\n\x11\n\t\
    \x06\0\x02\x19\x04\xc2\xf3\x04\0\x12\x04\xd8\x03\x04?\n\r\n\x05\x06\0\
    \x02\x19\x04\x12\x04\xd9\x03\x04F\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\
    \x04\x01\x12\x04\xd9\x03\x04F\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xda\
    \x03\x04C\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x02\x12\x04\xda\x03\
    \x04C\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xdb\x03\x04A\n\x11\n\t\x06\0\
    \x02\x19\x04\xc2\xf3\x04\x03\x12\x04\xdb\x03\x04A\n\r\n\x05\x06\0\x02\
    \x19\x04\x12\x04\xdc\x03\x04A\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\
    \x04\x12\x04\xdc\x03\x04A\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xdd\x03\
    \x04=\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x05\x12\x04\xdd\x03\x04=\n\
    \r\n\x05\x06\0\x02\x19\x04\x12\x04\xde\x03\x04D\nN\n\t\x06\0\x02\x19\x04\
    \xc2\xf3\x04\x06\x12\x04\xde\x03\x04D\";\x20to\x20know\x20the\x20concept\
    s\x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n-\n\x04\x06\
    \0\x02\x1a\x12\x06\xe2\x03\x02\xee\x03\x03\x1a\x1d\x20Get\x20input\x20co\
    unt\x20per\x20status.\n\n\r\n\x05\x06\0\x02\x1a\x01\x12\x04\xe2\x03\x06\
    \x13\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xe2\x03\x15)\n\r\n\x05\x06\0\
    \x02\x1a\x03\x12\x04\xe2\x034L\n\x0f\n\x05\x06\0\x02\x1a\x04\x12\x06\xe3\
    \x03\x04\xe8\x03\x06\n\x13\n\t\x06\0\x02\x1a\x04\xb0\xca\xbc\"\x12\x06\
    \xe3\x03\x04\xe8\x03\x06\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xe9\x03\x04\
    7\n\x10\n\x08\x06\0\x02\x1a\x04\xc3\xf3\x04\x12\x04\xe9\x03\x047\n\r\n\
    \x05\x06\0\x02\x1a\x04\x12\x04\xea\x03\x04?\n\x11\n\t\x06\0\x02\x1a\x04\
    \xc2\xf3\x04\0\x12\x04\xea\x03\x04?\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\
    \xeb\x03\x04F\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\x01\x12\x04\xeb\
    \x03\x04F\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xec\x03\x04C\n\x11\n\t\x06\
    \0\x02\x1a\x04\xc2\xf3\x04\x02\x12\x04\xec\x03\x04C\n\r\n\x05\x06\0\x02\
    \x1a\x04\x12\x04\xed\x03\x04A\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\
    \x03\x12\x04\xed\x03\x04A\nE\n\x04\x06\0\x02\x1b\x12\x06\xf1\x03\x02\xfd\
    \x03\x03\x1a5\x20Streams\x20all\x20the\x20inputs\x20starting\x20from\x20\
    oldest\x20assets.\n\n\r\n\x05\x06\0\x02\x1b\x01\x12\x04\xf1\x03\x06\x12\
    \n\r\n\x05\x06\0\x02\x1b\x02\x12\x04\xf1\x03\x14'\n\r\n\x05\x06\0\x02\
    \x1b\x03\x12\x04\xf1\x032D\n\x0f\n\x05\x06\0\x02\x1b\x04\x12\x06\xf2\x03\
    \x04\xf7\x03\x06\n\x13\n\t\x06\0\x02\x1b\x04\xb0\xca\xbc\"\x12\x06\xf2\
    \x03\x04\xf7\x03\x06\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xf8\x03\x047\n\
    \x10\n\x08\x06\0\x02\x1b\x04\xc3\xf3\x04\x12\x04\xf8\x03\x047\n\r\n\x05\
    \x06\0\x02\x1b\x04\x12\x04\xf9\x03\x04?\n\x11\n\t\x06\0\x02\x1b\x04\xc2\
    \xf3\x04\0\x12\x04\xf9\x03\x04?\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xfa\
    \x03\x04F\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\x01\x12\x04\xfa\x03\
    \x04F\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xfb\x03\x04C\n\x11\n\t\x06\0\
    \x02\x1b\x04\xc2\xf3\x04\x02\x12\x04\xfb\x03\x04C\n\r\n\x05\x06\0\x02\
    \x1b\x04\x12\x04\xfc\x03\x04A\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\
    \x03\x12\x04\xfc\x03\x04A\n3\n\x04\x06\0\x02\x1c\x12\x06\x80\x04\x02\x8c\
    \x04\x03\x1a#\x20Get\x20a\x20specific\x20input\x20from\x20an\x20app.\n\n\
    \r\n\x05\x06\0\x02\x1c\x01\x12\x04\x80\x04\x06\x15\n\r\n\x05\x06\0\x02\
    \x1c\x02\x12\x04\x80\x04\x17-\n\r\n\x05\x06\0\x02\x1c\x03\x12\x04\x80\
    \x048T\n\x0f\n\x05\x06\0\x02\x1c\x04\x12\x06\x81\x04\x04\x86\x04\x06\n\
    \x13\n\t\x06\0\x02\x1c\x04\xb0\xca\xbc\"\x12\x06\x81\x04\x04\x86\x04\x06\
    \n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x87\x04\x047\n\x10\n\x08\x06\0\x02\
    \x1c\x04\xc3\xf3\x04\x12\x04\x87\x04\x047\n\r\n\x05\x06\0\x02\x1c\x04\
    \x12\x04\x88\x04\x04?\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\0\x12\x04\
    \x88\x04\x04?\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x89\x04\x04F\n\x11\n\t\
    \x06\0\x02\x1c\x04\xc2\xf3\x04\x01\x12\x04\x89\x04\x04F\n\r\n\x05\x06\0\
    \x02\x1c\x04\x12\x04\x8a\x04\x04C\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\
    \x04\x02\x12\x04\x8a\x04\x04C\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x8b\
    \x04\x04A\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\x03\x12\x04\x8b\x04\
    \x04A\n3\n\x04\x06\0\x02\x1d\x12\x06\x8f\x04\x02\x9b\x04\x03\x1a#\x20Get\
    \x20a\x20specific\x20input\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\
    \x1d\x01\x12\x04\x8f\x04\x06\x0e\n\r\n\x05\x06\0\x02\x1d\x02\x12\x04\x8f\
    \x04\x10\x1f\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\x8f\x04*=\n\x0f\n\x05\
    \x06\0\x02\x1d\x04\x12\x06\x90\x04\x04\x95\x04\x06\n\x13\n\t\x06\0\x02\
    \x1d\x04\xb0\xca\xbc\"\x12\x06\x90\x04\x04\x95\x04\x06\n\r\n\x05\x06\0\
    \x02\x1d\x04\x12\x04\x96\x04\x047\n\x10\n\x08\x06\0\x02\x1d\x04\xc3\xf3\
    \x04\x12\x04\x96\x04\x047\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x97\x04\
    \x04?\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\0\x12\x04\x97\x04\x04?\n\r\
    \n\x05\x06\0\x02\x1d\x04\x12\x04\x98\x04\x04F\n\x11\n\t\x06\0\x02\x1d\
    \x04\xc2\xf3\x04\x01\x12\x04\x98\x04\x04F\n\r\n\x05\x06\0\x02\x1d\x04\
    \x12\x04\x99\x04\x04C\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x02\x12\
    \x04\x99\x04\x04C\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x9a\x04\x04A\n\x11\
    \n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x03\x12\x04\x9a\x04\x04A\n-\n\x04\x06\
    \0\x02\x1e\x12\x06\x9e\x04\x02\xa8\x04\x03\x1a\x1d\x20Get\x20a\x20video\
    \x20input\x20manifest.\n\n\r\n\x05\x06\0\x02\x1e\x01\x12\x04\x9e\x04\x06\
    \x1b\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\x9e\x04\x1d4\n\r\n\x05\x06\0\
    \x02\x1e\x03\x12\x04\x9e\x04?W\n\x0f\n\x05\x06\0\x02\x1e\x04\x12\x06\x9f\
    \x04\x04\xa4\x04\x06\n\x13\n\t\x06\0\x02\x1e\x04\xb0\xca\xbc\"\x12\x06\
    \x9f\x04\x04\xa4\x04\x06\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xa5\x04\x04\
    7\n\x10\n\x08\x06\0\x02\x1e\x04\xc3\xf3\x04\x12\x04\xa5\x04\x047\n\r\n\
    \x05\x06\0\x02\x1e\x04\x12\x04\xa6\x04\x04?\n\x11\n\t\x06\0\x02\x1e\x04\
    \xc2\xf3\x04\0\x12\x04\xa6\x04\x04?\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\
    \xa7\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x01\x12\x04\xa7\
    \x04\x04A\n&\n\x04\x06\0\x02\x1f\x12\x06\xab\x04\x02\xb7\x04\x03\x1a\x16\
    \x20List\x20all\x20the\x20inputs.\n\n\r\n\x05\x06\0\x02\x1f\x01\x12\x04\
    \xab\x04\x06\x10\n\r\n\x05\x06\0\x02\x1f\x02\x12\x04\xab\x04\x12#\n\r\n\
    \x05\x06\0\x02\x1f\x03\x12\x04\xab\x04.@\n\x0f\n\x05\x06\0\x02\x1f\x04\
    \x12\x06\xac\x04\x04\xb1\x04\x06\n\x13\n\t\x06\0\x02\x1f\x04\xb0\xca\xbc\
    \"\x12\x06\xac\x04\x04\xb1\x04\x06\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\
    \xb2\x04\x047\n\x10\n\x08\x06\0\x02\x1f\x04\xc3\xf3\x04\x12\x04\xb2\x04\
    \x047\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xb3\x04\x04?\n\x11\n\t\x06\0\
    \x02\x1f\x04\xc2\xf3\x04\0\x12\x04\xb3\x04\x04?\n\r\n\x05\x06\0\x02\x1f\
    \x04\x12\x04\xb4\x04\x04F\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x01\
    \x12\x04\xb4\x04\x04F\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xb5\x04\x04C\n\
    \x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x02\x12\x04\xb5\x04\x04C\n\r\n\
    \x05\x06\0\x02\x1f\x04\x12\x04\xb6\x04\x04A\n\x11\n\t\x06\0\x02\x1f\x04\
    \xc2\xf3\x04\x03\x12\x04\xb6\x04\x04A\n_\n\x04\x06\0\x02\x20\x12\x06\xbb\
    \x04\x02\xce\x04\x03\x1aO\x20Add\x201\x20or\x20more\x20input\x20to\x20an\
    \x20app.\n\x20The\x20actual\x20inputs\x20processing\x20is\x20asynchronou\
    s.\n\n\r\n\x05\x06\0\x02\x20\x01\x12\x04\xbb\x04\x06\x10\n\r\n\x05\x06\0\
    \x02\x20\x02\x12\x04\xbb\x04\x12#\n\r\n\x05\x06\0\x02\x20\x03\x12\x04\
    \xbb\x04.@\n\x0f\n\x05\x06\0\x02\x20\x04\x12\x06\xbc\x04\x04\xc3\x04\x06\
    \n\x13\n\t\x06\0\x02\x20\x04\xb0\xca\xbc\"\x12\x06\xbc\x04\x04\xc3\x04\
    \x06\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xc4\x04\x047\n\x10\n\x08\x06\0\
    \x02\x20\x04\xc3\xf3\x04\x12\x04\xc4\x04\x047\n\r\n\x05\x06\0\x02\x20\
    \x04\x12\x04\xc5\x04\x04?\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\0\x12\
    \x04\xc5\x04\x04?\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xc6\x04\x04F\n\x11\
    \n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x01\x12\x04\xc6\x04\x04F\n\r\n\x05\
    \x06\0\x02\x20\x04\x12\x04\xc7\x04\x04F\n\x11\n\t\x06\0\x02\x20\x04\xc2\
    \xf3\x04\x02\x12\x04\xc7\x04\x04F\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\
    \xc8\x04\x04C\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x03\x12\x04\xc8\
    \x04\x04C\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xc9\x04\x04A\n\x11\n\t\x06\
    \0\x02\x20\x04\xc2\xf3\x04\x04\x12\x04\xc9\x04\x04A\n\r\n\x05\x06\0\x02\
    \x20\x04\x12\x04\xca\x04\x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\
    \x05\x12\x04\xca\x04\x04A\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xcb\x04\
    \x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x06\x12\x04\xcb\x04\x04A\n\
    \r\n\x05\x06\0\x02\x20\x04\x12\x04\xcc\x04\x04>\n\x11\n\t\x06\0\x02\x20\
    \x04\xc2\xf3\x04\x07\x12\x04\xcc\x04\x04>\n\r\n\x05\x06\0\x02\x20\x04\
    \x12\x04\xcd\x04\x04D\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x08\x12\
    \x04\xcd\x04\x04D\n+\n\x04\x06\0\x02!\x12\x06\xd4\x04\x02\xe5\x04\x03\
    \x1a\x1b\x20Patch\x20one\x20or\x20more\x20inputs.\n\n\r\n\x05\x06\0\x02!\
    \x01\x12\x04\xd4\x04\x06\x11\n\r\n\x05\x06\0\x02!\x02\x12\x04\xd4\x04\
    \x13%\n\r\n\x05\x06\0\x02!\x03\x12\x04\xd4\x040B\n\x0f\n\x05\x06\0\x02!\
    \x04\x12\x06\xd5\x04\x04\xdc\x04\x06\n\x13\n\t\x06\0\x02!\x04\xb0\xca\
    \xbc\"\x12\x06\xd5\x04\x04\xdc\x04\x06\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xdd\x04\x047\n\x10\n\x08\x06\0\x02!\x04\xc3\xf3\x04\x12\x04\xdd\x04\x04\
    7\n\r\n\x05\x06\0\x02!\x04\x12\x04\xde\x04\x04?\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\0\x12\x04\xde\x04\x04?\n\r\n\x05\x06\0\x02!\x04\x12\x04\xdf\
    \x04\x04F\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x01\x12\x04\xdf\x04\x04F\
    \n\r\n\x05\x06\0\x02!\x04\x12\x04\xe0\x04\x04F\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\x02\x12\x04\xe0\x04\x04F\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xe1\x04\x04C\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x03\x12\x04\xe1\x04\
    \x04C\n\r\n\x05\x06\0\x02!\x04\x12\x04\xe2\x04\x04A\n\x11\n\t\x06\0\x02!\
    \x04\xc2\xf3\x04\x04\x12\x04\xe2\x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\
    \x04\xe3\x04\x04A\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x05\x12\x04\xe3\
    \x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\x04\xe4\x04\x04A\n\x11\n\t\x06\0\
    \x02!\x04\xc2\xf3\x04\x06\x12\x04\xe4\x04\x04A\n7\n\x04\x06\0\x02\"\x12\
    \x06\xe8\x04\x02\xf9\x04\x03\x1a'\x20Delete\x20a\x20single\x20input\x20a\
    synchronously.\n\n\r\n\x05\x06\0\x02\"\x01\x12\x04\xe8\x04\x06\x11\n\r\n\
    \x05\x06\0\x02\"\x02\x12\x04\xe8\x04\x13%\n\r\n\x05\x06\0\x02\"\x03\x12\
    \x04\xe8\x040P\n\x0f\n\x05\x06\0\x02\"\x04\x12\x06\xe9\x04\x04\xee\x04\
    \x06\n\x13\n\t\x06\0\x02\"\x04\xb0\xca\xbc\"\x12\x06\xe9\x04\x04\xee\x04\
    \x06\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xef\x04\x047\n\x10\n\x08\x06\0\
    \x02\"\x04\xc3\xf3\x04\x12\x04\xef\x04\x047\n\r\n\x05\x06\0\x02\"\x04\
    \x12\x04\xf0\x04\x04?\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\0\x12\x04\
    \xf0\x04\x04?\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf1\x04\x04F\n\x11\n\t\
    \x06\0\x02\"\x04\xc2\xf3\x04\x01\x12\x04\xf1\x04\x04F\n\r\n\x05\x06\0\
    \x02\"\x04\x12\x04\xf2\x04\x04I\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\
    \x02\x12\x04\xf2\x04\x04I\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf3\x04\x04F\
    \n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x03\x12\x04\xf3\x04\x04F\n\r\n\
    \x05\x06\0\x02\"\x04\x12\x04\xf4\x04\x04A\n\x11\n\t\x06\0\x02\"\x04\xc2\
    \xf3\x04\x04\x12\x04\xf4\x04\x04A\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf5\
    \x04\x04D\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x05\x12\x04\xf5\x04\x04D\
    \n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf6\x04\x04A\n\x11\n\t\x06\0\x02\"\
    \x04\xc2\xf3\x04\x06\x12\x04\xf6\x04\x04A\n\r\n\x05\x06\0\x02\"\x04\x12\
    \x04\xf7\x04\x04A\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x07\x12\x04\xf7\
    \x04\x04A\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf8\x04\x04D\n\x11\n\t\x06\0\
    \x02\"\x04\xc2\xf3\x04\x08\x12\x04\xf8\x04\x04D\nT\n\x04\x06\0\x02#\x12\
    \x06\xfd\x04\x02\x90\x05\x03\x1aD\x20Delete\x20multiple\x20inputs\x20in\
    \x20one\x20request.\n\x20This\x20call\x20is\x20asynchronous.\n\n\r\n\x05\
    \x06\0\x02#\x01\x12\x04\xfd\x04\x06\x12\n\r\n\x05\x06\0\x02#\x02\x12\x04\
    \xfd\x04\x14'\n\r\n\x05\x06\0\x02#\x03\x12\x04\xfd\x042R\n\x0f\n\x05\x06\
    \0\x02#\x04\x12\x06\xfe\x04\x04\x85\x05\x06\n\x13\n\t\x06\0\x02#\x04\xb0\
    \xca\xbc\"\x12\x06\xfe\x04\x04\x85\x05\x06\n\r\n\x05\x06\0\x02#\x04\x12\
    \x04\x86\x05\x047\n\x10\n\x08\x06\0\x02#\x04\xc3\xf3\x04\x12\x04\x86\x05\
    \x047\n\r\n\x05\x06\0\x02#\x04\x12\x04\x87\x05\x04?\n\x11\n\t\x06\0\x02#\
    \x04\xc2\xf3\x04\0\x12\x04\x87\x05\x04?\n\r\n\x05\x06\0\x02#\x04\x12\x04\
    \x88\x05\x04F\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x01\x12\x04\x88\x05\
    \x04F\n\r\n\x05\x06\0\x02#\x04\x12\x04\x89\x05\x04I\n\x11\n\t\x06\0\x02#\
    \x04\xc2\xf3\x04\x02\x12\x04\x89\x05\x04I\n\r\n\x05\x06\0\x02#\x04\x12\
    \x04\x8a\x05\x04F\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x03\x12\x04\x8a\
    \x05\x04F\n\r\n\x05\x06\0\x02#\x04\x12\x04\x8b\x05\x04A\n\x11\n\t\x06\0\
    \x02#\x04\xc2\xf3\x04\x04\x12\x04\x8b\x05\x04A\n\r\n\x05\x06\0\x02#\x04\
    \x12\x04\x8c\x05\x04D\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x05\x12\x04\
    \x8c\x05\x04D\n\r\n\x05\x06\0\x02#\x04\x12\x04\x8d\x05\x04A\n\x11\n\t\
    \x06\0\x02#\x04\xc2\xf3\x04\x06\x12\x04\x8d\x05\x04A\n\r\n\x05\x06\0\x02\
    #\x04\x12\x04\x8e\x05\x04A\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x07\x12\
    \x04\x8e\x05\x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\x8f\x05\x04D\n\x11\n\
    \t\x06\0\x02#\x04\xc2\xf3\x04\x08\x12\x04\x8f\x05\x04D\n5\n\x04\x06\0\
    \x02$\x12\x06\x93\x05\x02\xa0\x05\x03\x1a%\x20Patch\x20saved\x20inputs\
    \x20searches\x20by\x20ids.\n\n\r\n\x05\x06\0\x02$\x01\x12\x04\x93\x05\
    \x06\x19\n\r\n\x05\x06\0\x02$\x02\x12\x04\x93\x05\x1b5\n\r\n\x05\x06\0\
    \x02$\x03\x12\x04\x93\x05@S\n\x0f\n\x05\x06\0\x02$\x04\x12\x06\x94\x05\
    \x04\x9b\x05\x06\n\x13\n\t\x06\0\x02$\x04\xb0\xca\xbc\"\x12\x06\x94\x05\
    \x04\x9b\x05\x06\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9c\x05\x047\n\x10\n\
    \x08\x06\0\x02$\x04\xc3\xf3\x04\x12\x04\x9c\x05\x047\n\r\n\x05\x06\0\x02\
    $\x04\x12\x04\x9d\x05\x04?\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\0\x12\
    \x04\x9d\x05\x04?\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9e\x05\x04F\n\x11\n\
    \t\x06\0\x02$\x04\xc2\xf3\x04\x01\x12\x04\x9e\x05\x04F\n\r\n\x05\x06\0\
    \x02$\x04\x12\x04\x9f\x05\x04F\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x02\
    \x12\x04\x9f\x05\x04F\n.\n\x04\x06\0\x02%\x12\x06\xa3\x05\x02\xb4\x05\
    \x03\x1a\x1e\x20Execute\x20a\x20search\x20over\x20inputs\n\n\r\n\x05\x06\
    \0\x02%\x01\x12\x04\xa3\x05\x06\x18\n\r\n\x05\x06\0\x02%\x02\x12\x04\xa3\
    \x05\x192\n\r\n\x05\x06\0\x02%\x03\x12\x04\xa3\x05=P\n\x0f\n\x05\x06\0\
    \x02%\x04\x12\x06\xa4\x05\x04\xab\x05\x06\n\x13\n\t\x06\0\x02%\x04\xb0\
    \xca\xbc\"\x12\x06\xa4\x05\x04\xab\x05\x06\n\r\n\x05\x06\0\x02%\x04\x12\
    \x04\xac\x05\x047\n\x10\n\x08\x06\0\x02%\x04\xc3\xf3\x04\x12\x04\xac\x05\
    \x047\n\r\n\x05\x06\0\x02%\x04\x12\x04\xad\x05\x04?\n\x11\n\t\x06\0\x02%\
    \x04\xc2\xf3\x04\0\x12\x04\xad\x05\x04?\n\r\n\x05\x06\0\x02%\x04\x12\x04\
    \xae\x05\x04F\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\x01\x12\x04\xae\x05\
    \x04F\n\r\n\x05\x06\0\x02%\x04\x12\x04\xaf\x05\x04C\n\x11\n\t\x06\0\x02%\
    \x04\xc2\xf3\x04\x02\x12\x04\xaf\x05\x04C\n\r\n\x05\x06\0\x02%\x04\x12\
    \x04\xb0\x05\x04A\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\x03\x12\x04\xb0\
    \x05\x04A\n\r\n\x05\x06\0\x02%\x04\x12\x04\xb1\x05\x04A\n\x11\n\t\x06\0\
    \x02%\x04\xc2\xf3\x04\x04\x12\x04\xb1\x05\x04A\n\r\n\x05\x06\0\x02%\x04\
    \x12\x04\xb2\x05\x04=\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\x05\x12\x04\
    \xb2\x05\x04=\n\r\n\x05\x06\0\x02%\x04\x12\x04\xb3\x05\x04D\nN\n\t\x06\0\
    \x02%\x04\xc2\xf3\x04\x06\x12\x04\xb3\x05\x04D\";\x20to\x20know\x20the\
    \x20concepts\x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n7\
    \n\x04\x06\0\x02&\x12\x06\xb7\x05\x02\xcd\x05\x03\x1a'\x20Get\x20predict\
    ed\x20outputs\x20from\x20the\x20model.\n\n\r\n\x05\x06\0\x02&\x01\x12\
    \x04\xb7\x05\x06\x16\n\r\n\x05\x06\0\x02&\x02\x12\x04\xb7\x05\x18/\n\r\n\
    \x05\x06\0\x02&\x03\x12\x04\xb7\x05:M\n\x0f\n\x05\x06\0\x02&\x04\x12\x06\
    \xb8\x05\x04\xc7\x05\x06\n\x13\n\t\x06\0\x02&\x04\xb0\xca\xbc\"\x12\x06\
    \xb8\x05\x04\xc7\x05\x06\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc8\x05\x047\n\
    \x10\n\x08\x06\0\x02&\x04\xc3\xf3\x04\x12\x04\xc8\x05\x047\n\r\n\x05\x06\
    \0\x02&\x04\x12\x04\xc9\x05\x04?\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\0\
    \x12\x04\xc9\x05\x04?\n\r\n\x05\x06\0\x02&\x04\x12\x04\xca\x05\x04C\n\
    \x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x01\x12\x04\xca\x05\x04C\n\r\n\x05\
    \x06\0\x02&\x04\x12\x04\xcb\x05\x04A\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\
    \x04\x02\x12\x04\xcb\x05\x04A\n\r\n\x05\x06\0\x02&\x04\x12\x04\xcc\x05\
    \x04>\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x03\x12\x04\xcc\x05\x04>\n(\n\
    \x04\x06\0\x02'\x12\x06\xd0\x05\x02\xde\x05\x03\x1a\x18\x20List\x20all\
    \x20the\x20datasets.\n\n\r\n\x05\x06\0\x02'\x01\x12\x04\xd0\x05\x06\x12\
    \n\r\n\x05\x06\0\x02'\x02\x12\x04\xd0\x05\x14'\n\r\n\x05\x06\0\x02'\x03\
    \x12\x04\xd0\x052F\n\x0f\n\x05\x06\0\x02'\x04\x12\x06\xd1\x05\x04\xd9\
    \x05\x06\n\x13\n\t\x06\0\x02'\x04\xb0\xca\xbc\"\x12\x06\xd1\x05\x04\xd9\
    \x05\x06\n\r\n\x05\x06\0\x02'\x04\x12\x04\xda\x05\x047\n\x10\n\x08\x06\0\
    \x02'\x04\xc3\xf3\x04\x12\x04\xda\x05\x047\n\r\n\x05\x06\0\x02'\x04\x12\
    \x04\xdb\x05\x04?\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\0\x12\x04\xdb\x05\
    \x04?\n\r\n\x05\x06\0\x02'\x04\x12\x04\xdc\x05\x04C\n\x11\n\t\x06\0\x02'\
    \x04\xc2\xf3\x04\x01\x12\x04\xdc\x05\x04C\n\r\n\x05\x06\0\x02'\x04\x12\
    \x04\xdd\x05\x04F\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\x02\x12\x04\xdd\
    \x05\x04F\n)\n\x04\x06\0\x02(\x12\x06\xe1\x05\x02\xec\x05\x03\x1a\x19\
    \x20Get\x20a\x20specific\x20dataset.\n\n\r\n\x05\x06\0\x02(\x01\x12\x04\
    \xe1\x05\x06\x10\n\r\n\x05\x06\0\x02(\x02\x12\x04\xe1\x05\x12#\n\r\n\x05\
    \x06\0\x02(\x03\x12\x04\xe1\x05.C\n\x0f\n\x05\x06\0\x02(\x04\x12\x06\xe2\
    \x05\x04\xe7\x05\x06\n\x13\n\t\x06\0\x02(\x04\xb0\xca\xbc\"\x12\x06\xe2\
    \x05\x04\xe7\x05\x06\n\r\n\x05\x06\0\x02(\x04\x12\x04\xe8\x05\x047\n\x10\
    \n\x08\x06\0\x02(\x04\xc3\xf3\x04\x12\x04\xe8\x05\x047\n\r\n\x05\x06\0\
    \x02(\x04\x12\x04\xe9\x05\x04?\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\0\
    \x12\x04\xe9\x05\x04?\n\r\n\x05\x06\0\x02(\x04\x12\x04\xea\x05\x04C\n\
    \x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\x01\x12\x04\xea\x05\x04C\n\r\n\x05\
    \x06\0\x02(\x04\x12\x04\xeb\x05\x04F\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\
    \x04\x02\x12\x04\xeb\x05\x04F\n\xd8\x01\n\x04\x06\0\x02)\x12\x06\xf2\x05\
    \x02\x80\x06\x03\x1a\xc7\x01\x20Add\x20datasets\x20to\x20an\x20app.\n\
    \x20The\x20process\x20is\x20atomic,\x20i.e.\x20either\x20all\x20or\x20no\
    \x20datasets\x20are\x20added.\n\x20If\x20there\x20is\x20an\x20error\x20f\
    or\x20one\x20dataset,\n\x20the\x20process\x20will\x20stop,\x20revert\x20\
    the\x20transaction\x20and\x20return\x20the\x20error.\n\n\r\n\x05\x06\0\
    \x02)\x01\x12\x04\xf2\x05\x06\x12\n\r\n\x05\x06\0\x02)\x02\x12\x04\xf2\
    \x05\x14'\n\r\n\x05\x06\0\x02)\x03\x12\x04\xf2\x052F\n\x0f\n\x05\x06\0\
    \x02)\x04\x12\x06\xf3\x05\x04\xfa\x05\x06\n\x13\n\t\x06\0\x02)\x04\xb0\
    \xca\xbc\"\x12\x06\xf3\x05\x04\xfa\x05\x06\n\r\n\x05\x06\0\x02)\x04\x12\
    \x04\xfb\x05\x047\n\x10\n\x08\x06\0\x02)\x04\xc3\xf3\x04\x12\x04\xfb\x05\
    \x047\n\r\n\x05\x06\0\x02)\x04\x12\x04\xfc\x05\x04?\n\x11\n\t\x06\0\x02)\
    \x04\xc2\xf3\x04\0\x12\x04\xfc\x05\x04?\n\r\n\x05\x06\0\x02)\x04\x12\x04\
    \xfd\x05\x04C\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\x01\x12\x04\xfd\x05\
    \x04C\n\r\n\x05\x06\0\x02)\x04\x12\x04\xfe\x05\x04C\n\x11\n\t\x06\0\x02)\
    \x04\xc2\xf3\x04\x02\x12\x04\xfe\x05\x04C\n\r\n\x05\x06\0\x02)\x04\x12\
    \x04\xff\x05\x04F\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\x03\x12\x04\xff\
    \x05\x04F\n\xde\x01\n\x04\x06\0\x02*\x12\x06\x86\x06\x02\x94\x06\x03\x1a\
    \xcd\x01\x20Patch\x20one\x20or\x20more\x20datasets.\n\x20The\x20process\
    \x20is\x20atomic,\x20i.e.\x20either\x20all\x20or\x20no\x20datasets\x20ar\
    e\x20patched.\n\x20If\x20there\x20is\x20an\x20error\x20for\x20one\x20dat\
    aset,\n\x20the\x20process\x20will\x20stop,\x20revert\x20the\x20transacti\
    on\x20and\x20return\x20the\x20error.\n\n\r\n\x05\x06\0\x02*\x01\x12\x04\
    \x86\x06\x06\x13\n\r\n\x05\x06\0\x02*\x02\x12\x04\x86\x06\x15)\n\r\n\x05\
    \x06\0\x02*\x03\x12\x04\x86\x064H\n\x0f\n\x05\x06\0\x02*\x04\x12\x06\x87\
    \x06\x04\x8e\x06\x06\n\x13\n\t\x06\0\x02*\x04\xb0\xca\xbc\"\x12\x06\x87\
    \x06\x04\x8e\x06\x06\n\r\n\x05\x06\0\x02*\x04\x12\x04\x8f\x06\x047\n\x10\
    \n\x08\x06\0\x02*\x04\xc3\xf3\x04\x12\x04\x8f\x06\x047\n\r\n\x05\x06\0\
    \x02*\x04\x12\x04\x90\x06\x04?\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\0\
    \x12\x04\x90\x06\x04?\n\r\n\x05\x06\0\x02*\x04\x12\x04\x91\x06\x04C\n\
    \x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x01\x12\x04\x91\x06\x04C\n\r\n\x05\
    \x06\0\x02*\x04\x12\x04\x92\x06\x04C\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\
    \x04\x02\x12\x04\x92\x06\x04C\n\r\n\x05\x06\0\x02*\x04\x12\x04\x93\x06\
    \x04F\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x03\x12\x04\x93\x06\x04F\nB\n\
    \x04\x06\0\x02+\x12\x06\x97\x06\x02\xa5\x06\x03\x1a2\x20Delete\x20one\
    \x20or\x20more\x20datasets\x20in\x20a\x20single\x20request.\n\n\r\n\x05\
    \x06\0\x02+\x01\x12\x04\x97\x06\x06\x14\n\r\n\x05\x06\0\x02+\x02\x12\x04\
    \x97\x06\x16+\n\r\n\x05\x06\0\x02+\x03\x12\x04\x97\x066V\n\x0f\n\x05\x06\
    \0\x02+\x04\x12\x06\x98\x06\x04\x9f\x06\x06\n\x13\n\t\x06\0\x02+\x04\xb0\
    \xca\xbc\"\x12\x06\x98\x06\x04\x9f\x06\x06\n\r\n\x05\x06\0\x02+\x04\x12\
    \x04\xa0\x06\x047\n\x10\n\x08\x06\0\x02+\x04\xc3\xf3\x04\x12\x04\xa0\x06\
    \x047\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa1\x06\x04?\n\x11\n\t\x06\0\x02+\
    \x04\xc2\xf3\x04\0\x12\x04\xa1\x06\x04?\n\r\n\x05\x06\0\x02+\x04\x12\x04\
    \xa2\x06\x04C\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x01\x12\x04\xa2\x06\
    \x04C\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa3\x06\x04C\n\x11\n\t\x06\0\x02+\
    \x04\xc2\xf3\x04\x02\x12\x04\xa3\x06\x04C\n\r\n\x05\x06\0\x02+\x04\x12\
    \x04\xa4\x06\x04F\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x03\x12\x04\xa4\
    \x06\x04F\n;\n\x04\x06\0\x02,\x12\x06\xa8\x06\x02\xb5\x06\x03\x1a+\x20Li\
    st\x20all\x20the\x20dataset\x20inputs\x20in\x20a\x20dataset.\n\n\r\n\x05\
    \x06\0\x02,\x01\x12\x04\xa8\x06\x06\x17\n\r\n\x05\x06\0\x02,\x02\x12\x04\
    \xa8\x06\x191\n\r\n\x05\x06\0\x02,\x03\x12\x04\xa8\x06<U\n\x0f\n\x05\x06\
    \0\x02,\x04\x12\x06\xa9\x06\x04\xae\x06\x06\n\x13\n\t\x06\0\x02,\x04\xb0\
    \xca\xbc\"\x12\x06\xa9\x06\x04\xae\x06\x06\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xaf\x06\x047\n\x10\n\x08\x06\0\x02,\x04\xc3\xf3\x04\x12\x04\xaf\x06\
    \x047\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb0\x06\x04?\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\0\x12\x04\xb0\x06\x04?\n\r\n\x05\x06\0\x02,\x04\x12\x04\
    \xb1\x06\x04C\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x01\x12\x04\xb1\x06\
    \x04C\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb2\x06\x04A\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\x02\x12\x04\xb2\x06\x04A\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xb3\x06\x04F\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x03\x12\x04\xb3\
    \x06\x04F\n\r\n\x05\x06\0\x02,\x04\x12\x04\xb4\x06\x04C\n\x11\n\t\x06\0\
    \x02,\x04\xc2\xf3\x04\x04\x12\x04\xb4\x06\x04C\n/\n\x04\x06\0\x02-\x12\
    \x06\xb8\x06\x02\xc5\x06\x03\x1a\x1f\x20Get\x20a\x20specific\x20dataset\
    \x20input.\n\n\r\n\x05\x06\0\x02-\x01\x12\x04\xb8\x06\x06\x15\n\r\n\x05\
    \x06\0\x02-\x02\x12\x04\xb8\x06\x17-\n\r\n\x05\x06\0\x02-\x03\x12\x04\
    \xb8\x068R\n\x0f\n\x05\x06\0\x02-\x04\x12\x06\xb9\x06\x04\xbe\x06\x06\n\
    \x13\n\t\x06\0\x02-\x04\xb0\xca\xbc\"\x12\x06\xb9\x06\x04\xbe\x06\x06\n\
    \r\n\x05\x06\0\x02-\x04\x12\x04\xbf\x06\x047\n\x10\n\x08\x06\0\x02-\x04\
    \xc3\xf3\x04\x12\x04\xbf\x06\x047\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc0\
    \x06\x04?\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\0\x12\x04\xc0\x06\x04?\n\
    \r\n\x05\x06\0\x02-\x04\x12\x04\xc1\x06\x04C\n\x11\n\t\x06\0\x02-\x04\
    \xc2\xf3\x04\x01\x12\x04\xc1\x06\x04C\n\r\n\x05\x06\0\x02-\x04\x12\x04\
    \xc2\x06\x04A\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x02\x12\x04\xc2\x06\
    \x04A\n\r\n\x05\x06\0\x02-\x04\x12\x04\xc3\x06\x04F\n\x11\n\t\x06\0\x02-\
    \x04\xc2\xf3\x04\x03\x12\x04\xc3\x06\x04F\n\r\n\x05\x06\0\x02-\x04\x12\
    \x04\xc4\x06\x04C\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x04\x12\x04\xc4\
    \x06\x04C\n\xce\x03\n\x04\x06\0\x02.\x12\x06\xcf\x06\x02\xdf\x06\x03\x1a\
    \xbd\x03\x20Add\x20dataset\x20inputs\x20to\x20a\x20dataset.\n\x20The\x20\
    process\x20is\x20not\x20atomic,\x20i.e.\x20if\x20there\x20are\x20errors\
    \x20with\x20some\x20dataset\n\x20inputs,\x20others\x20might\x20still\x20\
    be\x20added.\x20The\x20response\x20reports\n\x20\x20\x20-\x20SUCCESS\x20\
    if\x20all\x20dataset\x20inputs\x20were\x20added,\n\x20\x20\x20-\x20MIXED\
    _STATUS\x20if\x20only\x20some\x20dataset\x20inputs\x20were\x20added,\x20\
    and\n\x20\x20\x20-\x20FAILURE\x20if\x20no\x20dataset\x20inputs\x20were\
    \x20added.\n\x20Each\x20individual\x20dataset\x20input\x20in\x20the\x20r\
    esponse\x20has\x20the\x20status\x20set\x20to\n\x20indicate\x20if\x20it\
    \x20was\x20successful\x20or\x20if\x20there\x20was\x20an\x20error.\n\n\r\
    \n\x05\x06\0\x02.\x01\x12\x04\xcf\x06\x06\x17\n\r\n\x05\x06\0\x02.\x02\
    \x12\x04\xcf\x06\x191\n\r\n\x05\x06\0\x02.\x03\x12\x04\xcf\x06<U\n\x0f\n\
    \x05\x06\0\x02.\x04\x12\x06\xd0\x06\x04\xd7\x06\x06\n\x13\n\t\x06\0\x02.\
    \x04\xb0\xca\xbc\"\x12\x06\xd0\x06\x04\xd7\x06\x06\n\r\n\x05\x06\0\x02.\
    \x04\x12\x04\xd8\x06\x047\n\x10\n\x08\x06\0\x02.\x04\xc3\xf3\x04\x12\x04\
    \xd8\x06\x047\n\r\n\x05\x06\0\x02.\x04\x12\x04\xd9\x06\x04?\n\x11\n\t\
    \x06\0\x02.\x04\xc2\xf3\x04\0\x12\x04\xd9\x06\x04?\n\r\n\x05\x06\0\x02.\
    \x04\x12\x04\xda\x06\x04C\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x01\x12\
    \x04\xda\x06\x04C\n\r\n\x05\x06\0\x02.\x04\x12\x04\xdb\x06\x04C\n\x11\n\
    \t\x06\0\x02.\x04\xc2\xf3\x04\x02\x12\x04\xdb\x06\x04C\n\r\n\x05\x06\0\
    \x02.\x04\x12\x04\xdc\x06\x04A\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x03\
    \x12\x04\xdc\x06\x04A\n\r\n\x05\x06\0\x02.\x04\x12\x04\xdd\x06\x04F\n\
    \x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x04\x12\x04\xdd\x06\x04F\n\r\n\x05\
    \x06\0\x02.\x04\x12\x04\xde\x06\x04C\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\
    \x04\x05\x12\x04\xde\x06\x04C\nH\n\x04\x06\0\x02/\x12\x06\xe2\x06\x02\
    \xf1\x06\x03\x1a8\x20Delete\x20one\x20or\x20more\x20dataset\x20inputs\
    \x20in\x20a\x20single\x20request.\n\n\r\n\x05\x06\0\x02/\x01\x12\x04\xe2\
    \x06\x06\x19\n\r\n\x05\x06\0\x02/\x02\x12\x04\xe2\x06\x1b5\n\r\n\x05\x06\
    \0\x02/\x03\x12\x04\xe2\x06@`\n\x0f\n\x05\x06\0\x02/\x04\x12\x06\xe3\x06\
    \x04\xea\x06\x06\n\x13\n\t\x06\0\x02/\x04\xb0\xca\xbc\"\x12\x06\xe3\x06\
    \x04\xea\x06\x06\n\r\n\x05\x06\0\x02/\x04\x12\x04\xeb\x06\x047\n\x10\n\
    \x08\x06\0\x02/\x04\xc3\xf3\x04\x12\x04\xeb\x06\x047\n\r\n\x05\x06\0\x02\
    /\x04\x12\x04\xec\x06\x04?\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\0\x12\
    \x04\xec\x06\x04?\n\r\n\x05\x06\0\x02/\x04\x12\x04\xed\x06\x04C\n\x11\n\
    \t\x06\0\x02/\x04\xc2\xf3\x04\x01\x12\x04\xed\x06\x04C\n\r\n\x05\x06\0\
    \x02/\x04\x12\x04\xee\x06\x04C\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x02\
    \x12\x04\xee\x06\x04C\n\r\n\x05\x06\0\x02/\x04\x12\x04\xef\x06\x04F\n\
    \x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x03\x12\x04\xef\x06\x04F\n\r\n\x05\
    \x06\0\x02/\x04\x12\x04\xf0\x06\x04A\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\
    \x04\x04\x12\x04\xf0\x06\x04A\n0\n\x04\x06\0\x020\x12\x06\xf4\x06\x02\
    \xff\x06\x03\x1a\x20\x20List\x20all\x20the\x20dataset\x20versions.\n\n\r\
    \n\x05\x06\0\x020\x01\x12\x04\xf4\x06\x06\x19\n\r\n\x05\x06\0\x020\x02\
    \x12\x04\xf4\x06\x1b5\n\r\n\x05\x06\0\x020\x03\x12\x04\xf4\x06@[\n\x0f\n\
    \x05\x06\0\x020\x04\x12\x06\xf5\x06\x04\xfa\x06\x06\n\x13\n\t\x06\0\x020\
    \x04\xb0\xca\xbc\"\x12\x06\xf5\x06\x04\xfa\x06\x06\n\r\n\x05\x06\0\x020\
    \x04\x12\x04\xfb\x06\x047\n\x10\n\x08\x06\0\x020\x04\xc3\xf3\x04\x12\x04\
    \xfb\x06\x047\n\r\n\x05\x06\0\x020\x04\x12\x04\xfc\x06\x04?\n\x11\n\t\
    \x06\0\x020\x04\xc2\xf3\x04\0\x12\x04\xfc\x06\x04?\n\r\n\x05\x06\0\x020\
    \x04\x12\x04\xfd\x06\x04C\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x01\x12\
    \x04\xfd\x06\x04C\n\r\n\x05\x06\0\x020\x04\x12\x04\xfe\x06\x04F\n\x11\n\
    \t\x06\0\x020\x04\xc2\xf3\x04\x02\x12\x04\xfe\x06\x04F\n1\n\x04\x06\0\
    \x021\x12\x06\x82\x07\x02\x8d\x07\x03\x1a!\x20Get\x20a\x20specific\x20da\
    taset\x20version.\n\n\r\n\x05\x06\0\x021\x01\x12\x04\x82\x07\x06\x17\n\r\
    \n\x05\x06\0\x021\x02\x12\x04\x82\x07\x191\n\r\n\x05\x06\0\x021\x03\x12\
    \x04\x82\x07<X\n\x0f\n\x05\x06\0\x021\x04\x12\x06\x83\x07\x04\x88\x07\
    \x06\n\x13\n\t\x06\0\x021\x04\xb0\xca\xbc\"\x12\x06\x83\x07\x04\x88\x07\
    \x06\n\r\n\x05\x06\0\x021\x04\x12\x04\x89\x07\x047\n\x10\n\x08\x06\0\x02\
    1\x04\xc3\xf3\x04\x12\x04\x89\x07\x047\n\r\n\x05\x06\0\x021\x04\x12\x04\
    \x8a\x07\x04?\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\0\x12\x04\x8a\x07\x04\
    ?\n\r\n\x05\x06\0\x021\x04\x12\x04\x8b\x07\x04C\n\x11\n\t\x06\0\x021\x04\
    \xc2\xf3\x04\x01\x12\x04\x8b\x07\x04C\n\r\n\x05\x06\0\x021\x04\x12\x04\
    \x8c\x07\x04F\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x02\x12\x04\x8c\x07\
    \x04F\n\x0e\n\x04\x06\0\x022\x12\x06\x8f\x07\x02\x9c\x07\x03\n\r\n\x05\
    \x06\0\x022\x01\x12\x04\x8f\x07\x06%\n\r\n\x05\x06\0\x022\x02\x12\x04\
    \x8f\x07'M\n\r\n\x05\x06\0\x022\x03\x12\x04\x8f\x07X\x7f\n\x0f\n\x05\x06\
    \0\x022\x04\x12\x06\x90\x07\x04\x95\x07\x06\n\x13\n\t\x06\0\x022\x04\xb0\
    \xca\xbc\"\x12\x06\x90\x07\x04\x95\x07\x06\n\r\n\x05\x06\0\x022\x04\x12\
    \x04\x96\x07\x047\n\x10\n\x08\x06\0\x022\x04\xc3\xf3\x04\x12\x04\x96\x07\
    \x047\n\r\n\x05\x06\0\x022\x04\x12\x04\x97\x07\x04?\n\x11\n\t\x06\0\x022\
    \x04\xc2\xf3\x04\0\x12\x04\x97\x07\x04?\n\r\n\x05\x06\0\x022\x04\x12\x04\
    \x98\x07\x04C\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x01\x12\x04\x98\x07\
    \x04C\n\r\n\x05\x06\0\x022\x04\x12\x04\x99\x07\x04F\n\x11\n\t\x06\0\x022\
    \x04\xc2\xf3\x04\x02\x12\x04\x99\x07\x04F\n\r\n\x05\x06\0\x022\x04\x12\
    \x04\x9a\x07\x04C\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x03\x12\x04\x9a\
    \x07\x04C\n\r\n\x05\x06\0\x022\x04\x12\x04\x9b\x07\x04A\n\x11\n\t\x06\0\
    \x022\x04\xc2\xf3\x04\x04\x12\x04\x9b\x07\x04A\n4\n\x04\x06\0\x023\x12\
    \x06\x9f\x07\x02\xae\x07\x03\x1a$\x20Add\x20dataset\x20versions\x20to\
    \x20a\x20dataset.\n\n\r\n\x05\x06\0\x023\x01\x12\x04\x9f\x07\x06\x19\n\r\
    \n\x05\x06\0\x023\x02\x12\x04\x9f\x07\x1b5\n\r\n\x05\x06\0\x023\x03\x12\
    \x04\x9f\x07@[\n\x0f\n\x05\x06\0\x023\x04\x12\x06\xa0\x07\x04\xa7\x07\
    \x06\n\x13\n\t\x06\0\x023\x04\xb0\xca\xbc\"\x12\x06\xa0\x07\x04\xa7\x07\
    \x06\n\r\n\x05\x06\0\x023\x04\x12\x04\xa8\x07\x047\n\x10\n\x08\x06\0\x02\
    3\x04\xc3\xf3\x04\x12\x04\xa8\x07\x047\n\r\n\x05\x06\0\x023\x04\x12\x04\
    \xa9\x07\x04?\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\0\x12\x04\xa9\x07\x04\
    ?\n\r\n\x05\x06\0\x023\x04\x12\x04\xaa\x07\x04C\n\x11\n\t\x06\0\x023\x04\
    \xc2\xf3\x04\x01\x12\x04\xaa\x07\x04C\n\r\n\x05\x06\0\x023\x04\x12\x04\
    \xab\x07\x04C\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x02\x12\x04\xab\x07\
    \x04C\n\r\n\x05\x06\0\x023\x04\x12\x04\xac\x07\x04A\n\x11\n\t\x06\0\x023\
    \x04\xc2\xf3\x04\x03\x12\x04\xac\x07\x04A\n\r\n\x05\x06\0\x023\x04\x12\
    \x04\xad\x07\x04D\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x04\x12\x04\xad\
    \x07\x04D\n5\n\x04\x06\0\x024\x12\x06\xb1\x07\x02\xbe\x07\x03\x1a%\x20Pa\
    tch\x20one\x20or\x20more\x20dataset\x20versions.\n\n\r\n\x05\x06\0\x024\
    \x01\x12\x04\xb1\x07\x06\x1a\n\r\n\x05\x06\0\x024\x02\x12\x04\xb1\x07\
    \x1c7\n\r\n\x05\x06\0\x024\x03\x12\x04\xb1\x07B]\n\x0f\n\x05\x06\0\x024\
    \x04\x12\x06\xb2\x07\x04\xb9\x07\x06\n\x13\n\t\x06\0\x024\x04\xb0\xca\
    \xbc\"\x12\x06\xb2\x07\x04\xb9\x07\x06\n\r\n\x05\x06\0\x024\x04\x12\x04\
    \xba\x07\x047\n\x10\n\x08\x06\0\x024\x04\xc3\xf3\x04\x12\x04\xba\x07\x04\
    7\n\r\n\x05\x06\0\x024\x04\x12\x04\xbb\x07\x04?\n\x11\n\t\x06\0\x024\x04\
    \xc2\xf3\x04\0\x12\x04\xbb\x07\x04?\n\r\n\x05\x06\0\x024\x04\x12\x04\xbc\
    \x07\x04C\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x01\x12\x04\xbc\x07\x04C\
    \n\r\n\x05\x06\0\x024\x04\x12\x04\xbd\x07\x04C\n\x11\n\t\x06\0\x024\x04\
    \xc2\xf3\x04\x02\x12\x04\xbd\x07\x04C\nJ\n\x04\x06\0\x025\x12\x06\xc1\
    \x07\x02\xcf\x07\x03\x1a:\x20Delete\x20one\x20or\x20more\x20dataset\x20v\
    ersions\x20in\x20a\x20single\x20request.\n\n\r\n\x05\x06\0\x025\x01\x12\
    \x04\xc1\x07\x06\x1b\n\r\n\x05\x06\0\x025\x02\x12\x04\xc1\x07\x1d9\n\r\n\
    \x05\x06\0\x025\x03\x12\x04\xc1\x07Dd\n\x0f\n\x05\x06\0\x025\x04\x12\x06\
    \xc2\x07\x04\xc9\x07\x06\n\x13\n\t\x06\0\x025\x04\xb0\xca\xbc\"\x12\x06\
    \xc2\x07\x04\xc9\x07\x06\n\r\n\x05\x06\0\x025\x04\x12\x04\xca\x07\x047\n\
    \x10\n\x08\x06\0\x025\x04\xc3\xf3\x04\x12\x04\xca\x07\x047\n\r\n\x05\x06\
    \0\x025\x04\x12\x04\xcb\x07\x04?\n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\0\
    \x12\x04\xcb\x07\x04?\n\r\n\x05\x06\0\x025\x04\x12\x04\xcc\x07\x04C\n\
    \x11\n\t\x06\0\x025\x04\xc2\xf3\x04\x01\x12\x04\xcc\x07\x04C\n\r\n\x05\
    \x06\0\x025\x04\x12\x04\xcd\x07\x04C\n\x11\n\t\x06\0\x025\x04\xc2\xf3\
    \x04\x02\x12\x04\xcd\x07\x04C\n\r\n\x05\x06\0\x025\x04\x12\x04\xce\x07\
    \x04F\n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\x03\x12\x04\xce\x07\x04F\n5\n\
    \x04\x06\0\x026\x12\x06\xd2\x07\x02\xdf\x07\x03\x1a%\x20Create\x20export\
    \x20of\x20a\x20dataset\x20version.\n\n\r\n\x05\x06\0\x026\x01\x12\x04\
    \xd2\x07\x06\x1e\n\r\n\x05\x06\0\x026\x02\x12\x04\xd2\x07\x20?\n\r\n\x05\
    \x06\0\x026\x03\x12\x04\xd2\x07Jk\n\x0f\n\x05\x06\0\x026\x04\x12\x06\xd3\
    \x07\x04\xda\x07\x06\n\x13\n\t\x06\0\x026\x04\xb0\xca\xbc\"\x12\x06\xd3\
    \x07\x04\xda\x07\x06\n\r\n\x05\x06\0\x026\x04\x12\x04\xdb\x07\x047\n\x10\
    \n\x08\x06\0\x026\x04\xc3\xf3\x04\x12\x04\xdb\x07\x047\n\r\n\x05\x06\0\
    \x026\x04\x12\x04\xdc\x07\x04?\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\0\
    \x12\x04\xdc\x07\x04?\n\r\n\x05\x06\0\x026\x04\x12\x04\xdd\x07\x04C\n\
    \x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x01\x12\x04\xdd\x07\x04C\n\r\n\x05\
    \x06\0\x026\x04\x12\x04\xde\x07\x04C\n\x11\n\t\x06\0\x026\x04\xc2\xf3\
    \x04\x02\x12\x04\xde\x07\x04C\n\x84\x01\n\x04\x06\0\x027\x12\x06\xe7\x07\
    \x02\xf1\x07\x03\x1a\x1c\x20Get\x20a\x20specific\x20model\x20type.\n2V//\
    ////////////////////////////////////\n\x20Models\n//////////////////////\
    ////////////////\n\n\r\n\x05\x06\0\x027\x01\x12\x04\xe7\x07\x06\x12\n\r\
    \n\x05\x06\0\x027\x02\x12\x04\xe7\x07\x14'\n\r\n\x05\x06\0\x027\x03\x12\
    \x04\xe7\x072I\n\x0f\n\x05\x06\0\x027\x04\x12\x06\xe8\x07\x04\xed\x07\
    \x06\n\x13\n\t\x06\0\x027\x04\xb0\xca\xbc\"\x12\x06\xe8\x07\x04\xed\x07\
    \x06\n\r\n\x05\x06\0\x027\x04\x12\x04\xee\x07\x047\n\x10\n\x08\x06\0\x02\
    7\x04\xc3\xf3\x04\x12\x04\xee\x07\x047\n\r\n\x05\x06\0\x027\x04\x12\x04\
    \xef\x07\x04?\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\0\x12\x04\xef\x07\x04\
    ?\n\r\n\x05\x06\0\x027\x04\x12\x04\xf0\x07\x04A\n\x11\n\t\x06\0\x027\x04\
    \xc2\xf3\x04\x01\x12\x04\xf0\x07\x04A\nN\n\x04\x06\0\x028\x12\x06\xf4\
    \x07\x02\xf9\x07\x03\x1a>\x20List\x20all\x20the\x20supported\x20open\x20\
    source\x20licenses\x20in\x20the\x20platform.\n\n\r\n\x05\x06\0\x028\x01\
    \x12\x04\xf4\x07\x06\x1c\n\r\n\x05\x06\0\x028\x02\x12\x04\xf4\x07\x1e;\n\
    \r\n\x05\x06\0\x028\x03\x12\x04\xf4\x07Fd\n\x0f\n\x05\x06\0\x028\x04\x12\
    \x06\xf5\x07\x04\xf7\x07\x06\n\x13\n\t\x06\0\x028\x04\xb0\xca\xbc\"\x12\
    \x06\xf5\x07\x04\xf7\x07\x06\n\r\n\x05\x06\0\x028\x04\x12\x04\xf8\x07\
    \x046\n\x10\n\x08\x06\0\x028\x04\xc3\xf3\x04\x12\x04\xf8\x07\x046\n\x9a\
    \x01\n\x04\x06\0\x029\x12\x06\xfd\x07\x02\x87\x08\x03\x1a\x89\x01\x20Lis\
    t\x20all\x20the\x20model\x20types\x20available\x20in\x20the\x20platform.\
    \n\x20This\x20MUST\x20be\x20above\x20ListModels\x20so\x20that\x20the\x20\
    /models/types\x20endpoint\x20takes\x20precedence.\n\n\r\n\x05\x06\0\x029\
    \x01\x12\x04\xfd\x07\x06\x14\n\r\n\x05\x06\0\x029\x02\x12\x04\xfd\x07\
    \x16+\n\r\n\x05\x06\0\x029\x03\x12\x04\xfd\x076L\n\x0f\n\x05\x06\0\x029\
    \x04\x12\x06\xfe\x07\x04\x83\x08\x06\n\x13\n\t\x06\0\x029\x04\xb0\xca\
    \xbc\"\x12\x06\xfe\x07\x04\x83\x08\x06\n\r\n\x05\x06\0\x029\x04\x12\x04\
    \x84\x08\x047\n\x10\n\x08\x06\0\x029\x04\xc3\xf3\x04\x12\x04\x84\x08\x04\
    7\n\r\n\x05\x06\0\x029\x04\x12\x04\x85\x08\x04?\n\x11\n\t\x06\0\x029\x04\
    \xc2\xf3\x04\0\x12\x04\x85\x08\x04?\n\r\n\x05\x06\0\x029\x04\x12\x04\x86\
    \x08\x04A\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\x01\x12\x04\x86\x08\x04A\
    \n3\n\x04\x06\0\x02:\x12\x06\x8a\x08\x02\x95\x08\x03\x1a#\x20Get\x20a\
    \x20specific\x20model\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02:\x01\
    \x12\x04\x8a\x08\x06\x0e\n\r\n\x05\x06\0\x02:\x02\x12\x04\x8a\x08\x10\
    \x1f\n\r\n\x05\x06\0\x02:\x03\x12\x04\x8a\x08*=\n\x0f\n\x05\x06\0\x02:\
    \x04\x12\x06\x8b\x08\x04\x90\x08\x06\n\x13\n\t\x06\0\x02:\x04\xb0\xca\
    \xbc\"\x12\x06\x8b\x08\x04\x90\x08\x06\n\r\n\x05\x06\0\x02:\x04\x12\x04\
    \x91\x08\x047\n\x10\n\x08\x06\0\x02:\x04\xc3\xf3\x04\x12\x04\x91\x08\x04\
    7\n\r\n\x05\x06\0\x02:\x04\x12\x04\x92\x08\x04?\n\x11\n\t\x06\0\x02:\x04\
    \xc2\xf3\x04\0\x12\x04\x92\x08\x04?\n\r\n\x05\x06\0\x02:\x04\x12\x04\x93\
    \x08\x04C\n\x11\n\t\x06\0\x02:\x04\xc2\xf3\x04\x01\x12\x04\x93\x08\x04C\
    \n\r\n\x05\x06\0\x02:\x04\x12\x04\x94\x08\x04A\n\x11\n\t\x06\0\x02:\x04\
    \xc2\xf3\x04\x02\x12\x04\x94\x08\x04A\n[\n\x04\x06\0\x02;\x12\x06\x99\
    \x08\x02\xaa\x08\x03\x1aK\x20Get\x20a\x20the\x20output\x20info\x20for\
    \x20a\x20given\x20model_id\x20or\x20model_id/version_id\n\x20combo.\n\n\
    \r\n\x05\x06\0\x02;\x01\x12\x04\x99\x08\x06\x18\n\r\n\x05\x06\0\x02;\x02\
    \x12\x04\x99\x08\x1a)\n\r\n\x05\x06\0\x02;\x03\x12\x04\x99\x084G\n\x0f\n\
    \x05\x06\0\x02;\x04\x12\x06\x9a\x08\x04\xa5\x08\x06\n\x13\n\t\x06\0\x02;\
    \x04\xb0\xca\xbc\"\x12\x06\x9a\x08\x04\xa5\x08\x06\n\r\n\x05\x06\0\x02;\
    \x04\x12\x04\xa6\x08\x047\n\x10\n\x08\x06\0\x02;\x04\xc3\xf3\x04\x12\x04\
    \xa6\x08\x047\n\r\n\x05\x06\0\x02;\x04\x12\x04\xa7\x08\x04?\n\x11\n\t\
    \x06\0\x02;\x04\xc2\xf3\x04\0\x12\x04\xa7\x08\x04?\n\r\n\x05\x06\0\x02;\
    \x04\x12\x04\xa8\x08\x04C\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\x01\x12\
    \x04\xa8\x08\x04C\n\r\n\x05\x06\0\x02;\x04\x12\x04\xa9\x08\x04A\n\x11\n\
    \t\x06\0\x02;\x04\xc2\xf3\x04\x02\x12\x04\xa9\x08\x04A\n&\n\x04\x06\0\
    \x02<\x12\x06\xad\x08\x02\xbb\x08\x03\x1a\x16\x20List\x20all\x20the\x20m\
    odels.\n\n\r\n\x05\x06\0\x02<\x01\x12\x04\xad\x08\x06\x10\n\r\n\x05\x06\
    \0\x02<\x02\x12\x04\xad\x08\x12#\n\r\n\x05\x06\0\x02<\x03\x12\x04\xad\
    \x08.@\n\x0f\n\x05\x06\0\x02<\x04\x12\x06\xae\x08\x04\xb6\x08\x06\n\x13\
    \n\t\x06\0\x02<\x04\xb0\xca\xbc\"\x12\x06\xae\x08\x04\xb6\x08\x06\n\r\n\
    \x05\x06\0\x02<\x04\x12\x04\xb7\x08\x047\n\x10\n\x08\x06\0\x02<\x04\xc3\
    \xf3\x04\x12\x04\xb7\x08\x047\n\r\n\x05\x06\0\x02<\x04\x12\x04\xb8\x08\
    \x04?\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\0\x12\x04\xb8\x08\x04?\n\r\n\
    \x05\x06\0\x02<\x04\x12\x04\xb9\x08\x04C\n\x11\n\t\x06\0\x02<\x04\xc2\
    \xf3\x04\x01\x12\x04\xb9\x08\x04C\n\r\n\x05\x06\0\x02<\x04\x12\x04\xba\
    \x08\x04A\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x02\x12\x04\xba\x08\x04A\
    \n7\n\x04\x06\0\x02=\x12\x06\xbe\x08\x02\xcc\x08\x03\x1a'\x20List\x20the\
    \x20resource\x20counts\x20for\x20the\x20app.\n\n\r\n\x05\x06\0\x02=\x01\
    \x12\x04\xbe\x08\x06\x17\n\r\n\x05\x06\0\x02=\x02\x12\x04\xbe\x08\x191\n\
    \r\n\x05\x06\0\x02=\x03\x12\x04\xbe\x08<U\n\x0f\n\x05\x06\0\x02=\x04\x12\
    \x06\xbf\x08\x04\xc4\x08\x06\n\x13\n\t\x06\0\x02=\x04\xb0\xca\xbc\"\x12\
    \x06\xbf\x08\x04\xc4\x08\x06\n\r\n\x05\x06\0\x02=\x04\x12\x04\xc5\x08\
    \x047\n\x10\n\x08\x06\0\x02=\x04\xc3\xf3\x04\x12\x04\xc5\x08\x047\n\r\n\
    \x05\x06\0\x02=\x04\x12\x04\xc6\x08\x04C\n\x11\n\t\x06\0\x02=\x04\xc2\
    \xf3\x04\0\x12\x04\xc6\x08\x04C\n\r\n\x05\x06\0\x02=\x04\x12\x04\xc7\x08\
    \x04A\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x01\x12\x04\xc7\x08\x04A\n\r\
    \n\x05\x06\0\x02=\x04\x12\x04\xc8\x08\x04D\n\x11\n\t\x06\0\x02=\x04\xc2\
    \xf3\x04\x02\x12\x04\xc8\x08\x04D\n\r\n\x05\x06\0\x02=\x04\x12\x04\xc9\
    \x08\x04B\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x03\x12\x04\xc9\x08\x04B\
    \n\r\n\x05\x06\0\x02=\x04\x12\x04\xca\x08\x04?\n\x11\n\t\x06\0\x02=\x04\
    \xc2\xf3\x04\x04\x12\x04\xca\x08\x04?\n\xcb\x01\n\x04\x06\0\x02>\x12\x06\
    \xd1\x08\x02\xde\x08\x03\x1a\xba\x01\x20Search\x20over\x20the\x20models\
    \x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20Th\
    is\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\
    \x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20\
    variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02>\x01\x12\x04\
    \xd1\x08\x06\x18\n\r\n\x05\x06\0\x02>\x02\x12\x04\xd1\x08\x1a3\n\r\n\x05\
    \x06\0\x02>\x03\x12\x04\xd1\x08>P\n\x0f\n\x05\x06\0\x02>\x04\x12\x06\xd2\
    \x08\x04\xd9\x08\x06\n\x13\n\t\x06\0\x02>\x04\xb0\xca\xbc\"\x12\x06\xd2\
    \x08\x04\xd9\x08\x06\n\r\n\x05\x06\0\x02>\x04\x12\x04\xda\x08\x047\n\x10\
    \n\x08\x06\0\x02>\x04\xc3\xf3\x04\x12\x04\xda\x08\x047\n\r\n\x05\x06\0\
    \x02>\x04\x12\x04\xdb\x08\x04?\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\0\
    \x12\x04\xdb\x08\x04?\n\r\n\x05\x06\0\x02>\x04\x12\x04\xdc\x08\x04C\n\
    \x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\x01\x12\x04\xdc\x08\x04C\n\r\n\x05\
    \x06\0\x02>\x04\x12\x04\xdd\x08\x04A\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\
    \x04\x02\x12\x04\xdd\x08\x04A\n)\n\x04\x06\0\x02?\x12\x06\xe1\x08\x02\
    \xf1\x08\x03\x1a\x19\x20Add\x20a\x20models\x20to\x20an\x20app.\n\n\r\n\
    \x05\x06\0\x02?\x01\x12\x04\xe1\x08\x06\x10\n\r\n\x05\x06\0\x02?\x02\x12\
    \x04\xe1\x08\x12#\n\r\n\x05\x06\0\x02?\x03\x12\x04\xe1\x08.A\n\x0f\n\x05\
    \x06\0\x02?\x04\x12\x06\xe2\x08\x04\xe9\x08\x06\n\x13\n\t\x06\0\x02?\x04\
    \xb0\xca\xbc\"\x12\x06\xe2\x08\x04\xe9\x08\x06\n\r\n\x05\x06\0\x02?\x04\
    \x12\x04\xea\x08\x047\n\x10\n\x08\x06\0\x02?\x04\xc3\xf3\x04\x12\x04\xea\
    \x08\x047\n\r\n\x05\x06\0\x02?\x04\x12\x04\xeb\x08\x04?\n\x11\n\t\x06\0\
    \x02?\x04\xc2\xf3\x04\0\x12\x04\xeb\x08\x04?\n\r\n\x05\x06\0\x02?\x04\
    \x12\x04\xec\x08\x04C\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\x01\x12\x04\
    \xec\x08\x04C\n\r\n\x05\x06\0\x02?\x04\x12\x04\xed\x08\x04A\n\x11\n\t\
    \x06\0\x02?\x04\xc2\xf3\x04\x02\x12\x04\xed\x08\x04A\n\r\n\x05\x06\0\x02\
    ?\x04\x12\x04\xee\x08\x04A\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\x03\x12\
    \x04\xee\x08\x04A\n\r\n\x05\x06\0\x02?\x04\x12\x04\xef\x08\x04C\nF\n\t\
    \x06\0\x02?\x04\xc2\xf3\x04\x04\x12\x04\xef\x08\x04C\"3\x20Train\x20is\
    \x20needed\x20because\x20it\x20creates\x20a\x20new\x20version.\n\n\r\n\
    \x05\x06\0\x02?\x04\x12\x04\xf0\x08\x04D\nF\n\t\x06\0\x02?\x04\xc2\xf3\
    \x04\x05\x12\x04\xf0\x08\x04D\"3\x20Needs\x20to\x20check\x20the\x20base\
    \x20workflow\x20to\x20build\x20off\x20of.\n\n+\n\x04\x06\0\x02@\x12\x06\
    \xf4\x08\x02\x83\t\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\x20models.\
    \n\n\r\n\x05\x06\0\x02@\x01\x12\x04\xf4\x08\x06\x11\n\r\n\x05\x06\0\x02@\
    \x02\x12\x04\xf4\x08\x13%\n\r\n\x05\x06\0\x02@\x03\x12\x04\xf4\x080B\n\
    \x0f\n\x05\x06\0\x02@\x04\x12\x06\xf5\x08\x04\xfc\x08\x06\n\x13\n\t\x06\
    \0\x02@\x04\xb0\xca\xbc\"\x12\x06\xf5\x08\x04\xfc\x08\x06\n\r\n\x05\x06\
    \0\x02@\x04\x12\x04\xfd\x08\x047\n\x10\n\x08\x06\0\x02@\x04\xc3\xf3\x04\
    \x12\x04\xfd\x08\x047\n\r\n\x05\x06\0\x02@\x04\x12\x04\xfe\x08\x04?\n\
    \x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\0\x12\x04\xfe\x08\x04?\n\r\n\x05\x06\
    \0\x02@\x04\x12\x04\xff\x08\x04C\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\
    \x01\x12\x04\xff\x08\x04C\n\r\n\x05\x06\0\x02@\x04\x12\x04\x80\t\x04A\n\
    \x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\x02\x12\x04\x80\t\x04A\n\r\n\x05\x06\
    \0\x02@\x04\x12\x04\x81\t\x04A\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\x03\
    \x12\x04\x81\t\x04A\n\r\n\x05\x06\0\x02@\x04\x12\x04\x82\t\x04C\n\x11\n\
    \t\x06\0\x02@\x04\xc2\xf3\x04\x04\x12\x04\x82\t\x04C\n/\n\x04\x06\0\x02A\
    \x12\x06\x86\t\x02\x8f\t\x03\x1a\x1f\x20Patch\x20one\x20or\x20more\x20mo\
    dels\x20ids.\n\n\r\n\x05\x06\0\x02A\x01\x12\x04\x86\t\x06\x13\n\r\n\x05\
    \x06\0\x02A\x02\x12\x04\x86\t\x15)\n\r\n\x05\x06\0\x02A\x03\x12\x04\x86\
    \t4F\n\x0f\n\x05\x06\0\x02A\x04\x12\x06\x87\t\x04\x8a\t\x06\n\x13\n\t\
    \x06\0\x02A\x04\xb0\xca\xbc\"\x12\x06\x87\t\x04\x8a\t\x06\n\r\n\x05\x06\
    \0\x02A\x04\x12\x04\x8b\t\x047\n\x10\n\x08\x06\0\x02A\x04\xc3\xf3\x04\
    \x12\x04\x8b\t\x047\n\r\n\x05\x06\0\x02A\x04\x12\x04\x8c\t\x04?\n\x11\n\
    \t\x06\0\x02A\x04\xc2\xf3\x04\0\x12\x04\x8c\t\x04?\n\r\n\x05\x06\0\x02A\
    \x04\x12\x04\x8d\t\x04A\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\x01\x12\x04\
    \x8d\t\x04A\n\r\n\x05\x06\0\x02A\x04\x12\x04\x8e\t\x04A\n\x11\n\t\x06\0\
    \x02A\x04\xc2\xf3\x04\x02\x12\x04\x8e\t\x04A\n(\n\x04\x06\0\x02B\x12\x06\
    \x92\t\x02\xa0\t\x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\
    \x05\x06\0\x02B\x01\x12\x04\x92\t\x06\x11\n\r\n\x05\x06\0\x02B\x02\x12\
    \x04\x92\t\x13%\n\r\n\x05\x06\0\x02B\x03\x12\x04\x92\t0P\n\x0f\n\x05\x06\
    \0\x02B\x04\x12\x06\x93\t\x04\x98\t\x06\n\x13\n\t\x06\0\x02B\x04\xb0\xca\
    \xbc\"\x12\x06\x93\t\x04\x98\t\x06\n\r\n\x05\x06\0\x02B\x04\x12\x04\x99\
    \t\x047\n\x10\n\x08\x06\0\x02B\x04\xc3\xf3\x04\x12\x04\x99\t\x047\n\r\n\
    \x05\x06\0\x02B\x04\x12\x04\x9a\t\x04?\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\
    \x04\0\x12\x04\x9a\t\x04?\n\r\n\x05\x06\0\x02B\x04\x12\x04\x9b\t\x04C\n\
    \x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\x01\x12\x04\x9b\t\x04C\n\r\n\x05\x06\
    \0\x02B\x04\x12\x04\x9c\t\x04A\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\x02\
    \x12\x04\x9c\t\x04A\n\r\n\x05\x06\0\x02B\x04\x12\x04\x9d\t\x04D\n\x11\n\
    \t\x06\0\x02B\x04\xc2\xf3\x04\x03\x12\x04\x9d\t\x04D\n\r\n\x05\x06\0\x02\
    B\x04\x12\x04\x9e\t\x04A\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\x04\x12\
    \x04\x9e\t\x04A\n\r\n\x05\x06\0\x02B\x04\x12\x04\x9f\t\x04D\n\x11\n\t\
    \x06\0\x02B\x04\xc2\xf3\x04\x05\x12\x04\x9f\t\x04D\n8\n\x04\x06\0\x02C\
    \x12\x06\xa3\t\x02\xb3\t\x03\x1a(\x20Delete\x20multiple\x20models\x20in\
    \x20one\x20request.\n\n\r\n\x05\x06\0\x02C\x01\x12\x04\xa3\t\x06\x12\n\r\
    \n\x05\x06\0\x02C\x02\x12\x04\xa3\t\x14'\n\r\n\x05\x06\0\x02C\x03\x12\
    \x04\xa3\t2R\n\x0f\n\x05\x06\0\x02C\x04\x12\x06\xa4\t\x04\xab\t\x06\n\
    \x13\n\t\x06\0\x02C\x04\xb0\xca\xbc\"\x12\x06\xa4\t\x04\xab\t\x06\n\r\n\
    \x05\x06\0\x02C\x04\x12\x04\xac\t\x047\n\x10\n\x08\x06\0\x02C\x04\xc3\
    \xf3\x04\x12\x04\xac\t\x047\n\r\n\x05\x06\0\x02C\x04\x12\x04\xad\t\x04?\
    \n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\0\x12\x04\xad\t\x04?\n\r\n\x05\x06\
    \0\x02C\x04\x12\x04\xae\t\x04C\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x01\
    \x12\x04\xae\t\x04C\n\r\n\x05\x06\0\x02C\x04\x12\x04\xaf\t\x04A\n\x11\n\
    \t\x06\0\x02C\x04\xc2\xf3\x04\x02\x12\x04\xaf\t\x04A\n\r\n\x05\x06\0\x02\
    C\x04\x12\x04\xb0\t\x04D\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x03\x12\
    \x04\xb0\t\x04D\n\r\n\x05\x06\0\x02C\x04\x12\x04\xb1\t\x04A\n\x11\n\t\
    \x06\0\x02C\x04\xc2\xf3\x04\x04\x12\x04\xb1\t\x04A\n\r\n\x05\x06\0\x02C\
    \x04\x12\x04\xb2\t\x04D\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x05\x12\x04\
    \xb2\t\x04D\n-\n\x04\x06\0\x02D\x12\x06\xb6\t\x02\xc2\t\x03\x1a\x1d\x20U\
    pdate\x20model\x20check\x20consents\n\n\r\n\x05\x06\0\x02D\x01\x12\x04\
    \xb6\t\x06\x1d\n\r\n\x05\x06\0\x02D\x02\x12\x04\xb6\t\x1f=\n\r\n\x05\x06\
    \0\x02D\x03\x12\x04\xb6\tHf\n\x0f\n\x05\x06\0\x02D\x04\x12\x06\xb7\t\x04\
    \xbe\t\x06\n\x13\n\t\x06\0\x02D\x04\xb0\xca\xbc\"\x12\x06\xb7\t\x04\xbe\
    \t\x06\n\r\n\x05\x06\0\x02D\x04\x12\x04\xbf\t\x047\n\x10\n\x08\x06\0\x02\
    D\x04\xc3\xf3\x04\x12\x04\xbf\t\x047\n\r\n\x05\x06\0\x02D\x04\x12\x04\
    \xc0\t\x04?\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\0\x12\x04\xc0\t\x04?\n\
    \r\n\x05\x06\0\x02D\x04\x12\x04\xc1\t\x04A\n\x11\n\t\x06\0\x02D\x04\xc2\
    \xf3\x04\x01\x12\x04\xc1\t\x04A\n,\n\x04\x06\0\x02E\x12\x06\xc5\t\x02\
    \xd1\t\x03\x1a\x1c\x20Update\x20model\x20toolkits\x20tags\n\n\r\n\x05\
    \x06\0\x02E\x01\x12\x04\xc5\t\x06\x18\n\r\n\x05\x06\0\x02E\x02\x12\x04\
    \xc5\t\x1a3\n\r\n\x05\x06\0\x02E\x03\x12\x04\xc5\t>W\n\x0f\n\x05\x06\0\
    \x02E\x04\x12\x06\xc6\t\x04\xcd\t\x06\n\x13\n\t\x06\0\x02E\x04\xb0\xca\
    \xbc\"\x12\x06\xc6\t\x04\xcd\t\x06\n\r\n\x05\x06\0\x02E\x04\x12\x04\xce\
    \t\x047\n\x10\n\x08\x06\0\x02E\x04\xc3\xf3\x04\x12\x04\xce\t\x047\n\r\n\
    \x05\x06\0\x02E\x04\x12\x04\xcf\t\x04?\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\
    \x04\0\x12\x04\xcf\t\x04?\n\r\n\x05\x06\0\x02E\x04\x12\x04\xd0\t\x04A\n\
    \x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\x01\x12\x04\xd0\t\x04A\n-\n\x04\x06\
    \0\x02F\x12\x06\xd4\t\x02\xe0\t\x03\x1a\x1d\x20Update\x20model\x20use_ca\
    ses\x20tags\n\n\r\n\x05\x06\0\x02F\x01\x12\x04\xd4\t\x06\x18\n\r\n\x05\
    \x06\0\x02F\x02\x12\x04\xd4\t\x1a3\n\r\n\x05\x06\0\x02F\x03\x12\x04\xd4\
    \t>W\n\x0f\n\x05\x06\0\x02F\x04\x12\x06\xd5\t\x04\xdc\t\x06\n\x13\n\t\
    \x06\0\x02F\x04\xb0\xca\xbc\"\x12\x06\xd5\t\x04\xdc\t\x06\n\r\n\x05\x06\
    \0\x02F\x04\x12\x04\xdd\t\x047\n\x10\n\x08\x06\0\x02F\x04\xc3\xf3\x04\
    \x12\x04\xdd\t\x047\n\r\n\x05\x06\0\x02F\x04\x12\x04\xde\t\x04?\n\x11\n\
    \t\x06\0\x02F\x04\xc2\xf3\x04\0\x12\x04\xde\t\x04?\n\r\n\x05\x06\0\x02F\
    \x04\x12\x04\xdf\t\x04A\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\x01\x12\x04\
    \xdf\t\x04A\n-\n\x04\x06\0\x02G\x12\x06\xe3\t\x02\xef\t\x03\x1a\x1d\x20U\
    pdate\x20model\x20languages\x20tags\n\n\r\n\x05\x06\0\x02G\x01\x12\x04\
    \xe3\t\x06\x19\n\r\n\x05\x06\0\x02G\x02\x12\x04\xe3\t\x1b5\n\r\n\x05\x06\
    \0\x02G\x03\x12\x04\xe3\t@Z\n\x0f\n\x05\x06\0\x02G\x04\x12\x06\xe4\t\x04\
    \xeb\t\x06\n\x13\n\t\x06\0\x02G\x04\xb0\xca\xbc\"\x12\x06\xe4\t\x04\xeb\
    \t\x06\n\r\n\x05\x06\0\x02G\x04\x12\x04\xec\t\x047\n\x10\n\x08\x06\0\x02\
    G\x04\xc3\xf3\x04\x12\x04\xec\t\x047\n\r\n\x05\x06\0\x02G\x04\x12\x04\
    \xed\t\x04?\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\0\x12\x04\xed\t\x04?\n\
    \r\n\x05\x06\0\x02G\x04\x12\x04\xee\t\x04A\n\x11\n\t\x06\0\x02G\x04\xc2\
    \xf3\x04\x01\x12\x04\xee\t\x04A\n&\n\x04\x06\0\x02H\x12\x06\xf2\t\x02\
    \x85\n\x03\x1a\x16\x20List\x20all\x20the\x20inputs.\n\n\r\n\x05\x06\0\
    \x02H\x01\x12\x04\xf2\t\x06\x15\n\r\n\x05\x06\0\x02H\x02\x12\x04\xf2\t\
    \x17-\n\r\n\x05\x06\0\x02H\x03\x12\x04\xf2\t8J\n\x0f\n\x05\x06\0\x02H\
    \x04\x12\x06\xf3\t\x04\xfe\t\x06\n\x13\n\t\x06\0\x02H\x04\xb0\xca\xbc\"\
    \x12\x06\xf3\t\x04\xfe\t\x06\n\r\n\x05\x06\0\x02H\x04\x12\x04\xff\t\x047\
    \n\x10\n\x08\x06\0\x02H\x04\xc3\xf3\x04\x12\x04\xff\t\x047\n\r\n\x05\x06\
    \0\x02H\x04\x12\x04\x80\n\x04?\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\0\
    \x12\x04\x80\n\x04?\n\r\n\x05\x06\0\x02H\x04\x12\x04\x81\n\x04F\n\x11\n\
    \t\x06\0\x02H\x04\xc2\xf3\x04\x01\x12\x04\x81\n\x04F\n\r\n\x05\x06\0\x02\
    H\x04\x12\x04\x82\n\x04C\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x02\x12\
    \x04\x82\n\x04C\n\r\n\x05\x06\0\x02H\x04\x12\x04\x83\n\x04A\n\x11\n\t\
    \x06\0\x02H\x04\xc2\xf3\x04\x03\x12\x04\x83\n\x04A\n\r\n\x05\x06\0\x02H\
    \x04\x12\x04\x84\n\x04A\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x04\x12\x04\
    \x84\n\x04A\n3\n\x04\x06\0\x02I\x12\x06\x88\n\x02\x93\n\x03\x1a#\x20Get\
    \x20a\x20specific\x20model\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02I\
    \x01\x12\x04\x88\n\x06\x15\n\r\n\x05\x06\0\x02I\x02\x12\x04\x88\n\x17-\n\
    \r\n\x05\x06\0\x02I\x03\x12\x04\x88\n8R\n\x0f\n\x05\x06\0\x02I\x04\x12\
    \x06\x89\n\x04\x8e\n\x06\n\x13\n\t\x06\0\x02I\x04\xb0\xca\xbc\"\x12\x06\
    \x89\n\x04\x8e\n\x06\n\r\n\x05\x06\0\x02I\x04\x12\x04\x8f\n\x047\n\x10\n\
    \x08\x06\0\x02I\x04\xc3\xf3\x04\x12\x04\x8f\n\x047\n\r\n\x05\x06\0\x02I\
    \x04\x12\x04\x90\n\x04?\n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\0\x12\x04\
    \x90\n\x04?\n\r\n\x05\x06\0\x02I\x04\x12\x04\x91\n\x04C\n\x11\n\t\x06\0\
    \x02I\x04\xc2\xf3\x04\x01\x12\x04\x91\n\x04C\n\r\n\x05\x06\0\x02I\x04\
    \x12\x04\x92\n\x04A\n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\x02\x12\x04\x92\
    \n\x04A\n&\n\x04\x06\0\x02J\x12\x06\x96\n\x02\xa1\n\x03\x1a\x16\x20List\
    \x20all\x20the\x20models.\n\n\r\n\x05\x06\0\x02J\x01\x12\x04\x96\n\x06\
    \x17\n\r\n\x05\x06\0\x02J\x02\x12\x04\x96\n\x191\n\r\n\x05\x06\0\x02J\
    \x03\x12\x04\x96\n<U\n\x0f\n\x05\x06\0\x02J\x04\x12\x06\x97\n\x04\x9c\n\
    \x06\n\x13\n\t\x06\0\x02J\x04\xb0\xca\xbc\"\x12\x06\x97\n\x04\x9c\n\x06\
    \n\r\n\x05\x06\0\x02J\x04\x12\x04\x9d\n\x047\n\x10\n\x08\x06\0\x02J\x04\
    \xc3\xf3\x04\x12\x04\x9d\n\x047\n\r\n\x05\x06\0\x02J\x04\x12\x04\x9e\n\
    \x04?\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\0\x12\x04\x9e\n\x04?\n\r\n\
    \x05\x06\0\x02J\x04\x12\x04\x9f\n\x04C\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\
    \x04\x01\x12\x04\x9f\n\x04C\n\r\n\x05\x06\0\x02J\x04\x12\x04\xa0\n\x04A\
    \n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\x02\x12\x04\xa0\n\x04A\n\x0e\n\x04\
    \x06\0\x02K\x12\x06\xa3\n\x02\xb8\n\x03\n\r\n\x05\x06\0\x02K\x01\x12\x04\
    \xa3\n\x06#\n\r\n\x05\x06\0\x02K\x02\x12\x04\xa3\n%I\n\r\n\x05\x06\0\x02\
    K\x03\x12\x04\xa3\nTt\n\x0f\n\x05\x06\0\x02K\x04\x12\x06\xa4\n\x04\xab\n\
    \x06\n\x13\n\t\x06\0\x02K\x04\xb0\xca\xbc\"\x12\x06\xa4\n\x04\xab\n\x06\
    \n\r\n\x05\x06\0\x02K\x04\x12\x04\xac\n\x047\n\x10\n\x08\x06\0\x02K\x04\
    \xc3\xf3\x04\x12\x04\xac\n\x047\n\r\n\x05\x06\0\x02K\x04\x12\x04\xad\n\
    \x04?\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\0\x12\x04\xad\n\x04?\n\r\n\
    \x05\x06\0\x02K\x04\x12\x04\xae\n\x04R\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\
    \x04\x01\x12\x04\xae\n\x04R\n\r\n\x05\x06\0\x02K\x04\x12\x04\xaf\n\x04F\
    \n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x02\x12\x04\xaf\n\x04F\n\r\n\x05\
    \x06\0\x02K\x04\x12\x04\xb0\n\x04C\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\
    \x03\x12\x04\xb0\n\x04C\n\r\n\x05\x06\0\x02K\x04\x12\x04\xb1\n\x04A\n\
    \x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x04\x12\x04\xb1\n\x04A\n\r\n\x05\x06\
    \0\x02K\x04\x12\x04\xb2\n\x04A\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x05\
    \x12\x04\xb2\n\x04A\n\r\n\x05\x06\0\x02K\x04\x12\x04\xb3\n\x04A\n\x11\n\
    \t\x06\0\x02K\x04\xc2\xf3\x04\x06\x12\x04\xb3\n\x04A\n\r\n\x05\x06\0\x02\
    K\x04\x12\x04\xb4\n\x04C\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x07\x12\
    \x04\xb4\n\x04C\n\r\n\x05\x06\0\x02K\x04\x12\x04\xb5\n\x04D\n\x11\n\t\
    \x06\0\x02K\x04\xc2\xf3\x04\x08\x12\x04\xb5\n\x04D\n\r\n\x05\x06\0\x02K\
    \x04\x12\x04\xb6\n\x04B\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\t\x12\x04\
    \xb6\n\x04B\n\r\n\x05\x06\0\x02K\x04\x12\x04\xb7\n\x04B\n\x11\n\t\x06\0\
    \x02K\x04\xc2\xf3\x04\n\x12\x04\xb7\n\x04B\n\x0e\n\x04\x06\0\x02L\x12\
    \x06\xba\n\x02\xcf\n\x03\n\r\n\x05\x06\0\x02L\x01\x12\x04\xba\n\x06!\n\r\
    \n\x05\x06\0\x02L\x02\x12\x04\xba\n#E\n\r\n\x05\x06\0\x02L\x03\x12\x04\
    \xba\nPp\n\x0f\n\x05\x06\0\x02L\x04\x12\x06\xbb\n\x04\xc2\n\x06\n\x13\n\
    \t\x06\0\x02L\x04\xb0\xca\xbc\"\x12\x06\xbb\n\x04\xc2\n\x06\n\r\n\x05\
    \x06\0\x02L\x04\x12\x04\xc3\n\x047\n\x10\n\x08\x06\0\x02L\x04\xc3\xf3\
    \x04\x12\x04\xc3\n\x047\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc4\n\x04?\n\
    \x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\0\x12\x04\xc4\n\x04?\n\r\n\x05\x06\0\
    \x02L\x04\x12\x04\xc5\n\x04O\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x01\
    \x12\x04\xc5\n\x04O\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc6\n\x04F\n\x11\n\
    \t\x06\0\x02L\x04\xc2\xf3\x04\x02\x12\x04\xc6\n\x04F\n\r\n\x05\x06\0\x02\
    L\x04\x12\x04\xc7\n\x04C\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x03\x12\
    \x04\xc7\n\x04C\n\r\n\x05\x06\0\x02L\x04\x12\x04\xc8\n\x04A\n\x11\n\t\
    \x06\0\x02L\x04\xc2\xf3\x04\x04\x12\x04\xc8\n\x04A\n\r\n\x05\x06\0\x02L\
    \x04\x12\x04\xc9\n\x04A\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x05\x12\x04\
    \xc9\n\x04A\n\r\n\x05\x06\0\x02L\x04\x12\x04\xca\n\x04A\n\x11\n\t\x06\0\
    \x02L\x04\xc2\xf3\x04\x06\x12\x04\xca\n\x04A\n\r\n\x05\x06\0\x02L\x04\
    \x12\x04\xcb\n\x04C\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x07\x12\x04\xcb\
    \n\x04C\n\r\n\x05\x06\0\x02L\x04\x12\x04\xcc\n\x04D\n\x11\n\t\x06\0\x02L\
    \x04\xc2\xf3\x04\x08\x12\x04\xcc\n\x04D\n\r\n\x05\x06\0\x02L\x04\x12\x04\
    \xcd\n\x04B\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\t\x12\x04\xcd\n\x04B\n\
    \r\n\x05\x06\0\x02L\x04\x12\x04\xce\n\x04B\n\x11\n\t\x06\0\x02L\x04\xc2\
    \xf3\x04\n\x12\x04\xce\n\x04B\n*\n\x04\x06\0\x02M\x12\x06\xd2\n\x02\xe7\
    \n\x03\x1a\x1a\x20PostModelVersionsPublish\n\n\r\n\x05\x06\0\x02M\x01\
    \x12\x04\xd2\n\x06\x1e\n\r\n\x05\x06\0\x02M\x02\x12\x04\xd2\n\x20?\n\r\n\
    \x05\x06\0\x02M\x03\x12\x04\xd2\nJj\n\x0f\n\x05\x06\0\x02M\x04\x12\x06\
    \xd3\n\x04\xda\n\x06\n\x13\n\t\x06\0\x02M\x04\xb0\xca\xbc\"\x12\x06\xd3\
    \n\x04\xda\n\x06\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdb\n\x047\n\x10\n\x08\
    \x06\0\x02M\x04\xc3\xf3\x04\x12\x04\xdb\n\x047\n\r\n\x05\x06\0\x02M\x04\
    \x12\x04\xdc\n\x04?\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\0\x12\x04\xdc\n\
    \x04?\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdd\n\x04S\n\x11\n\t\x06\0\x02M\
    \x04\xc2\xf3\x04\x01\x12\x04\xdd\n\x04S\n\r\n\x05\x06\0\x02M\x04\x12\x04\
    \xde\n\x04F\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x02\x12\x04\xde\n\x04F\
    \n\r\n\x05\x06\0\x02M\x04\x12\x04\xdf\n\x04C\n\x11\n\t\x06\0\x02M\x04\
    \xc2\xf3\x04\x03\x12\x04\xdf\n\x04C\n\r\n\x05\x06\0\x02M\x04\x12\x04\xe0\
    \n\x04A\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x04\x12\x04\xe0\n\x04A\n\r\
    \n\x05\x06\0\x02M\x04\x12\x04\xe1\n\x04A\n\x11\n\t\x06\0\x02M\x04\xc2\
    \xf3\x04\x05\x12\x04\xe1\n\x04A\n\r\n\x05\x06\0\x02M\x04\x12\x04\xe2\n\
    \x04A\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x06\x12\x04\xe2\n\x04A\n\r\n\
    \x05\x06\0\x02M\x04\x12\x04\xe3\n\x04C\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\
    \x04\x07\x12\x04\xe3\n\x04C\n\r\n\x05\x06\0\x02M\x04\x12\x04\xe4\n\x04D\
    \n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x08\x12\x04\xe4\n\x04D\n\r\n\x05\
    \x06\0\x02M\x04\x12\x04\xe5\n\x04B\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\
    \t\x12\x04\xe5\n\x04B\n\r\n\x05\x06\0\x02M\x04\x12\x04\xe6\n\x04B\n\x11\
    \n\t\x06\0\x02M\x04\xc2\xf3\x04\n\x12\x04\xe6\n\x04B\n,\n\x04\x06\0\x02N\
    \x12\x06\xea\n\x02\xff\n\x03\x1a\x1c\x20PostModelVersionsUnPublish\n\n\r\
    \n\x05\x06\0\x02N\x01\x12\x04\xea\n\x06\x20\n\r\n\x05\x06\0\x02N\x02\x12\
    \x04\xea\n\"C\n\r\n\x05\x06\0\x02N\x03\x12\x04\xea\nNn\n\x0f\n\x05\x06\0\
    \x02N\x04\x12\x06\xeb\n\x04\xf2\n\x06\n\x13\n\t\x06\0\x02N\x04\xb0\xca\
    \xbc\"\x12\x06\xeb\n\x04\xf2\n\x06\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf3\
    \n\x047\n\x10\n\x08\x06\0\x02N\x04\xc3\xf3\x04\x12\x04\xf3\n\x047\n\r\n\
    \x05\x06\0\x02N\x04\x12\x04\xf4\n\x04?\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\
    \x04\0\x12\x04\xf4\n\x04?\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf5\n\x04V\n\
    \x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x01\x12\x04\xf5\n\x04V\n\r\n\x05\x06\
    \0\x02N\x04\x12\x04\xf6\n\x04F\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x02\
    \x12\x04\xf6\n\x04F\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf7\n\x04C\n\x11\n\
    \t\x06\0\x02N\x04\xc2\xf3\x04\x03\x12\x04\xf7\n\x04C\n\r\n\x05\x06\0\x02\
    N\x04\x12\x04\xf8\n\x04A\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x04\x12\
    \x04\xf8\n\x04A\n\r\n\x05\x06\0\x02N\x04\x12\x04\xf9\n\x04A\n\x11\n\t\
    \x06\0\x02N\x04\xc2\xf3\x04\x05\x12\x04\xf9\n\x04A\n\r\n\x05\x06\0\x02N\
    \x04\x12\x04\xfa\n\x04A\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x06\x12\x04\
    \xfa\n\x04A\n\r\n\x05\x06\0\x02N\x04\x12\x04\xfb\n\x04C\n\x11\n\t\x06\0\
    \x02N\x04\xc2\xf3\x04\x07\x12\x04\xfb\n\x04C\n\r\n\x05\x06\0\x02N\x04\
    \x12\x04\xfc\n\x04D\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x08\x12\x04\xfc\
    \n\x04D\n\r\n\x05\x06\0\x02N\x04\x12\x04\xfd\n\x04B\n\x11\n\t\x06\0\x02N\
    \x04\xc2\xf3\x04\t\x12\x04\xfd\n\x04B\n\r\n\x05\x06\0\x02N\x04\x12\x04\
    \xfe\n\x04B\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\n\x12\x04\xfe\n\x04B\n\
    \x97\x01\n\x04\x06\0\x02O\x12\x06\x85\x0b\x02\x99\x0b\x03\x1a>\x20Create\
    \x20a\x20new\x20model\x20version\x20to\x20trigger\x20training\x20of\x20t\
    he\x20model.\n2G\x20NOTE:\x20inconsistency:\x20do\x20we\x20want\x20this\
    \x20to\x20return\x20a\x20SingleModelResponse?\n\n\r\n\x05\x06\0\x02O\x01\
    \x12\x04\x85\x0b\x06\x17\n\r\n\x05\x06\0\x02O\x02\x12\x04\x85\x0b\x191\n\
    \r\n\x05\x06\0\x02O\x03\x12\x04\x85\x0b<O\n\x0f\n\x05\x06\0\x02O\x04\x12\
    \x06\x86\x0b\x04\x8d\x0b\x06\n\x13\n\t\x06\0\x02O\x04\xb0\xca\xbc\"\x12\
    \x06\x86\x0b\x04\x8d\x0b\x06\n\r\n\x05\x06\0\x02O\x04\x12\x04\x8e\x0b\
    \x047\n\x10\n\x08\x06\0\x02O\x04\xc3\xf3\x04\x12\x04\x8e\x0b\x047\n\r\n\
    \x05\x06\0\x02O\x04\x12\x04\x8f\x0b\x04?\n\x11\n\t\x06\0\x02O\x04\xc2\
    \xf3\x04\0\x12\x04\x8f\x0b\x04?\n\r\n\x05\x06\0\x02O\x04\x12\x04\x90\x0b\
    \x04F\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x01\x12\x04\x90\x0b\x04F\n\r\
    \n\x05\x06\0\x02O\x04\x12\x04\x91\x0b\x04C\n\x11\n\t\x06\0\x02O\x04\xc2\
    \xf3\x04\x02\x12\x04\x91\x0b\x04C\n\r\n\x05\x06\0\x02O\x04\x12\x04\x92\
    \x0b\x04A\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x03\x12\x04\x92\x0b\x04A\
    \n\r\n\x05\x06\0\x02O\x04\x12\x04\x93\x0b\x04A\n\x11\n\t\x06\0\x02O\x04\
    \xc2\xf3\x04\x04\x12\x04\x93\x0b\x04A\n\r\n\x05\x06\0\x02O\x04\x12\x04\
    \x94\x0b\x04A\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x05\x12\x04\x94\x0b\
    \x04A\n\r\n\x05\x06\0\x02O\x04\x12\x04\x95\x0b\x04C\n\x11\n\t\x06\0\x02O\
    \x04\xc2\xf3\x04\x06\x12\x04\x95\x0b\x04C\n\r\n\x05\x06\0\x02O\x04\x12\
    \x04\x96\x0b\x04D\nF\n\t\x06\0\x02O\x04\xc2\xf3\x04\x07\x12\x04\x96\x0b\
    \x04D\"3\x20Needs\x20to\x20check\x20the\x20base\x20workflow\x20to\x20bui\
    ld\x20off\x20of.\n\n\r\n\x05\x06\0\x02O\x04\x12\x04\x97\x0b\x04B\n\x11\n\
    \t\x06\0\x02O\x04\xc2\xf3\x04\x08\x12\x04\x97\x0b\x04B\n\r\n\x05\x06\0\
    \x02O\x04\x12\x04\x98\x0b\x04B\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\t\
    \x12\x04\x98\x0b\x04B\n$\n\x04\x06\0\x02P\x12\x06\x9c\x0b\x02\xa7\x0b\
    \x03\x1a\x14\x20PatchModelVersions\n\n\r\n\x05\x06\0\x02P\x01\x12\x04\
    \x9c\x0b\x06\x18\n\r\n\x05\x06\0\x02P\x02\x12\x04\x9c\x0b\x1a3\n\r\n\x05\
    \x06\0\x02P\x03\x12\x04\x9c\x0b>W\n\x0f\n\x05\x06\0\x02P\x04\x12\x06\x9d\
    \x0b\x04\xa0\x0b\x06\n\x13\n\t\x06\0\x02P\x04\xb0\xca\xbc\"\x12\x06\x9d\
    \x0b\x04\xa0\x0b\x06\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa1\x0b\x047\n\x10\
    \n\x08\x06\0\x02P\x04\xc3\xf3\x04\x12\x04\xa1\x0b\x047\n\r\n\x05\x06\0\
    \x02P\x04\x12\x04\xa2\x0b\x04?\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\0\
    \x12\x04\xa2\x0b\x04?\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa3\x0b\x04C\n\
    \x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x01\x12\x04\xa3\x0b\x04C\n\r\n\x05\
    \x06\0\x02P\x04\x12\x04\xa4\x0b\x04A\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\
    \x04\x02\x12\x04\xa4\x0b\x04A\n\r\n\x05\x06\0\x02P\x04\x12\x04\xa5\x0b\
    \x04A\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x03\x12\x04\xa5\x0b\x04A\n\r\
    \n\x05\x06\0\x02P\x04\x12\x04\xa6\x0b\x04C\n\x11\n\t\x06\0\x02P\x04\xc2\
    \xf3\x04\x04\x12\x04\xa6\x0b\x04C\n(\n\x04\x06\0\x02Q\x12\x06\xaa\x0b\
    \x02\xb8\x0b\x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\x05\
    \x06\0\x02Q\x01\x12\x04\xaa\x0b\x06\x18\n\r\n\x05\x06\0\x02Q\x02\x12\x04\
    \xaa\x0b\x1a3\n\r\n\x05\x06\0\x02Q\x03\x12\x04\xaa\x0b>^\n\x0f\n\x05\x06\
    \0\x02Q\x04\x12\x06\xab\x0b\x04\xb0\x0b\x06\n\x13\n\t\x06\0\x02Q\x04\xb0\
    \xca\xbc\"\x12\x06\xab\x0b\x04\xb0\x0b\x06\n\r\n\x05\x06\0\x02Q\x04\x12\
    \x04\xb1\x0b\x047\n\x10\n\x08\x06\0\x02Q\x04\xc3\xf3\x04\x12\x04\xb1\x0b\
    \x047\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xb2\x0b\x04?\n\x11\n\t\x06\0\x02Q\
    \x04\xc2\xf3\x04\0\x12\x04\xb2\x0b\x04?\n\r\n\x05\x06\0\x02Q\x04\x12\x04\
    \xb3\x0b\x04C\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x01\x12\x04\xb3\x0b\
    \x04C\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xb4\x0b\x04A\n\x11\n\t\x06\0\x02Q\
    \x04\xc2\xf3\x04\x02\x12\x04\xb4\x0b\x04A\n\r\n\x05\x06\0\x02Q\x04\x12\
    \x04\xb5\x0b\x04D\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x03\x12\x04\xb5\
    \x0b\x04D\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xb6\x0b\x04A\n\x11\n\t\x06\0\
    \x02Q\x04\xc2\xf3\x04\x04\x12\x04\xb6\x0b\x04A\n\r\n\x05\x06\0\x02Q\x04\
    \x12\x04\xb7\x0b\x04D\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x05\x12\x04\
    \xb7\x0b\x04D\nh\n\x04\x06\0\x02R\x12\x06\xbc\x0b\x02\xca\x0b\x03\x1aX\
    \x20Deprecated:\x20Use\x20GetEvaluation\x20instead\n\x20Get\x20the\x20ev\
    aluation\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\
    \x02R\x01\x12\x04\xbc\x0b\x06\x1c\n\r\n\x05\x06\0\x02R\x02\x12\x04\xbc\
    \x0b\x1e;\n\r\n\x05\x06\0\x02R\x03\x12\x04\xbc\x0bF`\n\x0f\n\x05\x06\0\
    \x02R\x04\x12\x06\xbd\x0b\x04\xc2\x0b\x06\n\x13\n\t\x06\0\x02R\x04\xb0\
    \xca\xbc\"\x12\x06\xbd\x0b\x04\xc2\x0b\x06\n\r\n\x05\x06\0\x02R\x04\x12\
    \x04\xc3\x0b\x047\n\x10\n\x08\x06\0\x02R\x04\xc3\xf3\x04\x12\x04\xc3\x0b\
    \x047\n\r\n\x05\x06\0\x02R\x04\x12\x04\xc4\x0b\x04?\n\x11\n\t\x06\0\x02R\
    \x04\xc2\xf3\x04\0\x12\x04\xc4\x0b\x04?\n\r\n\x05\x06\0\x02R\x04\x12\x04\
    \xc5\x0b\x04F\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x01\x12\x04\xc5\x0b\
    \x04F\n\r\n\x05\x06\0\x02R\x04\x12\x04\xc6\x0b\x04C\n\x11\n\t\x06\0\x02R\
    \x04\xc2\xf3\x04\x02\x12\x04\xc6\x0b\x04C\n\r\n\x05\x06\0\x02R\x04\x12\
    \x04\xc7\x0b\x04A\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x03\x12\x04\xc7\
    \x0b\x04A\n\r\n\x05\x06\0\x02R\x04\x12\x04\xc8\x0b\x04A\n\x11\n\t\x06\0\
    \x02R\x04\xc2\xf3\x04\x04\x12\x04\xc8\x0b\x04A\n\r\n\x05\x06\0\x02R\x04\
    \x12\x04\xc9\x0b\x04B\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x05\x12\x04\
    \xc9\x0b\x04B\nj\n\x04\x06\0\x02S\x12\x06\xce\x0b\x02\xe3\x0b\x03\x1aZ\
    \x20Deprecated,\x20use\x20PostEvaluations\x20instead\n\x20Run\x20the\x20\
    evaluation\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\
    \x02S\x01\x12\x04\xce\x0b\x06\x1d\n\r\n\x05\x06\0\x02S\x02\x12\x04\xce\
    \x0b\x1f=\n\r\n\x05\x06\0\x02S\x03\x12\x04\xce\x0bHb\n\x0f\n\x05\x06\0\
    \x02S\x04\x12\x06\xcf\x0b\x04\xd6\x0b\x06\n\x13\n\t\x06\0\x02S\x04\xb0\
    \xca\xbc\"\x12\x06\xcf\x0b\x04\xd6\x0b\x06\n\r\n\x05\x06\0\x02S\x04\x12\
    \x04\xd7\x0b\x047\n\x10\n\x08\x06\0\x02S\x04\xc3\xf3\x04\x12\x04\xd7\x0b\
    \x047\n\r\n\x05\x06\0\x02S\x04\x12\x04\xd8\x0b\x04?\n\x11\n\t\x06\0\x02S\
    \x04\xc2\xf3\x04\0\x12\x04\xd8\x0b\x04?\n\r\n\x05\x06\0\x02S\x04\x12\x04\
    \xd9\x0b\x04F\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x01\x12\x04\xd9\x0b\
    \x04F\n\r\n\x05\x06\0\x02S\x04\x12\x04\xda\x0b\x04C\n\x11\n\t\x06\0\x02S\
    \x04\xc2\xf3\x04\x02\x12\x04\xda\x0b\x04C\n\r\n\x05\x06\0\x02S\x04\x12\
    \x04\xdb\x0b\x04A\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x03\x12\x04\xdb\
    \x0b\x04A\n\r\n\x05\x06\0\x02S\x04\x12\x04\xdc\x0b\x04A\n\x11\n\t\x06\0\
    \x02S\x04\xc2\xf3\x04\x04\x12\x04\xdc\x0b\x04A\n\r\n\x05\x06\0\x02S\x04\
    \x12\x04\xdd\x0b\x04A\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x05\x12\x04\
    \xdd\x0b\x04A\n\r\n\x05\x06\0\x02S\x04\x12\x04\xde\x0b\x04C\n\x11\n\t\
    \x06\0\x02S\x04\xc2\xf3\x04\x06\x12\x04\xde\x0b\x04C\n\r\n\x05\x06\0\x02\
    S\x04\x12\x04\xdf\x0b\x04>\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x07\x12\
    \x04\xdf\x0b\x04>\n\r\n\x05\x06\0\x02S\x04\x12\x04\xe0\x0b\x04D\nF\n\t\
    \x06\0\x02S\x04\xc2\xf3\x04\x08\x12\x04\xe0\x0b\x04D\"3\x20Needs\x20to\
    \x20check\x20the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n\r\
    \n\x05\x06\0\x02S\x04\x12\x04\xe1\x0b\x04B\n\x11\n\t\x06\0\x02S\x04\xc2\
    \xf3\x04\t\x12\x04\xe1\x0b\x04B\n\r\n\x05\x06\0\x02S\x04\x12\x04\xe2\x0b\
    \x04B\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\n\x12\x04\xe2\x0b\x04B\n9\n\
    \x04\x06\0\x02T\x12\x06\xe6\x0b\x02\xfb\x0b\x03\x1a)\x20Deprecated,\x20u\
    se\x20PostEvaluations\x20instead\n\n\r\n\x05\x06\0\x02T\x01\x12\x04\xe6\
    \x0b\x06!\n\r\n\x05\x06\0\x02T\x02\x12\x04\xe6\x0b#E\n\r\n\x05\x06\0\x02\
    T\x03\x12\x04\xe6\x0bPh\n\x0f\n\x05\x06\0\x02T\x04\x12\x06\xe7\x0b\x04\
    \xee\x0b\x06\n\x13\n\t\x06\0\x02T\x04\xb0\xca\xbc\"\x12\x06\xe7\x0b\x04\
    \xee\x0b\x06\n\r\n\x05\x06\0\x02T\x04\x12\x04\xef\x0b\x047\n\x10\n\x08\
    \x06\0\x02T\x04\xc3\xf3\x04\x12\x04\xef\x0b\x047\n\r\n\x05\x06\0\x02T\
    \x04\x12\x04\xf0\x0b\x04?\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\0\x12\x04\
    \xf0\x0b\x04?\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf1\x0b\x04F\n\x11\n\t\
    \x06\0\x02T\x04\xc2\xf3\x04\x01\x12\x04\xf1\x0b\x04F\n\r\n\x05\x06\0\x02\
    T\x04\x12\x04\xf2\x0b\x04C\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x02\x12\
    \x04\xf2\x0b\x04C\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf3\x0b\x04A\n\x11\n\
    \t\x06\0\x02T\x04\xc2\xf3\x04\x03\x12\x04\xf3\x0b\x04A\n\r\n\x05\x06\0\
    \x02T\x04\x12\x04\xf4\x0b\x04A\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x04\
    \x12\x04\xf4\x0b\x04A\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf5\x0b\x04A\n\
    \x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x05\x12\x04\xf5\x0b\x04A\n\r\n\x05\
    \x06\0\x02T\x04\x12\x04\xf6\x0b\x04C\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\
    \x04\x06\x12\x04\xf6\x0b\x04C\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf7\x0b\
    \x04>\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x07\x12\x04\xf7\x0b\x04>\n\r\
    \n\x05\x06\0\x02T\x04\x12\x04\xf8\x0b\x04D\n\x11\n\t\x06\0\x02T\x04\xc2\
    \xf3\x04\x08\x12\x04\xf8\x0b\x04D\n\r\n\x05\x06\0\x02T\x04\x12\x04\xf9\
    \x0b\x04B\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\t\x12\x04\xf9\x0b\x04B\n\
    \r\n\x05\x06\0\x02T\x04\x12\x04\xfa\x0b\x04B\n\x11\n\t\x06\0\x02T\x04\
    \xc2\xf3\x04\n\x12\x04\xfa\x0b\x04B\ni\n\x04\x06\0\x02U\x12\x06\xff\x0b\
    \x02\x8d\x0c\x03\x1aY\x20Deprecated,\x20use\x20GetEvaluation\x20instead\
    \n\x20List\x20the\x20evaluation\x20metrics\x20for\x20a\x20model\x20versi\
    on.\n\n\r\n\x05\x06\0\x02U\x01\x12\x04\xff\x0b\x06!\n\r\n\x05\x06\0\x02U\
    \x02\x12\x04\xff\x0b#E\n\r\n\x05\x06\0\x02U\x03\x12\x04\xff\x0bPh\n\x0f\
    \n\x05\x06\0\x02U\x04\x12\x06\x80\x0c\x04\x85\x0c\x06\n\x13\n\t\x06\0\
    \x02U\x04\xb0\xca\xbc\"\x12\x06\x80\x0c\x04\x85\x0c\x06\n\r\n\x05\x06\0\
    \x02U\x04\x12\x04\x86\x0c\x047\n\x10\n\x08\x06\0\x02U\x04\xc3\xf3\x04\
    \x12\x04\x86\x0c\x047\n\r\n\x05\x06\0\x02U\x04\x12\x04\x87\x0c\x04?\n\
    \x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\0\x12\x04\x87\x0c\x04?\n\r\n\x05\x06\
    \0\x02U\x04\x12\x04\x88\x0c\x04F\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\
    \x01\x12\x04\x88\x0c\x04F\n\r\n\x05\x06\0\x02U\x04\x12\x04\x89\x0c\x04C\
    \n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x02\x12\x04\x89\x0c\x04C\n\r\n\x05\
    \x06\0\x02U\x04\x12\x04\x8a\x0c\x04A\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\
    \x04\x03\x12\x04\x8a\x0c\x04A\n\r\n\x05\x06\0\x02U\x04\x12\x04\x8b\x0c\
    \x04A\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x04\x12\x04\x8b\x0c\x04A\n\r\
    \n\x05\x06\0\x02U\x04\x12\x04\x8c\x0c\x04B\n\x11\n\t\x06\0\x02U\x04\xc2\
    \xf3\x04\x05\x12\x04\x8c\x0c\x04B\ng\n\x04\x06\0\x02V\x12\x06\x91\x0c\
    \x02\x9f\x0c\x03\x1aW\x20Deprecated,\x20use\x20GetEvaluation\x20instead\
    \n\x20Get\x20an\x20evaluation\x20metrics\x20for\x20a\x20model\x20version\
    .\n\n\r\n\x05\x06\0\x02V\x01\x12\x04\x91\x0c\x06\x1f\n\r\n\x05\x06\0\x02\
    V\x02\x12\x04\x91\x0c!A\n\r\n\x05\x06\0\x02V\x03\x12\x04\x91\x0cLe\n\x0f\
    \n\x05\x06\0\x02V\x04\x12\x06\x92\x0c\x04\x97\x0c\x06\n\x13\n\t\x06\0\
    \x02V\x04\xb0\xca\xbc\"\x12\x06\x92\x0c\x04\x97\x0c\x06\n\r\n\x05\x06\0\
    \x02V\x04\x12\x04\x98\x0c\x047\n\x10\n\x08\x06\0\x02V\x04\xc3\xf3\x04\
    \x12\x04\x98\x0c\x047\n\r\n\x05\x06\0\x02V\x04\x12\x04\x99\x0c\x04?\n\
    \x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\0\x12\x04\x99\x0c\x04?\n\r\n\x05\x06\
    \0\x02V\x04\x12\x04\x9a\x0c\x04F\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\
    \x01\x12\x04\x9a\x0c\x04F\n\r\n\x05\x06\0\x02V\x04\x12\x04\x9b\x0c\x04C\
    \n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\x02\x12\x04\x9b\x0c\x04C\n\r\n\x05\
    \x06\0\x02V\x04\x12\x04\x9c\x0c\x04A\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\
    \x04\x03\x12\x04\x9c\x0c\x04A\n\r\n\x05\x06\0\x02V\x04\x12\x04\x9d\x0c\
    \x04A\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\x04\x12\x04\x9d\x0c\x04A\n\r\
    \n\x05\x06\0\x02V\x04\x12\x04\x9e\x0c\x04B\n\x11\n\t\x06\0\x02V\x04\xc2\
    \xf3\x04\x05\x12\x04\x9e\x0c\x04B\n\x0e\n\x04\x06\0\x02W\x12\x06\xa1\x0c\
    \x02\xb6\x0c\x03\n\r\n\x05\x06\0\x02W\x01\x12\x04\xa1\x0c\x06\x15\n\r\n\
    \x05\x06\0\x02W\x02\x12\x04\xa1\x0c\x17-\n\r\n\x05\x06\0\x02W\x03\x12\
    \x04\xa1\x0c8P\n\x0f\n\x05\x06\0\x02W\x04\x12\x06\xa2\x0c\x04\xa9\x0c\
    \x06\n\x13\n\t\x06\0\x02W\x04\xb0\xca\xbc\"\x12\x06\xa2\x0c\x04\xa9\x0c\
    \x06\n\r\n\x05\x06\0\x02W\x04\x12\x04\xaa\x0c\x047\n\x10\n\x08\x06\0\x02\
    W\x04\xc3\xf3\x04\x12\x04\xaa\x0c\x047\n\r\n\x05\x06\0\x02W\x04\x12\x04\
    \xab\x0c\x04?\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\0\x12\x04\xab\x0c\x04\
    ?\n\r\n\x05\x06\0\x02W\x04\x12\x04\xac\x0c\x04F\n\x11\n\t\x06\0\x02W\x04\
    \xc2\xf3\x04\x01\x12\x04\xac\x0c\x04F\n\r\n\x05\x06\0\x02W\x04\x12\x04\
    \xad\x0c\x04C\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x02\x12\x04\xad\x0c\
    \x04C\n\r\n\x05\x06\0\x02W\x04\x12\x04\xae\x0c\x04A\n\x11\n\t\x06\0\x02W\
    \x04\xc2\xf3\x04\x03\x12\x04\xae\x0c\x04A\n\r\n\x05\x06\0\x02W\x04\x12\
    \x04\xaf\x0c\x04A\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x04\x12\x04\xaf\
    \x0c\x04A\n\r\n\x05\x06\0\x02W\x04\x12\x04\xb0\x0c\x04A\n\x11\n\t\x06\0\
    \x02W\x04\xc2\xf3\x04\x05\x12\x04\xb0\x0c\x04A\n\r\n\x05\x06\0\x02W\x04\
    \x12\x04\xb1\x0c\x04C\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x06\x12\x04\
    \xb1\x0c\x04C\n\r\n\x05\x06\0\x02W\x04\x12\x04\xb2\x0c\x04>\n\x11\n\t\
    \x06\0\x02W\x04\xc2\xf3\x04\x07\x12\x04\xb2\x0c\x04>\n\r\n\x05\x06\0\x02\
    W\x04\x12\x04\xb3\x0c\x04D\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x08\x12\
    \x04\xb3\x0c\x04D\n\r\n\x05\x06\0\x02W\x04\x12\x04\xb4\x0c\x04B\n\x11\n\
    \t\x06\0\x02W\x04\xc2\xf3\x04\t\x12\x04\xb4\x0c\x04B\n\r\n\x05\x06\0\x02\
    W\x04\x12\x04\xb5\x0c\x04B\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\n\x12\
    \x04\xb5\x0c\x04B\n\x0e\n\x04\x06\0\x02X\x12\x06\xb8\x0c\x02\xc9\x0c\x03\
    \n\r\n\x05\x06\0\x02X\x01\x12\x04\xb8\x0c\x06\x15\n\r\n\x05\x06\0\x02X\
    \x02\x12\x04\xb8\x0c\x17-\n\r\n\x05\x06\0\x02X\x03\x12\x04\xb8\x0c8P\n\
    \x0f\n\x05\x06\0\x02X\x04\x12\x06\xb9\x0c\x04\xc1\x0c\x06\n\x13\n\t\x06\
    \0\x02X\x04\xb0\xca\xbc\"\x12\x06\xb9\x0c\x04\xc1\x0c\x06\n\r\n\x05\x06\
    \0\x02X\x04\x12\x04\xc2\x0c\x047\n\x10\n\x08\x06\0\x02X\x04\xc3\xf3\x04\
    \x12\x04\xc2\x0c\x047\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc3\x0c\x04?\n\
    \x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\0\x12\x04\xc3\x0c\x04?\n\r\n\x05\x06\
    \0\x02X\x04\x12\x04\xc4\x0c\x04F\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\
    \x01\x12\x04\xc4\x0c\x04F\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc5\x0c\x04C\
    \n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x02\x12\x04\xc5\x0c\x04C\n\r\n\x05\
    \x06\0\x02X\x04\x12\x04\xc6\x0c\x04A\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\
    \x04\x03\x12\x04\xc6\x0c\x04A\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc7\x0c\
    \x04A\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x04\x12\x04\xc7\x0c\x04A\n\r\
    \n\x05\x06\0\x02X\x04\x12\x04\xc8\x0c\x04B\n\x11\n\t\x06\0\x02X\x04\xc2\
    \xf3\x04\x05\x12\x04\xc8\x0c\x04B\n\x0e\n\x04\x06\0\x02Y\x12\x06\xcb\x0c\
    \x02\xd9\x0c\x03\n\r\n\x05\x06\0\x02Y\x01\x12\x04\xcb\x0c\x06\x13\n\r\n\
    \x05\x06\0\x02Y\x02\x12\x04\xcb\x0c\x15)\n\r\n\x05\x06\0\x02Y\x03\x12\
    \x04\xcb\x0c4M\n\x0f\n\x05\x06\0\x02Y\x04\x12\x06\xcc\x0c\x04\xd1\x0c\
    \x06\n\x13\n\t\x06\0\x02Y\x04\xb0\xca\xbc\"\x12\x06\xcc\x0c\x04\xd1\x0c\
    \x06\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd2\x0c\x047\n\x10\n\x08\x06\0\x02\
    Y\x04\xc3\xf3\x04\x12\x04\xd2\x0c\x047\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xd3\x0c\x04?\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\0\x12\x04\xd3\x0c\x04\
    ?\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd4\x0c\x04F\n\x11\n\t\x06\0\x02Y\x04\
    \xc2\xf3\x04\x01\x12\x04\xd4\x0c\x04F\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xd5\x0c\x04C\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x02\x12\x04\xd5\x0c\
    \x04C\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd6\x0c\x04A\n\x11\n\t\x06\0\x02Y\
    \x04\xc2\xf3\x04\x03\x12\x04\xd6\x0c\x04A\n\r\n\x05\x06\0\x02Y\x04\x12\
    \x04\xd7\x0c\x04A\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x04\x12\x04\xd7\
    \x0c\x04A\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xd8\x0c\x04B\n\x11\n\t\x06\0\
    \x02Y\x04\xc2\xf3\x04\x05\x12\x04\xd8\x0c\x04B\nG\n\x04\x06\0\x02Z\x12\
    \x06\xdc\x0c\x02\xe6\x0c\x03\x1a7\x20Lists\x20model\x20references\x20tie\
    d\x20to\x20a\x20particular\x20model\x20id.\n\n\r\n\x05\x06\0\x02Z\x01\
    \x12\x04\xdc\x0c\x06\x19\n\r\n\x05\x06\0\x02Z\x02\x12\x04\xdc\x0c\x1b5\n\
    \r\n\x05\x06\0\x02Z\x03\x12\x04\xdc\x0c@[\n\x0f\n\x05\x06\0\x02Z\x04\x12\
    \x06\xdd\x0c\x04\xe2\x0c\x06\n\x13\n\t\x06\0\x02Z\x04\xb0\xca\xbc\"\x12\
    \x06\xdd\x0c\x04\xe2\x0c\x06\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xe3\x0c\
    \x047\n\x10\n\x08\x06\0\x02Z\x04\xc3\xf3\x04\x12\x04\xe3\x0c\x047\n\r\n\
    \x05\x06\0\x02Z\x04\x12\x04\xe4\x0c\x04?\n\x11\n\t\x06\0\x02Z\x04\xc2\
    \xf3\x04\0\x12\x04\xe4\x0c\x04?\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xe5\x0c\
    \x04A\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x01\x12\x04\xe5\x0c\x04A\n-\n\
    \x04\x06\0\x02[\x12\x06\xeb\x0c\x02\xf5\x0c\x03\x1a\x1d\x20GetModelVersi\
    onInputExample\n\n\r\n\x05\x06\0\x02[\x01\x12\x04\xeb\x0c\x06!\n\r\n\x05\
    \x06\0\x02[\x02\x12\x04\xeb\x0c#E\n\r\n\x05\x06\0\x02[\x03\x12\x04\xeb\
    \x0cPv\n\x0f\n\x05\x06\0\x02[\x04\x12\x06\xec\x0c\x04\xf1\x0c\x06\n\x13\
    \n\t\x06\0\x02[\x04\xb0\xca\xbc\"\x12\x06\xec\x0c\x04\xf1\x0c\x06\n\r\n\
    \x05\x06\0\x02[\x04\x12\x04\xf2\x0c\x047\n\x10\n\x08\x06\0\x02[\x04\xc3\
    \xf3\x04\x12\x04\xf2\x0c\x047\n\r\n\x05\x06\0\x02[\x04\x12\x04\xf3\x0c\
    \x04?\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\0\x12\x04\xf3\x0c\x04?\n\r\n\
    \x05\x06\0\x02[\x04\x12\x04\xf4\x0c\x04A\n\x11\n\t\x06\0\x02[\x04\xc2\
    \xf3\x04\x01\x12\x04\xf4\x0c\x04A\n/\n\x04\x06\0\x02\\\x12\x06\xf8\x0c\
    \x02\x82\r\x03\x1a\x1f\x20ListModelVersionInputExamples\n\n\r\n\x05\x06\
    \0\x02\\\x01\x12\x04\xf8\x0c\x06#\n\r\n\x05\x06\0\x02\\\x02\x12\x04\xf8\
    \x0c%I\n\r\n\x05\x06\0\x02\\\x03\x12\x04\xf8\x0cTy\n\x0f\n\x05\x06\0\x02\
    \\\x04\x12\x06\xf9\x0c\x04\xfe\x0c\x06\n\x13\n\t\x06\0\x02\\\x04\xb0\xca\
    \xbc\"\x12\x06\xf9\x0c\x04\xfe\x0c\x06\n\r\n\x05\x06\0\x02\\\x04\x12\x04\
    \xff\x0c\x047\n\x10\n\x08\x06\0\x02\\\x04\xc3\xf3\x04\x12\x04\xff\x0c\
    \x047\n\r\n\x05\x06\0\x02\\\x04\x12\x04\x80\r\x04?\n\x11\n\t\x06\0\x02\\\
    \x04\xc2\xf3\x04\0\x12\x04\x80\r\x04?\n\r\n\x05\x06\0\x02\\\x04\x12\x04\
    \x81\r\x04A\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x01\x12\x04\x81\r\x04A\
    \n\xba\x01\n\x04\x06\0\x02]\x12\x06\x99\r\x02\xa4\r\x03\x1a&\x20Get\x20a\
    \x20specific\x20workflow\x20from\x20an\x20app.\n2'//////////////////////\
    ////////////////\n2Y//////////////////////////////////////\n\x20Workflow\
    s\n//////////////////////////////////////\n\n\r\n\x05\x06\0\x02]\x01\x12\
    \x04\x99\r\x06\x11\n\r\n\x05\x06\0\x02]\x02\x12\x04\x99\r\x13%\n\r\n\x05\
    \x06\0\x02]\x03\x12\x04\x99\r0F\n\x0f\n\x05\x06\0\x02]\x04\x12\x06\x9a\r\
    \x04\x9f\r\x06\n\x13\n\t\x06\0\x02]\x04\xb0\xca\xbc\"\x12\x06\x9a\r\x04\
    \x9f\r\x06\n\r\n\x05\x06\0\x02]\x04\x12\x04\xa0\r\x047\n\x10\n\x08\x06\0\
    \x02]\x04\xc3\xf3\x04\x12\x04\xa0\r\x047\n\r\n\x05\x06\0\x02]\x04\x12\
    \x04\xa1\r\x04?\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\0\x12\x04\xa1\r\x04\
    ?\n\r\n\x05\x06\0\x02]\x04\x12\x04\xa2\r\x04A\n\x11\n\t\x06\0\x02]\x04\
    \xc2\xf3\x04\x01\x12\x04\xa2\r\x04A\n\r\n\x05\x06\0\x02]\x04\x12\x04\xa3\
    \r\x04D\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\x02\x12\x04\xa3\r\x04D\n)\n\
    \x04\x06\0\x02^\x12\x06\xa7\r\x02\xb5\r\x03\x1a\x19\x20List\x20all\x20th\
    e\x20workflows.\n\n\r\n\x05\x06\0\x02^\x01\x12\x04\xa7\r\x06\x13\n\r\n\
    \x05\x06\0\x02^\x02\x12\x04\xa7\r\x15)\n\r\n\x05\x06\0\x02^\x03\x12\x04\
    \xa7\r4I\n\x0f\n\x05\x06\0\x02^\x04\x12\x06\xa8\r\x04\xb0\r\x06\n\x13\n\
    \t\x06\0\x02^\x04\xb0\xca\xbc\"\x12\x06\xa8\r\x04\xb0\r\x06\n\r\n\x05\
    \x06\0\x02^\x04\x12\x04\xb1\r\x047\n\x10\n\x08\x06\0\x02^\x04\xc3\xf3\
    \x04\x12\x04\xb1\r\x047\n\r\n\x05\x06\0\x02^\x04\x12\x04\xb2\r\x04?\n\
    \x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\0\x12\x04\xb2\r\x04?\n\r\n\x05\x06\0\
    \x02^\x04\x12\x04\xb3\r\x04A\n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\x01\
    \x12\x04\xb3\r\x04A\n\r\n\x05\x06\0\x02^\x04\x12\x04\xb4\r\x04D\n\x11\n\
    \t\x06\0\x02^\x04\xc2\xf3\x04\x02\x12\x04\xb4\r\x04D\n+\n\x04\x06\0\x02_\
    \x12\x06\xb9\r\x02\xc7\r\x03\x1a\x1b\x20Add\x20a\x20workflow\x20to\x20an\
    \x20app.\n\n\r\n\x05\x06\0\x02_\x01\x12\x04\xb9\r\x06\x13\n\r\n\x05\x06\
    \0\x02_\x02\x12\x04\xb9\r\x15)\n\r\n\x05\x06\0\x02_\x03\x12\x04\xb9\r4I\
    \n\x0f\n\x05\x06\0\x02_\x04\x12\x06\xba\r\x04\xc1\r\x06\n\x13\n\t\x06\0\
    \x02_\x04\xb0\xca\xbc\"\x12\x06\xba\r\x04\xc1\r\x06\n\r\n\x05\x06\0\x02_\
    \x04\x12\x04\xc2\r\x047\n\x10\n\x08\x06\0\x02_\x04\xc3\xf3\x04\x12\x04\
    \xc2\r\x047\n\r\n\x05\x06\0\x02_\x04\x12\x04\xc3\r\x04?\n\x11\n\t\x06\0\
    \x02_\x04\xc2\xf3\x04\0\x12\x04\xc3\r\x04?\n\r\n\x05\x06\0\x02_\x04\x12\
    \x04\xc4\r\x04A\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x01\x12\x04\xc4\r\
    \x04A\n\r\n\x05\x06\0\x02_\x04\x12\x04\xc5\r\x04D\n\x11\n\t\x06\0\x02_\
    \x04\xc2\xf3\x04\x02\x12\x04\xc5\r\x04D\n\r\n\x05\x06\0\x02_\x04\x12\x04\
    \xc6\r\x04D\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x03\x12\x04\xc6\r\x04D\
    \n.\n\x04\x06\0\x02`\x12\x06\xca\r\x02\xd8\r\x03\x1a\x1e\x20Patch\x20one\
    \x20or\x20more\x20workflows.\n\n\r\n\x05\x06\0\x02`\x01\x12\x04\xca\r\
    \x06\x14\n\r\n\x05\x06\0\x02`\x02\x12\x04\xca\r\x16+\n\r\n\x05\x06\0\x02\
    `\x03\x12\x04\xca\r6K\n\x0f\n\x05\x06\0\x02`\x04\x12\x06\xcb\r\x04\xd2\r\
    \x06\n\x13\n\t\x06\0\x02`\x04\xb0\xca\xbc\"\x12\x06\xcb\r\x04\xd2\r\x06\
    \n\r\n\x05\x06\0\x02`\x04\x12\x04\xd3\r\x047\n\x10\n\x08\x06\0\x02`\x04\
    \xc3\xf3\x04\x12\x04\xd3\r\x047\n\r\n\x05\x06\0\x02`\x04\x12\x04\xd4\r\
    \x04?\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\0\x12\x04\xd4\r\x04?\n\r\n\
    \x05\x06\0\x02`\x04\x12\x04\xd5\r\x04A\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\
    \x04\x01\x12\x04\xd5\r\x04A\n\r\n\x05\x06\0\x02`\x04\x12\x04\xd6\r\x04D\
    \n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\x02\x12\x04\xd6\r\x04D\n\r\n\x05\
    \x06\0\x02`\x04\x12\x04\xd7\r\x04D\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\
    \x03\x12\x04\xd7\r\x04D\n2\n\x04\x06\0\x02a\x12\x06\xdb\r\x02\xe4\r\x03\
    \x1a\"\x20Patch\x20one\x20or\x20more\x20workflows\x20ids.\n\n\r\n\x05\
    \x06\0\x02a\x01\x12\x04\xdb\r\x06\x16\n\r\n\x05\x06\0\x02a\x02\x12\x04\
    \xdb\r\x18/\n\r\n\x05\x06\0\x02a\x03\x12\x04\xdb\r:O\n\x0f\n\x05\x06\0\
    \x02a\x04\x12\x06\xdc\r\x04\xdf\r\x06\n\x13\n\t\x06\0\x02a\x04\xb0\xca\
    \xbc\"\x12\x06\xdc\r\x04\xdf\r\x06\n\r\n\x05\x06\0\x02a\x04\x12\x04\xe0\
    \r\x047\n\x10\n\x08\x06\0\x02a\x04\xc3\xf3\x04\x12\x04\xe0\r\x047\n\r\n\
    \x05\x06\0\x02a\x04\x12\x04\xe1\r\x04?\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\
    \x04\0\x12\x04\xe1\r\x04?\n\r\n\x05\x06\0\x02a\x04\x12\x04\xe2\r\x04D\n\
    \x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\x01\x12\x04\xe2\r\x04D\n\r\n\x05\x06\
    \0\x02a\x04\x12\x04\xe3\r\x04D\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\x02\
    \x12\x04\xe3\r\x04D\n+\n\x04\x06\0\x02b\x12\x06\xe7\r\x02\xf3\r\x03\x1a\
    \x1b\x20Delete\x20a\x20single\x20workflow.\n\n\r\n\x05\x06\0\x02b\x01\
    \x12\x04\xe7\r\x06\x14\n\r\n\x05\x06\0\x02b\x02\x12\x04\xe7\r\x16+\n\r\n\
    \x05\x06\0\x02b\x03\x12\x04\xe7\r6V\n\x0f\n\x05\x06\0\x02b\x04\x12\x06\
    \xe8\r\x04\xed\r\x06\n\x13\n\t\x06\0\x02b\x04\xb0\xca\xbc\"\x12\x06\xe8\
    \r\x04\xed\r\x06\n\r\n\x05\x06\0\x02b\x04\x12\x04\xee\r\x047\n\x10\n\x08\
    \x06\0\x02b\x04\xc3\xf3\x04\x12\x04\xee\r\x047\n\r\n\x05\x06\0\x02b\x04\
    \x12\x04\xef\r\x04?\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\0\x12\x04\xef\r\
    \x04?\n\r\n\x05\x06\0\x02b\x04\x12\x04\xf0\r\x04D\n\x11\n\t\x06\0\x02b\
    \x04\xc2\xf3\x04\x01\x12\x04\xf0\r\x04D\n\r\n\x05\x06\0\x02b\x04\x12\x04\
    \xf1\r\x04G\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\x02\x12\x04\xf1\r\x04G\
    \n\r\n\x05\x06\0\x02b\x04\x12\x04\xf2\r\x04D\n\x11\n\t\x06\0\x02b\x04\
    \xc2\xf3\x04\x03\x12\x04\xf2\r\x04D\n;\n\x04\x06\0\x02c\x12\x06\xf6\r\
    \x02\x84\x0e\x03\x1a+\x20Delete\x20multiple\x20workflows\x20in\x20one\
    \x20request.\n\n\r\n\x05\x06\0\x02c\x01\x12\x04\xf6\r\x06\x15\n\r\n\x05\
    \x06\0\x02c\x02\x12\x04\xf6\r\x17-\n\r\n\x05\x06\0\x02c\x03\x12\x04\xf6\
    \r8X\n\x0f\n\x05\x06\0\x02c\x04\x12\x06\xf7\r\x04\xfe\r\x06\n\x13\n\t\
    \x06\0\x02c\x04\xb0\xca\xbc\"\x12\x06\xf7\r\x04\xfe\r\x06\n\r\n\x05\x06\
    \0\x02c\x04\x12\x04\xff\r\x047\n\x10\n\x08\x06\0\x02c\x04\xc3\xf3\x04\
    \x12\x04\xff\r\x047\n\r\n\x05\x06\0\x02c\x04\x12\x04\x80\x0e\x04?\n\x11\
    \n\t\x06\0\x02c\x04\xc2\xf3\x04\0\x12\x04\x80\x0e\x04?\n\r\n\x05\x06\0\
    \x02c\x04\x12\x04\x81\x0e\x04D\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x01\
    \x12\x04\x81\x0e\x04D\n\r\n\x05\x06\0\x02c\x04\x12\x04\x82\x0e\x04G\n\
    \x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x02\x12\x04\x82\x0e\x04G\n\r\n\x05\
    \x06\0\x02c\x04\x12\x04\x83\x0e\x04D\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\
    \x04\x03\x12\x04\x83\x0e\x04D\n+\n\x04\x06\0\x02d\x12\x06\x87\x0e\x02\
    \x9a\x0e\x03\x1a\x1b\x20Predict\x20using\x20a\x20workflow.\n\n\r\n\x05\
    \x06\0\x02d\x01\x12\x04\x87\x0e\x06\x19\n\r\n\x05\x06\0\x02d\x02\x12\x04\
    \x87\x0e\x1b5\n\r\n\x05\x06\0\x02d\x03\x12\x04\x87\x0e@[\n\x0f\n\x05\x06\
    \0\x02d\x04\x12\x06\x88\x0e\x04\x93\x0e\x06\n\x13\n\t\x06\0\x02d\x04\xb0\
    \xca\xbc\"\x12\x06\x88\x0e\x04\x93\x0e\x06\n\r\n\x05\x06\0\x02d\x04\x12\
    \x04\x94\x0e\x047\n\x10\n\x08\x06\0\x02d\x04\xc3\xf3\x04\x12\x04\x94\x0e\
    \x047\n\r\n\x05\x06\0\x02d\x04\x12\x04\x95\x0e\x04?\n\x11\n\t\x06\0\x02d\
    \x04\xc2\xf3\x04\0\x12\x04\x95\x0e\x04?\n\r\n\x05\x06\0\x02d\x04\x12\x04\
    \x96\x0e\x04A\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x01\x12\x04\x96\x0e\
    \x04A\n\r\n\x05\x06\0\x02d\x04\x12\x04\x97\x0e\x04C\n\x11\n\t\x06\0\x02d\
    \x04\xc2\xf3\x04\x02\x12\x04\x97\x0e\x04C\n\r\n\x05\x06\0\x02d\x04\x12\
    \x04\x98\x0e\x04>\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x03\x12\x04\x98\
    \x0e\x04>\n\r\n\x05\x06\0\x02d\x04\x12\x04\x99\x0e\x04D\n\x11\n\t\x06\0\
    \x02d\x04\xc2\xf3\x04\x04\x12\x04\x99\x0e\x04D\n?\n\x04\x06\0\x02e\x12\
    \x06\x9d\x0e\x02\xb0\x0e\x03\x1a/\x20Compare\x20embeddings\x20distances\
    \x20using\x20a\x20workflow\n\n\r\n\x05\x06\0\x02e\x01\x12\x04\x9d\x0e\
    \x06#\n\r\n\x05\x06\0\x02e\x02\x12\x04\x9d\x0e$H\n\r\n\x05\x06\0\x02e\
    \x03\x12\x04\x9d\x0eSx\n\x0f\n\x05\x06\0\x02e\x04\x12\x06\x9e\x0e\x04\
    \xa9\x0e\x06\n\x13\n\t\x06\0\x02e\x04\xb0\xca\xbc\"\x12\x06\x9e\x0e\x04\
    \xa9\x0e\x06\n\r\n\x05\x06\0\x02e\x04\x12\x04\xaa\x0e\x047\n\x10\n\x08\
    \x06\0\x02e\x04\xc3\xf3\x04\x12\x04\xaa\x0e\x047\n\r\n\x05\x06\0\x02e\
    \x04\x12\x04\xab\x0e\x04?\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\0\x12\x04\
    \xab\x0e\x04?\n\r\n\x05\x06\0\x02e\x04\x12\x04\xac\x0e\x04A\n\x11\n\t\
    \x06\0\x02e\x04\xc2\xf3\x04\x01\x12\x04\xac\x0e\x04A\n\r\n\x05\x06\0\x02\
    e\x04\x12\x04\xad\x0e\x04C\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x02\x12\
    \x04\xad\x0e\x04C\n\r\n\x05\x06\0\x02e\x04\x12\x04\xae\x0e\x04>\n\x11\n\
    \t\x06\0\x02e\x04\xc2\xf3\x04\x03\x12\x04\xae\x0e\x04>\n\r\n\x05\x06\0\
    \x02e\x04\x12\x04\xaf\x0e\x04D\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x04\
    \x12\x04\xaf\x0e\x04D\n)\n\x04\x06\0\x02f\x12\x06\xb3\x0e\x02\xbe\x0e\
    \x03\x1a\x19\x20List\x20workflow\x20versions.\n\n\r\n\x05\x06\0\x02f\x01\
    \x12\x04\xb3\x0e\x06\x1a\n\r\n\x05\x06\0\x02f\x02\x12\x04\xb3\x0e\x1c7\n\
    \r\n\x05\x06\0\x02f\x03\x12\x04\xb3\x0eB^\n\x0f\n\x05\x06\0\x02f\x04\x12\
    \x06\xb4\x0e\x04\xb9\x0e\x06\n\x13\n\t\x06\0\x02f\x04\xb0\xca\xbc\"\x12\
    \x06\xb4\x0e\x04\xb9\x0e\x06\n\r\n\x05\x06\0\x02f\x04\x12\x04\xba\x0e\
    \x047\n\x10\n\x08\x06\0\x02f\x04\xc3\xf3\x04\x12\x04\xba\x0e\x047\n\r\n\
    \x05\x06\0\x02f\x04\x12\x04\xbb\x0e\x04?\n\x11\n\t\x06\0\x02f\x04\xc2\
    \xf3\x04\0\x12\x04\xbb\x0e\x04?\n\r\n\x05\x06\0\x02f\x04\x12\x04\xbc\x0e\
    \x04A\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x01\x12\x04\xbc\x0e\x04A\n\r\
    \n\x05\x06\0\x02f\x04\x12\x04\xbd\x0e\x04D\n\x11\n\t\x06\0\x02f\x04\xc2\
    \xf3\x04\x02\x12\x04\xbd\x0e\x04D\n.\n\x04\x06\0\x02g\x12\x06\xc1\x0e\
    \x02\xcc\x0e\x03\x1a\x1e\x20Get\x20single\x20workflow\x20version.\n\n\r\
    \n\x05\x06\0\x02g\x01\x12\x04\xc1\x0e\x06\x18\n\r\n\x05\x06\0\x02g\x02\
    \x12\x04\xc1\x0e\x1a3\n\r\n\x05\x06\0\x02g\x03\x12\x04\xc1\x0e>[\n\x0f\n\
    \x05\x06\0\x02g\x04\x12\x06\xc2\x0e\x04\xc7\x0e\x06\n\x13\n\t\x06\0\x02g\
    \x04\xb0\xca\xbc\"\x12\x06\xc2\x0e\x04\xc7\x0e\x06\n\r\n\x05\x06\0\x02g\
    \x04\x12\x04\xc8\x0e\x047\n\x10\n\x08\x06\0\x02g\x04\xc3\xf3\x04\x12\x04\
    \xc8\x0e\x047\n\r\n\x05\x06\0\x02g\x04\x12\x04\xc9\x0e\x04?\n\x11\n\t\
    \x06\0\x02g\x04\xc2\xf3\x04\0\x12\x04\xc9\x0e\x04?\n\r\n\x05\x06\0\x02g\
    \x04\x12\x04\xca\x0e\x04A\n\x11\n\t\x06\0\x02g\x04\xc2\xf3\x04\x01\x12\
    \x04\xca\x0e\x04A\n\r\n\x05\x06\0\x02g\x04\x12\x04\xcb\x0e\x04D\n\x11\n\
    \t\x06\0\x02g\x04\xc2\xf3\x04\x02\x12\x04\xcb\x0e\x04D\n+\n\x04\x06\0\
    \x02h\x12\x06\xcf\x0e\x02\xdd\x0e\x03\x1a\x1b\x20Delete\x20workflow\x20v\
    ersions.\n\n\r\n\x05\x06\0\x02h\x01\x12\x04\xcf\x0e\x06\x1c\n\r\n\x05\
    \x06\0\x02h\x02\x12\x04\xcf\x0e\x1e;\n\r\n\x05\x06\0\x02h\x03\x12\x04\
    \xcf\x0eFf\n\x0f\n\x05\x06\0\x02h\x04\x12\x06\xd0\x0e\x04\xd7\x0e\x06\n\
    \x13\n\t\x06\0\x02h\x04\xb0\xca\xbc\"\x12\x06\xd0\x0e\x04\xd7\x0e\x06\n\
    \r\n\x05\x06\0\x02h\x04\x12\x04\xd8\x0e\x047\n\x10\n\x08\x06\0\x02h\x04\
    \xc3\xf3\x04\x12\x04\xd8\x0e\x047\n\r\n\x05\x06\0\x02h\x04\x12\x04\xd9\
    \x0e\x04?\n\x11\n\t\x06\0\x02h\x04\xc2\xf3\x04\0\x12\x04\xd9\x0e\x04?\n\
    \r\n\x05\x06\0\x02h\x04\x12\x04\xda\x0e\x04D\n\x11\n\t\x06\0\x02h\x04\
    \xc2\xf3\x04\x01\x12\x04\xda\x0e\x04D\n\r\n\x05\x06\0\x02h\x04\x12\x04\
    \xdb\x0e\x04D\n\x11\n\t\x06\0\x02h\x04\xc2\xf3\x04\x02\x12\x04\xdb\x0e\
    \x04D\n\r\n\x05\x06\0\x02h\x04\x12\x04\xdc\x0e\x04G\n\x11\n\t\x06\0\x02h\
    \x04\xc2\xf3\x04\x03\x12\x04\xdc\x0e\x04G\n*\n\x04\x06\0\x02i\x12\x06\
    \xe0\x0e\x02\xee\x0e\x03\x1a\x1a\x20Patch\x20workflow\x20versions.\n\n\r\
    \n\x05\x06\0\x02i\x01\x12\x04\xe0\x0e\x06\x1b\n\r\n\x05\x06\0\x02i\x02\
    \x12\x04\xe0\x0e\x1d9\n\r\n\x05\x06\0\x02i\x03\x12\x04\xe0\x0eD`\n\x0f\n\
    \x05\x06\0\x02i\x04\x12\x06\xe1\x0e\x04\xe8\x0e\x06\n\x13\n\t\x06\0\x02i\
    \x04\xb0\xca\xbc\"\x12\x06\xe1\x0e\x04\xe8\x0e\x06\n\r\n\x05\x06\0\x02i\
    \x04\x12\x04\xe9\x0e\x047\n\x10\n\x08\x06\0\x02i\x04\xc3\xf3\x04\x12\x04\
    \xe9\x0e\x047\n\r\n\x05\x06\0\x02i\x04\x12\x04\xea\x0e\x04?\n\x11\n\t\
    \x06\0\x02i\x04\xc2\xf3\x04\0\x12\x04\xea\x0e\x04?\n\r\n\x05\x06\0\x02i\
    \x04\x12\x04\xeb\x0e\x04A\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\x01\x12\
    \x04\xeb\x0e\x04A\n\r\n\x05\x06\0\x02i\x04\x12\x04\xec\x0e\x04D\n\x11\n\
    \t\x06\0\x02i\x04\xc2\xf3\x04\x02\x12\x04\xec\x0e\x04D\n\r\n\x05\x06\0\
    \x02i\x04\x12\x04\xed\x0e\x04D\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\x03\
    \x12\x04\xed\x0e\x04D\n1\n\x04\x06\0\x02j\x12\x06\xf6\x0e\x02\xfc\x0e\
    \x03\x1a!\x20Get\x20a\x20specific\x20key\x20from\x20an\x20app.\n\n\r\n\
    \x05\x06\0\x02j\x01\x12\x04\xf6\x0e\x06\x0c\n\r\n\x05\x06\0\x02j\x02\x12\
    \x04\xf6\x0e\x0e\x1b\n\r\n\x05\x06\0\x02j\x03\x12\x04\xf6\x0e&7\n\x0f\n\
    \x05\x06\0\x02j\x04\x12\x06\xf7\x0e\x04\xf9\x0e\x06\n\x13\n\t\x06\0\x02j\
    \x04\xb0\xca\xbc\"\x12\x06\xf7\x0e\x04\xf9\x0e\x06\n\r\n\x05\x06\0\x02j\
    \x04\x12\x04\xfa\x0e\x047\n\x10\n\x08\x06\0\x02j\x04\xc3\xf3\x04\x12\x04\
    \xfa\x0e\x047\n\r\n\x05\x06\0\x02j\x04\x12\x04\xfb\x0e\x04?\n\x11\n\t\
    \x06\0\x02j\x04\xc2\xf3\x04\0\x12\x04\xfb\x0e\x04?\n$\n\x04\x06\0\x02k\
    \x12\x06\xff\x0e\x02\x85\x0f\x03\x1a\x14\x20List\x20all\x20the\x20keys.\
    \n\n\r\n\x05\x06\0\x02k\x01\x12\x04\xff\x0e\x06\x0e\n\r\n\x05\x06\0\x02k\
    \x02\x12\x04\xff\x0e\x10\x1f\n\r\n\x05\x06\0\x02k\x03\x12\x04\xff\x0e*:\
    \n\x0f\n\x05\x06\0\x02k\x04\x12\x06\x80\x0f\x04\x82\x0f\x06\n\x13\n\t\
    \x06\0\x02k\x04\xb0\xca\xbc\"\x12\x06\x80\x0f\x04\x82\x0f\x06\n\r\n\x05\
    \x06\0\x02k\x04\x12\x04\x83\x0f\x047\n\x10\n\x08\x06\0\x02k\x04\xc3\xf3\
    \x04\x12\x04\x83\x0f\x047\n\r\n\x05\x06\0\x02k\x04\x12\x04\x84\x0f\x04?\
    \n\x11\n\t\x06\0\x02k\x04\xc2\xf3\x04\0\x12\x04\x84\x0f\x04?\n%\n\x04\
    \x06\0\x02l\x12\x06\x88\x0f\x02\x8f\x0f\x03\x1a\x15\x20List\x20keys\x20b\
    y\x20app_id\n\n\r\n\x05\x06\0\x02l\x01\x12\x04\x88\x0f\x06\x11\n\r\n\x05\
    \x06\0\x02l\x02\x12\x04\x88\x0f\x13%\n\r\n\x05\x06\0\x02l\x03\x12\x04\
    \x88\x0f0@\n\x0f\n\x05\x06\0\x02l\x04\x12\x06\x89\x0f\x04\x8b\x0f\x06\n\
    \x13\n\t\x06\0\x02l\x04\xb0\xca\xbc\"\x12\x06\x89\x0f\x04\x8b\x0f\x06\n\
    \r\n\x05\x06\0\x02l\x04\x12\x04\x8c\x0f\x047\n\x10\n\x08\x06\0\x02l\x04\
    \xc3\xf3\x04\x12\x04\x8c\x0f\x047\n\r\n\x05\x06\0\x02l\x04\x12\x04\x8d\
    \x0f\x04?\n\x11\n\t\x06\0\x02l\x04\xc2\xf3\x04\0\x12\x04\x8d\x0f\x04?\n\
    \r\n\x05\x06\0\x02l\x04\x12\x04\x8e\x0f\x04?\n\x11\n\t\x06\0\x02l\x04\
    \xc2\xf3\x04\x01\x12\x04\x8e\x0f\x04?\n\xc9\x01\n\x04\x06\0\x02m\x12\x06\
    \x94\x0f\x02\x9c\x0f\x03\x1a\xb8\x01\x20Search\x20over\x20the\x20keys\
    \x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20Th\
    is\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\
    \x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20\
    variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02m\x01\x12\x04\
    \x94\x0f\x06\x0f\n\r\n\x05\x06\0\x02m\x02\x12\x04\x94\x0f\x11!\n\r\n\x05\
    \x06\0\x02m\x03\x12\x04\x94\x0f,L\n\x0f\n\x05\x06\0\x02m\x04\x12\x06\x95\
    \x0f\x04\x97\x0f\x06\n\x13\n\t\x06\0\x02m\x04\xb0\xca\xbc\"\x12\x06\x95\
    \x0f\x04\x97\x0f\x06\n\r\n\x05\x06\0\x02m\x04\x12\x04\x98\x0f\x047\n\x10\
    \n\x08\x06\0\x02m\x04\xc3\xf3\x04\x12\x04\x98\x0f\x047\n\r\n\x05\x06\0\
    \x02m\x04\x12\x04\x99\x0f\x04?\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\0\
    \x12\x04\x99\x0f\x04?\n\r\n\x05\x06\0\x02m\x04\x12\x04\x9a\x0f\x04B\n\
    \x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\x01\x12\x04\x9a\x0f\x04B\n\r\n\x05\
    \x06\0\x02m\x04\x12\x04\x9b\x0f\x04?\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\
    \x04\x02\x12\x04\x9b\x0f\x04?\n&\n\x04\x06\0\x02n\x12\x06\x9f\x0f\x02\
    \xa8\x0f\x03\x1a\x16\x20Add\x20a\x20key\x20to\x20an\x20app.\n\n\r\n\x05\
    \x06\0\x02n\x01\x12\x04\x9f\x0f\x06\x0e\n\r\n\x05\x06\0\x02n\x02\x12\x04\
    \x9f\x0f\x10\x1f\n\r\n\x05\x06\0\x02n\x03\x12\x04\x9f\x0f*:\n\x0f\n\x05\
    \x06\0\x02n\x04\x12\x06\xa0\x0f\x04\xa3\x0f\x06\n\x13\n\t\x06\0\x02n\x04\
    \xb0\xca\xbc\"\x12\x06\xa0\x0f\x04\xa3\x0f\x06\n\r\n\x05\x06\0\x02n\x04\
    \x12\x04\xa4\x0f\x047\n\x10\n\x08\x06\0\x02n\x04\xc3\xf3\x04\x12\x04\xa4\
    \x0f\x047\n\r\n\x05\x06\0\x02n\x04\x12\x04\xa5\x0f\x04?\n\x11\n\t\x06\0\
    \x02n\x04\xc2\xf3\x04\0\x12\x04\xa5\x0f\x04?\n\r\n\x05\x06\0\x02n\x04\
    \x12\x04\xa6\x0f\x04?\n\x11\n\t\x06\0\x02n\x04\xc2\xf3\x04\x01\x12\x04\
    \xa6\x0f\x04?\n\r\n\x05\x06\0\x02n\x04\x12\x04\xa7\x0f\x04?\n\x11\n\t\
    \x06\0\x02n\x04\xc2\xf3\x04\x02\x12\x04\xa7\x0f\x04?\n)\n\x04\x06\0\x02o\
    \x12\x06\xab\x0f\x02\xb3\x0f\x03\x1a\x19\x20Patch\x20one\x20or\x20more\
    \x20keys.\n\n\r\n\x05\x06\0\x02o\x01\x12\x04\xab\x0f\x06\x0f\n\r\n\x05\
    \x06\0\x02o\x02\x12\x04\xab\x0f\x11!\n\r\n\x05\x06\0\x02o\x03\x12\x04\
    \xab\x0f,<\n\x0f\n\x05\x06\0\x02o\x04\x12\x06\xac\x0f\x04\xaf\x0f\x06\n\
    \x13\n\t\x06\0\x02o\x04\xb0\xca\xbc\"\x12\x06\xac\x0f\x04\xaf\x0f\x06\n\
    \r\n\x05\x06\0\x02o\x04\x12\x04\xb0\x0f\x047\n\x10\n\x08\x06\0\x02o\x04\
    \xc3\xf3\x04\x12\x04\xb0\x0f\x047\n\r\n\x05\x06\0\x02o\x04\x12\x04\xb1\
    \x0f\x04?\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\0\x12\x04\xb1\x0f\x04?\n\
    \r\n\x05\x06\0\x02o\x04\x12\x04\xb2\x0f\x04?\n\x11\n\t\x06\0\x02o\x04\
    \xc2\xf3\x04\x01\x12\x04\xb2\x0f\x04?\n\xc5\x01\n\x04\x06\0\x02p\x12\x06\
    \xb8\x0f\x02\xc3\x0f\x03\x1a\xb4\x01\x20API\x20Keys\x20in\x20the\x20publ\
    ic\x20API\x20--\x20request\x20is\x20itself\x20Key\x20authorized,\x20and\
    \x20will\x20tell\n\x20the\x20user\x20the\x20scopes/access\x20of\x20the\
    \x20key/credential\x20they're\x20providing,\x20as\x20computed\x20by\n\
    \x20our\x20authorizer:\n\n\r\n\x05\x06\0\x02p\x01\x12\x04\xb8\x0f\x06\
    \x0e\n\r\n\x05\x06\0\x02p\x02\x12\x04\xb8\x0f\x10\x1f\n\r\n\x05\x06\0\
    \x02p\x03\x12\x04\xb8\x0f*<\n\x0f\n\x05\x06\0\x02p\x04\x12\x06\xb9\x0f\
    \x04\xc1\x0f\x06\n\x13\n\t\x06\0\x02p\x04\xb0\xca\xbc\"\x12\x06\xb9\x0f\
    \x04\xc1\x0f\x06\n\r\n\x05\x06\0\x02p\x04\x12\x04\xc2\x0f\x047\n\x10\n\
    \x08\x06\0\x02p\x04\xc3\xf3\x04\x12\x04\xc2\x0f\x047\n\x0e\n\x04\x06\0\
    \x02q\x12\x06\xc5\x0f\x02\xca\x0f\x03\n\r\n\x05\x06\0\x02q\x01\x12\x04\
    \xc5\x0f\x06\x12\n\r\n\x05\x06\0\x02q\x02\x12\x04\xc5\x0f\x14'\n\r\n\x05\
    \x06\0\x02q\x03\x12\x04\xc5\x0f2H\n\x0f\n\x05\x06\0\x02q\x04\x12\x06\xc6\
    \x0f\x04\xc8\x0f\x06\n\x13\n\t\x06\0\x02q\x04\xb0\xca\xbc\"\x12\x06\xc6\
    \x0f\x04\xc8\x0f\x06\n\r\n\x05\x06\0\x02q\x04\x12\x04\xc9\x0f\x047\n\x10\
    \n\x08\x06\0\x02q\x04\xc3\xf3\x04\x12\x04\xc9\x0f\x047\n\x0e\n\x04\x06\0\
    \x02r\x12\x06\xcc\x0f\x02\xd1\x0f\x03\n\r\n\x05\x06\0\x02r\x01\x12\x04\
    \xcc\x0f\x06\x12\n\r\n\x05\x06\0\x02r\x02\x12\x04\xcc\x0f\x14'\n\r\n\x05\
    \x06\0\x02r\x03\x12\x04\xcc\x0f2H\n\x0f\n\x05\x06\0\x02r\x04\x12\x06\xcd\
    \x0f\x04\xcf\x0f\x06\n\x13\n\t\x06\0\x02r\x04\xb0\xca\xbc\"\x12\x06\xcd\
    \x0f\x04\xcf\x0f\x06\n\r\n\x05\x06\0\x02r\x04\x12\x04\xd0\x0f\x047\n\x10\
    \n\x08\x06\0\x02r\x04\xc3\xf3\x04\x12\x04\xd0\x0f\x047\nA\n\x04\x06\0\
    \x02s\x12\x06\xd4\x0f\x02\xd9\x0f\x03\x1a1\x20List\x20all\x20auth\x20sco\
    pes\x20available\x20to\x20me\x20as\x20a\x20user.\n\n\r\n\x05\x06\0\x02s\
    \x01\x12\x04\xd4\x0f\x06\x10\n\r\n\x05\x06\0\x02s\x02\x12\x04\xd4\x0f\
    \x12#\n\r\n\x05\x06\0\x02s\x03\x12\x04\xd4\x0f.D\n\x0f\n\x05\x06\0\x02s\
    \x04\x12\x06\xd5\x0f\x04\xd7\x0f\x06\n\x13\n\t\x06\0\x02s\x04\xb0\xca\
    \xbc\"\x12\x06\xd5\x0f\x04\xd7\x0f\x06\n\r\n\x05\x06\0\x02s\x04\x12\x04\
    \xd8\x0f\x04@\n\x10\n\x08\x06\0\x02s\x04\xc3\xf3\x04\x12\x04\xd8\x0f\x04\
    @\n1\n\x04\x06\0\x02t\x12\x06\xdc\x0f\x02\xe3\x0f\x03\x1a!\x20Get\x20a\
    \x20specific\x20app\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02t\x01\x12\
    \x04\xdc\x0f\x06\x0c\n\r\n\x05\x06\0\x02t\x02\x12\x04\xdc\x0f\x0e\x1b\n\
    \r\n\x05\x06\0\x02t\x03\x12\x04\xdc\x0f&7\n\x0f\n\x05\x06\0\x02t\x04\x12\
    \x06\xdd\x0f\x04\xdf\x0f\x06\n\x13\n\t\x06\0\x02t\x04\xb0\xca\xbc\"\x12\
    \x06\xdd\x0f\x04\xdf\x0f\x06\n\r\n\x05\x06\0\x02t\x04\x12\x04\xe0\x0f\
    \x047\n\x10\n\x08\x06\0\x02t\x04\xc3\xf3\x04\x12\x04\xe0\x0f\x047\n\r\n\
    \x05\x06\0\x02t\x04\x12\x04\xe1\x0f\x04?\n\x11\n\t\x06\0\x02t\x04\xc2\
    \xf3\x04\0\x12\x04\xe1\x0f\x04?\n\r\n\x05\x06\0\x02t\x04\x12\x04\xe2\x0f\
    \x04D\n\x11\n\t\x06\0\x02t\x04\xc2\xf3\x04\x01\x12\x04\xe2\x0f\x04D\n$\n\
    \x04\x06\0\x02u\x12\x06\xe6\x0f\x02\xf0\x0f\x03\x1a\x14\x20List\x20all\
    \x20the\x20apps.\n\n\r\n\x05\x06\0\x02u\x01\x12\x04\xe6\x0f\x06\x0e\n\r\
    \n\x05\x06\0\x02u\x02\x12\x04\xe6\x0f\x10\x1f\n\r\n\x05\x06\0\x02u\x03\
    \x12\x04\xe6\x0f*:\n\x0f\n\x05\x06\0\x02u\x04\x12\x06\xe7\x0f\x04\xec\
    \x0f\x06\n\x13\n\t\x06\0\x02u\x04\xb0\xca\xbc\"\x12\x06\xe7\x0f\x04\xec\
    \x0f\x06\n\r\n\x05\x06\0\x02u\x04\x12\x04\xed\x0f\x047\n\x10\n\x08\x06\0\
    \x02u\x04\xc3\xf3\x04\x12\x04\xed\x0f\x047\n\r\n\x05\x06\0\x02u\x04\x12\
    \x04\xee\x0f\x04?\n\x11\n\t\x06\0\x02u\x04\xc2\xf3\x04\0\x12\x04\xee\x0f\
    \x04?\n\r\n\x05\x06\0\x02u\x04\x12\x04\xef\x0f\x04D\n\x11\n\t\x06\0\x02u\
    \x04\xc2\xf3\x04\x01\x12\x04\xef\x0f\x04D\n\xc9\x01\n\x04\x06\0\x02v\x12\
    \x06\xf5\x0f\x02\xfe\x0f\x03\x1a\xb8\x01\x20Search\x20over\x20the\x20app\
    s\x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20T\
    his\x20leverage\x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\
    \x20have\x20page\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20\
    variables\x20in\x20this\x20request.\n\n\r\n\x05\x06\0\x02v\x01\x12\x04\
    \xf5\x0f\x06\x0f\n\r\n\x05\x06\0\x02v\x02\x12\x04\xf5\x0f\x11!\n\r\n\x05\
    \x06\0\x02v\x03\x12\x04\xf5\x0f,L\n\x0f\n\x05\x06\0\x02v\x04\x12\x06\xf6\
    \x0f\x04\xf8\x0f\x06\n\x13\n\t\x06\0\x02v\x04\xb0\xca\xbc\"\x12\x06\xf6\
    \x0f\x04\xf8\x0f\x06\n\r\n\x05\x06\0\x02v\x04\x12\x04\xf9\x0f\x047\n\x10\
    \n\x08\x06\0\x02v\x04\xc3\xf3\x04\x12\x04\xf9\x0f\x047\n\r\n\x05\x06\0\
    \x02v\x04\x12\x04\xfa\x0f\x04?\n\x11\n\t\x06\0\x02v\x04\xc2\xf3\x04\0\
    \x12\x04\xfa\x0f\x04?\n\r\n\x05\x06\0\x02v\x04\x12\x04\xfb\x0f\x04B\n\
    \x11\n\t\x06\0\x02v\x04\xc2\xf3\x04\x01\x12\x04\xfb\x0f\x04B\n\r\n\x05\
    \x06\0\x02v\x04\x12\x04\xfc\x0f\x04?\n\x11\n\t\x06\0\x02v\x04\xc2\xf3\
    \x04\x02\x12\x04\xfc\x0f\x04?\n\r\n\x05\x06\0\x02v\x04\x12\x04\xfd\x0f\
    \x04D\n\x11\n\t\x06\0\x02v\x04\xc2\xf3\x04\x03\x12\x04\xfd\x0f\x04D\n\
    \xba\x01\n\x04\x06\0\x02w\x12\x06\x83\x10\x02\x8e\x10\x03\x1a\xa9\x01\
    \x20Add\x20a\x20app\x20to\x20an\x20app.\n\x20This\x20needs\x20to\x20load\
    \x20the\x20default\x20workflow\x20to\x20make\x20a\x20copy,\x20validating\
    \x20all\x20the\x20models\x20in\x20it,\x20and\n\x20then\x20writing\x20the\
    \x20new\x20workflow\x20back\x20to\x20this\x20new\x20app.\n\n\r\n\x05\x06\
    \0\x02w\x01\x12\x04\x83\x10\x06\x0e\n\r\n\x05\x06\0\x02w\x02\x12\x04\x83\
    \x10\x10\x1f\n\r\n\x05\x06\0\x02w\x03\x12\x04\x83\x10*:\n\x0f\n\x05\x06\
    \0\x02w\x04\x12\x06\x84\x10\x04\x87\x10\x06\n\x13\n\t\x06\0\x02w\x04\xb0\
    \xca\xbc\"\x12\x06\x84\x10\x04\x87\x10\x06\n\r\n\x05\x06\0\x02w\x04\x12\
    \x04\x88\x10\x047\n\x10\n\x08\x06\0\x02w\x04\xc3\xf3\x04\x12\x04\x88\x10\
    \x047\n\r\n\x05\x06\0\x02w\x04\x12\x04\x89\x10\x04?\n\x11\n\t\x06\0\x02w\
    \x04\xc2\xf3\x04\0\x12\x04\x89\x10\x04?\n\r\n\x05\x06\0\x02w\x04\x12\x04\
    \x8a\x10\x04?\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x01\x12\x04\x8a\x10\
    \x04?\n\r\n\x05\x06\0\x02w\x04\x12\x04\x8b\x10\x04A\n\x11\n\t\x06\0\x02w\
    \x04\xc2\xf3\x04\x02\x12\x04\x8b\x10\x04A\n\r\n\x05\x06\0\x02w\x04\x12\
    \x04\x8c\x10\x04D\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x03\x12\x04\x8c\
    \x10\x04D\n\r\n\x05\x06\0\x02w\x04\x12\x04\x8d\x10\x04D\n\x11\n\t\x06\0\
    \x02w\x04\xc2\xf3\x04\x04\x12\x04\x8d\x10\x04D\n)\n\x04\x06\0\x02x\x12\
    \x06\x91\x10\x02\x99\x10\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20ap\
    ps.\n\n\r\n\x05\x06\0\x02x\x01\x12\x04\x91\x10\x06\x0f\n\r\n\x05\x06\0\
    \x02x\x02\x12\x04\x91\x10\x11!\n\r\n\x05\x06\0\x02x\x03\x12\x04\x91\x10,\
    <\n\x0f\n\x05\x06\0\x02x\x04\x12\x06\x92\x10\x04\x95\x10\x06\n\x13\n\t\
    \x06\0\x02x\x04\xb0\xca\xbc\"\x12\x06\x92\x10\x04\x95\x10\x06\n\r\n\x05\
    \x06\0\x02x\x04\x12\x04\x96\x10\x047\n\x10\n\x08\x06\0\x02x\x04\xc3\xf3\
    \x04\x12\x04\x96\x10\x047\n\r\n\x05\x06\0\x02x\x04\x12\x04\x97\x10\x04?\
    \n\x11\n\t\x06\0\x02x\x04\xc2\xf3\x04\0\x12\x04\x97\x10\x04?\n\r\n\x05\
    \x06\0\x02x\x04\x12\x04\x98\x10\x04?\n\x11\n\t\x06\0\x02x\x04\xc2\xf3\
    \x04\x01\x12\x04\x98\x10\x04?\n!\n\x04\x06\0\x02y\x12\x06\x9c\x10\x02\
    \xa4\x10\x03\x1a\x11\x20Patch\x20apps\x20ids.\n\n\r\n\x05\x06\0\x02y\x01\
    \x12\x04\x9c\x10\x06\x12\n\r\n\x05\x06\0\x02y\x02\x12\x04\x9c\x10\x14'\n\
    \r\n\x05\x06\0\x02y\x03\x12\x04\x9c\x102B\n\x0f\n\x05\x06\0\x02y\x04\x12\
    \x06\x9d\x10\x04\xa0\x10\x06\n\x13\n\t\x06\0\x02y\x04\xb0\xca\xbc\"\x12\
    \x06\x9d\x10\x04\xa0\x10\x06\n\r\n\x05\x06\0\x02y\x04\x12\x04\xa1\x10\
    \x047\n\x10\n\x08\x06\0\x02y\x04\xc3\xf3\x04\x12\x04\xa1\x10\x047\n\r\n\
    \x05\x06\0\x02y\x04\x12\x04\xa2\x10\x04?\n\x11\n\t\x06\0\x02y\x04\xc2\
    \xf3\x04\0\x12\x04\xa2\x10\x04?\n\r\n\x05\x06\0\x02y\x04\x12\x04\xa3\x10\
    \x04?\n\x11\n\t\x06\0\x02y\x04\xc2\xf3\x04\x01\x12\x04\xa3\x10\x04?\n\
    \x20\n\x04\x06\0\x02z\x12\x06\xa7\x10\x02\xaf\x10\x03\x1a\x10\x20Patch\
    \x20one\x20app.\n\n\r\n\x05\x06\0\x02z\x01\x12\x04\xa7\x10\x06\x0e\n\r\n\
    \x05\x06\0\x02z\x02\x12\x04\xa7\x10\x10\x1f\n\r\n\x05\x06\0\x02z\x03\x12\
    \x04\xa7\x10*;\n\x0f\n\x05\x06\0\x02z\x04\x12\x06\xa8\x10\x04\xab\x10\
    \x06\n\x13\n\t\x06\0\x02z\x04\xb0\xca\xbc\"\x12\x06\xa8\x10\x04\xab\x10\
    \x06\n\r\n\x05\x06\0\x02z\x04\x12\x04\xac\x10\x047\n\x10\n\x08\x06\0\x02\
    z\x04\xc3\xf3\x04\x12\x04\xac\x10\x047\n\r\n\x05\x06\0\x02z\x04\x12\x04\
    \xad\x10\x04?\n\x11\n\t\x06\0\x02z\x04\xc2\xf3\x04\0\x12\x04\xad\x10\x04\
    ?\n\r\n\x05\x06\0\x02z\x04\x12\x04\xae\x10\x04?\n\x11\n\t\x06\0\x02z\x04\
    \xc2\xf3\x04\x01\x12\x04\xae\x10\x04?\nV\n\x04\x06\0\x02{\x12\x06\xb3\
    \x10\x02\xbb\x10\x03\x1aF\x20Search\x20over\x20the\x20applications\x20to\
    \x20find\x20one\x20or\x20more\x20you're\x20looking\x20for.\n\n\r\n\x05\
    \x06\0\x02{\x01\x12\x04\xb3\x10\x06\x16\n\r\n\x05\x06\0\x02{\x02\x12\x04\
    \xb3\x10\x18/\n\r\n\x05\x06\0\x02{\x03\x12\x04\xb3\x10:J\n\x0f\n\x05\x06\
    \0\x02{\x04\x12\x06\xb4\x10\x04\xb7\x10\x06\n\x13\n\t\x06\0\x02{\x04\xb0\
    \xca\xbc\"\x12\x06\xb4\x10\x04\xb7\x10\x06\n\r\n\x05\x06\0\x02{\x04\x12\
    \x04\xb8\x10\x047\n\x10\n\x08\x06\0\x02{\x04\xc3\xf3\x04\x12\x04\xb8\x10\
    \x047\n\r\n\x05\x06\0\x02{\x04\x12\x04\xb9\x10\x04?\n\x11\n\t\x06\0\x02{\
    \x04\xc2\xf3\x04\0\x12\x04\xb9\x10\x04?\n\r\n\x05\x06\0\x02{\x04\x12\x04\
    \xba\x10\x04D\n\x11\n\t\x06\0\x02{\x04\xc2\xf3\x04\x01\x12\x04\xba\x10\
    \x04D\n&\n\x04\x06\0\x02|\x12\x06\xbe\x10\x02\xc3\x10\x03\x1a\x16\x20Get\
    \x20user\x20information\n\n\r\n\x05\x06\0\x02|\x01\x12\x04\xbe\x10\x06\r\
    \n\r\n\x05\x06\0\x02|\x02\x12\x04\xbe\x10\x0f\x1d\n\r\n\x05\x06\0\x02|\
    \x03\x12\x04\xbe\x10(:\n\x0f\n\x05\x06\0\x02|\x04\x12\x06\xbf\x10\x04\
    \xc1\x10\x06\n\x13\n\t\x06\0\x02|\x04\xb0\xca\xbc\"\x12\x06\xbf\x10\x04\
    \xc1\x10\x06\n\r\n\x05\x06\0\x02|\x04\x12\x04\xc2\x10\x047\n\x10\n\x08\
    \x06\0\x02|\x04\xc3\xf3\x04\x12\x04\xc2\x10\x047\n?\n\x04\x06\0\x02}\x12\
    \x06\xd1\x10\x02\xdb\x10\x03\x1a/\x20Validate\x20new\x20password\x20in\
    \x20real-time\x20for\x20a\x20user\n\n\r\n\x05\x06\0\x02}\x01\x12\x04\xd1\
    \x10\x06\x1a\n\r\n\x05\x06\0\x02}\x02\x12\x04\xd1\x10\x1c7\n\r\n\x05\x06\
    \0\x02}\x03\x12\x04\xd1\x10Bb\n\x0f\n\x05\x06\0\x02}\x04\x12\x06\xd2\x10\
    \x04\xd9\x10\x06\n\x13\n\t\x06\0\x02}\x04\xb0\xca\xbc\"\x12\x06\xd2\x10\
    \x04\xd9\x10\x06\n\r\n\x05\x06\0\x02}\x04\x12\x04\xda\x10\x04@\n\x10\n\
    \x08\x06\0\x02}\x04\xc3\xf3\x04\x12\x04\xda\x10\x04@\n,\n\x04\x06\0\x02~\
    \x12\x06\x8a\x11\x02\x94\x11\x03\x1a\x1c\x20Get\x20a\x20saved\x20legacy\
    \x20search.\n\n\r\n\x05\x06\0\x02~\x01\x12\x04\x8a\x11\x06\x0f\n\r\n\x05\
    \x06\0\x02~\x02\x12\x04\x8a\x11\x11!\n\r\n\x05\x06\0\x02~\x03\x12\x04\
    \x8a\x11,@\n\x0f\n\x05\x06\0\x02~\x04\x12\x06\x8b\x11\x04\x90\x11\x06\n\
    \x13\n\t\x06\0\x02~\x04\xb0\xca\xbc\"\x12\x06\x8b\x11\x04\x90\x11\x06\n\
    \r\n\x05\x06\0\x02~\x04\x12\x04\x91\x11\x047\n\x10\n\x08\x06\0\x02~\x04\
    \xc3\xf3\x04\x12\x04\x91\x11\x047\n\r\n\x05\x06\0\x02~\x04\x12\x04\x92\
    \x11\x04?\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\0\x12\x04\x92\x11\x04?\n\
    \r\n\x05\x06\0\x02~\x04\x12\x04\x93\x11\x04F\n\x11\n\t\x06\0\x02~\x04\
    \xc2\xf3\x04\x01\x12\x04\x93\x11\x04F\n1\n\x04\x06\0\x02\x7f\x12\x06\x97\
    \x11\x02\xa1\x11\x03\x1a!\x20List\x20all\x20saved\x20legacy\x20searches.\
    \n\n\r\n\x05\x06\0\x02\x7f\x01\x12\x04\x97\x11\x06\x12\n\r\n\x05\x06\0\
    \x02\x7f\x02\x12\x04\x97\x11\x14'\n\r\n\x05\x06\0\x02\x7f\x03\x12\x04\
    \x97\x112E\n\x0f\n\x05\x06\0\x02\x7f\x04\x12\x06\x98\x11\x04\x9d\x11\x06\
    \n\x13\n\t\x06\0\x02\x7f\x04\xb0\xca\xbc\"\x12\x06\x98\x11\x04\x9d\x11\
    \x06\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\x9e\x11\x047\n\x10\n\x08\x06\0\
    \x02\x7f\x04\xc3\xf3\x04\x12\x04\x9e\x11\x047\n\r\n\x05\x06\0\x02\x7f\
    \x04\x12\x04\x9f\x11\x04?\n\x11\n\t\x06\0\x02\x7f\x04\xc2\xf3\x04\0\x12\
    \x04\x9f\x11\x04?\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\xa0\x11\x04F\n\x11\
    \n\t\x06\0\x02\x7f\x04\xc2\xf3\x04\x01\x12\x04\xa0\x11\x04F\n6\n\x05\x06\
    \0\x02\x80\x01\x12\x06\xa4\x11\x02\xb1\x11\x03\x1a%\x20Patch\x20saved\
    \x20legacy\x20searches\x20by\x20ids.\n\n\x0e\n\x06\x06\0\x02\x80\x01\x01\
    \x12\x04\xa4\x11\x06\x13\n\x0e\n\x06\x06\0\x02\x80\x01\x02\x12\x04\xa4\
    \x11\x15)\n\x0e\n\x06\x06\0\x02\x80\x01\x03\x12\x04\xa4\x114G\n\x10\n\
    \x06\x06\0\x02\x80\x01\x04\x12\x06\xa5\x11\x04\xac\x11\x06\n\x14\n\n\x06\
    \0\x02\x80\x01\x04\xb0\xca\xbc\"\x12\x06\xa5\x11\x04\xac\x11\x06\n\x0e\n\
    \x06\x06\0\x02\x80\x01\x04\x12\x04\xad\x11\x047\n\x11\n\t\x06\0\x02\x80\
    \x01\x04\xc3\xf3\x04\x12\x04\xad\x11\x047\n\x0e\n\x06\x06\0\x02\x80\x01\
    \x04\x12\x04\xae\x11\x04?\n\x12\n\n\x06\0\x02\x80\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xae\x11\x04?\n\x0e\n\x06\x06\0\x02\x80\x01\x04\x12\x04\xaf\x11\
    \x04F\n\x12\n\n\x06\0\x02\x80\x01\x04\xc2\xf3\x04\x01\x12\x04\xaf\x11\
    \x04F\n\x0e\n\x06\x06\0\x02\x80\x01\x04\x12\x04\xb0\x11\x04F\n\x12\n\n\
    \x06\0\x02\x80\x01\x04\xc2\xf3\x04\x02\x12\x04\xb0\x11\x04F\n\x88\x01\n\
    \x05\x06\0\x02\x81\x01\x12\x06\xb6\x11\x02\xc9\x11\x03\x1aw\x20Execute\
    \x20a\x20new\x20search\x20and\x20optionally\x20save\x20it.\n\n\x20Deprec\
    ated:\x20Use\x20PostInputsSearches\x20or\x20PostAnnotationsSearches\x20i\
    nstead.\n\n\x0e\n\x06\x06\0\x02\x81\x01\x01\x12\x04\xb6\x11\x06\x12\n\
    \x0e\n\x06\x06\0\x02\x81\x01\x02\x12\x04\xb6\x11\x14'\n\x0e\n\x06\x06\0\
    \x02\x81\x01\x03\x12\x04\xb6\x112E\n\x10\n\x06\x06\0\x02\x81\x01\x04\x12\
    \x06\xb7\x11\x04\xbe\x11\x06\n\x14\n\n\x06\0\x02\x81\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xb7\x11\x04\xbe\x11\x06\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\
    \x04\xbf\x11\x047\n\x11\n\t\x06\0\x02\x81\x01\x04\xc3\xf3\x04\x12\x04\
    \xbf\x11\x047\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc0\x11\x04?\n\
    \x12\n\n\x06\0\x02\x81\x01\x04\xc2\xf3\x04\0\x12\x04\xc0\x11\x04?\n\x0e\
    \n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc1\x11\x04F\n\x12\n\n\x06\0\x02\
    \x81\x01\x04\xc2\xf3\x04\x01\x12\x04\xc1\x11\x04F\n\x0e\n\x06\x06\0\x02\
    \x81\x01\x04\x12\x04\xc2\x11\x04C\n\x12\n\n\x06\0\x02\x81\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xc2\x11\x04C\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\
    \x04\xc3\x11\x04A\n\x12\n\n\x06\0\x02\x81\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xc3\x11\x04A\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc4\x11\x04A\
    \n\x12\n\n\x06\0\x02\x81\x01\x04\xc2\xf3\x04\x04\x12\x04\xc4\x11\x04A\n\
    \x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc6\x11\x04=\n\\\n\n\x06\0\x02\
    \x81\x01\x04\xc2\xf3\x04\x05\x12\x04\xc6\x11\x04=\x1aH\x20option\x20(cla\
    rifai.auth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20optional\
    \n\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc7\x11\x04D\nO\n\n\x06\0\
    \x02\x81\x01\x04\xc2\xf3\x04\x06\x12\x04\xc7\x11\x04D\";\x20to\x20know\
    \x20the\x20concepts\x20and\x20models\x20in\x20your\x20default\x20workflo\
    w.\n\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc8\x11\x04\x1d\n\x0f\n\
    \x07\x06\0\x02\x81\x01\x04!\x12\x04\xc8\x11\x04\x1d\n<\n\x05\x06\0\x02\
    \x82\x01\x12\x06\xcc\x11\x02\xd9\x11\x03\x1a+\x20Execute\x20a\x20previou\
    sly\x20saved\x20legacy\x20search.\n\n\x0e\n\x06\x06\0\x02\x82\x01\x01\
    \x12\x04\xcc\x11\x06\x16\n\x0e\n\x06\x06\0\x02\x82\x01\x02\x12\x04\xcc\
    \x11\x18/\n\x0e\n\x06\x06\0\x02\x82\x01\x03\x12\x04\xcc\x11:M\n\x10\n\
    \x06\x06\0\x02\x82\x01\x04\x12\x06\xcd\x11\x04\xd4\x11\x06\n\x14\n\n\x06\
    \0\x02\x82\x01\x04\xb0\xca\xbc\"\x12\x06\xcd\x11\x04\xd4\x11\x06\n\x0e\n\
    \x06\x06\0\x02\x82\x01\x04\x12\x04\xd5\x11\x047\n\x11\n\t\x06\0\x02\x82\
    \x01\x04\xc3\xf3\x04\x12\x04\xd5\x11\x047\n\x0e\n\x06\x06\0\x02\x82\x01\
    \x04\x12\x04\xd6\x11\x04?\n\x12\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xd6\x11\x04?\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xd7\x11\
    \x04F\n\x12\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\x01\x12\x04\xd7\x11\
    \x04F\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xd8\x11\x04=\n\x12\n\n\
    \x06\0\x02\x82\x01\x04\xc2\xf3\x04\x02\x12\x04\xd8\x11\x04=\n>\n\x05\x06\
    \0\x02\x83\x01\x12\x06\xdc\x11\x02\xee\x11\x03\x1a-\x20Evaluate\x20the\
    \x20results\x20of\x20two\x20search\x20requests\n\n\x0e\n\x06\x06\0\x02\
    \x83\x01\x01\x12\x04\xdc\x11\x06!\n\x0e\n\x06\x06\0\x02\x83\x01\x02\x12\
    \x04\xdc\x11\"D\n\x0e\n\x06\x06\0\x02\x83\x01\x03\x12\x04\xdc\x11Os\n\
    \x10\n\x06\x06\0\x02\x83\x01\x04\x12\x06\xdd\x11\x04\xe4\x11\x06\n\x14\n\
    \n\x06\0\x02\x83\x01\x04\xb0\xca\xbc\"\x12\x06\xdd\x11\x04\xe4\x11\x06\n\
    \x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\xe5\x11\x047\n\x11\n\t\x06\0\
    \x02\x83\x01\x04\xc3\xf3\x04\x12\x04\xe5\x11\x047\n\x0e\n\x06\x06\0\x02\
    \x83\x01\x04\x12\x04\xe6\x11\x04?\n\x12\n\n\x06\0\x02\x83\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xe6\x11\x04?\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\
    \x04\xe7\x11\x04F\n\x12\n\n\x06\0\x02\x83\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xe7\x11\x04F\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\xe8\x11\x04C\
    \n\x12\n\n\x06\0\x02\x83\x01\x04\xc2\xf3\x04\x02\x12\x04\xe8\x11\x04C\n\
    \x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\xe9\x11\x04A\n\x12\n\n\x06\0\
    \x02\x83\x01\x04\xc2\xf3\x04\x03\x12\x04\xe9\x11\x04A\n\x0e\n\x06\x06\0\
    \x02\x83\x01\x04\x12\x04\xea\x11\x04B\n\x12\n\n\x06\0\x02\x83\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xea\x11\x04B\n\x0e\n\x06\x06\0\x02\x83\x01\x04\
    \x12\x04\xeb\x11\x04B\n\x12\n\n\x06\0\x02\x83\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xeb\x11\x04B\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\xec\x11\
    \x04A\n\x12\n\n\x06\0\x02\x83\x01\x04\xc2\xf3\x04\x06\x12\x04\xec\x11\
    \x04A\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\xed\x11\x04D\nQ\n\n\x06\
    \0\x02\x83\x01\x04\xc2\xf3\x04\x07\x12\x04\xed\x11\x04D\"=\x20as\x20it\
    \x20needs\x20to\x20know\x20the\x20concepts\x20in\x20your\x20workflow's\
    \x20models.\n\nI\n\x05\x06\0\x02\x84\x01\x12\x06\xf1\x11\x02\xfe\x11\x03\
    \x1a8\x20Get\x20the\x20evaluation\x20results\x20between\x20two\x20search\
    \x20requests\n\n\x0e\n\x06\x06\0\x02\x84\x01\x01\x12\x04\xf1\x11\x06\x20\
    \n\x0e\n\x06\x06\0\x02\x84\x01\x02\x12\x04\xf1\x11!B\n\x0e\n\x06\x06\0\
    \x02\x84\x01\x03\x12\x04\xf1\x11Mq\n\x10\n\x06\x06\0\x02\x84\x01\x04\x12\
    \x06\xf2\x11\x04\xf7\x11\x06\n\x14\n\n\x06\0\x02\x84\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xf2\x11\x04\xf7\x11\x06\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\
    \x04\xf8\x11\x047\n\x11\n\t\x06\0\x02\x84\x01\x04\xc3\xf3\x04\x12\x04\
    \xf8\x11\x047\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\xf9\x11\x04?\n\
    \x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\0\x12\x04\xf9\x11\x04?\n\x0e\
    \n\x06\x06\0\x02\x84\x01\x04\x12\x04\xfa\x11\x04F\n\x12\n\n\x06\0\x02\
    \x84\x01\x04\xc2\xf3\x04\x01\x12\x04\xfa\x11\x04F\n\x0e\n\x06\x06\0\x02\
    \x84\x01\x04\x12\x04\xfb\x11\x04C\n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xfb\x11\x04C\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\
    \x04\xfc\x11\x04A\n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xfc\x11\x04A\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\xfd\x11\x04B\
    \n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\x04\x12\x04\xfd\x11\x04B\nJ\
    \n\x05\x06\0\x02\x85\x01\x12\x06\x83\x12\x02\x90\x12\x03\x1a9\x20List\
    \x20the\x20evaluation\x20results\x20between\x20two\x20search\x20requests\
    \n\n\x0e\n\x06\x06\0\x02\x85\x01\x01\x12\x04\x83\x12\x06!\n\x0e\n\x06\
    \x06\0\x02\x85\x01\x02\x12\x04\x83\x12\"D\n\x0e\n\x06\x06\0\x02\x85\x01\
    \x03\x12\x04\x83\x12Os\n\x10\n\x06\x06\0\x02\x85\x01\x04\x12\x06\x84\x12\
    \x04\x89\x12\x06\n\x14\n\n\x06\0\x02\x85\x01\x04\xb0\xca\xbc\"\x12\x06\
    \x84\x12\x04\x89\x12\x06\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8a\
    \x12\x047\n\x11\n\t\x06\0\x02\x85\x01\x04\xc3\xf3\x04\x12\x04\x8a\x12\
    \x047\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8b\x12\x04?\n\x12\n\n\
    \x06\0\x02\x85\x01\x04\xc2\xf3\x04\0\x12\x04\x8b\x12\x04?\n\x0e\n\x06\
    \x06\0\x02\x85\x01\x04\x12\x04\x8c\x12\x04F\n\x12\n\n\x06\0\x02\x85\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x8c\x12\x04F\n\x0e\n\x06\x06\0\x02\x85\x01\
    \x04\x12\x04\x8d\x12\x04C\n\x12\n\n\x06\0\x02\x85\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\x8d\x12\x04C\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8e\
    \x12\x04A\n\x12\n\n\x06\0\x02\x85\x01\x04\xc2\xf3\x04\x03\x12\x04\x8e\
    \x12\x04A\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\x8f\x12\x04B\n\x12\n\
    \n\x06\0\x02\x85\x01\x04\xc2\xf3\x04\x04\x12\x04\x8f\x12\x04B\n0\n\x05\
    \x06\0\x02\x86\x01\x12\x06\x93\x12\x02\x9f\x12\x03\x1a\x1f\x20DeleteAnno\
    tationSearchMetrics\n\n\x0e\n\x06\x06\0\x02\x86\x01\x01\x12\x04\x93\x12\
    \x06#\n\x0e\n\x06\x06\0\x02\x86\x01\x02\x12\x04\x93\x12%I\n\x0e\n\x06\
    \x06\0\x02\x86\x01\x03\x12\x04\x93\x12Tt\n\x10\n\x06\x06\0\x02\x86\x01\
    \x04\x12\x06\x94\x12\x04\x99\x12\x06\n\x14\n\n\x06\0\x02\x86\x01\x04\xb0\
    \xca\xbc\"\x12\x06\x94\x12\x04\x99\x12\x06\n\x0e\n\x06\x06\0\x02\x86\x01\
    \x04\x12\x04\x9a\x12\x047\n\x11\n\t\x06\0\x02\x86\x01\x04\xc3\xf3\x04\
    \x12\x04\x9a\x12\x047\n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\x04\x9b\x12\
    \x04?\n\x12\n\n\x06\0\x02\x86\x01\x04\xc2\xf3\x04\0\x12\x04\x9b\x12\x04?\
    \n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\x04\x9c\x12\x04B\n\x12\n\n\x06\0\
    \x02\x86\x01\x04\xc2\xf3\x04\x01\x12\x04\x9c\x12\x04B\n\x0e\n\x06\x06\0\
    \x02\x86\x01\x04\x12\x04\x9d\x12\x04B\n\x12\n\n\x06\0\x02\x86\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\x9d\x12\x04B\n\x0e\n\x06\x06\0\x02\x86\x01\x04\
    \x12\x04\x9e\x12\x04E\n\x12\n\n\x06\0\x02\x86\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\x9e\x12\x04E\n)\n\x05\x06\0\x02\x87\x01\x12\x06\xa2\x12\x02\xae\
    \x12\x03\x1a\x18\x20Delete\x20a\x20saved\x20search.\n\n\x0e\n\x06\x06\0\
    \x02\x87\x01\x01\x12\x04\xa2\x12\x06\x12\n\x0e\n\x06\x06\0\x02\x87\x01\
    \x02\x12\x04\xa2\x12\x14'\n\x0e\n\x06\x06\0\x02\x87\x01\x03\x12\x04\xa2\
    \x122R\n\x10\n\x06\x06\0\x02\x87\x01\x04\x12\x06\xa3\x12\x04\xa8\x12\x06\
    \n\x14\n\n\x06\0\x02\x87\x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x12\x04\xa8\
    \x12\x06\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xa9\x12\x047\n\x11\n\
    \t\x06\0\x02\x87\x01\x04\xc3\xf3\x04\x12\x04\xa9\x12\x047\n\x0e\n\x06\
    \x06\0\x02\x87\x01\x04\x12\x04\xaa\x12\x04?\n\x12\n\n\x06\0\x02\x87\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xaa\x12\x04?\n\x0e\n\x06\x06\0\x02\x87\x01\
    \x04\x12\x04\xab\x12\x04F\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xab\x12\x04F\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xac\
    \x12\x04F\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\x02\x12\x04\xac\
    \x12\x04F\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xad\x12\x04I\n\x12\n\
    \n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\x03\x12\x04\xad\x12\x04I\n3\n\x05\
    \x06\0\x02\x88\x01\x12\x06\xb2\x12\x02\xbc\x12\x03\x1a\"\x20List\x20all\
    \x20the\x20annotation\x20filters.\n\n\x0e\n\x06\x06\0\x02\x88\x01\x01\
    \x12\x04\xb2\x12\x06\x1b\n\x0e\n\x06\x06\0\x02\x88\x01\x02\x12\x04\xb2\
    \x12\x1d9\n\x0e\n\x06\x06\0\x02\x88\x01\x03\x12\x04\xb2\x12Da\n\x10\n\
    \x06\x06\0\x02\x88\x01\x04\x12\x06\xb3\x12\x04\xb8\x12\x06\n\x14\n\n\x06\
    \0\x02\x88\x01\x04\xb0\xca\xbc\"\x12\x06\xb3\x12\x04\xb8\x12\x06\n\x0e\n\
    \x06\x06\0\x02\x88\x01\x04\x12\x04\xb9\x12\x047\n\x11\n\t\x06\0\x02\x88\
    \x01\x04\xc3\xf3\x04\x12\x04\xb9\x12\x047\n\x0e\n\x06\x06\0\x02\x88\x01\
    \x04\x12\x04\xba\x12\x04?\n\x12\n\n\x06\0\x02\x88\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xba\x12\x04?\n\x0e\n\x06\x06\0\x02\x88\x01\x04\x12\x04\xbb\x12\
    \x04F\n\x12\n\n\x06\0\x02\x88\x01\x04\xc2\xf3\x04\x01\x12\x04\xbb\x12\
    \x04F\n4\n\x05\x06\0\x02\x89\x01\x12\x06\xbf\x12\x02\xc9\x12\x03\x1a#\
    \x20Get\x20a\x20specific\x20annotation\x20filter.\n\n\x0e\n\x06\x06\0\
    \x02\x89\x01\x01\x12\x04\xbf\x12\x06\x19\n\x0e\n\x06\x06\0\x02\x89\x01\
    \x02\x12\x04\xbf\x12\x1b5\n\x0e\n\x06\x06\0\x02\x89\x01\x03\x12\x04\xbf\
    \x12@^\n\x10\n\x06\x06\0\x02\x89\x01\x04\x12\x06\xc0\x12\x04\xc5\x12\x06\
    \n\x14\n\n\x06\0\x02\x89\x01\x04\xb0\xca\xbc\"\x12\x06\xc0\x12\x04\xc5\
    \x12\x06\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xc6\x12\x047\n\x11\n\
    \t\x06\0\x02\x89\x01\x04\xc3\xf3\x04\x12\x04\xc6\x12\x047\n\x0e\n\x06\
    \x06\0\x02\x89\x01\x04\x12\x04\xc7\x12\x04?\n\x12\n\n\x06\0\x02\x89\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xc7\x12\x04?\n\x0e\n\x06\x06\0\x02\x89\x01\
    \x04\x12\x04\xc8\x12\x04F\n\x12\n\n\x06\0\x02\x89\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xc8\x12\x04F\n*\n\x05\x06\0\x02\x8a\x01\x12\x06\xcc\x12\x02\
    \xd9\x12\x03\x1a\x19\x20Add\x20annotation\x20filters.\n\n\x0e\n\x06\x06\
    \0\x02\x8a\x01\x01\x12\x04\xcc\x12\x06\x1b\n\x0e\n\x06\x06\0\x02\x8a\x01\
    \x02\x12\x04\xcc\x12\x1d9\n\x0e\n\x06\x06\0\x02\x8a\x01\x03\x12\x04\xcc\
    \x12Da\n\x10\n\x06\x06\0\x02\x8a\x01\x04\x12\x06\xcd\x12\x04\xd4\x12\x06\
    \n\x14\n\n\x06\0\x02\x8a\x01\x04\xb0\xca\xbc\"\x12\x06\xcd\x12\x04\xd4\
    \x12\x06\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\x04\xd5\x12\x047\n\x11\n\
    \t\x06\0\x02\x8a\x01\x04\xc3\xf3\x04\x12\x04\xd5\x12\x047\n\x0e\n\x06\
    \x06\0\x02\x8a\x01\x04\x12\x04\xd6\x12\x04?\n\x12\n\n\x06\0\x02\x8a\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xd6\x12\x04?\n\x0e\n\x06\x06\0\x02\x8a\x01\
    \x04\x12\x04\xd7\x12\x04F\n\x12\n\n\x06\0\x02\x8a\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xd7\x12\x04F\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\x04\xd8\
    \x12\x04F\n\x12\n\n\x06\0\x02\x8a\x01\x04\xc2\xf3\x04\x02\x12\x04\xd8\
    \x12\x04F\n8\n\x05\x06\0\x02\x8b\x01\x12\x06\xdc\x12\x02\xe9\x12\x03\x1a\
    '\x20Patch\x20one\x20or\x20more\x20annotation\x20filters.\n\n\x0e\n\x06\
    \x06\0\x02\x8b\x01\x01\x12\x04\xdc\x12\x06\x1c\n\x0e\n\x06\x06\0\x02\x8b\
    \x01\x02\x12\x04\xdc\x12\x1e;\n\x0e\n\x06\x06\0\x02\x8b\x01\x03\x12\x04\
    \xdc\x12Fc\n\x10\n\x06\x06\0\x02\x8b\x01\x04\x12\x06\xdd\x12\x04\xe4\x12\
    \x06\n\x14\n\n\x06\0\x02\x8b\x01\x04\xb0\xca\xbc\"\x12\x06\xdd\x12\x04\
    \xe4\x12\x06\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\xe5\x12\x047\n\
    \x11\n\t\x06\0\x02\x8b\x01\x04\xc3\xf3\x04\x12\x04\xe5\x12\x047\n\x0e\n\
    \x06\x06\0\x02\x8b\x01\x04\x12\x04\xe6\x12\x04?\n\x12\n\n\x06\0\x02\x8b\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xe6\x12\x04?\n\x0e\n\x06\x06\0\x02\x8b\
    \x01\x04\x12\x04\xe7\x12\x04F\n\x12\n\n\x06\0\x02\x8b\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xe7\x12\x04F\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\
    \xe8\x12\x04F\n\x12\n\n\x06\0\x02\x8b\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xe8\x12\x04F\nM\n\x05\x06\0\x02\x8c\x01\x12\x06\xec\x12\x02\xf9\x12\x03\
    \x1a<\x20Delete\x20one\x20or\x20more\x20annotation\x20filters\x20in\x20a\
    \x20single\x20request.\n\n\x0e\n\x06\x06\0\x02\x8c\x01\x01\x12\x04\xec\
    \x12\x06\x1d\n\x0e\n\x06\x06\0\x02\x8c\x01\x02\x12\x04\xec\x12\x1f=\n\
    \x0e\n\x06\x06\0\x02\x8c\x01\x03\x12\x04\xec\x12Hh\n\x10\n\x06\x06\0\x02\
    \x8c\x01\x04\x12\x06\xed\x12\x04\xf4\x12\x06\n\x14\n\n\x06\0\x02\x8c\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xed\x12\x04\xf4\x12\x06\n\x0e\n\x06\x06\0\x02\
    \x8c\x01\x04\x12\x04\xf5\x12\x047\n\x11\n\t\x06\0\x02\x8c\x01\x04\xc3\
    \xf3\x04\x12\x04\xf5\x12\x047\n\x0e\n\x06\x06\0\x02\x8c\x01\x04\x12\x04\
    \xf6\x12\x04?\n\x12\n\n\x06\0\x02\x8c\x01\x04\xc2\xf3\x04\0\x12\x04\xf6\
    \x12\x04?\n\x0e\n\x06\x06\0\x02\x8c\x01\x04\x12\x04\xf7\x12\x04F\n\x12\n\
    \n\x06\0\x02\x8c\x01\x04\xc2\xf3\x04\x01\x12\x04\xf7\x12\x04F\n\x0e\n\
    \x06\x06\0\x02\x8c\x01\x04\x12\x04\xf8\x12\x04F\n\x12\n\n\x06\0\x02\x8c\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\xf8\x12\x04F\n)\n\x05\x06\0\x02\x8d\x01\
    \x12\x06\x9a\x13\x02\x9f\x13\x03\x1a\x18\x20List\x20all\x20status\x20cod\
    es.\n\n\x0e\n\x06\x06\0\x02\x8d\x01\x01\x12\x04\x9a\x13\x06\x15\n\x0e\n\
    \x06\x06\0\x02\x8d\x01\x02\x12\x04\x9a\x13\x17-\n\x0e\n\x06\x06\0\x02\
    \x8d\x01\x03\x12\x04\x9a\x138O\n\x10\n\x06\x06\0\x02\x8d\x01\x04\x12\x06\
    \x9b\x13\x04\x9d\x13\x06\n\x14\n\n\x06\0\x02\x8d\x01\x04\xb0\xca\xbc\"\
    \x12\x06\x9b\x13\x04\x9d\x13\x06\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\x12\
    \x04\x9e\x13\x046\n\x11\n\t\x06\0\x02\x8d\x01\x04\xc3\xf3\x04\x12\x04\
    \x9e\x13\x046\n6\n\x05\x06\0\x02\x8e\x01\x12\x06\xa2\x13\x02\xa7\x13\x03\
    \x1a%\x20Get\x20more\x20details\x20for\x20a\x20status\x20code.\n\n\x0e\n\
    \x06\x06\0\x02\x8e\x01\x01\x12\x04\xa2\x13\x06\x13\n\x0e\n\x06\x06\0\x02\
    \x8e\x01\x02\x12\x04\xa2\x13\x15)\n\x0e\n\x06\x06\0\x02\x8e\x01\x03\x12\
    \x04\xa2\x134L\n\x10\n\x06\x06\0\x02\x8e\x01\x04\x12\x06\xa3\x13\x04\xa5\
    \x13\x06\n\x14\n\n\x06\0\x02\x8e\x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x13\
    \x04\xa5\x13\x06\n\x0e\n\x06\x06\0\x02\x8e\x01\x04\x12\x04\xa6\x13\x046\
    \n\x11\n\t\x06\0\x02\x8e\x01\x04\xc3\xf3\x04\x12\x04\xa6\x13\x046\n>\n\
    \x05\x06\0\x02\x8f\x01\x12\x06\xb3\x13\x02\xba\x13\x03\x1a-\x20owner\x20\
    list\x20users\x20who\x20the\x20app\x20is\x20shared\x20with\n\n\x0e\n\x06\
    \x06\0\x02\x8f\x01\x01\x12\x04\xb3\x13\x06\x17\n\x0e\n\x06\x06\0\x02\x8f\
    \x01\x02\x12\x04\xb3\x13\x191\n\x0e\n\x06\x06\0\x02\x8f\x01\x03\x12\x04\
    \xb3\x13<V\n\x10\n\x06\x06\0\x02\x8f\x01\x04\x12\x06\xb4\x13\x04\xb6\x13\
    \x06\n\x14\n\n\x06\0\x02\x8f\x01\x04\xb0\xca\xbc\"\x12\x06\xb4\x13\x04\
    \xb6\x13\x06\n\x0e\n\x06\x06\0\x02\x8f\x01\x04\x12\x04\xb7\x13\x047\n\
    \x11\n\t\x06\0\x02\x8f\x01\x04\xc3\xf3\x04\x12\x04\xb7\x13\x047\n\x0e\n\
    \x06\x06\0\x02\x8f\x01\x04\x12\x04\xb8\x13\x04?\n\x12\n\n\x06\0\x02\x8f\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xb8\x13\x04?\n\x0e\n\x06\x06\0\x02\x8f\
    \x01\x04\x12\x04\xb9\x13\x04H\n\x12\n\n\x06\0\x02\x8f\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xb9\x13\x04H\n/\n\x05\x06\0\x02\x90\x01\x12\x06\xbd\x13\
    \x02\xc6\x13\x03\x1a\x1e\x20add\x20collaborators\x20to\x20an\x20app.\n\n\
    \x0e\n\x06\x06\0\x02\x90\x01\x01\x12\x04\xbd\x13\x06\x17\n\x0e\n\x06\x06\
    \0\x02\x90\x01\x02\x12\x04\xbd\x13\x191\n\x0e\n\x06\x06\0\x02\x90\x01\
    \x03\x12\x04\xbd\x13<V\n\x10\n\x06\x06\0\x02\x90\x01\x04\x12\x06\xbe\x13\
    \x04\xc1\x13\x06\n\x14\n\n\x06\0\x02\x90\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xbe\x13\x04\xc1\x13\x06\n\x0e\n\x06\x06\0\x02\x90\x01\x04\x12\x04\xc2\
    \x13\x047\n\x11\n\t\x06\0\x02\x90\x01\x04\xc3\xf3\x04\x12\x04\xc2\x13\
    \x047\n\x0e\n\x06\x06\0\x02\x90\x01\x04\x12\x04\xc3\x13\x04?\n\x12\n\n\
    \x06\0\x02\x90\x01\x04\xc2\xf3\x04\0\x12\x04\xc3\x13\x04?\n\x0e\n\x06\
    \x06\0\x02\x90\x01\x04\x12\x04\xc4\x13\x04H\n\x12\n\n\x06\0\x02\x90\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xc4\x13\x04H\n\x0e\n\x06\x06\0\x02\x90\x01\
    \x04\x12\x04\xc5\x13\x04H\n\x12\n\n\x06\0\x02\x90\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xc5\x13\x04H\n0\n\x05\x06\0\x02\x91\x01\x12\x06\xc9\x13\x02\
    \xd3\x13\x03\x1a\x1f\x20Patch\x20existing\x20collaborators.\n\n\x0e\n\
    \x06\x06\0\x02\x91\x01\x01\x12\x04\xc9\x13\x06\x18\n\x0e\n\x06\x06\0\x02\
    \x91\x01\x02\x12\x04\xc9\x13\x1a3\n\x0e\n\x06\x06\0\x02\x91\x01\x03\x12\
    \x04\xc9\x13>X\n\x10\n\x06\x06\0\x02\x91\x01\x04\x12\x06\xca\x13\x04\xcd\
    \x13\x06\n\x14\n\n\x06\0\x02\x91\x01\x04\xb0\xca\xbc\"\x12\x06\xca\x13\
    \x04\xcd\x13\x06\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\x04\xce\x13\x047\
    \n\x11\n\t\x06\0\x02\x91\x01\x04\xc3\xf3\x04\x12\x04\xce\x13\x047\n\x0e\
    \n\x06\x06\0\x02\x91\x01\x04\x12\x04\xcf\x13\x04?\n\x12\n\n\x06\0\x02\
    \x91\x01\x04\xc2\xf3\x04\0\x12\x04\xcf\x13\x04?\n\x0e\n\x06\x06\0\x02\
    \x91\x01\x04\x12\x04\xd0\x13\x04H\n\x12\n\n\x06\0\x02\x91\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xd0\x13\x04H\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\
    \x04\xd1\x13\x04H\n\x12\n\n\x06\0\x02\x91\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xd1\x13\x04H\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\x04\xd2\x13\x04K\
    \n\x12\n\n\x06\0\x02\x91\x01\x04\xc2\xf3\x04\x03\x12\x04\xd2\x13\x04K\n1\
    \n\x05\x06\0\x02\x92\x01\x12\x06\xd6\x13\x02\xe2\x13\x03\x1a\x20\x20Dele\
    te\x20existing\x20collaborators.\n\n\x0e\n\x06\x06\0\x02\x92\x01\x01\x12\
    \x04\xd6\x13\x06\x19\n\x0e\n\x06\x06\0\x02\x92\x01\x02\x12\x04\xd6\x13\
    \x1b5\n\x0e\n\x06\x06\0\x02\x92\x01\x03\x12\x04\xd6\x13@`\n\x10\n\x06\
    \x06\0\x02\x92\x01\x04\x12\x06\xd7\x13\x04\xda\x13\x06\n\x14\n\n\x06\0\
    \x02\x92\x01\x04\xb0\xca\xbc\"\x12\x06\xd7\x13\x04\xda\x13\x06\n\x0e\n\
    \x06\x06\0\x02\x92\x01\x04\x12\x04\xdb\x13\x047\n\x11\n\t\x06\0\x02\x92\
    \x01\x04\xc3\xf3\x04\x12\x04\xdb\x13\x047\n\x0e\n\x06\x06\0\x02\x92\x01\
    \x04\x12\x04\xdc\x13\x04?\n\x12\n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xdc\x13\x04?\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\xdd\x13\
    \x04H\n\x12\n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\x01\x12\x04\xdd\x13\
    \x04H\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\xde\x13\x04H\n\x12\n\n\
    \x06\0\x02\x92\x01\x04\xc2\xf3\x04\x02\x12\x04\xde\x13\x04H\n\x0e\n\x06\
    \x06\0\x02\x92\x01\x04\x12\x04\xdf\x13\x04K\n\x12\n\n\x06\0\x02\x92\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\xdf\x13\x04K\n\x0e\n\x06\x06\0\x02\x92\x01\
    \x04\x12\x04\xe0\x13\x04@\no\n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\x04\
    \x12\x04\xe0\x13\x04@\"[\x20when\x20deleting\x20a\x20collaborator,\x20we\
    \x20also\x20delete\x20task\x20workers\x20associated\x20to\x20this\x20col\
    laborator\n\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\xe1\x13\x04@\n\x12\
    \n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\x05\x12\x04\xe1\x13\x04@\nN\n\x05\
    \x06\0\x02\x93\x01\x12\x06\xe5\x13\x02\xea\x13\x03\x1a=\x20Collaboration\
    \x20includes\x20the\x20app\x20user\x20are\x20invitied\x20to\x20work\x20o\
    n\n\n\x0e\n\x06\x06\0\x02\x93\x01\x01\x12\x04\xe5\x13\x06\x18\n\x0e\n\
    \x06\x06\0\x02\x93\x01\x02\x12\x04\xe5\x13\x1a3\n\x0e\n\x06\x06\0\x02\
    \x93\x01\x03\x12\x04\xe5\x13>Y\n\x10\n\x06\x06\0\x02\x93\x01\x04\x12\x06\
    \xe6\x13\x04\xe8\x13\x06\n\x14\n\n\x06\0\x02\x93\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xe6\x13\x04\xe8\x13\x06\n\x0e\n\x06\x06\0\x02\x93\x01\x04\x12\
    \x04\xe9\x13\x04@\n\x11\n\t\x06\0\x02\x93\x01\x04\xc3\xf3\x04\x12\x04\
    \xe9\x13\x04@\n\xe3\x01\n\x05\x06\0\x02\x94\x01\x12\x06\xf2\x13\x02\x84\
    \x14\x03\x1a\xd1\x01\x20start\x20to\x20duplicate\x20an\x20app\x20which\
    \x20copies\x20all\x20the\x20inputs,\x20annotations,\x20models,\x20concep\
    ts\x20etc.\x20to\x20a\x20new\x20app.\n\x20this\x20is\x20an\x20async\x20p\
    rocess,\x20you\x20should\x20use\x20ListAppDuplications\x20or\x20GetAppDu\
    plication\x20to\x20check\x20the\x20status.\n\n\x0e\n\x06\x06\0\x02\x94\
    \x01\x01\x12\x04\xf2\x13\x06\x19\n\x0e\n\x06\x06\0\x02\x94\x01\x02\x12\
    \x04\xf2\x13\x1b5\n\x0e\n\x06\x06\0\x02\x94\x01\x03\x12\x04\xf2\x13@\\\n\
    \x10\n\x06\x06\0\x02\x94\x01\x04\x12\x06\xf3\x13\x04\xf6\x13\x06\n\x14\n\
    \n\x06\0\x02\x94\x01\x04\xb0\xca\xbc\"\x12\x06\xf3\x13\x04\xf6\x13\x06\n\
    \x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\xf7\x13\x047\n\x11\n\t\x06\0\
    \x02\x94\x01\x04\xc3\xf3\x04\x12\x04\xf7\x13\x047\n\x0e\n\x06\x06\0\x02\
    \x94\x01\x04\x12\x04\xf8\x13\x04?\n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xf8\x13\x04?\n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\
    \x04\xf9\x13\x04A\n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xf9\x13\x04A\n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\xfa\x13\x04A\
    \n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\xf3\x04\x02\x12\x04\xfa\x13\x04A\n\
    \x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\xfb\x13\x04C\n\x12\n\n\x06\0\
    \x02\x94\x01\x04\xc2\xf3\x04\x03\x12\x04\xfb\x13\x04C\n\x0e\n\x06\x06\0\
    \x02\x94\x01\x04\x12\x04\xfc\x13\x04C\n\x12\n\n\x06\0\x02\x94\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xfc\x13\x04C\n\x0e\n\x06\x06\0\x02\x94\x01\x04\
    \x12\x04\xfd\x13\x04C\n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xfd\x13\x04C\n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\xfe\x13\
    \x04A\n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\xf3\x04\x06\x12\x04\xfe\x13\
    \x04A\n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\xff\x13\x04A\n\x12\n\n\
    \x06\0\x02\x94\x01\x04\xc2\xf3\x04\x07\x12\x04\xff\x13\x04A\n\x0e\n\x06\
    \x06\0\x02\x94\x01\x04\x12\x04\x80\x14\x04F\n\x12\n\n\x06\0\x02\x94\x01\
    \x04\xc2\xf3\x04\x08\x12\x04\x80\x14\x04F\n\x0e\n\x06\x06\0\x02\x94\x01\
    \x04\x12\x04\x81\x14\x04F\n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\xf3\x04\t\
    \x12\x04\x81\x14\x04F\n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\x82\x14\
    \x04D\n\x12\n\n\x06\0\x02\x94\x01\x04\xc2\xf3\x04\n\x12\x04\x82\x14\x04D\
    \n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\x83\x14\x04D\n\x12\n\n\x06\0\
    \x02\x94\x01\x04\xc2\xf3\x04\x0b\x12\x04\x83\x14\x04D\n>\n\x05\x06\0\x02\
    \x95\x01\x12\x06\x87\x14\x02\x8c\x14\x03\x1a-\x20list\x20all\x20the\x20a\
    pp\x20duplications\x20user\x20triggers\n\n\x0e\n\x06\x06\0\x02\x95\x01\
    \x01\x12\x04\x87\x14\x06\x19\n\x0e\n\x06\x06\0\x02\x95\x01\x02\x12\x04\
    \x87\x14\x1b5\n\x0e\n\x06\x06\0\x02\x95\x01\x03\x12\x04\x87\x14@\\\n\x10\
    \n\x06\x06\0\x02\x95\x01\x04\x12\x06\x88\x14\x04\x8a\x14\x06\n\x14\n\n\
    \x06\0\x02\x95\x01\x04\xb0\xca\xbc\"\x12\x06\x88\x14\x04\x8a\x14\x06\n\
    \x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\x8b\x14\x047\n\x11\n\t\x06\0\
    \x02\x95\x01\x04\xc3\xf3\x04\x12\x04\x8b\x14\x047\n1\n\x05\x06\0\x02\x96\
    \x01\x12\x06\x8f\x14\x02\x94\x14\x03\x1a\x20\x20get\x20the\x20app\x20dup\
    lication\x20status\n\n\x0e\n\x06\x06\0\x02\x96\x01\x01\x12\x04\x8f\x14\
    \x06\x17\n\x0e\n\x06\x06\0\x02\x96\x01\x02\x12\x04\x8f\x14\x191\n\x0e\n\
    \x06\x06\0\x02\x96\x01\x03\x12\x04\x8f\x14<X\n\x10\n\x06\x06\0\x02\x96\
    \x01\x04\x12\x06\x90\x14\x04\x92\x14\x06\n\x14\n\n\x06\0\x02\x96\x01\x04\
    \xb0\xca\xbc\"\x12\x06\x90\x14\x04\x92\x14\x06\n\x0e\n\x06\x06\0\x02\x96\
    \x01\x04\x12\x04\x93\x14\x047\n\x11\n\t\x06\0\x02\x96\x01\x04\xc3\xf3\
    \x04\x12\x04\x93\x14\x047\n'\n\x05\x06\0\x02\x97\x01\x12\x06\x97\x14\x02\
    \xad\x14\x03\x1a\x16\x20Add\x20tasks\x20to\x20an\x20app.\n\n\x0e\n\x06\
    \x06\0\x02\x97\x01\x01\x12\x04\x97\x14\x06\x0f\n\x0e\n\x06\x06\0\x02\x97\
    \x01\x02\x12\x04\x97\x14\x11!\n\x0e\n\x06\x06\0\x02\x97\x01\x03\x12\x04\
    \x97\x14,=\n\x10\n\x06\x06\0\x02\x97\x01\x04\x12\x06\x98\x14\x04\x9f\x14\
    \x06\n\x14\n\n\x06\0\x02\x97\x01\x04\xb0\xca\xbc\"\x12\x06\x98\x14\x04\
    \x9f\x14\x06\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xa0\x14\x047\n\
    \x11\n\t\x06\0\x02\x97\x01\x04\xc3\xf3\x04\x12\x04\xa0\x14\x047\n\x0e\n\
    \x06\x06\0\x02\x97\x01\x04\x12\x04\xa1\x14\x04?\n\x12\n\n\x06\0\x02\x97\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xa1\x14\x04?\n\x0e\n\x06\x06\0\x02\x97\
    \x01\x04\x12\x04\xa2\x14\x04@\n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xa2\x14\x04@\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\
    \xa3\x14\x04@\n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xa3\x14\x04@\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xa4\x14\x04A\n\
    \x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\x03\x12\x04\xa4\x14\x04A\n\
    \x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xa5\x14\x04=\n\x12\n\n\x06\0\
    \x02\x97\x01\x04\xc2\xf3\x04\x04\x12\x04\xa5\x14\x04=\n\x0e\n\x06\x06\0\
    \x02\x97\x01\x04\x12\x04\xa6\x14\x04F\n\x12\n\n\x06\0\x02\x97\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\xa6\x14\x04F\n\x0e\n\x06\x06\0\x02\x97\x01\x04\
    \x12\x04\xa7\x14\x04C\n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\xa7\x14\x04C\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xa8\x14\
    \x04D\n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\x07\x12\x04\xa8\x14\
    \x04D\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xa9\x14\x04A\nP\n\n\x06\
    \0\x02\x97\x01\x04\xc2\xf3\x04\x08\x12\x04\xa9\x14\x04A\"<\x20needed\x20\
    for\x20converting\x20workers\x20internal\x20ids\x20to\x20external\x20ids\
    \n\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xab\x14\x04F\n\xcc\x01\n\n\
    \x06\0\x02\x97\x01\x04\xc2\xf3\x04\t\x12\x04\xab\x14\x04F\x1a\x91\x01\
    \x20option\x20(clarifai.auth.util.cl_depending_scopes)\x20=\x20Predict;\
    \x20//\x20optional,\x20needed\x20for\x20add_task_annotations.go\x20when\
    \x20saved\x20search\x20uses\x20visual\x20search\n\"$\x20needed\x20for\
    \x20add_task_annotations.go\n\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\
    \xac\x14\x04F\n8\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\n\x12\x04\xac\x14\
    \x04F\"$\x20needed\x20for\x20add_task_annotations.go\n\n(\n\x05\x06\0\
    \x02\x98\x01\x12\x06\xb0\x14\x02\xba\x14\x03\x1a\x17\x20Task\x20annotati\
    on\x20count\n\n\x0e\n\x06\x06\0\x02\x98\x01\x01\x12\x04\xb0\x14\x06\x1c\
    \n\x0e\n\x06\x06\0\x02\x98\x01\x02\x12\x04\xb0\x14\x1e1\n\x0e\n\x06\x06\
    \0\x02\x98\x01\x03\x12\x04\xb0\x14<S\n\x10\n\x06\x06\0\x02\x98\x01\x04\
    \x12\x06\xb1\x14\x04\xb6\x14\x06\n\x14\n\n\x06\0\x02\x98\x01\x04\xb0\xca\
    \xbc\"\x12\x06\xb1\x14\x04\xb6\x14\x06\n\x0e\n\x06\x06\0\x02\x98\x01\x04\
    \x12\x04\xb7\x14\x047\n\x11\n\t\x06\0\x02\x98\x01\x04\xc3\xf3\x04\x12\
    \x04\xb7\x14\x047\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xb8\x14\x04?\
    \n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\0\x12\x04\xb8\x14\x04?\n\
    \x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xb9\x14\x04@\n\x12\n\n\x06\0\
    \x02\x98\x01\x04\xc2\xf3\x04\x01\x12\x04\xb9\x14\x04@\n#\n\x05\x06\0\x02\
    \x99\x01\x12\x06\xbd\x14\x02\xc7\x14\x03\x1a\x12\x20Task\x20Input\x20cou\
    nt\n\n\x0e\n\x06\x06\0\x02\x99\x01\x01\x12\x04\xbd\x14\x06\x17\n\x0e\n\
    \x06\x06\0\x02\x99\x01\x02\x12\x04\xbd\x14\x19,\n\x0e\n\x06\x06\0\x02\
    \x99\x01\x03\x12\x04\xbd\x147N\n\x10\n\x06\x06\0\x02\x99\x01\x04\x12\x06\
    \xbe\x14\x04\xc3\x14\x06\n\x14\n\n\x06\0\x02\x99\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xbe\x14\x04\xc3\x14\x06\n\x0e\n\x06\x06\0\x02\x99\x01\x04\x12\
    \x04\xc4\x14\x047\n\x11\n\t\x06\0\x02\x99\x01\x04\xc3\xf3\x04\x12\x04\
    \xc4\x14\x047\n\x0e\n\x06\x06\0\x02\x99\x01\x04\x12\x04\xc5\x14\x04?\n\
    \x12\n\n\x06\0\x02\x99\x01\x04\xc2\xf3\x04\0\x12\x04\xc5\x14\x04?\n\x0e\
    \n\x06\x06\0\x02\x99\x01\x04\x12\x04\xc6\x14\x04@\n\x12\n\n\x06\0\x02\
    \x99\x01\x04\xc2\xf3\x04\x01\x12\x04\xc6\x14\x04@\n3\n\x05\x06\0\x02\x9a\
    \x01\x12\x06\xca\x14\x02\xd8\x14\x03\x1a\"\x20Get\x20a\x20specific\x20ta\
    sk\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\x9a\x01\x01\x12\x04\xca\
    \x14\x06\r\n\x0e\n\x06\x06\0\x02\x9a\x01\x02\x12\x04\xca\x14\x0f\x1d\n\
    \x0e\n\x06\x06\0\x02\x9a\x01\x03\x12\x04\xca\x14(:\n\x10\n\x06\x06\0\x02\
    \x9a\x01\x04\x12\x06\xcb\x14\x04\xd0\x14\x06\n\x14\n\n\x06\0\x02\x9a\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xcb\x14\x04\xd0\x14\x06\n\x0e\n\x06\x06\0\x02\
    \x9a\x01\x04\x12\x04\xd1\x14\x047\n\x11\n\t\x06\0\x02\x9a\x01\x04\xc3\
    \xf3\x04\x12\x04\xd1\x14\x047\n\x0e\n\x06\x06\0\x02\x9a\x01\x04\x12\x04\
    \xd2\x14\x04?\n\x12\n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\0\x12\x04\xd2\
    \x14\x04?\n\x0e\n\x06\x06\0\x02\x9a\x01\x04\x12\x04\xd3\x14\x04@\n\x12\n\
    \n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\x01\x12\x04\xd3\x14\x04@\n\x0e\n\
    \x06\x06\0\x02\x9a\x01\x04\x12\x04\xd4\x14\x04F\n\x12\n\n\x06\0\x02\x9a\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\xd4\x14\x04F\n\x0e\n\x06\x06\0\x02\x9a\
    \x01\x04\x12\x04\xd5\x14\x04C\n\x12\n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\
    \x04\x03\x12\x04\xd5\x14\x04C\n\x0e\n\x06\x06\0\x02\x9a\x01\x04\x12\x04\
    \xd6\x14\x04D\n\x12\n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\x04\x12\x04\
    \xd6\x14\x04D\n\x0e\n\x06\x06\0\x02\x9a\x01\x04\x12\x04\xd7\x14\x04A\nP\
    \n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\x05\x12\x04\xd7\x14\x04A\"<\x20ne\
    eded\x20for\x20converting\x20workers\x20internal\x20ids\x20to\x20externa\
    l\x20ids\n\n*\n\x05\x06\0\x02\x9b\x01\x12\x06\xdb\x14\x02\xe9\x14\x03\
    \x1a\x19\x20List\x20tasks\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\
    \x9b\x01\x01\x12\x04\xdb\x14\x06\x0f\n\x0e\n\x06\x06\0\x02\x9b\x01\x02\
    \x12\x04\xdb\x14\x11!\n\x0e\n\x06\x06\0\x02\x9b\x01\x03\x12\x04\xdb\x14,\
    =\n\x10\n\x06\x06\0\x02\x9b\x01\x04\x12\x06\xdc\x14\x04\xe1\x14\x06\n\
    \x14\n\n\x06\0\x02\x9b\x01\x04\xb0\xca\xbc\"\x12\x06\xdc\x14\x04\xe1\x14\
    \x06\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\xe2\x14\x047\n\x11\n\t\
    \x06\0\x02\x9b\x01\x04\xc3\xf3\x04\x12\x04\xe2\x14\x047\n\x0e\n\x06\x06\
    \0\x02\x9b\x01\x04\x12\x04\xe3\x14\x04?\n\x12\n\n\x06\0\x02\x9b\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xe3\x14\x04?\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\
    \x12\x04\xe4\x14\x04@\n\x12\n\n\x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xe4\x14\x04@\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\xe5\x14\
    \x04F\n\x12\n\n\x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x02\x12\x04\xe5\x14\
    \x04F\n\x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\xe6\x14\x04C\n\x12\n\n\
    \x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x03\x12\x04\xe6\x14\x04C\n\x0e\n\x06\
    \x06\0\x02\x9b\x01\x04\x12\x04\xe7\x14\x04D\n\x12\n\n\x06\0\x02\x9b\x01\
    \x04\xc2\xf3\x04\x04\x12\x04\xe7\x14\x04D\n\x0e\n\x06\x06\0\x02\x9b\x01\
    \x04\x12\x04\xe8\x14\x04A\nP\n\n\x06\0\x02\x9b\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xe8\x14\x04A\"<\x20needed\x20for\x20converting\x20workers\x20in\
    ternal\x20ids\x20to\x20external\x20ids\n\n+\n\x05\x06\0\x02\x9c\x01\x12\
    \x06\xec\x14\x02\x81\x15\x03\x1a\x1a\x20Patch\x20one\x20or\x20more\x20ta\
    sks.\n\n\x0e\n\x06\x06\0\x02\x9c\x01\x01\x12\x04\xec\x14\x06\x10\n\x0e\n\
    \x06\x06\0\x02\x9c\x01\x02\x12\x04\xec\x14\x12#\n\x0e\n\x06\x06\0\x02\
    \x9c\x01\x03\x12\x04\xec\x14.?\n\x10\n\x06\x06\0\x02\x9c\x01\x04\x12\x06\
    \xed\x14\x04\xf4\x14\x06\n\x14\n\n\x06\0\x02\x9c\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xed\x14\x04\xf4\x14\x06\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\
    \x04\xf5\x14\x047\n\x11\n\t\x06\0\x02\x9c\x01\x04\xc3\xf3\x04\x12\x04\
    \xf5\x14\x047\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\xf6\x14\x04?\n\
    \x12\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\0\x12\x04\xf6\x14\x04?\n\x0e\
    \n\x06\x06\0\x02\x9c\x01\x04\x12\x04\xf7\x14\x04@\n\x12\n\n\x06\0\x02\
    \x9c\x01\x04\xc2\xf3\x04\x01\x12\x04\xf7\x14\x04@\n\x0e\n\x06\x06\0\x02\
    \x9c\x01\x04\x12\x04\xf8\x14\x04@\n\x12\n\n\x06\0\x02\x9c\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xf8\x14\x04@\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\
    \x04\xf9\x14\x04A\n\x12\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xf9\x14\x04A\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\xfa\x14\x04F\
    \n\x12\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\x04\x12\x04\xfa\x14\x04F\n\
    \x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\xfb\x14\x04C\n\x12\n\n\x06\0\
    \x02\x9c\x01\x04\xc2\xf3\x04\x05\x12\x04\xfb\x14\x04C\n\x0e\n\x06\x06\0\
    \x02\x9c\x01\x04\x12\x04\xfc\x14\x04D\n\x12\n\n\x06\0\x02\x9c\x01\x04\
    \xc2\xf3\x04\x06\x12\x04\xfc\x14\x04D\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\
    \x12\x04\xfd\x14\x04A\nP\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\x07\x12\
    \x04\xfd\x14\x04A\"<\x20needed\x20for\x20converting\x20workers\x20intern\
    al\x20ids\x20to\x20external\x20ids\n\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\
    \x12\x04\xff\x14\x04F\n\xcc\x01\n\n\x06\0\x02\x9c\x01\x04\xc2\xf3\x04\
    \x08\x12\x04\xff\x14\x04F\x1a\x91\x01\x20option\x20(clarifai.auth.util.c\
    l_depending_scopes)\x20=\x20Predict;\x20//\x20optional,\x20needed\x20for\
    \x20add_task_annotations.go\x20when\x20saved\x20search\x20uses\x20visual\
    \x20search\n\"$\x20needed\x20for\x20add_task_annotations.go\n\n\x0e\n\
    \x06\x06\0\x02\x9c\x01\x04\x12\x04\x80\x15\x04F\n8\n\n\x06\0\x02\x9c\x01\
    \x04\xc2\xf3\x04\t\x12\x04\x80\x15\x04F\"$\x20needed\x20for\x20add_task_\
    annotations.go\n\n8\n\x05\x06\0\x02\x9d\x01\x12\x06\x84\x15\x02\x92\x15\
    \x03\x1a'\x20Delete\x20multiple\x20tasks\x20in\x20one\x20request.\n\n\
    \x0e\n\x06\x06\0\x02\x9d\x01\x01\x12\x04\x84\x15\x06\x11\n\x0e\n\x06\x06\
    \0\x02\x9d\x01\x02\x12\x04\x84\x15\x13%\n\x0e\n\x06\x06\0\x02\x9d\x01\
    \x03\x12\x04\x84\x150P\n\x10\n\x06\x06\0\x02\x9d\x01\x04\x12\x06\x85\x15\
    \x04\x8c\x15\x06\n\x14\n\n\x06\0\x02\x9d\x01\x04\xb0\xca\xbc\"\x12\x06\
    \x85\x15\x04\x8c\x15\x06\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x8d\
    \x15\x047\n\x11\n\t\x06\0\x02\x9d\x01\x04\xc3\xf3\x04\x12\x04\x8d\x15\
    \x047\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x8e\x15\x04?\n\x12\n\n\
    \x06\0\x02\x9d\x01\x04\xc2\xf3\x04\0\x12\x04\x8e\x15\x04?\n\x0e\n\x06\
    \x06\0\x02\x9d\x01\x04\x12\x04\x8f\x15\x04@\n\x12\n\n\x06\0\x02\x9d\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x8f\x15\x04@\n\x0e\n\x06\x06\0\x02\x9d\x01\
    \x04\x12\x04\x90\x15\x04@\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\x90\x15\x04@\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\x91\
    \x15\x04C\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x03\x12\x04\x91\
    \x15\x04C\n\x81\x01\n\x05\x06\0\x02\x9e\x01\x12\x06\x9b\x15\x02\xb0\x15\
    \x03\x1a\x13\x20Add\x20Label\x20orders.\n2[/////////////////////////////\
    /////////\n\x20Label\x20Order\n//////////////////////////////////////\n\
    \n\x0e\n\x06\x06\0\x02\x9e\x01\x01\x12\x04\x9b\x15\x06\x15\n\x0e\n\x06\
    \x06\0\x02\x9e\x01\x02\x12\x04\x9b\x15\x17-\n\x0e\n\x06\x06\0\x02\x9e\
    \x01\x03\x12\x04\x9b\x158O\n\x10\n\x06\x06\0\x02\x9e\x01\x04\x12\x06\x9c\
    \x15\x04\xa3\x15\x06\n\x14\n\n\x06\0\x02\x9e\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x9c\x15\x04\xa3\x15\x06\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\
    \xa5\x15\x047\n\x11\n\t\x06\0\x02\x9e\x01\x04\xc3\xf3\x04\x12\x04\xa5\
    \x15\x047\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xa6\x15\x04?\n\x12\n\
    \n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\0\x12\x04\xa6\x15\x04?\n\x0e\n\x06\
    \x06\0\x02\x9e\x01\x04\x12\x04\xa7\x15\x04F\n\x12\n\n\x06\0\x02\x9e\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xa7\x15\x04F\n\x0e\n\x06\x06\0\x02\x9e\x01\
    \x04\x12\x04\xa8\x15\x04F\n\x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xa8\x15\x04F\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xa9\
    \x15\x04@\n\x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\x03\x12\x04\xa9\
    \x15\x04@\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xaa\x15\x04@\n\x12\n\
    \n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\x04\x12\x04\xaa\x15\x04@\n\x0e\n\
    \x06\x06\0\x02\x9e\x01\x04\x12\x04\xab\x15\x04A\n\x12\n\n\x06\0\x02\x9e\
    \x01\x04\xc2\xf3\x04\x05\x12\x04\xab\x15\x04A\n\x0e\n\x06\x06\0\x02\x9e\
    \x01\x04\x12\x04\xac\x15\x04F\n\x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\
    \x04\x06\x12\x04\xac\x15\x04F\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\
    \xad\x15\x04C\n\x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\x07\x12\x04\
    \xad\x15\x04C\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xae\x15\x04D\n\
    \x12\n\n\x06\0\x02\x9e\x01\x04\xc2\xf3\x04\x08\x12\x04\xae\x15\x04D\n\
    \x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xaf\x15\x04A\nP\n\n\x06\0\x02\
    \x9e\x01\x04\xc2\xf3\x04\t\x12\x04\xaf\x15\x04A\"<\x20needed\x20for\x20c\
    onverting\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n%\n\
    \x05\x06\0\x02\x9f\x01\x12\x06\xb3\x15\x02\xc0\x15\x03\x1a\x14\x20Get\
    \x20a\x20label\x20order.\n\n\x0e\n\x06\x06\0\x02\x9f\x01\x01\x12\x04\xb3\
    \x15\x06\x13\n\x0e\n\x06\x06\0\x02\x9f\x01\x02\x12\x04\xb3\x15\x15)\n\
    \x0e\n\x06\x06\0\x02\x9f\x01\x03\x12\x04\xb3\x154L\n\x10\n\x06\x06\0\x02\
    \x9f\x01\x04\x12\x06\xb4\x15\x04\xb9\x15\x06\n\x14\n\n\x06\0\x02\x9f\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xb4\x15\x04\xb9\x15\x06\n\x0e\n\x06\x06\0\x02\
    \x9f\x01\x04\x12\x04\xbb\x15\x047\n\x11\n\t\x06\0\x02\x9f\x01\x04\xc3\
    \xf3\x04\x12\x04\xbb\x15\x047\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\
    \xbc\x15\x04?\n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\0\x12\x04\xbc\
    \x15\x04?\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xbd\x15\x04F\n\x12\n\
    \n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\x01\x12\x04\xbd\x15\x04F\n\x0e\n\
    \x06\x06\0\x02\x9f\x01\x04\x12\x04\xbe\x15\x04C\n\x12\n\n\x06\0\x02\x9f\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\xbe\x15\x04C\n\x0e\n\x06\x06\0\x02\x9f\
    \x01\x04\x12\x04\xbf\x15\x04@\n5\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\x04\
    \x03\x12\x04\xbf\x15\x04@\"!\x20needed\x20because\x20task\x20is\x20embed\
    ded\n\n%\n\x05\x06\0\x02\xa0\x01\x12\x06\xc3\x15\x02\xd0\x15\x03\x1a\x14\
    \x20List\x20label\x20orders.\n\n\x0e\n\x06\x06\0\x02\xa0\x01\x01\x12\x04\
    \xc3\x15\x06\x15\n\x0e\n\x06\x06\0\x02\xa0\x01\x02\x12\x04\xc3\x15\x17-\
    \n\x0e\n\x06\x06\0\x02\xa0\x01\x03\x12\x04\xc3\x158O\n\x10\n\x06\x06\0\
    \x02\xa0\x01\x04\x12\x06\xc4\x15\x04\xc9\x15\x06\n\x14\n\n\x06\0\x02\xa0\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xc4\x15\x04\xc9\x15\x06\n\x0e\n\x06\x06\0\
    \x02\xa0\x01\x04\x12\x04\xcb\x15\x047\n\x11\n\t\x06\0\x02\xa0\x01\x04\
    \xc3\xf3\x04\x12\x04\xcb\x15\x047\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\
    \x04\xcc\x15\x04?\n\x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xcc\x15\x04?\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xcd\x15\x04F\n\
    \x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\x01\x12\x04\xcd\x15\x04F\n\
    \x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xce\x15\x04C\n\x12\n\n\x06\0\
    \x02\xa0\x01\x04\xc2\xf3\x04\x02\x12\x04\xce\x15\x04C\n\x0e\n\x06\x06\0\
    \x02\xa0\x01\x04\x12\x04\xcf\x15\x04@\n5\n\n\x06\0\x02\xa0\x01\x04\xc2\
    \xf3\x04\x03\x12\x04\xcf\x15\x04@\"!\x20needed\x20because\x20task\x20is\
    \x20embedded\n\n2\n\x05\x06\0\x02\xa1\x01\x12\x06\xd3\x15\x02\xe5\x15\
    \x03\x1a!\x20Patch\x20one\x20or\x20more\x20label\x20orders.\n\n\x0e\n\
    \x06\x06\0\x02\xa1\x01\x01\x12\x04\xd3\x15\x06\x16\n\x0e\n\x06\x06\0\x02\
    \xa1\x01\x02\x12\x04\xd3\x15\x18/\n\x0e\n\x06\x06\0\x02\xa1\x01\x03\x12\
    \x04\xd3\x15:Q\n\x10\n\x06\x06\0\x02\xa1\x01\x04\x12\x06\xd4\x15\x04\xdb\
    \x15\x06\n\x14\n\n\x06\0\x02\xa1\x01\x04\xb0\xca\xbc\"\x12\x06\xd4\x15\
    \x04\xdb\x15\x06\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xdd\x15\x047\
    \n\x11\n\t\x06\0\x02\xa1\x01\x04\xc3\xf3\x04\x12\x04\xdd\x15\x047\n\x0e\
    \n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xde\x15\x04?\n\x12\n\n\x06\0\x02\
    \xa1\x01\x04\xc2\xf3\x04\0\x12\x04\xde\x15\x04?\n\x0e\n\x06\x06\0\x02\
    \xa1\x01\x04\x12\x04\xdf\x15\x04F\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xdf\x15\x04F\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\
    \x04\xe0\x15\x04F\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xe0\x15\x04F\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xe1\x15\x04C\
    \n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x03\x12\x04\xe1\x15\x04C\n\
    \x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xe2\x15\x04@\n\x12\n\n\x06\0\
    \x02\xa1\x01\x04\xc2\xf3\x04\x04\x12\x04\xe2\x15\x04@\n\x0e\n\x06\x06\0\
    \x02\xa1\x01\x04\x12\x04\xe3\x15\x04@\n\x12\n\n\x06\0\x02\xa1\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\xe3\x15\x04@\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\
    \x12\x04\xe4\x15\x04C\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\xe4\x15\x04C\n_\n\x05\x06\0\x02\xa2\x01\x12\x06\xe9\x15\x02\xfa\
    \x15\x03\x1aN\x20Delete\x20multiple\x20label\x20orders\x20in\x20one\x20r\
    equest.\n\x20this\x20do\x20not\x20change\x20task\x20status\n\n\x0e\n\x06\
    \x06\0\x02\xa2\x01\x01\x12\x04\xe9\x15\x06\x17\n\x0e\n\x06\x06\0\x02\xa2\
    \x01\x02\x12\x04\xe9\x15\x191\n\x0e\n\x06\x06\0\x02\xa2\x01\x03\x12\x04\
    \xe9\x15<\\\n\x10\n\x06\x06\0\x02\xa2\x01\x04\x12\x06\xea\x15\x04\xf1\
    \x15\x06\n\x14\n\n\x06\0\x02\xa2\x01\x04\xb0\xca\xbc\"\x12\x06\xea\x15\
    \x04\xf1\x15\x06\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\xf3\x15\x047\
    \n\x11\n\t\x06\0\x02\xa2\x01\x04\xc3\xf3\x04\x12\x04\xf3\x15\x047\n\x0e\
    \n\x06\x06\0\x02\xa2\x01\x04\x12\x04\xf4\x15\x04?\n\x12\n\n\x06\0\x02\
    \xa2\x01\x04\xc2\xf3\x04\0\x12\x04\xf4\x15\x04?\n\x0e\n\x06\x06\0\x02\
    \xa2\x01\x04\x12\x04\xf5\x15\x04I\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xf5\x15\x04I\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\
    \x04\xf6\x15\x04F\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xf6\x15\x04F\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\xf7\x15\x04F\
    \n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x03\x12\x04\xf7\x15\x04F\n\
    \x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\xf8\x15\x04@\n\x12\n\n\x06\0\
    \x02\xa2\x01\x04\xc2\xf3\x04\x04\x12\x04\xf8\x15\x04@\n\x0e\n\x06\x06\0\
    \x02\xa2\x01\x04\x12\x04\xf9\x15\x04@\n\x12\n\n\x06\0\x02\xa2\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\xf9\x15\x04@\n\xf3\x02\n\x05\x06\0\x02\xa3\x01\
    \x12\x06\x82\x16\x02\x97\x16\x03\x1a\xe1\x02\x20Add\x20a\x20list\x20of\
    \x20Collectors\x20to\x20an\x20app.\n\x20In\x20the\x20handler\x20of\x20th\
    is\x20endpoint\x20we\x20also\x20check\x20for\x20all\x20the\x20scopes\x20\
    of\x20the\x20\x20POST\x20/inputs\n\x20endpoint.\n\x20Those\x20current\
    \x20scopes\x20are\x20listed\x20here\x20as\x20a\x20hard\x20requirement.\n\
    \x20They\x20are\x20needed\x20when\x20adding\x20the\x20collectors\x20just\
    \x20so\x20we\x20now\x20that\x20you\x20have\x20permission\x20with\n\x20th\
    at\x20key\x20at\x20least\x20to\x20do\x20the\x20writing\x20to\x20this\x20\
    app\x20with\x20POST\x20/inputs.\n\n\x0e\n\x06\x06\0\x02\xa3\x01\x01\x12\
    \x04\x82\x16\x06\x14\n\x0e\n\x06\x06\0\x02\xa3\x01\x02\x12\x04\x82\x16\
    \x16+\n\x0e\n\x06\x06\0\x02\xa3\x01\x03\x12\x04\x82\x166L\n\x10\n\x06\
    \x06\0\x02\xa3\x01\x04\x12\x06\x83\x16\x04\x8a\x16\x06\n\x14\n\n\x06\0\
    \x02\xa3\x01\x04\xb0\xca\xbc\"\x12\x06\x83\x16\x04\x8a\x16\x06\n\x0e\n\
    \x06\x06\0\x02\xa3\x01\x04\x12\x04\x8b\x16\x047\n\x11\n\t\x06\0\x02\xa3\
    \x01\x04\xc3\xf3\x04\x12\x04\x8b\x16\x047\n\x0e\n\x06\x06\0\x02\xa3\x01\
    \x04\x12\x04\x8c\x16\x04?\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x8c\x16\x04?\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x8d\x16\
    \x04A\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x01\x12\x04\x8d\x16\
    \x04A\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x8e\x16\x04F\n\x12\n\n\
    \x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x02\x12\x04\x8e\x16\x04F\n\x0e\n\x06\
    \x06\0\x02\xa3\x01\x04\x12\x04\x8f\x16\x04F\n\x12\n\n\x06\0\x02\xa3\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\x8f\x16\x04F\n\x0e\n\x06\x06\0\x02\xa3\x01\
    \x04\x12\x04\x90\x16\x04E\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\
    \x04\x12\x04\x90\x16\x04E\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x91\
    \x16\x04C\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x05\x12\x04\x91\
    \x16\x04C\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x92\x16\x04A\n\x12\n\
    \n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x06\x12\x04\x92\x16\x04A\n\x0e\n\
    \x06\x06\0\x02\xa3\x01\x04\x12\x04\x93\x16\x04A\n\x12\n\n\x06\0\x02\xa3\
    \x01\x04\xc2\xf3\x04\x07\x12\x04\x93\x16\x04A\n\x0e\n\x06\x06\0\x02\xa3\
    \x01\x04\x12\x04\x94\x16\x04A\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\
    \x04\x08\x12\x04\x94\x16\x04A\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\
    \x95\x16\x04>\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\t\x12\x04\x95\
    \x16\x04>\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x96\x16\x04D\n\x12\n\
    \n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\n\x12\x04\x96\x16\x04D\n8\n\x05\x06\
    \0\x02\xa4\x01\x12\x06\x9a\x16\x02\xa4\x16\x03\x1a'\x20Get\x20a\x20speci\
    fic\x20collector\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xa4\x01\
    \x01\x12\x04\x9a\x16\x06\x12\n\x0e\n\x06\x06\0\x02\xa4\x01\x02\x12\x04\
    \x9a\x16\x14'\n\x0e\n\x06\x06\0\x02\xa4\x01\x03\x12\x04\x9a\x162I\n\x10\
    \n\x06\x06\0\x02\xa4\x01\x04\x12\x06\x9b\x16\x04\xa0\x16\x06\n\x14\n\n\
    \x06\0\x02\xa4\x01\x04\xb0\xca\xbc\"\x12\x06\x9b\x16\x04\xa0\x16\x06\n\
    \x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xa1\x16\x047\n\x11\n\t\x06\0\
    \x02\xa4\x01\x04\xc3\xf3\x04\x12\x04\xa1\x16\x047\n\x0e\n\x06\x06\0\x02\
    \xa4\x01\x04\x12\x04\xa2\x16\x04?\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xa2\x16\x04?\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\
    \x04\xa3\x16\x04E\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xa3\x16\x04E\n+\n\x05\x06\0\x02\xa5\x01\x12\x06\xa7\x16\x02\xb1\x16\
    \x03\x1a\x1a\x20List\x20all\x20the\x20collectors.\n\n\x0e\n\x06\x06\0\
    \x02\xa5\x01\x01\x12\x04\xa7\x16\x06\x14\n\x0e\n\x06\x06\0\x02\xa5\x01\
    \x02\x12\x04\xa7\x16\x16+\n\x0e\n\x06\x06\0\x02\xa5\x01\x03\x12\x04\xa7\
    \x166L\n\x10\n\x06\x06\0\x02\xa5\x01\x04\x12\x06\xa8\x16\x04\xad\x16\x06\
    \n\x14\n\n\x06\0\x02\xa5\x01\x04\xb0\xca\xbc\"\x12\x06\xa8\x16\x04\xad\
    \x16\x06\n\x0e\n\x06\x06\0\x02\xa5\x01\x04\x12\x04\xae\x16\x047\n\x11\n\
    \t\x06\0\x02\xa5\x01\x04\xc3\xf3\x04\x12\x04\xae\x16\x047\n\x0e\n\x06\
    \x06\0\x02\xa5\x01\x04\x12\x04\xaf\x16\x04?\n\x12\n\n\x06\0\x02\xa5\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xaf\x16\x04?\n\x0e\n\x06\x06\0\x02\xa5\x01\
    \x04\x12\x04\xb0\x16\x04E\n\x12\n\n\x06\0\x02\xa5\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xb0\x16\x04E\n0\n\x05\x06\0\x02\xa6\x01\x12\x06\xb4\x16\x02\
    \xc1\x16\x03\x1a\x1f\x20Patch\x20one\x20or\x20more\x20collectors.\n\n\
    \x0e\n\x06\x06\0\x02\xa6\x01\x01\x12\x04\xb4\x16\x06\x15\n\x0e\n\x06\x06\
    \0\x02\xa6\x01\x02\x12\x04\xb4\x16\x17-\n\x0e\n\x06\x06\0\x02\xa6\x01\
    \x03\x12\x04\xb4\x168N\n\x10\n\x06\x06\0\x02\xa6\x01\x04\x12\x06\xb5\x16\
    \x04\xbc\x16\x06\n\x14\n\n\x06\0\x02\xa6\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xb5\x16\x04\xbc\x16\x06\n\x0e\n\x06\x06\0\x02\xa6\x01\x04\x12\x04\xbd\
    \x16\x047\n\x11\n\t\x06\0\x02\xa6\x01\x04\xc3\xf3\x04\x12\x04\xbd\x16\
    \x047\n\x0e\n\x06\x06\0\x02\xa6\x01\x04\x12\x04\xbe\x16\x04?\n\x12\n\n\
    \x06\0\x02\xa6\x01\x04\xc2\xf3\x04\0\x12\x04\xbe\x16\x04?\n\x0e\n\x06\
    \x06\0\x02\xa6\x01\x04\x12\x04\xbf\x16\x04E\n\x12\n\n\x06\0\x02\xa6\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xbf\x16\x04E\n\x0e\n\x06\x06\0\x02\xa6\x01\
    \x04\x12\x04\xc0\x16\x04E\n\x12\n\n\x06\0\x02\xa6\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xc0\x16\x04E\n\x90\x01\n\x05\x06\0\x02\xa7\x01\x12\x06\xc7\
    \x16\x02\xd5\x16\x03\x1a\x7f\x20Delete\x20multiple\x20collectors\x20in\
    \x20one\x20request.\n\x20This\x20call\x20is\x20asynchronous.\x20Use\x20D\
    eleteCollector\x20if\x20you\x20want\x20a\x20synchronous\x20version.\n\n\
    \x0e\n\x06\x06\0\x02\xa7\x01\x01\x12\x04\xc7\x16\x06\x16\n\x0e\n\x06\x06\
    \0\x02\xa7\x01\x02\x12\x04\xc7\x16\x18/\n\x0e\n\x06\x06\0\x02\xa7\x01\
    \x03\x12\x04\xc7\x16:Z\n\x10\n\x06\x06\0\x02\xa7\x01\x04\x12\x06\xc8\x16\
    \x04\xcf\x16\x06\n\x14\n\n\x06\0\x02\xa7\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xc8\x16\x04\xcf\x16\x06\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xd0\
    \x16\x047\n\x11\n\t\x06\0\x02\xa7\x01\x04\xc3\xf3\x04\x12\x04\xd0\x16\
    \x047\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xd1\x16\x04?\n\x12\n\n\
    \x06\0\x02\xa7\x01\x04\xc2\xf3\x04\0\x12\x04\xd1\x16\x04?\n\x0e\n\x06\
    \x06\0\x02\xa7\x01\x04\x12\x04\xd2\x16\x04E\n\x12\n\n\x06\0\x02\xa7\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xd2\x16\x04E\n\x0e\n\x06\x06\0\x02\xa7\x01\
    \x04\x12\x04\xd3\x16\x04H\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xd3\x16\x04H\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xd4\
    \x16\x04E\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\x03\x12\x04\xd4\
    \x16\x04E\n!\n\x05\x06\0\x02\xa8\x01\x12\x06\xd8\x16\x02\xe2\x16\x03\x1a\
    \x10\x20PostStatValues\n\n\x0e\n\x06\x06\0\x02\xa8\x01\x01\x12\x04\xd8\
    \x16\x06\x14\n\x0e\n\x06\x06\0\x02\xa8\x01\x02\x12\x04\xd8\x16\x16+\n\
    \x0e\n\x06\x06\0\x02\xa8\x01\x03\x12\x04\xd8\x166L\n\x10\n\x06\x06\0\x02\
    \xa8\x01\x04\x12\x06\xd9\x16\x04\xe0\x16\x06\n\x14\n\n\x06\0\x02\xa8\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xd9\x16\x04\xe0\x16\x06\n\x0e\n\x06\x06\0\x02\
    \xa8\x01\x04\x12\x04\xe1\x16\x047\n\x11\n\t\x06\0\x02\xa8\x01\x04\xc3\
    \xf3\x04\x12\x04\xe1\x16\x047\n*\n\x05\x06\0\x02\xa9\x01\x12\x06\xe5\x16\
    \x02\xf0\x16\x03\x1a\x19\x20PostStatValuesAggregate\n\n\x0e\n\x06\x06\0\
    \x02\xa9\x01\x01\x12\x04\xe5\x16\x06\x1d\n\x0e\n\x06\x06\0\x02\xa9\x01\
    \x02\x12\x04\xe5\x16\x1f=\n\x0e\n\x06\x06\0\x02\xa9\x01\x03\x12\x04\xe5\
    \x16Hg\n\x10\n\x06\x06\0\x02\xa9\x01\x04\x12\x06\xe6\x16\x04\xed\x16\x06\
    \n\x14\n\n\x06\0\x02\xa9\x01\x04\xb0\xca\xbc\"\x12\x06\xe6\x16\x04\xed\
    \x16\x06\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\xee\x16\x047\n\x11\n\
    \t\x06\0\x02\xa9\x01\x04\xc3\xf3\x04\x12\x04\xee\x16\x047\n\x0e\n\x06\
    \x06\0\x02\xa9\x01\x04\x12\x04\xef\x16\x04?\n\x12\n\n\x06\0\x02\xa9\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xef\x16\x04?\n=\n\x05\x06\0\x02\xaa\x01\x12\
    \x06\xfa\x16\x02\x80\x17\x03\x1a,\x20Increase\x20the\x20view\x20metric\
    \x20for\x20a\x20detail\x20view\n\n\x0e\n\x06\x06\0\x02\xaa\x01\x01\x12\
    \x04\xfa\x16\x06\x1d\n\x0e\n\x06\x06\0\x02\xaa\x01\x02\x12\x04\xfa\x16\
    \x1f=\n\x0e\n\x06\x06\0\x02\xaa\x01\x03\x12\x04\xfa\x16Hh\n\x10\n\x06\
    \x06\0\x02\xaa\x01\x04\x12\x06\xfb\x16\x04\xfe\x16\x06\n\x14\n\n\x06\0\
    \x02\xaa\x01\x04\xb0\xca\xbc\"\x12\x06\xfb\x16\x04\xfe\x16\x06\n\x0e\n\
    \x06\x06\0\x02\xaa\x01\x04\x12\x04\xff\x16\x047\n\x11\n\t\x06\0\x02\xaa\
    \x01\x04\xc3\xf3\x04\x12\x04\xff\x16\x047\n:\n\x05\x06\0\x02\xab\x01\x12\
    \x06\x83\x17\x02\x8b\x17\x03\x1a)\x20List\x20the\x20view\x20metrics\x20f\
    or\x20a\x20detail\x20view\n\n\x0e\n\x06\x06\0\x02\xab\x01\x01\x12\x04\
    \x83\x17\x06\x1e\n\x0e\n\x06\x06\0\x02\xab\x01\x02\x12\x04\x83\x17\x20?\
    \n\x0e\n\x06\x06\0\x02\xab\x01\x03\x12\x04\x83\x17Jj\n\x10\n\x06\x06\0\
    \x02\xab\x01\x04\x12\x06\x84\x17\x04\x89\x17\x06\n\x14\n\n\x06\0\x02\xab\
    \x01\x04\xb0\xca\xbc\"\x12\x06\x84\x17\x04\x89\x17\x06\n\x0e\n\x06\x06\0\
    \x02\xab\x01\x04\x12\x04\x8a\x17\x047\n\x11\n\t\x06\0\x02\xab\x01\x04\
    \xc3\xf3\x04\x12\x04\x8a\x17\x047\n5\n\x05\x06\0\x02\xac\x01\x12\x06\x96\
    \x17\x02\x9d\x17\x03\x1a$\x20Get\x20a\x20specific\x20module\x20from\x20a\
    n\x20app.\n\n\x0e\n\x06\x06\0\x02\xac\x01\x01\x12\x04\x96\x17\x06\x0f\n\
    \x0e\n\x06\x06\0\x02\xac\x01\x02\x12\x04\x96\x17\x11!\n\x0e\n\x06\x06\0\
    \x02\xac\x01\x03\x12\x04\x96\x17,@\n\x10\n\x06\x06\0\x02\xac\x01\x04\x12\
    \x06\x97\x17\x04\x99\x17\x06\n\x14\n\n\x06\0\x02\xac\x01\x04\xb0\xca\xbc\
    \"\x12\x06\x97\x17\x04\x99\x17\x06\n\x0e\n\x06\x06\0\x02\xac\x01\x04\x12\
    \x04\x9a\x17\x047\n\x11\n\t\x06\0\x02\xac\x01\x04\xc3\xf3\x04\x12\x04\
    \x9a\x17\x047\n\x0e\n\x06\x06\0\x02\xac\x01\x04\x12\x04\x9b\x17\x04?\n\
    \x12\n\n\x06\0\x02\xac\x01\x04\xc2\xf3\x04\0\x12\x04\x9b\x17\x04?\n\x0e\
    \n\x06\x06\0\x02\xac\x01\x04\x12\x04\x9c\x17\x04B\n\x12\n\n\x06\0\x02\
    \xac\x01\x04\xc2\xf3\x04\x01\x12\x04\x9c\x17\x04B\nH\n\x05\x06\0\x02\xad\
    \x01\x12\x06\xa0\x17\x02\xad\x17\x03\x1a7\x20List\x20all\x20the\x20modul\
    es\x20in\x20community,\x20by\x20user\x20or\x20by\x20app.\n\n\x0e\n\x06\
    \x06\0\x02\xad\x01\x01\x12\x04\xa0\x17\x06\x11\n\x0e\n\x06\x06\0\x02\xad\
    \x01\x02\x12\x04\xa0\x17\x13%\n\x0e\n\x06\x06\0\x02\xad\x01\x03\x12\x04\
    \xa0\x170C\n\x10\n\x06\x06\0\x02\xad\x01\x04\x12\x06\xa1\x17\x04\xa9\x17\
    \x06\n\x14\n\n\x06\0\x02\xad\x01\x04\xb0\xca\xbc\"\x12\x06\xa1\x17\x04\
    \xa9\x17\x06\n\x0e\n\x06\x06\0\x02\xad\x01\x04\x12\x04\xaa\x17\x047\n\
    \x11\n\t\x06\0\x02\xad\x01\x04\xc3\xf3\x04\x12\x04\xaa\x17\x047\n\x0e\n\
    \x06\x06\0\x02\xad\x01\x04\x12\x04\xab\x17\x04?\n\x12\n\n\x06\0\x02\xad\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xab\x17\x04?\n\x0e\n\x06\x06\0\x02\xad\
    \x01\x04\x12\x04\xac\x17\x04B\n\x12\n\n\x06\0\x02\xad\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xac\x17\x04B\n+\n\x05\x06\0\x02\xae\x01\x12\x06\xb0\x17\
    \x02\xb9\x17\x03\x1a\x1a\x20Add\x20a\x20modules\x20to\x20an\x20app.\n\n\
    \x0e\n\x06\x06\0\x02\xae\x01\x01\x12\x04\xb0\x17\x06\x11\n\x0e\n\x06\x06\
    \0\x02\xae\x01\x02\x12\x04\xb0\x17\x13%\n\x0e\n\x06\x06\0\x02\xae\x01\
    \x03\x12\x04\xb0\x170C\n\x10\n\x06\x06\0\x02\xae\x01\x04\x12\x06\xb1\x17\
    \x04\xb4\x17\x06\n\x14\n\n\x06\0\x02\xae\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xb1\x17\x04\xb4\x17\x06\n\x0e\n\x06\x06\0\x02\xae\x01\x04\x12\x04\xb5\
    \x17\x047\n\x11\n\t\x06\0\x02\xae\x01\x04\xc3\xf3\x04\x12\x04\xb5\x17\
    \x047\n\x0e\n\x06\x06\0\x02\xae\x01\x04\x12\x04\xb6\x17\x04?\n\x12\n\n\
    \x06\0\x02\xae\x01\x04\xc2\xf3\x04\0\x12\x04\xb6\x17\x04?\n\x0e\n\x06\
    \x06\0\x02\xae\x01\x04\x12\x04\xb7\x17\x04B\n\x12\n\n\x06\0\x02\xae\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xb7\x17\x04B\n\x0e\n\x06\x06\0\x02\xae\x01\
    \x04\x12\x04\xb8\x17\x04B\n\x12\n\n\x06\0\x02\xae\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xb8\x17\x04B\n-\n\x05\x06\0\x02\xaf\x01\x12\x06\xbc\x17\x02\
    \xc5\x17\x03\x1a\x1c\x20Patch\x20one\x20or\x20more\x20modules.\n\n\x0e\n\
    \x06\x06\0\x02\xaf\x01\x01\x12\x04\xbc\x17\x06\x12\n\x0e\n\x06\x06\0\x02\
    \xaf\x01\x02\x12\x04\xbc\x17\x14'\n\x0e\n\x06\x06\0\x02\xaf\x01\x03\x12\
    \x04\xbc\x172E\n\x10\n\x06\x06\0\x02\xaf\x01\x04\x12\x06\xbd\x17\x04\xc0\
    \x17\x06\n\x14\n\n\x06\0\x02\xaf\x01\x04\xb0\xca\xbc\"\x12\x06\xbd\x17\
    \x04\xc0\x17\x06\n\x0e\n\x06\x06\0\x02\xaf\x01\x04\x12\x04\xc1\x17\x047\
    \n\x11\n\t\x06\0\x02\xaf\x01\x04\xc3\xf3\x04\x12\x04\xc1\x17\x047\n\x0e\
    \n\x06\x06\0\x02\xaf\x01\x04\x12\x04\xc2\x17\x04?\n\x12\n\n\x06\0\x02\
    \xaf\x01\x04\xc2\xf3\x04\0\x12\x04\xc2\x17\x04?\n\x0e\n\x06\x06\0\x02\
    \xaf\x01\x04\x12\x04\xc3\x17\x04B\n\x12\n\n\x06\0\x02\xaf\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xc3\x17\x04B\n\x0e\n\x06\x06\0\x02\xaf\x01\x04\x12\
    \x04\xc4\x17\x04B\n\x12\n\n\x06\0\x02\xaf\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xc4\x17\x04B\n:\n\x05\x06\0\x02\xb0\x01\x12\x06\xc8\x17\x02\xd8\x17\
    \x03\x1a)\x20Delete\x20multiple\x20modules\x20in\x20one\x20request.\n\n\
    \x0e\n\x06\x06\0\x02\xb0\x01\x01\x12\x04\xc8\x17\x06\x13\n\x0e\n\x06\x06\
    \0\x02\xb0\x01\x02\x12\x04\xc8\x17\x15)\n\x0e\n\x06\x06\0\x02\xb0\x01\
    \x03\x12\x04\xc8\x174T\n\x10\n\x06\x06\0\x02\xb0\x01\x04\x12\x06\xc9\x17\
    \x04\xcc\x17\x06\n\x14\n\n\x06\0\x02\xb0\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xc9\x17\x04\xcc\x17\x06\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xcd\
    \x17\x047\n\x11\n\t\x06\0\x02\xb0\x01\x04\xc3\xf3\x04\x12\x04\xcd\x17\
    \x047\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xce\x17\x04?\n\x12\n\n\
    \x06\0\x02\xb0\x01\x04\xc2\xf3\x04\0\x12\x04\xce\x17\x04?\n\x0e\n\x06\
    \x06\0\x02\xb0\x01\x04\x12\x04\xcf\x17\x04B\n\x12\n\n\x06\0\x02\xb0\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xcf\x17\x04B\n\x0e\n\x06\x06\0\x02\xb0\x01\
    \x04\x12\x04\xd0\x17\x04E\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xd0\x17\x04E\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xd1\
    \x17\x04B\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\xf3\x04\x03\x12\x04\xd1\
    \x17\x04B\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xd2\x17\x04R\n5\n\n\
    \x06\0\x02\xb0\x01\x04\xc2\xf3\x04\x04\x12\x04\xd2\x17\x04R\"!\x20Needed\
    \x20to\x20cascade\x20delete\x20to\x20IMV\n\n\x0e\n\x06\x06\0\x02\xb0\x01\
    \x04\x12\x04\xd3\x17\x04R\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\xf3\x04\
    \x05\x12\x04\xd3\x17\x04R\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xd4\
    \x17\x04U\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\xf3\x04\x06\x12\x04\xd4\
    \x17\x04U\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\x04\xd5\x17\x04B\n\x12\n\
    \n\x06\0\x02\xb0\x01\x04\xc2\xf3\x04\x07\x12\x04\xd5\x17\x04B\n\x0e\n\
    \x06\x06\0\x02\xb0\x01\x04\x12\x04\xd6\x17\x04?\n\x12\n\n\x06\0\x02\xb0\
    \x01\x04\xc2\xf3\x04\x08\x12\x04\xd6\x17\x04?\n\x0e\n\x06\x06\0\x02\xb0\
    \x01\x04\x12\x04\xd7\x17\x04?\n\x12\n\n\x06\0\x02\xb0\x01\x04\xc2\xf3\
    \x04\t\x12\x04\xd7\x17\x04?\n>\n\x05\x06\0\x02\xb1\x01\x12\x06\xdb\x17\
    \x02\xe2\x17\x03\x1a-\x20Get\x20a\x20specific\x20module\x20version\x20fo\
    r\x20a\x20module.\n\n\x0e\n\x06\x06\0\x02\xb1\x01\x01\x12\x04\xdb\x17\
    \x06\x16\n\x0e\n\x06\x06\0\x02\xb1\x01\x02\x12\x04\xdb\x17\x18/\n\x0e\n\
    \x06\x06\0\x02\xb1\x01\x03\x12\x04\xdb\x17:U\n\x10\n\x06\x06\0\x02\xb1\
    \x01\x04\x12\x06\xdc\x17\x04\xde\x17\x06\n\x14\n\n\x06\0\x02\xb1\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xdc\x17\x04\xde\x17\x06\n\x0e\n\x06\x06\0\x02\xb1\
    \x01\x04\x12\x04\xdf\x17\x047\n\x11\n\t\x06\0\x02\xb1\x01\x04\xc3\xf3\
    \x04\x12\x04\xdf\x17\x047\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xe0\
    \x17\x04?\n\x12\n\n\x06\0\x02\xb1\x01\x04\xc2\xf3\x04\0\x12\x04\xe0\x17\
    \x04?\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\xe1\x17\x04B\n\x12\n\n\
    \x06\0\x02\xb1\x01\x04\xc2\xf3\x04\x01\x12\x04\xe1\x17\x04B\nD\n\x05\x06\
    \0\x02\xb2\x01\x12\x06\xe5\x17\x02\xec\x17\x03\x1a3\x20List\x20all\x20th\
    e\x20modules\x20versions\x20for\x20a\x20given\x20module.\n\n\x0e\n\x06\
    \x06\0\x02\xb2\x01\x01\x12\x04\xe5\x17\x06\x18\n\x0e\n\x06\x06\0\x02\xb2\
    \x01\x02\x12\x04\xe5\x17\x1a3\n\x0e\n\x06\x06\0\x02\xb2\x01\x03\x12\x04\
    \xe5\x17>X\n\x10\n\x06\x06\0\x02\xb2\x01\x04\x12\x06\xe6\x17\x04\xe8\x17\
    \x06\n\x14\n\n\x06\0\x02\xb2\x01\x04\xb0\xca\xbc\"\x12\x06\xe6\x17\x04\
    \xe8\x17\x06\n\x0e\n\x06\x06\0\x02\xb2\x01\x04\x12\x04\xe9\x17\x047\n\
    \x11\n\t\x06\0\x02\xb2\x01\x04\xc3\xf3\x04\x12\x04\xe9\x17\x047\n\x0e\n\
    \x06\x06\0\x02\xb2\x01\x04\x12\x04\xea\x17\x04?\n\x12\n\n\x06\0\x02\xb2\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xea\x17\x04?\n\x0e\n\x06\x06\0\x02\xb2\
    \x01\x04\x12\x04\xeb\x17\x04B\n\x12\n\n\x06\0\x02\xb2\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xeb\x17\x04B\nQ\n\x05\x06\0\x02\xb3\x01\x12\x06\xef\x17\
    \x02\xf8\x17\x03\x1a@\x20Create\x20a\x20new\x20module\x20version\x20to\
    \x20trigger\x20training\x20of\x20the\x20module.\n\n\x0e\n\x06\x06\0\x02\
    \xb3\x01\x01\x12\x04\xef\x17\x06\x18\n\x0e\n\x06\x06\0\x02\xb3\x01\x02\
    \x12\x04\xef\x17\x1a3\n\x0e\n\x06\x06\0\x02\xb3\x01\x03\x12\x04\xef\x17>\
    X\n\x10\n\x06\x06\0\x02\xb3\x01\x04\x12\x06\xf0\x17\x04\xf3\x17\x06\n\
    \x14\n\n\x06\0\x02\xb3\x01\x04\xb0\xca\xbc\"\x12\x06\xf0\x17\x04\xf3\x17\
    \x06\n\x0e\n\x06\x06\0\x02\xb3\x01\x04\x12\x04\xf4\x17\x047\n\x11\n\t\
    \x06\0\x02\xb3\x01\x04\xc3\xf3\x04\x12\x04\xf4\x17\x047\n\x0e\n\x06\x06\
    \0\x02\xb3\x01\x04\x12\x04\xf5\x17\x04?\n\x12\n\n\x06\0\x02\xb3\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xf5\x17\x04?\n\x0e\n\x06\x06\0\x02\xb3\x01\x04\
    \x12\x04\xf6\x17\x04B\n\x12\n\n\x06\0\x02\xb3\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xf6\x17\x04B\n\x0e\n\x06\x06\0\x02\xb3\x01\x04\x12\x04\xf7\x17\
    \x04B\n\x12\n\n\x06\0\x02\xb3\x01\x04\xc2\xf3\x04\x02\x12\x04\xf7\x17\
    \x04B\n4\n\x05\x06\0\x02\xb4\x01\x12\x06\xfb\x17\x02\x8b\x18\x03\x1a#\
    \x20Delete\x20a\x20multiple\x20module\x20version.\n\n\x0e\n\x06\x06\0\
    \x02\xb4\x01\x01\x12\x04\xfb\x17\x06\x1a\n\x0e\n\x06\x06\0\x02\xb4\x01\
    \x02\x12\x04\xfb\x17\x1c7\n\x0e\n\x06\x06\0\x02\xb4\x01\x03\x12\x04\xfb\
    \x17Bb\n\x10\n\x06\x06\0\x02\xb4\x01\x04\x12\x06\xfc\x17\x04\xff\x17\x06\
    \n\x14\n\n\x06\0\x02\xb4\x01\x04\xb0\xca\xbc\"\x12\x06\xfc\x17\x04\xff\
    \x17\x06\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x80\x18\x047\n\x11\n\
    \t\x06\0\x02\xb4\x01\x04\xc3\xf3\x04\x12\x04\x80\x18\x047\n\x0e\n\x06\
    \x06\0\x02\xb4\x01\x04\x12\x04\x81\x18\x04?\n\x12\n\n\x06\0\x02\xb4\x01\
    \x04\xc2\xf3\x04\0\x12\x04\x81\x18\x04?\n\x0e\n\x06\x06\0\x02\xb4\x01\
    \x04\x12\x04\x82\x18\x04B\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\x82\x18\x04B\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x83\
    \x18\x04E\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x02\x12\x04\x83\
    \x18\x04E\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x84\x18\x04B\n\x12\n\
    \n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x03\x12\x04\x84\x18\x04B\n\x0e\n\
    \x06\x06\0\x02\xb4\x01\x04\x12\x04\x85\x18\x04R\n5\n\n\x06\0\x02\xb4\x01\
    \x04\xc2\xf3\x04\x04\x12\x04\x85\x18\x04R\"!\x20Needed\x20to\x20cascade\
    \x20delete\x20to\x20IMV\n\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x86\
    \x18\x04R\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x05\x12\x04\x86\
    \x18\x04R\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\x87\x18\x04U\n\x12\n\
    \n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x06\x12\x04\x87\x18\x04U\n\x0e\n\
    \x06\x06\0\x02\xb4\x01\x04\x12\x04\x88\x18\x04B\n\x12\n\n\x06\0\x02\xb4\
    \x01\x04\xc2\xf3\x04\x07\x12\x04\x88\x18\x04B\n\x0e\n\x06\x06\0\x02\xb4\
    \x01\x04\x12\x04\x89\x18\x04?\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\
    \x04\x08\x12\x04\x89\x18\x04?\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\
    \x8a\x18\x04?\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\t\x12\x04\x8a\
    \x18\x04?\n=\n\x05\x06\0\x02\xb5\x01\x12\x06\x8e\x18\x02\x97\x18\x03\x1a\
    ,\x20Get\x20installed\x20modules\x20vesrions\x20for\x20an\x20app.\n\n\
    \x0e\n\x06\x06\0\x02\xb5\x01\x01\x12\x04\x8e\x18\x06\x1f\n\x0e\n\x06\x06\
    \0\x02\xb5\x01\x02\x12\x04\x8e\x18!A\n\x0e\n\x06\x06\0\x02\xb5\x01\x03\
    \x12\x04\x8e\x18Lp\n\x10\n\x06\x06\0\x02\xb5\x01\x04\x12\x06\x8f\x18\x04\
    \x91\x18\x06\n\x14\n\n\x06\0\x02\xb5\x01\x04\xb0\xca\xbc\"\x12\x06\x8f\
    \x18\x04\x91\x18\x06\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\x92\x18\
    \x047\n\x11\n\t\x06\0\x02\xb5\x01\x04\xc3\xf3\x04\x12\x04\x92\x18\x047\n\
    \x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\x93\x18\x04?\n\x12\n\n\x06\0\
    \x02\xb5\x01\x04\xc2\xf3\x04\0\x12\x04\x93\x18\x04?\n\x0e\n\x06\x06\0\
    \x02\xb5\x01\x04\x12\x04\x94\x18\x04R\n\x12\n\n\x06\0\x02\xb5\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\x94\x18\x04R\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\
    \x12\x04\x95\x18\x04B\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x02\
    \x12\x04\x95\x18\x04B\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\x96\x18\
    \x04?\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x03\x12\x04\x96\x18\
    \x04?\n>\n\x05\x06\0\x02\xb6\x01\x12\x06\x9a\x18\x02\xa3\x18\x03\x1a-\
    \x20List\x20installed\x20modules\x20vesrions\x20for\x20an\x20app.\n\n\
    \x0e\n\x06\x06\0\x02\xb6\x01\x01\x12\x04\x9a\x18\x06!\n\x0e\n\x06\x06\0\
    \x02\xb6\x01\x02\x12\x04\x9a\x18#E\n\x0e\n\x06\x06\0\x02\xb6\x01\x03\x12\
    \x04\x9a\x18Ps\n\x10\n\x06\x06\0\x02\xb6\x01\x04\x12\x06\x9b\x18\x04\x9d\
    \x18\x06\n\x14\n\n\x06\0\x02\xb6\x01\x04\xb0\xca\xbc\"\x12\x06\x9b\x18\
    \x04\x9d\x18\x06\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\x9e\x18\x047\
    \n\x11\n\t\x06\0\x02\xb6\x01\x04\xc3\xf3\x04\x12\x04\x9e\x18\x047\n\x0e\
    \n\x06\x06\0\x02\xb6\x01\x04\x12\x04\x9f\x18\x04?\n\x12\n\n\x06\0\x02\
    \xb6\x01\x04\xc2\xf3\x04\0\x12\x04\x9f\x18\x04?\n\x0e\n\x06\x06\0\x02\
    \xb6\x01\x04\x12\x04\xa0\x18\x04R\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xa0\x18\x04R\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\
    \x04\xa1\x18\x04B\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xa1\x18\x04B\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xa2\x18\x04?\
    \n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x03\x12\x04\xa2\x18\x04?\ns\
    \n\x05\x06\0\x02\xb7\x01\x12\x06\xa6\x18\x02\xb0\x18\x03\x1ab\x20Install\
    \x20a\x20new\x20module\x20version\x20which\x20will\x20deploy\x20the\x20s\
    pecific\x20ModuleVersion\x20to\x20the\x20app\x20in\x20the\x20url.\n\n\
    \x0e\n\x06\x06\0\x02\xb7\x01\x01\x12\x04\xa6\x18\x06!\n\x0e\n\x06\x06\0\
    \x02\xb7\x01\x02\x12\x04\xa6\x18#E\n\x0e\n\x06\x06\0\x02\xb7\x01\x03\x12\
    \x04\xa6\x18Ps\n\x10\n\x06\x06\0\x02\xb7\x01\x04\x12\x06\xa7\x18\x04\xaa\
    \x18\x06\n\x14\n\n\x06\0\x02\xb7\x01\x04\xb0\xca\xbc\"\x12\x06\xa7\x18\
    \x04\xaa\x18\x06\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xab\x18\x047\
    \n\x11\n\t\x06\0\x02\xb7\x01\x04\xc3\xf3\x04\x12\x04\xab\x18\x047\n\x0e\
    \n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xac\x18\x04R\n\x12\n\n\x06\0\x02\
    \xb7\x01\x04\xc2\xf3\x04\0\x12\x04\xac\x18\x04R\n\x0e\n\x06\x06\0\x02\
    \xb7\x01\x04\x12\x04\xad\x18\x04R\n\x12\n\n\x06\0\x02\xb7\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xad\x18\x04R\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\
    \x04\xae\x18\x04B\n\x12\n\n\x06\0\x02\xb7\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xae\x18\x04B\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xaf\x18\x04?\
    \n3\n\n\x06\0\x02\xb7\x01\x04\xc2\xf3\x04\x03\x12\x04\xaf\x18\x04?\"\x1f\
    \x20since\x20adding\x20Keys\x20needs\x20that.\n\n\xca\x01\n\x05\x06\0\
    \x02\xb8\x01\x12\x06\xb5\x18\x02\xc3\x18\x03\x1a\xb8\x01\x20Uninstall\
    \x20an\x20installed\x20module\x20version\x20which\x20will\x20deploy\x20t\
    he\x20specific\x20ModuleVersion\x20to\x20the\x20app\n\x20in\x20the\x20ur\
    l.\n\x20This\x20cleaned\x20up\x20any\x20associated\x20caller\x20keys\x20\
    so\x20needs\x20the\x20Keys_Delete\x20scope.\n\n\x0e\n\x06\x06\0\x02\xb8\
    \x01\x01\x12\x04\xb5\x18\x06#\n\x0e\n\x06\x06\0\x02\xb8\x01\x02\x12\x04\
    \xb5\x18%I\n\x0e\n\x06\x06\0\x02\xb8\x01\x03\x12\x04\xb5\x18Tt\n\x10\n\
    \x06\x06\0\x02\xb8\x01\x04\x12\x06\xb6\x18\x04\xb9\x18\x06\n\x14\n\n\x06\
    \0\x02\xb8\x01\x04\xb0\xca\xbc\"\x12\x06\xb6\x18\x04\xb9\x18\x06\n\x0e\n\
    \x06\x06\0\x02\xb8\x01\x04\x12\x04\xba\x18\x047\n\x11\n\t\x06\0\x02\xb8\
    \x01\x04\xc3\xf3\x04\x12\x04\xba\x18\x047\n\x0e\n\x06\x06\0\x02\xb8\x01\
    \x04\x12\x04\xbb\x18\x04?\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xbb\x18\x04?\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xbc\x18\
    \x04B\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\x01\x12\x04\xbc\x18\
    \x04B\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xbd\x18\x04R\n\x12\n\n\
    \x06\0\x02\xb8\x01\x04\xc2\xf3\x04\x02\x12\x04\xbd\x18\x04R\n\x0e\n\x06\
    \x06\0\x02\xb8\x01\x04\x12\x04\xbe\x18\x04R\n\x12\n\n\x06\0\x02\xb8\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\xbe\x18\x04R\n\x0e\n\x06\x06\0\x02\xb8\x01\
    \x04\x12\x04\xbf\x18\x04U\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\
    \x04\x12\x04\xbf\x18\x04U\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xc0\
    \x18\x04B\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\x05\x12\x04\xc0\
    \x18\x04B\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xc1\x18\x04?\n\x12\n\
    \n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\x06\x12\x04\xc1\x18\x04?\n\x0e\n\
    \x06\x06\0\x02\xb8\x01\x04\x12\x04\xc2\x18\x04?\n\x12\n\n\x06\0\x02\xb8\
    \x01\x04\xc2\xf3\x04\x07\x12\x04\xc2\x18\x04?\n\xc0\x01\n\x05\x06\0\x02\
    \xb9\x01\x12\x06\xc7\x18\x02\xd3\x18\x03\x1a\xae\x01\x20Assign\x20a\x20k\
    ey\x20that\x20the\x20caller\x20owns\x20to\x20be\x20used\x20when\x20acces\
    sing\x20this\x20installed\x20module\x20version\n\x20If\x20this\x20endpoi\
    nt\x20is\x20called\x20with\x20a\x20different\x20key\x20then\x20it\x20ove\
    rwrites\x20what\x20is\x20there.\n\n\x0e\n\x06\x06\0\x02\xb9\x01\x01\x12\
    \x04\xc7\x18\x06$\n\x0e\n\x06\x06\0\x02\xb9\x01\x02\x12\x04\xc7\x18&K\n\
    \x0e\n\x06\x06\0\x02\xb9\x01\x03\x12\x04\xc7\x18Vg\n\x10\n\x06\x06\0\x02\
    \xb9\x01\x04\x12\x06\xc8\x18\x04\xcb\x18\x06\n\x14\n\n\x06\0\x02\xb9\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xc8\x18\x04\xcb\x18\x06\n\x0e\n\x06\x06\0\x02\
    \xb9\x01\x04\x12\x04\xcc\x18\x047\n\x11\n\t\x06\0\x02\xb9\x01\x04\xc3\
    \xf3\x04\x12\x04\xcc\x18\x047\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\
    \xcd\x18\x04R\n\x12\n\n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\0\x12\x04\xcd\
    \x18\x04R\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\xce\x18\x04R\n\x12\n\
    \n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\x01\x12\x04\xce\x18\x04R\n\x0e\n\
    \x06\x06\0\x02\xb9\x01\x04\x12\x04\xcf\x18\x04B\n\x12\n\n\x06\0\x02\xb9\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\xcf\x18\x04B\n\x0e\n\x06\x06\0\x02\xb9\
    \x01\x04\x12\x04\xd0\x18\x04?\n3\n\n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\
    \x03\x12\x04\xd0\x18\x04?\"\x1f\x20since\x20adding\x20Keys\x20needs\x20t\
    hat.\n\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\xd1\x18\x04?\n\x12\n\n\
    \x06\0\x02\xb9\x01\x04\xc2\xf3\x04\x04\x12\x04\xd1\x18\x04?\n\x0e\n\x06\
    \x06\0\x02\xb9\x01\x04\x12\x04\xd2\x18\x04?\n\x12\n\n\x06\0\x02\xb9\x01\
    \x04\xc2\xf3\x04\x05\x12\x04\xd2\x18\x04?\n\x83\x02\n\x05\x06\0\x02\xba\
    \x01\x12\x06\xd8\x18\x02\xe8\x18\x03\x1a\xf1\x01\x20Perform\x20bulk\x20o\
    perations\x20on\x20a\x20list\x20of\x20inputs\x20based\x20on\x20input\x20\
    source.\n\x20Operation\x20include\x20add,\x20update,\x20delete\x20of\x20\
    concepts,\x20metadata\x20and\x20geo\x20data.\n\x20This\x20is\x20an\x20As\
    ynchronous\x20process.\x20Use\x20ListBulkOperations\x20or\x20GetBulkOper\
    ation\x20to\x20check\x20the\x20status.\n\n\x0e\n\x06\x06\0\x02\xba\x01\
    \x01\x12\x04\xd8\x18\x06\x18\n\x0e\n\x06\x06\0\x02\xba\x01\x02\x12\x04\
    \xd8\x18\x1a3\n\x0e\n\x06\x06\0\x02\xba\x01\x03\x12\x04\xd8\x18>Y\n\x10\
    \n\x06\x06\0\x02\xba\x01\x04\x12\x06\xd9\x18\x04\xe0\x18\x06\n\x14\n\n\
    \x06\0\x02\xba\x01\x04\xb0\xca\xbc\"\x12\x06\xd9\x18\x04\xe0\x18\x06\n\
    \x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xe1\x18\x047\n\x11\n\t\x06\0\
    \x02\xba\x01\x04\xc3\xf3\x04\x12\x04\xe1\x18\x047\n\x0e\n\x06\x06\0\x02\
    \xba\x01\x04\x12\x04\xe2\x18\x04?\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xe2\x18\x04?\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\
    \x04\xe3\x18\x04H\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xe3\x18\x04H\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xe4\x18\x04H\
    \n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x02\x12\x04\xe4\x18\x04H\n\
    \x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\xe5\x18\x04F\n\x12\n\n\x06\0\
    \x02\xba\x01\x04\xc2\xf3\x04\x03\x12\x04\xe5\x18\x04F\n\x0e\n\x06\x06\0\
    \x02\xba\x01\x04\x12\x04\xe6\x18\x04F\n\x12\n\n\x06\0\x02\xba\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xe6\x18\x04F\n\x0e\n\x06\x06\0\x02\xba\x01\x04\
    \x12\x04\xe7\x18\x04I\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xe7\x18\x04I\n/\n\x05\x06\0\x02\xbb\x01\x12\x06\xeb\x18\x02\xf5\
    \x18\x03\x1a\x1e\x20List\x20all\x20the\x20bulk\x20operations\n\n\x0e\n\
    \x06\x06\0\x02\xbb\x01\x01\x12\x04\xeb\x18\x06\x18\n\x0e\n\x06\x06\0\x02\
    \xbb\x01\x02\x12\x04\xeb\x18\x1a3\n\x0e\n\x06\x06\0\x02\xbb\x01\x03\x12\
    \x04\xeb\x18>Y\n\x10\n\x06\x06\0\x02\xbb\x01\x04\x12\x06\xec\x18\x04\xf1\
    \x18\x06\n\x14\n\n\x06\0\x02\xbb\x01\x04\xb0\xca\xbc\"\x12\x06\xec\x18\
    \x04\xf1\x18\x06\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xf2\x18\x047\
    \n\x11\n\t\x06\0\x02\xbb\x01\x04\xc3\xf3\x04\x12\x04\xf2\x18\x047\n\x0e\
    \n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xf3\x18\x04?\n\x12\n\n\x06\0\x02\
    \xbb\x01\x04\xc2\xf3\x04\0\x12\x04\xf3\x18\x04?\n\x0e\n\x06\x06\0\x02\
    \xbb\x01\x04\x12\x04\xf4\x18\x04H\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xf4\x18\x04H\n7\n\x05\x06\0\x02\xbc\x01\x12\x06\xf8\
    \x18\x02\x82\x19\x03\x1a&\x20Get\x20the\x20bulk\x20operation\x20details\
    \x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\xbc\x01\x01\x12\x04\xf8\x18\x06\x16\
    \n\x0e\n\x06\x06\0\x02\xbc\x01\x02\x12\x04\xf8\x18\x18/\n\x0e\n\x06\x06\
    \0\x02\xbc\x01\x03\x12\x04\xf8\x18:V\n\x10\n\x06\x06\0\x02\xbc\x01\x04\
    \x12\x06\xf9\x18\x04\xfe\x18\x06\n\x14\n\n\x06\0\x02\xbc\x01\x04\xb0\xca\
    \xbc\"\x12\x06\xf9\x18\x04\xfe\x18\x06\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\
    \x12\x04\xff\x18\x047\n\x11\n\t\x06\0\x02\xbc\x01\x04\xc3\xf3\x04\x12\
    \x04\xff\x18\x047\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\x80\x19\x04?\
    \n\x12\n\n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\0\x12\x04\x80\x19\x04?\n\
    \x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\x81\x19\x04H\n\x12\n\n\x06\0\
    \x02\xbc\x01\x04\xc2\xf3\x04\x01\x12\x04\x81\x19\x04H\n5\n\x05\x06\0\x02\
    \xbd\x01\x12\x06\x85\x19\x02\x92\x19\x03\x1a$\x20Cancel\x20one\x20or\x20\
    more\x20bulk\x20operations\n\n\x0e\n\x06\x06\0\x02\xbd\x01\x01\x12\x04\
    \x85\x19\x06\x1a\n\x0e\n\x06\x06\0\x02\xbd\x01\x02\x12\x04\x85\x19\x1c6\
    \n\x0e\n\x06\x06\0\x02\xbd\x01\x03\x12\x04\x85\x19A\\\n\x10\n\x06\x06\0\
    \x02\xbd\x01\x04\x12\x06\x86\x19\x04\x8d\x19\x06\n\x14\n\n\x06\0\x02\xbd\
    \x01\x04\xb0\xca\xbc\"\x12\x06\x86\x19\x04\x8d\x19\x06\n\x0e\n\x06\x06\0\
    \x02\xbd\x01\x04\x12\x04\x8e\x19\x047\n\x11\n\t\x06\0\x02\xbd\x01\x04\
    \xc3\xf3\x04\x12\x04\x8e\x19\x047\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\
    \x04\x8f\x19\x04?\n\x12\n\n\x06\0\x02\xbd\x01\x04\xc2\xf3\x04\0\x12\x04\
    \x8f\x19\x04?\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\x90\x19\x04H\n\
    \x12\n\n\x06\0\x02\xbd\x01\x04\xc2\xf3\x04\x01\x12\x04\x90\x19\x04H\n\
    \x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\x91\x19\x04H\n\x12\n\n\x06\0\
    \x02\xbd\x01\x04\xc2\xf3\x04\x02\x12\x04\x91\x19\x04H\n@\n\x05\x06\0\x02\
    \xbe\x01\x12\x06\x95\x19\x02\xa6\x19\x03\x1a/\x20delete\x20one\x20or\x20\
    more\x20terminated\x20bulk\x20operations\n\n\x0e\n\x06\x06\0\x02\xbe\x01\
    \x01\x12\x04\x95\x19\x06\x1a\n\x0e\n\x06\x06\0\x02\xbe\x01\x02\x12\x04\
    \x95\x19\x1c6\n\x0e\n\x06\x06\0\x02\xbe\x01\x03\x12\x04\x95\x19Aa\n\x10\
    \n\x06\x06\0\x02\xbe\x01\x04\x12\x06\x96\x19\x04\x9d\x19\x06\n\x14\n\n\
    \x06\0\x02\xbe\x01\x04\xb0\xca\xbc\"\x12\x06\x96\x19\x04\x9d\x19\x06\n\
    \x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\x9e\x19\x047\n\x11\n\t\x06\0\
    \x02\xbe\x01\x04\xc3\xf3\x04\x12\x04\x9e\x19\x047\n\x0e\n\x06\x06\0\x02\
    \xbe\x01\x04\x12\x04\x9f\x19\x04?\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\
    \xf3\x04\0\x12\x04\x9f\x19\x04?\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\
    \x04\xa0\x19\x04F\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xa0\x19\x04F\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\xa1\x19\x04F\
    \n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x02\x12\x04\xa1\x19\x04F\n\
    \x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\xa2\x19\x04I\n\x12\n\n\x06\0\
    \x02\xbe\x01\x04\xc2\xf3\x04\x03\x12\x04\xa2\x19\x04I\n\x0e\n\x06\x06\0\
    \x02\xbe\x01\x04\x12\x04\xa3\x19\x04H\n\x12\n\n\x06\0\x02\xbe\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xa3\x19\x04H\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\
    \x12\x04\xa4\x19\x04H\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xa4\x19\x04H\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\xa5\x19\
    \x04K\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x06\x12\x04\xa5\x19\
    \x04K\n&\n\x05\x06\0\x02\xbf\x01\x12\x06\xa9\x19\x02\xb3\x19\x03\x1a\x15\
    \x20Get\x20a\x20specific\x20job.\n\n\x0e\n\x06\x06\0\x02\xbf\x01\x01\x12\
    \x04\xa9\x19\x06\"\n\x0e\n\x06\x06\0\x02\xbf\x01\x02\x12\x04\xa9\x19$G\n\
    \x0e\n\x06\x06\0\x02\xbf\x01\x03\x12\x04\xa9\x19Ry\n\x10\n\x06\x06\0\x02\
    \xbf\x01\x04\x12\x06\xaa\x19\x04\xaf\x19\x06\n\x14\n\n\x06\0\x02\xbf\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xaa\x19\x04\xaf\x19\x06\n\x0e\n\x06\x06\0\x02\
    \xbf\x01\x04\x12\x04\xb0\x19\x047\n\x11\n\t\x06\0\x02\xbf\x01\x04\xc3\
    \xf3\x04\x12\x04\xb0\x19\x047\n\x0e\n\x06\x06\0\x02\xbf\x01\x04\x12\x04\
    \xb1\x19\x04?\n\x12\n\n\x06\0\x02\xbf\x01\x04\xc2\xf3\x04\0\x12\x04\xb1\
    \x19\x04?\n\x0e\n\x06\x06\0\x02\xbf\x01\x04\x12\x04\xb2\x19\x04C\n\x12\n\
    \n\x06\0\x02\xbf\x01\x04\xc2\xf3\x04\x01\x12\x04\xb2\x19\x04C\nR\n\x05\
    \x06\0\x02\xc0\x01\x12\x06\xb6\x19\x02\xc4\x19\x03\x1aA\x20List\x20next\
    \x20non-labeled\x20and\x20unassigned\x20inputs\x20from\x20task's\x20data\
    set\n\n\x0e\n\x06\x06\0\x02\xc0\x01\x01\x12\x04\xb6\x19\x06\x1d\n\x0e\n\
    \x06\x06\0\x02\xc0\x01\x02\x12\x04\xb6\x19\x1f=\n\x0e\n\x06\x06\0\x02\
    \xc0\x01\x03\x12\x04\xb6\x19HZ\n\x10\n\x06\x06\0\x02\xc0\x01\x04\x12\x06\
    \xb7\x19\x04\xbc\x19\x06\n\x14\n\n\x06\0\x02\xc0\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xb7\x19\x04\xbc\x19\x06\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\
    \x04\xbd\x19\x047\n\x11\n\t\x06\0\x02\xc0\x01\x04\xc3\xf3\x04\x12\x04\
    \xbd\x19\x047\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xbe\x19\x04?\n\
    \x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\0\x12\x04\xbe\x19\x04?\n\x0e\
    \n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xbf\x19\x04F\n\x12\n\n\x06\0\x02\
    \xc0\x01\x04\xc2\xf3\x04\x01\x12\x04\xbf\x19\x04F\n\x0e\n\x06\x06\0\x02\
    \xc0\x01\x04\x12\x04\xc0\x19\x04C\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xc0\x19\x04C\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\
    \x04\xc1\x19\x04A\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xc1\x19\x04A\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xc2\x19\x04@\
    \n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x04\x12\x04\xc2\x19\x04@\n\
    \x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xc3\x19\x04C\n\x12\n\n\x06\0\
    \x02\xc0\x01\x04\xc2\xf3\x04\x05\x12\x04\xc3\x19\x04C\n\x93\x01\n\x05\
    \x06\0\x02\xc1\x01\x12\x06\xc7\x19\x02\xd4\x19\x03\x1a\x81\x01\x20PutTas\
    kAssignments\x20evaluates\x20all\x20the\x20annotations\x20by\x20labeler\
    \x20(authenticated\x20user)\x20for\x20given\x20task\x20(task_id)\x20and\
    \x20input\x20(input_id).\n\n\x0e\n\x06\x06\0\x02\xc1\x01\x01\x12\x04\xc7\
    \x19\x06\x18\n\x0e\n\x06\x06\0\x02\xc1\x01\x02\x12\x04\xc7\x19\x1a3\n\
    \x0e\n\x06\x06\0\x02\xc1\x01\x03\x12\x04\xc7\x19>^\n\x10\n\x06\x06\0\x02\
    \xc1\x01\x04\x12\x06\xc8\x19\x04\xcb\x19\x06\n\x14\n\n\x06\0\x02\xc1\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xc8\x19\x04\xcb\x19\x06\n\x0e\n\x06\x06\0\x02\
    \xc1\x01\x04\x12\x04\xcc\x19\x047\n\x11\n\t\x06\0\x02\xc1\x01\x04\xc3\
    \xf3\x04\x12\x04\xcc\x19\x047\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\
    \xcd\x19\x04?\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\0\x12\x04\xcd\
    \x19\x04?\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xce\x19\x04F\n\x12\n\
    \n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x01\x12\x04\xce\x19\x04F\n\x0e\n\
    \x06\x06\0\x02\xc1\x01\x04\x12\x04\xcf\x19\x04F\n\x12\n\n\x06\0\x02\xc1\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\xcf\x19\x04F\n\x0e\n\x06\x06\0\x02\xc1\
    \x01\x04\x12\x04\xd0\x19\x04C\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\
    \x04\x03\x12\x04\xd0\x19\x04C\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\
    \xd1\x19\x04A\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x04\x12\x04\
    \xd1\x19\x04A\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xd2\x19\x04@\n\
    \x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x05\x12\x04\xd2\x19\x04@\n\
    \x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xd3\x19\x04C\n\x12\n\n\x06\0\
    \x02\xc1\x01\x04\xc2\xf3\x04\x06\x12\x04\xd3\x19\x04C\n/\n\x05\x06\0\x02\
    \xc2\x01\x12\x06\xd9\x19\x02\xe3\x19\x03\x1a\x1e\x20List\x20all\x20the\
    \x20inputs\x20add\x20jobs\n\n\x0e\n\x06\x06\0\x02\xc2\x01\x01\x12\x04\
    \xd9\x19\x06\x17\n\x0e\n\x06\x06\0\x02\xc2\x01\x02\x12\x04\xd9\x19\x191\
    \n\x0e\n\x06\x06\0\x02\xc2\x01\x03\x12\x04\xd9\x19<U\n\x10\n\x06\x06\0\
    \x02\xc2\x01\x04\x12\x06\xda\x19\x04\xdf\x19\x06\n\x14\n\n\x06\0\x02\xc2\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xda\x19\x04\xdf\x19\x06\n\x0e\n\x06\x06\0\
    \x02\xc2\x01\x04\x12\x04\xe0\x19\x047\n\x11\n\t\x06\0\x02\xc2\x01\x04\
    \xc3\xf3\x04\x12\x04\xe0\x19\x047\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\
    \x04\xe1\x19\x04?\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xe1\x19\x04?\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\xe2\x19\x04A\n\
    \x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x01\x12\x04\xe2\x19\x04A\n6\n\
    \x05\x06\0\x02\xc3\x01\x12\x06\xe6\x19\x02\xf0\x19\x03\x1a%\x20Get\x20th\
    e\x20input\x20add\x20job\x20details\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\
    \xc3\x01\x01\x12\x04\xe6\x19\x06\x15\n\x0e\n\x06\x06\0\x02\xc3\x01\x02\
    \x12\x04\xe6\x19\x17-\n\x0e\n\x06\x06\0\x02\xc3\x01\x03\x12\x04\xe6\x198\
    R\n\x10\n\x06\x06\0\x02\xc3\x01\x04\x12\x06\xe7\x19\x04\xec\x19\x06\n\
    \x14\n\n\x06\0\x02\xc3\x01\x04\xb0\xca\xbc\"\x12\x06\xe7\x19\x04\xec\x19\
    \x06\n\x0e\n\x06\x06\0\x02\xc3\x01\x04\x12\x04\xed\x19\x047\n\x11\n\t\
    \x06\0\x02\xc3\x01\x04\xc3\xf3\x04\x12\x04\xed\x19\x047\n\x0e\n\x06\x06\
    \0\x02\xc3\x01\x04\x12\x04\xee\x19\x04?\n\x12\n\n\x06\0\x02\xc3\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xee\x19\x04?\n\x0e\n\x06\x06\0\x02\xc3\x01\x04\
    \x12\x04\xef\x19\x04A\n\x12\n\n\x06\0\x02\xc3\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xef\x19\x04A\n1\n\x05\x06\0\x02\xc4\x01\x12\x06\xf3\x19\x02\x80\
    \x1a\x03\x1a\x20\x20cancel\x20the\x20input\x20add\x20job\x20by\x20ID\n\n\
    \x0e\n\x06\x06\0\x02\xc4\x01\x01\x12\x04\xf3\x19\x06\x18\n\x0e\n\x06\x06\
    \0\x02\xc4\x01\x02\x12\x04\xf3\x19\x1a3\n\x0e\n\x06\x06\0\x02\xc4\x01\
    \x03\x12\x04\xf3\x19>X\n\x10\n\x06\x06\0\x02\xc4\x01\x04\x12\x06\xf4\x19\
    \x04\xfb\x19\x06\n\x14\n\n\x06\0\x02\xc4\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xf4\x19\x04\xfb\x19\x06\n\x0e\n\x06\x06\0\x02\xc4\x01\x04\x12\x04\xfc\
    \x19\x047\n\x11\n\t\x06\0\x02\xc4\x01\x04\xc3\xf3\x04\x12\x04\xfc\x19\
    \x047\n\x0e\n\x06\x06\0\x02\xc4\x01\x04\x12\x04\xfd\x19\x04?\n\x12\n\n\
    \x06\0\x02\xc4\x01\x04\xc2\xf3\x04\0\x12\x04\xfd\x19\x04?\n\x0e\n\x06\
    \x06\0\x02\xc4\x01\x04\x12\x04\xfe\x19\x04A\n\x12\n\n\x06\0\x02\xc4\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xfe\x19\x04A\n\x0e\n\x06\x06\0\x02\xc4\x01\
    \x04\x12\x04\xff\x19\x04A\n\x12\n\n\x06\0\x02\xc4\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xff\x19\x04A\n\x0f\n\x05\x06\0\x02\xc5\x01\x12\x06\x82\x1a\
    \x02\x8f\x1a\x03\n\x0e\n\x06\x06\0\x02\xc5\x01\x01\x12\x04\x82\x1a\x06\
    \x11\n\x0e\n\x06\x06\0\x02\xc5\x01\x02\x12\x04\x82\x1a\x13%\n\x0e\n\x06\
    \x06\0\x02\xc5\x01\x03\x12\x04\x82\x1a0C\n\x10\n\x06\x06\0\x02\xc5\x01\
    \x04\x12\x06\x83\x1a\x04\x8a\x1a\x06\n\x14\n\n\x06\0\x02\xc5\x01\x04\xb0\
    \xca\xbc\"\x12\x06\x83\x1a\x04\x8a\x1a\x06\n\x0e\n\x06\x06\0\x02\xc5\x01\
    \x04\x12\x04\x8b\x1a\x047\n\x11\n\t\x06\0\x02\xc5\x01\x04\xc3\xf3\x04\
    \x12\x04\x8b\x1a\x047\n\x0e\n\x06\x06\0\x02\xc5\x01\x04\x12\x04\x8c\x1a\
    \x04?\n\x12\n\n\x06\0\x02\xc5\x01\x04\xc2\xf3\x04\0\x12\x04\x8c\x1a\x04?\
    \n\x0e\n\x06\x06\0\x02\xc5\x01\x04\x12\x04\x8d\x1a\x04B\n\x12\n\n\x06\0\
    \x02\xc5\x01\x04\xc2\xf3\x04\x01\x12\x04\x8d\x1a\x04B\n\x0e\n\x06\x06\0\
    \x02\xc5\x01\x04\x12\x04\x8e\x1a\x04B\n\x12\n\n\x06\0\x02\xc5\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\x8e\x1a\x04B\n\x8e\x01\n\x05\x06\0\x02\xc6\x01\
    \x12\x06\x93\x1a\x02\x9f\x1a\x03\x1a}\x20Upload\x20a\x20part\x20of\x20a\
    \x20multipart\x20upload.\n\x20Behaviour\x20on\x20completion\x20depends\
    \x20on\x20the\x20endpoint\x20that\x20was\x20used\x20to\x20initiate\x20th\
    e\x20upload.\n\n\x0e\n\x06\x06\0\x02\xc6\x01\x01\x12\x04\x93\x1a\x06\x1b\
    \n\x0e\n\x06\x06\0\x02\xc6\x01\x02\x12\x04\x93\x1a\x1d9\n\x0e\n\x06\x06\
    \0\x02\xc6\x01\x03\x12\x04\x93\x1aDX\n\x10\n\x06\x06\0\x02\xc6\x01\x04\
    \x12\x06\x94\x1a\x04\x9a\x1a\x06\n\x14\n\n\x06\0\x02\xc6\x01\x04\xb0\xca\
    \xbc\"\x12\x06\x94\x1a\x04\x9a\x1a\x06\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\
    \x12\x04\x9b\x1a\x047\n\x11\n\t\x06\0\x02\xc6\x01\x04\xc3\xf3\x04\x12\
    \x04\x9b\x1a\x047\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\x9c\x1a\x04?\
    \n\x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\0\x12\x04\x9c\x1a\x04?\n\
    \x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\x9d\x1a\x04B\n\x12\n\n\x06\0\
    \x02\xc6\x01\x04\xc2\xf3\x04\x01\x12\x04\x9d\x1a\x04B\n\x0e\n\x06\x06\0\
    \x02\xc6\x01\x04\x12\x04\x9e\x1a\x04B\n\x12\n\n\x06\0\x02\xc6\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\x9e\x1a\x04B\n\x0f\n\x05\x06\0\x02\xc7\x01\x12\
    \x06\xa1\x1a\x02\xab\x1a\x03\n\x0e\n\x06\x06\0\x02\xc7\x01\x01\x12\x04\
    \xa1\x1a\x06\x0f\n\x0e\n\x06\x06\0\x02\xc7\x01\x02\x12\x04\xa1\x1a\x11!\
    \n\x0e\n\x06\x06\0\x02\xc7\x01\x03\x12\x04\xa1\x1a,@\n\x10\n\x06\x06\0\
    \x02\xc7\x01\x04\x12\x06\xa2\x1a\x04\xa7\x1a\x06\n\x14\n\n\x06\0\x02\xc7\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xa2\x1a\x04\xa7\x1a\x06\n\x0e\n\x06\x06\0\
    \x02\xc7\x01\x04\x12\x04\xa8\x1a\x047\n\x11\n\t\x06\0\x02\xc7\x01\x04\
    \xc3\xf3\x04\x12\x04\xa8\x1a\x047\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\
    \x04\xa9\x1a\x04?\n\x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xa9\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xaa\x1a\x04B\n\
    \x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\x01\x12\x04\xaa\x1a\x04B\n\
    \x0f\n\x05\x06\0\x02\xc8\x01\x12\x06\xad\x1a\x02\xb7\x1a\x03\n\x0e\n\x06\
    \x06\0\x02\xc8\x01\x01\x12\x04\xad\x1a\x06\x11\n\x0e\n\x06\x06\0\x02\xc8\
    \x01\x02\x12\x04\xad\x1a\x13%\n\x0e\n\x06\x06\0\x02\xc8\x01\x03\x12\x04\
    \xad\x1a0C\n\x10\n\x06\x06\0\x02\xc8\x01\x04\x12\x06\xae\x1a\x04\xb3\x1a\
    \x06\n\x14\n\n\x06\0\x02\xc8\x01\x04\xb0\xca\xbc\"\x12\x06\xae\x1a\x04\
    \xb3\x1a\x06\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\x04\xb4\x1a\x047\n\
    \x11\n\t\x06\0\x02\xc8\x01\x04\xc3\xf3\x04\x12\x04\xb4\x1a\x047\n\x0e\n\
    \x06\x06\0\x02\xc8\x01\x04\x12\x04\xb5\x1a\x04?\n\x12\n\n\x06\0\x02\xc8\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xb5\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc8\
    \x01\x04\x12\x04\xb6\x1a\x04B\n\x12\n\n\x06\0\x02\xc8\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xb6\x1a\x04B\n\x0f\n\x05\x06\0\x02\xc9\x01\x12\x06\xb9\
    \x1a\x02\xc7\x1a\x03\n\x0e\n\x06\x06\0\x02\xc9\x01\x01\x12\x04\xb9\x1a\
    \x06\x13\n\x0e\n\x06\x06\0\x02\xc9\x01\x02\x12\x04\xb9\x1a\x15)\n\x0e\n\
    \x06\x06\0\x02\xc9\x01\x03\x12\x04\xb9\x1a4T\n\x10\n\x06\x06\0\x02\xc9\
    \x01\x04\x12\x06\xba\x1a\x04\xc1\x1a\x06\n\x14\n\n\x06\0\x02\xc9\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xba\x1a\x04\xc1\x1a\x06\n\x0e\n\x06\x06\0\x02\xc9\
    \x01\x04\x12\x04\xc2\x1a\x047\n\x11\n\t\x06\0\x02\xc9\x01\x04\xc3\xf3\
    \x04\x12\x04\xc2\x1a\x047\n\x0e\n\x06\x06\0\x02\xc9\x01\x04\x12\x04\xc3\
    \x1a\x04?\n\x12\n\n\x06\0\x02\xc9\x01\x04\xc2\xf3\x04\0\x12\x04\xc3\x1a\
    \x04?\n\x0e\n\x06\x06\0\x02\xc9\x01\x04\x12\x04\xc4\x1a\x04B\n\x12\n\n\
    \x06\0\x02\xc9\x01\x04\xc2\xf3\x04\x01\x12\x04\xc4\x1a\x04B\n\x0e\n\x06\
    \x06\0\x02\xc9\x01\x04\x12\x04\xc5\x1a\x04B\n\x12\n\n\x06\0\x02\xc9\x01\
    \x04\xc2\xf3\x04\x02\x12\x04\xc5\x1a\x04B\n\x0e\n\x06\x06\0\x02\xc9\x01\
    \x04\x12\x04\xc6\x1a\x04E\n\x12\n\n\x06\0\x02\xc9\x01\x04\xc2\xf3\x04\
    \x03\x12\x04\xc6\x1a\x04E\n\xaf\x06\n\x05\x06\0\x02\xca\x01\x12\x06\xd6\
    \x1a\x02\xe9\x1a\x03\x1a\x9d\x06\x20Initiates\x20retrieval\x20of\x20inpu\
    ts\x20from\x20cloud\x20storage\x20from\x20a\x20user\x20provided\x20data\
    \x20source.\n\x20Will\x20create\x20and\x20return\x20an\x20inputs-add-job\
    \x20for\x20tracking\x20progress.\n\x20Archives\x20will\x20be\x20extracte\
    d\x20and\x20their\x20contents\x20will\x20be\x20processed\x20as\x20inputs\
    .\n\n\x20The\x20cloud\x20URL\x20will\x20be\x20treated\x20as\x20a\x20filt\
    er\x20prefix.\x20For\x20example\x20s3:/bucket/images_folder/abc\x20will\
    \x20process\n\x20files\x20in\x20the\x20images_folder\x20beginning\x20wit\
    h\x20abc\x20or\x20in\x20a\x20subfolder\x20beginning\x20with\x20abc.\n\
    \x20For\x20example:\n\x20bucket/images_folder/abcImage.png\n\x20bucket/i\
    mages_folder/abc-1/Data.zip\n\n\x20If\x20given\x20URL\x20is\x20for\x20a\
    \x20private\x20bucket\x20or\x20file,\x20then\x20credentials\x20should\
    \x20be\x20provided\x20to\x20access\x20the\x20bucket.\n\x20Credentials\
    \x20should\x20include\x20rights\x20to\x20list\x20the\x20objects\x20in\
    \x20the\x20bucket,\x20except\x20when\x20pointed\x20directly\x20at\x20a\
    \x20file\x20archive,\n\x20in\x20which\x20case\x20it\x20only\x20requires\
    \x20rights\x20to\x20access\x20that\x20particular\x20file.\n\n\x0e\n\x06\
    \x06\0\x02\xca\x01\x01\x12\x04\xd6\x1a\x06\x1b\n\x0e\n\x06\x06\0\x02\xca\
    \x01\x02\x12\x04\xd6\x1a\x1d9\n\x0e\n\x06\x06\0\x02\xca\x01\x03\x12\x04\
    \xd6\x1aD]\n\x10\n\x06\x06\0\x02\xca\x01\x04\x12\x06\xd7\x1a\x04\xde\x1a\
    \x06\n\x14\n\n\x06\0\x02\xca\x01\x04\xb0\xca\xbc\"\x12\x06\xd7\x1a\x04\
    \xde\x1a\x06\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xdf\x1a\x047\n\
    \x11\n\t\x06\0\x02\xca\x01\x04\xc3\xf3\x04\x12\x04\xdf\x1a\x047\n\x0e\n\
    \x06\x06\0\x02\xca\x01\x04\x12\x04\xe0\x1a\x04?\n\x12\n\n\x06\0\x02\xca\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xe0\x1a\x04?\n\x0e\n\x06\x06\0\x02\xca\
    \x01\x04\x12\x04\xe1\x1a\x04F\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xe1\x1a\x04F\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\
    \xe2\x1a\x04F\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xe2\x1a\x04F\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xe3\x1a\x04C\n\
    \x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\x03\x12\x04\xe3\x1a\x04C\n\
    \x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xe4\x1a\x04A\n\x12\n\n\x06\0\
    \x02\xca\x01\x04\xc2\xf3\x04\x04\x12\x04\xe4\x1a\x04A\n\x0e\n\x06\x06\0\
    \x02\xca\x01\x04\x12\x04\xe5\x1a\x04A\n\x12\n\n\x06\0\x02\xca\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\xe5\x1a\x04A\n\x0e\n\x06\x06\0\x02\xca\x01\x04\
    \x12\x04\xe6\x1a\x04A\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\xe6\x1a\x04A\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xe7\x1a\
    \x04>\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\x07\x12\x04\xe7\x1a\
    \x04>\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\xe8\x1a\x04D\n\x12\n\n\
    \x06\0\x02\xca\x01\x04\xc2\xf3\x04\x08\x12\x04\xe8\x1a\x04D\n=\n\x05\x06\
    \0\x02\xcb\x01\x12\x06\xec\x1a\x02\xf6\x1a\x03\x1a,\x20Get\x20the\x20inp\
    ut\x20extraction\x20job\x20details\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\
    \xcb\x01\x01\x12\x04\xec\x1a\x06\x1c\n\x0e\n\x06\x06\0\x02\xcb\x01\x02\
    \x12\x04\xec\x1a\x1e;\n\x0e\n\x06\x06\0\x02\xcb\x01\x03\x12\x04\xec\x1aF\
    g\n\x10\n\x06\x06\0\x02\xcb\x01\x04\x12\x06\xed\x1a\x04\xf2\x1a\x06\n\
    \x14\n\n\x06\0\x02\xcb\x01\x04\xb0\xca\xbc\"\x12\x06\xed\x1a\x04\xf2\x1a\
    \x06\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\xf3\x1a\x047\n\x11\n\t\
    \x06\0\x02\xcb\x01\x04\xc3\xf3\x04\x12\x04\xf3\x1a\x047\n\x0e\n\x06\x06\
    \0\x02\xcb\x01\x04\x12\x04\xf4\x1a\x04?\n\x12\n\n\x06\0\x02\xcb\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xf4\x1a\x04?\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\
    \x12\x04\xf5\x1a\x04A\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xf5\x1a\x04A\n5\n\x05\x06\0\x02\xcc\x01\x12\x06\xf9\x1a\x02\x83\
    \x1b\x03\x1a$\x20List\x20all\x20the\x20input\x20extraction\x20jobs\n\n\
    \x0e\n\x06\x06\0\x02\xcc\x01\x01\x12\x04\xf9\x1a\x06\x1e\n\x0e\n\x06\x06\
    \0\x02\xcc\x01\x02\x12\x04\xf9\x1a\x20?\n\x0e\n\x06\x06\0\x02\xcc\x01\
    \x03\x12\x04\xf9\x1aJj\n\x10\n\x06\x06\0\x02\xcc\x01\x04\x12\x06\xfa\x1a\
    \x04\xff\x1a\x06\n\x14\n\n\x06\0\x02\xcc\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xfa\x1a\x04\xff\x1a\x06\n\x0e\n\x06\x06\0\x02\xcc\x01\x04\x12\x04\x80\
    \x1b\x047\n\x11\n\t\x06\0\x02\xcc\x01\x04\xc3\xf3\x04\x12\x04\x80\x1b\
    \x047\n\x0e\n\x06\x06\0\x02\xcc\x01\x04\x12\x04\x81\x1b\x04?\n\x12\n\n\
    \x06\0\x02\xcc\x01\x04\xc2\xf3\x04\0\x12\x04\x81\x1b\x04?\n\x0e\n\x06\
    \x06\0\x02\xcc\x01\x04\x12\x04\x82\x1b\x04A\n\x12\n\n\x06\0\x02\xcc\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x82\x1b\x04A\n\x0f\n\x05\x06\0\x02\xcd\x01\
    \x12\x06\x85\x1b\x02\x92\x1b\x03\n\x0e\n\x06\x06\0\x02\xcd\x01\x01\x12\
    \x04\x85\x1b\x06\x20\n\x0e\n\x06\x06\0\x02\xcd\x01\x02\x12\x04\x85\x1b\"\
    C\n\x0e\n\x06\x06\0\x02\xcd\x01\x03\x12\x04\x85\x1bNn\n\x10\n\x06\x06\0\
    \x02\xcd\x01\x04\x12\x06\x86\x1b\x04\x8d\x1b\x06\n\x14\n\n\x06\0\x02\xcd\
    \x01\x04\xb0\xca\xbc\"\x12\x06\x86\x1b\x04\x8d\x1b\x06\n\x0e\n\x06\x06\0\
    \x02\xcd\x01\x04\x12\x04\x8e\x1b\x047\n\x11\n\t\x06\0\x02\xcd\x01\x04\
    \xc3\xf3\x04\x12\x04\x8e\x1b\x047\n\x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\
    \x04\x8f\x1b\x04?\n\x12\n\n\x06\0\x02\xcd\x01\x04\xc2\xf3\x04\0\x12\x04\
    \x8f\x1b\x04?\n\x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\x04\x90\x1b\x04A\n\
    \x12\n\n\x06\0\x02\xcd\x01\x04\xc2\xf3\x04\x01\x12\x04\x90\x1b\x04A\n\
    \x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\x04\x91\x1b\x04A\n\x12\n\n\x06\0\
    \x02\xcd\x01\x04\xc2\xf3\x04\x02\x12\x04\x91\x1b\x04A\n\xe8\x02\n\x05\
    \x06\0\x02\xce\x01\x12\x06\x99\x1b\x02\xae\x1b\x03\x1a\xd6\x02\x20Start\
    \x20uploading\x20a\x20file\x20archive\x20containing\x20inputs.\n\x20Will\
    \x20create\x20and\x20return\x20an\x20inputs-add-job\x20for\x20tracking\
    \x20progress.\n\n\x20Associated\x20inputs-add-job\x20contains\x20an\x20u\
    pload\x20id\x20which\x20should\x20be\x20completed\x20through\x20`PutUplo\
    adContentParts`\x20endpoint.\n\x20Completing\x20the\x20upload\x20will\
    \x20automatically\x20begin\x20unpacking\x20the\x20archive\x20and\x20uplo\
    ading\x20the\x20contents\x20as\x20inputs.\n\n\x0e\n\x06\x06\0\x02\xce\
    \x01\x01\x12\x04\x99\x1b\x06\x17\n\x0e\n\x06\x06\0\x02\xce\x01\x02\x12\
    \x04\x99\x1b\x191\n\x0e\n\x06\x06\0\x02\xce\x01\x03\x12\x04\x99\x1b<U\n\
    \x10\n\x06\x06\0\x02\xce\x01\x04\x12\x06\x9a\x1b\x04\xa1\x1b\x06\n\x14\n\
    \n\x06\0\x02\xce\x01\x04\xb0\xca\xbc\"\x12\x06\x9a\x1b\x04\xa1\x1b\x06\n\
    \x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xa2\x1b\x047\n\x11\n\t\x06\0\
    \x02\xce\x01\x04\xc3\xf3\x04\x12\x04\xa2\x1b\x047\n\x0e\n\x06\x06\0\x02\
    \xce\x01\x04\x12\x04\xa3\x1b\x04?\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xa3\x1b\x04?\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\
    \x04\xa4\x1b\x04F\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xa4\x1b\x04F\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xa5\x1b\x04F\
    \n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\x02\x12\x04\xa5\x1b\x04F\n\
    \x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xa6\x1b\x04C\n\x12\n\n\x06\0\
    \x02\xce\x01\x04\xc2\xf3\x04\x03\x12\x04\xa6\x1b\x04C\n\x0e\n\x06\x06\0\
    \x02\xce\x01\x04\x12\x04\xa7\x1b\x04A\n\x12\n\n\x06\0\x02\xce\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xa7\x1b\x04A\n\x0e\n\x06\x06\0\x02\xce\x01\x04\
    \x12\x04\xa8\x1b\x04A\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xa8\x1b\x04A\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xa9\x1b\
    \x04A\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\x06\x12\x04\xa9\x1b\
    \x04A\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xaa\x1b\x04>\n\x12\n\n\
    \x06\0\x02\xce\x01\x04\xc2\xf3\x04\x07\x12\x04\xaa\x1b\x04>\n\x0e\n\x06\
    \x06\0\x02\xce\x01\x04\x12\x04\xab\x1b\x04D\n\x12\n\n\x06\0\x02\xce\x01\
    \x04\xc2\xf3\x04\x08\x12\x04\xab\x1b\x04D\n\x0e\n\x06\x06\0\x02\xce\x01\
    \x04\x12\x04\xac\x1b\x04B\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\t\
    \x12\x04\xac\x1b\x04B\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xad\x1b\
    \x04B\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\n\x12\x04\xad\x1b\x04B\
    \n5\n\x05\x06\0\x02\xcf\x01\x12\x06\xb3\x1b\x02\xba\x1b\x03\x1a$\x20Get\
    \x20a\x20specific\x20runner\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\
    \x02\xcf\x01\x01\x12\x04\xb3\x1b\x06\x0f\n\x0e\n\x06\x06\0\x02\xcf\x01\
    \x02\x12\x04\xb3\x1b\x11!\n\x0e\n\x06\x06\0\x02\xcf\x01\x03\x12\x04\xb3\
    \x1b,@\n\x10\n\x06\x06\0\x02\xcf\x01\x04\x12\x06\xb4\x1b\x04\xb6\x1b\x06\
    \n\x14\n\n\x06\0\x02\xcf\x01\x04\xb0\xca\xbc\"\x12\x06\xb4\x1b\x04\xb6\
    \x1b\x06\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xb7\x1b\x047\n\x11\n\
    \t\x06\0\x02\xcf\x01\x04\xc3\xf3\x04\x12\x04\xb7\x1b\x047\n\x0e\n\x06\
    \x06\0\x02\xcf\x01\x04\x12\x04\xb8\x1b\x04?\n\x12\n\n\x06\0\x02\xcf\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xb8\x1b\x04?\n\x0e\n\x06\x06\0\x02\xcf\x01\
    \x04\x12\x04\xb9\x1b\x04B\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xb9\x1b\x04B\nH\n\x05\x06\0\x02\xd0\x01\x12\x06\xbd\x1b\x02\
    \xc4\x1b\x03\x1a7\x20List\x20all\x20the\x20runners\x20in\x20community,\
    \x20by\x20user\x20or\x20by\x20app.\n\n\x0e\n\x06\x06\0\x02\xd0\x01\x01\
    \x12\x04\xbd\x1b\x06\x11\n\x0e\n\x06\x06\0\x02\xd0\x01\x02\x12\x04\xbd\
    \x1b\x13%\n\x0e\n\x06\x06\0\x02\xd0\x01\x03\x12\x04\xbd\x1b0C\n\x10\n\
    \x06\x06\0\x02\xd0\x01\x04\x12\x06\xbe\x1b\x04\xc0\x1b\x06\n\x14\n\n\x06\
    \0\x02\xd0\x01\x04\xb0\xca\xbc\"\x12\x06\xbe\x1b\x04\xc0\x1b\x06\n\x0e\n\
    \x06\x06\0\x02\xd0\x01\x04\x12\x04\xc1\x1b\x047\n\x11\n\t\x06\0\x02\xd0\
    \x01\x04\xc3\xf3\x04\x12\x04\xc1\x1b\x047\n\x0e\n\x06\x06\0\x02\xd0\x01\
    \x04\x12\x04\xc2\x1b\x04?\n\x12\n\n\x06\0\x02\xd0\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xc2\x1b\x04?\n\x0e\n\x06\x06\0\x02\xd0\x01\x04\x12\x04\xc3\x1b\
    \x04B\n\x12\n\n\x06\0\x02\xd0\x01\x04\xc2\xf3\x04\x01\x12\x04\xc3\x1b\
    \x04B\n+\n\x05\x06\0\x02\xd1\x01\x12\x06\xc7\x1b\x02\xd0\x1b\x03\x1a\x1a\
    \x20Add\x20a\x20runners\x20to\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xd1\
    \x01\x01\x12\x04\xc7\x1b\x06\x11\n\x0e\n\x06\x06\0\x02\xd1\x01\x02\x12\
    \x04\xc7\x1b\x13%\n\x0e\n\x06\x06\0\x02\xd1\x01\x03\x12\x04\xc7\x1b0C\n\
    \x10\n\x06\x06\0\x02\xd1\x01\x04\x12\x06\xc8\x1b\x04\xcb\x1b\x06\n\x14\n\
    \n\x06\0\x02\xd1\x01\x04\xb0\xca\xbc\"\x12\x06\xc8\x1b\x04\xcb\x1b\x06\n\
    \x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\xcc\x1b\x047\n\x11\n\t\x06\0\
    \x02\xd1\x01\x04\xc3\xf3\x04\x12\x04\xcc\x1b\x047\n\x0e\n\x06\x06\0\x02\
    \xd1\x01\x04\x12\x04\xcd\x1b\x04?\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xcd\x1b\x04?\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\
    \x04\xce\x1b\x04B\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xce\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\xcf\x1b\x04B\
    \n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x02\x12\x04\xcf\x1b\x04B\n:\
    \n\x05\x06\0\x02\xd2\x01\x12\x06\xd3\x1b\x02\xdd\x1b\x03\x1a)\x20Delete\
    \x20multiple\x20runners\x20in\x20one\x20request.\n\n\x0e\n\x06\x06\0\x02\
    \xd2\x01\x01\x12\x04\xd3\x1b\x06\x13\n\x0e\n\x06\x06\0\x02\xd2\x01\x02\
    \x12\x04\xd3\x1b\x15)\n\x0e\n\x06\x06\0\x02\xd2\x01\x03\x12\x04\xd3\x1b4\
    T\n\x10\n\x06\x06\0\x02\xd2\x01\x04\x12\x06\xd4\x1b\x04\xd7\x1b\x06\n\
    \x14\n\n\x06\0\x02\xd2\x01\x04\xb0\xca\xbc\"\x12\x06\xd4\x1b\x04\xd7\x1b\
    \x06\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\x12\x04\xd8\x1b\x047\n\x11\n\t\
    \x06\0\x02\xd2\x01\x04\xc3\xf3\x04\x12\x04\xd8\x1b\x047\n\x0e\n\x06\x06\
    \0\x02\xd2\x01\x04\x12\x04\xd9\x1b\x04?\n\x12\n\n\x06\0\x02\xd2\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xd9\x1b\x04?\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\
    \x12\x04\xda\x1b\x04B\n\x12\n\n\x06\0\x02\xd2\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xda\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\x12\x04\xdb\x1b\
    \x04B\n\x12\n\n\x06\0\x02\xd2\x01\x04\xc2\xf3\x04\x02\x12\x04\xdb\x1b\
    \x04B\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\x12\x04\xdc\x1b\x04E\n\x12\n\n\
    \x06\0\x02\xd2\x01\x04\xc2\xf3\x04\x03\x12\x04\xdc\x1b\x04E\n?\n\x05\x06\
    \0\x02\xd3\x01\x12\x06\xe0\x1b\x02\xe8\x1b\x03\x1a.\x20List\x20items\x20\
    for\x20the\x20remote\x20runner\x20to\x20work\x20on.\n\n\x0e\n\x06\x06\0\
    \x02\xd3\x01\x01\x12\x04\xe0\x1b\x06\x15\n\x0e\n\x06\x06\0\x02\xd3\x01\
    \x02\x12\x04\xe0\x1b\x17-\n\x0e\n\x06\x06\0\x02\xd3\x01\x03\x12\x04\xe0\
    \x1b8O\n\x10\n\x06\x06\0\x02\xd3\x01\x04\x12\x06\xe1\x1b\x04\xe3\x1b\x06\
    \n\x14\n\n\x06\0\x02\xd3\x01\x04\xb0\xca\xbc\"\x12\x06\xe1\x1b\x04\xe3\
    \x1b\x06\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\x04\xe4\x1b\x047\n\x11\n\
    \t\x06\0\x02\xd3\x01\x04\xc3\xf3\x04\x12\x04\xe4\x1b\x047\n\x0e\n\x06\
    \x06\0\x02\xd3\x01\x04\x12\x04\xe5\x1b\x04?\n\x12\n\n\x06\0\x02\xd3\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xe5\x1b\x04?\n\x0e\n\x06\x06\0\x02\xd3\x01\
    \x04\x12\x04\xe6\x1b\x04B\n\x12\n\n\x06\0\x02\xd3\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xe6\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\x04\xe7\
    \x1b\x04F\n\x12\n\n\x06\0\x02\xd3\x01\x04\xc2\xf3\x04\x02\x12\x04\xe7\
    \x1b\x04F\n8\n\x05\x06\0\x02\xd4\x01\x12\x06\xeb\x1b\x02\xf5\x1b\x03\x1a\
    '\x20Post\x20back\x20outputs\x20from\x20remote\x20runners\n\n\x0e\n\x06\
    \x06\0\x02\xd4\x01\x01\x12\x04\xeb\x1b\x06\x1b\n\x0e\n\x06\x06\0\x02\xd4\
    \x01\x02\x12\x04\xeb\x1b\x1d9\n\x0e\n\x06\x06\0\x02\xd4\x01\x03\x12\x04\
    \xeb\x1bDa\n\x10\n\x06\x06\0\x02\xd4\x01\x04\x12\x06\xec\x1b\x04\xef\x1b\
    \x06\n\x14\n\n\x06\0\x02\xd4\x01\x04\xb0\xca\xbc\"\x12\x06\xec\x1b\x04\
    \xef\x1b\x06\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\x04\xf0\x1b\x047\n\
    \x11\n\t\x06\0\x02\xd4\x01\x04\xc3\xf3\x04\x12\x04\xf0\x1b\x047\n\x0e\n\
    \x06\x06\0\x02\xd4\x01\x04\x12\x04\xf1\x1b\x04?\n\x12\n\n\x06\0\x02\xd4\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xf1\x1b\x04?\n\x0e\n\x06\x06\0\x02\xd4\
    \x01\x04\x12\x04\xf2\x1b\x04B\n\x12\n\n\x06\0\x02\xd4\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xf2\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\x04\
    \xf3\x1b\x04F\n\x12\n\n\x06\0\x02\xd4\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xf3\x1b\x04F\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\x04\xf4\x1b\x04F\n\
    \x12\n\n\x06\0\x02\xd4\x01\x04\xc2\xf3\x04\x03\x12\x04\xf4\x1b\x04F\n-\n\
    \x02\x04\0\x12\x06\xfd\x1b\0\x82\x1c\x01\x1a\x1f\x20Split\x20the\x20resu\
    lts\x20into\x20pages.\n\n\x0b\n\x03\x04\0\x01\x12\x04\xfd\x1b\x08\x12\n}\
    \n\x04\x04\0\x02\0\x12\x04\xff\x1b\x02\x12\x1ao\x20(optional\x20URL\x20p\
    arameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\
    \x20split\x20the\x20results\x20into\x20chunks.\x20Defaults\x20to\x201.\n\
    \n\r\n\x05\x04\0\x02\0\x05\x12\x04\xff\x1b\x02\x08\n\r\n\x05\x04\0\x02\0\
    \x01\x12\x04\xff\x1b\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xff\x1b\x10\
    \x11\nt\n\x04\x04\0\x02\x01\x12\x04\x81\x1c\x02\x16\x1af\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\x20to\x20128.\n\n\
    \r\n\x05\x04\0\x02\x01\x05\x12\x04\x81\x1c\x02\x08\n\r\n\x05\x04\0\x02\
    \x01\x01\x12\x04\x81\x1c\t\x11\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x81\
    \x1c\x14\x15\n$\n\x02\x04\x01\x12\x06\x85\x1c\0\x89\x1c\x01\x1a\x16\x20G\
    etAnnotationRequest\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x85\x1c\x08\x1c\n\
    \x0c\n\x04\x04\x01\x02\0\x12\x04\x86\x1c\x02,\n\r\n\x05\x04\x01\x02\0\
    \x06\x12\x04\x86\x1c\x02\x1b\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x86\x1c\
    \x1c'\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x86\x1c*+\n\x0c\n\x04\x04\x01\
    \x02\x01\x12\x04\x87\x1c\x02\x1b\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\
    \x87\x1c\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x87\x1c\t\x16\n\r\
    \n\x05\x04\x01\x02\x01\x03\x12\x04\x87\x1c\x19\x1a\n\x0c\n\x04\x04\x01\
    \x02\x02\x12\x04\x88\x1c\x02\x16\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\
    \x88\x1c\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\x88\x1c\t\x11\n\r\
    \n\x05\x04\x01\x02\x02\x03\x12\x04\x88\x1c\x14\x15\n&\n\x02\x04\x02\x12\
    \x06\x8c\x1c\0\xbe\x1c\x01\x1a\x18\x20ListAnnotationsRequest\n\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\x8c\x1c\x08\x1e\n\x0b\n\x03\x04\x02\t\x12\x04\
    \x8d\x1c\x02\r\n\x0c\n\x04\x04\x02\t\0\x12\x04\x8d\x1c\x0b\x0c\n\r\n\x05\
    \x04\x02\t\0\x01\x12\x04\x8d\x1c\x0b\x0c\n\r\n\x05\x04\x02\t\0\x02\x12\
    \x04\x8d\x1c\x0b\x0c\n\x0c\n\x04\x04\x02\x02\0\x12\x04\x8f\x1c\x02,\n\r\
    \n\x05\x04\x02\x02\0\x06\x12\x04\x8f\x1c\x02\x1b\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\x8f\x1c\x1c'\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x8f\x1c*+\
    \n.\n\x04\x04\x02\x02\x01\x12\x04\x92\x1c\x02\x1a\x1a\x20\x20List\x20ann\
    otations\x20for\x20these\x20IDs\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\
    \x92\x1c\x02\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\x92\x1c\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x01\x01\x12\x04\x92\x1c\x12\x15\n\r\n\x05\x04\x02\x02\
    \x01\x03\x12\x04\x92\x1c\x18\x19\n\xd5\x02\n\x04\x04\x02\x02\x02\x12\x04\
    \x99\x1c\x02\x20\x1a\xc6\x02\x20List\x20annotations\x20for\x20these\x20I\
    nput\x20IDs\n\x20Note\x20that\x20'ids'\x20are\x20optional\x20but\x20if\
    \x20the\x20are\x20provided\x20the\x20number\x20and\x20order\x20in\n\x20'\
    ids'\x20and\x20'input_ids'\x20should\x20match\n\x20If\x20you\x20do\x20no\
    t\x20specify\x20'ids'\x20all\x20the\x20annotations\x20for\x20'input_ids'\
    \x20are\x20returned\n\x20If\x20a\x20you\x20do\x20not\x20specify\x20both\
    \x20'input_ids'\x20and\x20'ids'\x20all\x20the\x20annotations\x20in\x20th\
    e\x20app\x20are\x20returned\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\x99\
    \x1c\x02\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\x99\x1c\x0b\x11\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\x99\x1c\x12\x1b\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\x99\x1c\x1e\x1f\n\xe6\x03\n\x04\x04\x02\x02\x03\x12\x04\
    \xa1\x1c\x02\x1f\x1a\xd7\x03\x20Only\x20return\x20the\x20annotations\x20\
    that\x20has\x20one\x20of\x20these\x20user\x20IDs,\x20effectively\x20oper\
    ating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20th\
    e\x20results.\n\x20If\x20model_version_ids\x20are\x20also\x20provided\
    \x20these\x20user_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20si\
    nce\n\x20annotations\x20are\x20either\x20provided\x20by\x20users\x20or\
    \x20model\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\x20any\
    \n\x20provided\x20user\x20or\x20model\x20version\x20annotations\x20in\
    \x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20If\x20no\
    \x20user_ids\x20are\x20provided\x20then\x20annotations\x20from\x20all\
    \x20users\x20are\x20returned.\n\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\
    \xa1\x1c\x02\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xa1\x1c\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x03\x01\x12\x04\xa1\x1c\x12\x1a\n\r\n\x05\x04\x02\x02\
    \x03\x03\x12\x04\xa1\x1c\x1d\x1e\n\x82\x04\n\x04\x04\x02\x02\x04\x12\x04\
    \xa9\x1c\x02)\x1a\xf3\x03\x20Only\x20return\x20the\x20annotations\x20tha\
    t\x20has\x20one\x20of\x20these\x20model\x20version\x20IDs,\x20effectivel\
    y\x20operating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20d\
    own\x20the\x20results.\n\x20If\x20user_ids\x20are\x20also\x20provided\
    \x20these\x20model_versions_ids\x20are\x20OR'd\x20with\x20them\x20as\x20\
    well\x20since\n\x20annotations\x20are\x20either\x20provided\x20by\x20use\
    rs\x20or\x20model\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\
    \x20any\n\x20provided\x20user\x20or\x20model\x20version\x20annotations\
    \x20in\x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20If\
    \x20no\x20model_version_ids\x20are\x20provided\x20then\x20annotations\
    \x20from\x20all\x20model\x20versions\x20are\x20returned.\n\n\r\n\x05\x04\
    \x02\x02\x04\x04\x12\x04\xa9\x1c\x02\n\n\r\n\x05\x04\x02\x02\x04\x05\x12\
    \x04\xa9\x1c\x0b\x11\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xa9\x1c\x12#\
    \n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xa9\x1c&(\n\x8b\x01\n\x04\x04\x02\
    \x02\x05\x12\x04\xad\x1c\x023\x1a}\x20Set\x20status\x20to\x20filter\x20b\
    y\x20a\x20list\x20of\x20statuses\n\x20If\x20not\x20statuses\x20are\x20pr\
    ovided\x20then\x20annotations\x20with\x20any\x20status\x20will\x20be\x20\
    returned.\n\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04\xad\x1c\x02\n\n\r\n\
    \x05\x04\x02\x02\x05\x06\x12\x04\xad\x1c\x0b%\n\r\n\x05\x04\x02\x02\x05\
    \x01\x12\x04\xad\x1c&.\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xad\x1c12\n\
    \x80\x01\n\x04\x04\x02\x02\x06\x12\x04\xb1\x1c\x02\x20\x1ar\x20Set\x20th\
    is\x20flag\x20to\x20list\x20both\x20trusted\x20and\x20not\x20trusted\x20\
    annotations\n\x20by\x20default\x20it's\x20listing\x20only\x20trusted\x20\
    annotations\n\n\r\n\x05\x04\x02\x02\x06\x05\x12\x04\xb1\x1c\x02\x06\n\r\
    \n\x05\x04\x02\x02\x06\x01\x12\x04\xb1\x1c\x07\x1b\n\r\n\x05\x04\x02\x02\
    \x06\x03\x12\x04\xb1\x1c\x1e\x1f\n_\n\x04\x04\x02\x02\x07\x12\x04\xb4\
    \x1c\x02\x20\x1aQ\x20Set\x20this\x20flag\x20to\x20return\x20the\x20model\
    \x20output\x20for\x20model\x20annotations\x20in\x20the\x20response.\n\n\
    \r\n\x05\x04\x02\x02\x07\x05\x12\x04\xb4\x1c\x02\x06\n\r\n\x05\x04\x02\
    \x02\x07\x01\x12\x04\xb4\x1c\x07\x1a\n\r\n\x05\x04\x02\x02\x07\x03\x12\
    \x04\xb4\x1c\x1d\x1f\n~\n\x04\x04\x02\x02\x08\x12\x04\xb8\x1c\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x02\x02\x08\x05\x12\x04\xb8\
    \x1c\x02\x08\n\r\n\x05\x04\x02\x02\x08\x01\x12\x04\xb8\x1c\t\r\n\r\n\x05\
    \x04\x02\x02\x08\x03\x12\x04\xb8\x1c\x10\x11\nu\n\x04\x04\x02\x02\t\x12\
    \x04\xbb\x1c\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20nu\
    mber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x02\x02\t\x05\x12\
    \x04\xbb\x1c\x02\x08\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\xbb\x1c\t\x11\n\
    \r\n\x05\x04\x02\x02\t\x03\x12\x04\xbb\x1c\x14\x15\n5\n\x04\x04\x02\x02\
    \n\x12\x04\xbd\x1c\x02\x16\x1a'\x20Flag\x20to\x20filter\x20annotations\
    \x20by\x20task_id\n\n\r\n\x05\x04\x02\x02\n\x05\x12\x04\xbd\x1c\x02\x08\
    \n\r\n\x05\x04\x02\x02\n\x01\x12\x04\xbd\x1c\t\x10\n\r\n\x05\x04\x02\x02\
    \n\x03\x12\x04\xbd\x1c\x13\x15\n&\n\x02\x04\x03\x12\x06\xc1\x1c\0\xc6\
    \x1c\x01\x1a\x18\x20PostAnnotationsRequest\n\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\xc1\x1c\x08\x1e\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xc3\x1c\x02,\n\r\
    \n\x05\x04\x03\x02\0\x06\x12\x04\xc3\x1c\x02\x1b\n\r\n\x05\x04\x03\x02\0\
    \x01\x12\x04\xc3\x1c\x1c'\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xc3\x1c*+\
    \n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xc5\x1c\x02&\n\r\n\x05\x04\x03\x02\
    \x01\x04\x12\x04\xc5\x1c\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xc5\
    \x1c\x0b\x15\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xc5\x1c\x16!\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\xc5\x1c$%\n'\n\x02\x04\x04\x12\x06\xc9\
    \x1c\0\xd6\x1c\x01\x1a\x19\x20PatchAnnotationsRequest\n\n\x0b\n\x03\x04\
    \x04\x01\x12\x04\xc9\x1c\x08\x1f\n\x0c\n\x04\x04\x04\x02\0\x12\x04\xca\
    \x1c\x02,\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xca\x1c\x02\x1b\n\r\n\x05\
    \x04\x04\x02\0\x01\x12\x04\xca\x1c\x1c'\n\r\n\x05\x04\x04\x02\0\x03\x12\
    \x04\xca\x1c*+\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\xcc\x1c\x02&\n\r\n\
    \x05\x04\x04\x02\x01\x04\x12\x04\xcc\x1c\x02\n\n\r\n\x05\x04\x04\x02\x01\
    \x06\x12\x04\xcc\x1c\x0b\x15\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xcc\
    \x1c\x16!\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xcc\x1c$%\n~\n\x04\x04\
    \x04\x02\x02\x12\x04\xd0\x1c\x02\x14\x1ap\x20The\x20action\x20to\x20perf\
    orm\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'me\
    rge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\r\n\x05\
    \x04\x04\x02\x02\x05\x12\x04\xd0\x1c\x02\x08\n\r\n\x05\x04\x04\x02\x02\
    \x01\x12\x04\xd0\x1c\t\x0f\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xd0\x1c\
    \x12\x13\n\xee\x01\n\x04\x04\x04\x02\x03\x12\x04\xd5\x1c\x02\x20\x1a\xdf\
    \x01\x20If\x20the\x20request\x20is\x20a\x20\"remove\"\x20action\x20and\
    \x20the\x20annotation\x20is\x20left\x20with\x20empty\x20data,\n\x20then\
    \x20setting\x20delete_if_empty_data\x20to\x20true\x20will\x20delete\x20t\
    he\x20annotation,\n\x20if\x20possible\x20(for\x20example,\x20will\x20not\
    \x20delete\x20an\x20input-level\x20annotation).\n\n\r\n\x05\x04\x04\x02\
    \x03\x05\x12\x04\xd5\x1c\x02\x06\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\
    \xd5\x1c\x07\x1b\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xd5\x1c\x1e\x1f\n\
    -\n\x02\x04\x05\x12\x06\xd9\x1c\0\xe2\x1c\x01\x1a\x1f\x20PatchAnnotation\
    sStatusRequest\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xd9\x1c\x08%\n\x0c\n\
    \x04\x04\x05\x02\0\x12\x04\xda\x1c\x02,\n\r\n\x05\x04\x05\x02\0\x06\x12\
    \x04\xda\x1c\x02\x1b\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xda\x1c\x1c'\n\
    \r\n\x05\x04\x05\x02\0\x03\x12\x04\xda\x1c*+\n&\n\x04\x04\x05\x02\x01\
    \x12\x04\xdc\x1c\x021\x1a\x18\x20Annotation\x20Status\x20code\n\n\r\n\
    \x05\x04\x05\x02\x01\x06\x12\x04\xdc\x1c\x02\x20\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\xdc\x1c!,\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xdc\x1c\
    /0\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\xdd\x1c\x02\x1f\n\r\n\x05\x04\x05\
    \x02\x02\x04\x12\x04\xdd\x1c\x02\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\
    \xdd\x1c\x0b\x11\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xdd\x1c\x12\x1a\n\
    \r\n\x05\x04\x05\x02\x02\x03\x12\x04\xdd\x1c\x1d\x1e\n\x0c\n\x04\x04\x05\
    \x02\x03\x12\x04\xde\x1c\x02\x15\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\
    \xde\x1c\x02\x08\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xde\x1c\t\x10\n\r\
    \n\x05\x04\x05\x02\x03\x03\x12\x04\xde\x1c\x13\x14\n(\n\x04\x04\x05\x02\
    \x04\x12\x04\xe0\x1c\x02\x14\x1a\x1a\x20'overwrite'\x20is\x20supported\n\
    \n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\xe0\x1c\x02\x08\n\r\n\x05\x04\x05\
    \x02\x04\x01\x12\x04\xe0\x1c\t\x0f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\
    \xe0\x1c\x12\x13\n.\n\x02\x04\x06\x12\x06\xe5\x1c\0\xe9\x1c\x01\x1a\x20\
    \x20PatchAnnotationsStatusResponse\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xe5\
    \x1c\x08&\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xe6\x1c\x02(\n\r\n\x05\x04\
    \x06\x02\0\x06\x12\x04\xe6\x1c\x02\x1c\n\r\n\x05\x04\x06\x02\0\x01\x12\
    \x04\xe6\x1c\x1d#\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xe6\x1c&'\n\x0c\n\
    \x04\x04\x06\x02\x01\x12\x04\xe7\x1c\x02\x1f\n\r\n\x05\x04\x06\x02\x01\
    \x04\x12\x04\xe7\x1c\x02\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xe7\x1c\
    \x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xe7\x1c\x12\x1a\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\xe7\x1c\x1d\x1e\n\x0c\n\x04\x04\x06\x02\x02\
    \x12\x04\xe8\x1c\x02\x1b\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xe8\x1c\
    \x02\x08\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xe8\x1c\t\x16\n\r\n\x05\
    \x04\x06\x02\x02\x03\x12\x04\xe8\x1c\x19\x1a\n'\n\x02\x04\x07\x12\x06\
    \xec\x1c\0\xf2\x1c\x01\x1a\x19\x20DeleteAnnotationRequest\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xec\x1c\x08\x1f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \xed\x1c\x02,\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xed\x1c\x02\x1b\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\xed\x1c\x1c'\n\r\n\x05\x04\x07\x02\0\x03\
    \x12\x04\xed\x1c*+\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xef\x1c\x02\x16\n\
    \r\n\x05\x04\x07\x02\x01\x05\x12\x04\xef\x1c\x02\x08\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xef\x1c\t\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xef\x1c\x14\x15\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xf1\x1c\x02\x1b\n\r\
    \n\x05\x04\x07\x02\x02\x05\x12\x04\xf1\x1c\x02\x08\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xf1\x1c\t\x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xf1\
    \x1c\x19\x1a\nD\n\x02\x04\x08\x12\x06\xf5\x1c\0\x82\x1d\x01\x1a6\x20Requ\
    est\x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20i\
    ds.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xf5\x1c\x08\x20\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\xf6\x1c\x02,\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xf6\
    \x1c\x02\x1b\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xf6\x1c\x1c'\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xf6\x1c*+\n+\n\x04\x04\x08\x02\x01\x12\x04\
    \xf9\x1c\x02\x1a\x1a\x1d\x20Delete\x20annotations\x20with\x20IDs\n\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x04\xf9\x1c\x02\n\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\xf9\x1c\x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xf9\
    \x1c\x12\x15\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xf9\x1c\x18\x19\n\xf0\
    \x02\n\x04\x04\x08\x02\x02\x12\x04\x81\x1d\x02\x20\x1a\xe1\x02\x20Delete\
    \x20annotations\x20for\x20these\x20Input\x20IDs\n\x20Note\x20that\x20'id\
    s'\x20are\x20optional\x20but\x20if\x20the\x20are\x20provided\x20the\x20n\
    umber\x20and\x20order\x20in\n\x20'ids'\x20and\x20'input_ids'\x20should\
    \x20match\n\x20If\x20you\x20do\x20not\x20specifiy\x20'ids'\x20all\x20the\
    \x20annotations\x20for\x20'input_ids'\x20are\x20deleted\n\x20However\x20\
    you\x20need\x20to\x20specify\x20at\x20least\x20one\x20value\x20for\x20'i\
    nput_ids'\n\x20i.e.\x20this\x20API\x20does\x20not\x20support\x20deleting\
    \x20all\x20annotations\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x81\x1d\
    \x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x81\x1d\x0b\x11\n\r\n\x05\
    \x04\x08\x02\x02\x01\x12\x04\x81\x1d\x12\x1b\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\x81\x1d\x1e\x1f\n(\n\x02\x04\t\x12\x06\x85\x1d\0\x88\x1d\
    \x01\x1a\x1a\x20SingleAnnotationResponse\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \x85\x1d\x08\x20\n\x0c\n\x04\x04\t\x02\0\x12\x04\x86\x1d\x02(\n\r\n\x05\
    \x04\t\x02\0\x06\x12\x04\x86\x1d\x02\x1c\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\x86\x1d\x1d#\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x86\x1d&'\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\x87\x1d\x02\x1c\n\r\n\x05\x04\t\x02\x01\x06\
    \x12\x04\x87\x1d\x02\x0c\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x87\x1d\r\
    \x17\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x87\x1d\x1a\x1b\n'\n\x02\x04\n\
    \x12\x06\x8b\x1d\0\x8f\x1d\x01\x1a\x19\x20MultiAnnotationResponse\n\n\
    \x0b\n\x03\x04\n\x01\x12\x04\x8b\x1d\x08\x1f\n\x0c\n\x04\x04\n\x02\0\x12\
    \x04\x8c\x1d\x02(\n\r\n\x05\x04\n\x02\0\x06\x12\x04\x8c\x1d\x02\x1c\n\r\
    \n\x05\x04\n\x02\0\x01\x12\x04\x8c\x1d\x1d#\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\x8c\x1d&'\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x8e\x1d\x02U\n\r\n\
    \x05\x04\n\x02\x01\x04\x12\x04\x8e\x1d\x02\n\n\r\n\x05\x04\n\x02\x01\x06\
    \x12\x04\x8e\x1d\x0b\x15\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x8e\x1d\x16\
    !\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x8e\x1d$%\n\r\n\x05\x04\n\x02\x01\
    \x08\x12\x04\x8e\x1d&T\n\x10\n\x08\x04\n\x02\x01\x08\xd0\x86\x03\x12\x04\
    \x8e\x1d'S\n\x1d\n\x02\x04\x0b\x12\x06\x92\x1d\0\x96\x1d\x01\x1a\x0f\x20\
    GetAppRequest\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x92\x1d\x08\x15\n\x0c\n\
    \x04\x04\x0b\x02\0\x12\x04\x93\x1d\x02,\n\r\n\x05\x04\x0b\x02\0\x06\x12\
    \x04\x93\x1d\x02\x1b\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x93\x1d\x1c'\n\
    \r\n\x05\x04\x0b\x02\0\x03\x12\x04\x93\x1d*+\n\x82\x01\n\x04\x04\x0b\x02\
    \x01\x12\x04\x95\x1d\x02(\x1at\x20(optional\x20URL\x20parameter)\x20List\
    \x20of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20the\x20r\
    esponse.\x20Currently\x20supported:\x20all,\x20stars\n\n\r\n\x05\x04\x0b\
    \x02\x01\x04\x12\x04\x95\x1d\x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \x95\x1d\x0b\x11\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x95\x1d\x12#\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\x95\x1d&'\n\x1f\n\x02\x04\x0c\x12\x06\
    \x99\x1d\0\xbf\x1d\x01\x1a\x11\x20ListAppsRequest\n\n\x0b\n\x03\x04\x0c\
    \x01\x12\x04\x99\x1d\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x9a\x1d\
    \x02,\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x9a\x1d\x02\x1b\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\x9a\x1d\x1c'\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\
    \x9a\x1d*+\n~\n\x04\x04\x0c\x02\x01\x12\x04\x9d\x1d\x02\x12\x1ap\x20(opt\
    ional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x9d\x1d\x02\x08\n\
    \r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x9d\x1d\t\r\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\x9d\x1d\x10\x11\nu\n\x04\x04\x0c\x02\x02\x12\x04\xa0\
    \x1d\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xa0\
    \x1d\x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xa0\x1d\t\x11\n\r\n\
    \x05\x04\x0c\x02\x02\x03\x12\x04\xa0\x1d\x14\x15\no\n\x04\x04\x0c\x02\
    \x03\x12\x04\xa4\x1d\x03\x1b\x1aa\x20Sorting\x20opitons:\n\x20Whether\
    \x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\x20will\x20o\
    rder\x20in\x20descending\x20order.\n\n\r\n\x05\x04\x0c\x02\x03\x05\x12\
    \x04\xa4\x1d\x03\x07\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xa4\x1d\x08\
    \x16\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xa4\x1d\x19\x1a\n\x0e\n\x04\
    \x04\x0c\x08\0\x12\x06\xa5\x1d\x03\xaf\x1d\x04\n\r\n\x05\x04\x0c\x08\0\
    \x01\x12\x04\xa5\x1d\t\x10\n,\n\x04\x04\x0c\x02\x04\x12\x04\xa7\x1d\x04\
    \x1a\x1a\x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\r\n\x05\
    \x04\x0c\x02\x04\x05\x12\x04\xa7\x1d\x04\x08\n\r\n\x05\x04\x0c\x02\x04\
    \x01\x12\x04\xa7\x1d\t\x15\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xa7\x1d\
    \x18\x19\n\x80\x01\n\x04\x04\x0c\x02\x05\x12\x04\xaa\x1d\x04!\x1ar\x20Wh\
    ether\x20to\x20order\x20by\x20the\x20modified_at\x20time.\n\x20If\x20non\
    e\x20of\x20the\x20sort\x20options\x20is\x20set\x20to\x20true,\x20will\
    \x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\
    \xaa\x1d\x04\x08\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xaa\x1d\t\x1c\n\r\
    \n\x05\x04\x0c\x02\x05\x03\x12\x04\xaa\x1d\x1f\x20\n8\n\x04\x04\x0c\x02\
    \x06\x12\x04\xac\x1d\x04!\x1a*\x20Whether\x20to\x20order\x20by\x20the\
    \x20created_at\x20time.\n\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xac\x1d\
    \x04\x08\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xac\x1d\t\x1b\n\r\n\x05\
    \x04\x0c\x02\x06\x03\x12\x04\xac\x1d\x1e\x20\nF\n\x04\x04\x0c\x02\x07\
    \x12\x04\xae\x1d\x04!\x1a8\x20Whether\x20to\x20order\x20by\x20the\x20num\
    ber\x20of\x20users\x20stared\x20the\x20app\n\n\r\n\x05\x04\x0c\x02\x07\
    \x05\x12\x04\xae\x1d\x04\x08\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\xae\
    \x1d\t\x1b\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xae\x1d\x1e\x20\nl\n\
    \x04\x04\x0c\x02\x08\x12\x04\xb3\x1d\x02\x13\x1a^\x20Filtering\x20option\
    s:\n\x20Query\x20various\x20text\x20fields\x20that\x20can\x20contain\x20\
    the\x20words\x20in\x20the\x20query\x20string\n\n\r\n\x05\x04\x0c\x02\x08\
    \x05\x12\x04\xb3\x1d\x02\x08\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\xb3\
    \x1d\t\x0e\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\xb3\x1d\x11\x12\n\x99\
    \x01\n\x04\x04\x0c\x02\t\x12\x04\xb6\x1d\x02&\x1a\x8a\x01\x20Filter\x20b\
    y\x20the\x20name\x20of\x20the\x20app.\x20This\x20supports\x20wilcard\x20\
    queries\x20like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\
    \x20example.\n\x20Deprecated\x20in\x20favor\x20of\x20query\n\n\r\n\x05\
    \x04\x0c\x02\t\x05\x12\x04\xb6\x1d\x02\x08\n\r\n\x05\x04\x0c\x02\t\x01\
    \x12\x04\xb6\x1d\t\r\n\r\n\x05\x04\x0c\x02\t\x03\x12\x04\xb6\x1d\x10\x11\
    \n\r\n\x05\x04\x0c\x02\t\x08\x12\x04\xb6\x1d\x12%\n\x0e\n\x06\x04\x0c\
    \x02\t\x08\x03\x12\x04\xb6\x1d\x13$\n\x84\x01\n\x04\x04\x0c\x02\n\x12\
    \x04\xb8\x1d\x02\x11\x1av\x20Filter\x20by\x20the\x20user-unique-id\x20of\
    \x20the\x20app.\x20This\x20supports\x20wilcard\x20queries\x20like\x20\"g\
    en*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\n\r\n\x05\
    \x04\x0c\x02\n\x05\x12\x04\xb8\x1d\x02\x08\n\r\n\x05\x04\x0c\x02\n\x01\
    \x12\x04\xb8\x1d\t\x0b\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\xb8\x1d\x0e\
    \x10\nR\n\x04\x04\x0c\x02\x0b\x12\x04\xba\x1d\x02\x19\x1aD\x20If\x20true\
    ,\x20we\x20only\x20return\x20apps\x20that\x20are\x20handpicked\x20by\x20\
    clarifai\x20staff\n\n\r\n\x05\x04\x0c\x02\x0b\x05\x12\x04\xba\x1d\x02\
    \x06\n\r\n\x05\x04\x0c\x02\x0b\x01\x12\x04\xba\x1d\x07\x14\n\r\n\x05\x04\
    \x0c\x02\x0b\x03\x12\x04\xba\x1d\x17\x18\nT\n\x04\x04\x0c\x02\x0c\x12\
    \x04\xbc\x1d\x02\x19\x1aF\x20If\x20true,\x20we\x20only\x20return\x20apps\
    \x20that\x20are\x20starred\x20by\x20the\x20requesting\x20user\n\n\r\n\
    \x05\x04\x0c\x02\x0c\x05\x12\x04\xbc\x1d\x02\x06\n\r\n\x05\x04\x0c\x02\
    \x0c\x01\x12\x04\xbc\x1d\x07\x13\n\r\n\x05\x04\x0c\x02\x0c\x03\x12\x04\
    \xbc\x1d\x16\x18\n\x82\x01\n\x04\x04\x0c\x02\r\x12\x04\xbe\x1d\x02)\x1at\
    \x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\
    \x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20suppo\
    rted:\x20all,\x20stars\n\n\r\n\x05\x04\x0c\x02\r\x04\x12\x04\xbe\x1d\x02\
    \n\n\r\n\x05\x04\x0c\x02\r\x05\x12\x04\xbe\x1d\x0b\x11\n\r\n\x05\x04\x0c\
    \x02\r\x01\x12\x04\xbe\x1d\x12#\n\r\n\x05\x04\x0c\x02\r\x03\x12\x04\xbe\
    \x1d&(\n\x1f\n\x02\x04\r\x12\x06\xc2\x1d\0\xc5\x1d\x01\x1a\x11\x20PostAp\
    psRequest\n\n\x0b\n\x03\x04\r\x01\x12\x04\xc2\x1d\x08\x17\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\xc3\x1d\x02,\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xc3\
    \x1d\x02\x1b\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xc3\x1d\x1c'\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\xc3\x1d*+\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc4\
    \x1d\x02\x18\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xc4\x1d\x02\n\n\r\n\x05\
    \x04\r\x02\x01\x06\x12\x04\xc4\x1d\x0b\x0e\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\xc4\x1d\x0f\x13\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc4\x1d\x16\
    \x17\n\x20\n\x02\x04\x0e\x12\x06\xc8\x1d\0\xca\x1d\x01\x1a\x12\x20Delete\
    AppRequest\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc8\x1d\x08\x18\n\x0c\n\x04\
    \x04\x0e\x02\0\x12\x04\xc9\x1d\x02,\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\
    \xc9\x1d\x02\x1b\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xc9\x1d\x1c'\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xc9\x1d*+\n\x20\n\x02\x04\x0f\x12\x06\xcd\
    \x1d\0\xda\x1d\x01\x1a\x12\x20PatchAppsRequest\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xcd\x1d\x08\x18\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xce\x1d\x02,\
    \n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xce\x1d\x02\x1b\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\xce\x1d\x1c'\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xce\
    \x1d*+\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xcf\x1d\x02\x18\n\r\n\x05\x04\
    \x0f\x02\x01\x04\x12\x04\xcf\x1d\x02\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\
    \x04\xcf\x1d\x0b\x0e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xcf\x1d\x0f\
    \x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xcf\x1d\x16\x17\n\x82\x01\n\
    \x04\x04\x0f\x02\x02\x12\x04\xd3\x1d\x02\x14\x1at\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20App\x20objects\x20except\x20App.M\
    etadata\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20suppor\
    ted\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xd3\x1d\x02\x08\n\r\n\x05\
    \x04\x0f\x02\x02\x01\x12\x04\xd3\x1d\t\x0f\n\r\n\x05\x04\x0f\x02\x02\x03\
    \x12\x04\xd3\x1d\x12\x13\nA\n\x04\x04\x0f\x02\x03\x12\x04\xd6\x1d\x02/\
    \x1a3\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20App.M\
    etadata\n\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\xd6\x1d\x02\x1a\n\r\n\
    \x05\x04\x0f\x02\x03\x01\x12\x04\xd6\x1d\x1b*\n\r\n\x05\x04\x0f\x02\x03\
    \x03\x12\x04\xd6\x1d-.\na\n\x04\x04\x0f\x02\x04\x12\x04\xd9\x1d\x02\x13\
    \x1aS\x20If\x20set,\x20the\x20app\x20will\x20be\x20automatically\x20rein\
    dexed\x20upon\x20change\x20of\x20its\x20base\x20workflow.\n\n\r\n\x05\
    \x04\x0f\x02\x04\x05\x12\x04\xd9\x1d\x02\x06\n\r\n\x05\x04\x0f\x02\x04\
    \x01\x12\x04\xd9\x1d\x07\x0e\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xd9\
    \x1d\x11\x12\n\x1f\n\x02\x04\x10\x12\x06\xdd\x1d\0\xea\x1d\x01\x1a\x11\
    \x20PatchAppRequest\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xdd\x1d\x08\x17\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xde\x1d\x02,\n\r\n\x05\x04\x10\x02\0\
    \x06\x12\x04\xde\x1d\x02\x1b\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xde\x1d\
    \x1c'\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xde\x1d*+\n\x0c\n\x04\x04\x10\
    \x02\x01\x12\x04\xdf\x1d\x02\x0e\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\
    \xdf\x1d\x02\x05\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xdf\x1d\x06\t\n\r\
    \n\x05\x04\x10\x02\x01\x03\x12\x04\xdf\x1d\x0c\r\n\x81\x01\n\x04\x04\x10\
    \x02\x02\x12\x04\xe3\x1d\x02\x14\x1as\x20The\x20action\x20to\x20perform\
    \x20on\x20the\x20patched\x20App\x20object\x20except\x20App.Metadata\n\
    \x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\r\
    \n\x05\x04\x10\x02\x02\x05\x12\x04\xe3\x1d\x02\x08\n\r\n\x05\x04\x10\x02\
    \x02\x01\x12\x04\xe3\x1d\t\x0f\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xe3\
    \x1d\x12\x13\nA\n\x04\x04\x10\x02\x03\x12\x04\xe6\x1d\x02/\x1a3\x20The\
    \x20action\x20to\x20perform\x20on\x20the\x20patched\x20App.Metadata\n\n\
    \r\n\x05\x04\x10\x02\x03\x06\x12\x04\xe6\x1d\x02\x1a\n\r\n\x05\x04\x10\
    \x02\x03\x01\x12\x04\xe6\x1d\x1b*\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\
    \xe6\x1d-.\na\n\x04\x04\x10\x02\x04\x12\x04\xe9\x1d\x02\x13\x1aS\x20If\
    \x20set,\x20the\x20app\x20will\x20be\x20automatically\x20reindexed\x20up\
    on\x20change\x20of\x20its\x20base\x20workflow.\n\n\r\n\x05\x04\x10\x02\
    \x04\x05\x12\x04\xe9\x1d\x02\x06\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\
    \xe9\x1d\x07\x0e\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xe9\x1d\x11\x12\n\
    #\n\x02\x04\x11\x12\x06\xee\x1d\0\xf7\x1d\x01\x1a\x15\x20PatchAppsIdsReq\
    uest\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xee\x1d\x08\x1b\n\x0c\n\x04\x04\
    \x11\x02\0\x12\x04\xef\x1d\x02,\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xef\
    \x1d\x02\x1b\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xef\x1d\x1c'\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xef\x1d*+\n(\n\x04\x04\x11\x02\x01\x12\x04\
    \xf2\x1d\x02\"\x1a\x1a\x20Array\x20containing\x201\x20entry\n\n\r\n\x05\
    \x04\x11\x02\x01\x04\x12\x04\xf2\x1d\x02\n\n\r\n\x05\x04\x11\x02\x01\x06\
    \x12\x04\xf2\x1d\x0b\x19\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xf2\x1d\
    \x1a\x1d\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xf2\x1d\x20!\n[\n\x04\x04\
    \x11\x02\x02\x12\x04\xf6\x1d\x02\x14\x1aM\x20The\x20action\x20to\x20perf\
    orm\x20on\x20the\x20patched\x20objects\n\x20Only\x20'overwrite'\x20is\
    \x20supported\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xf6\x1d\x02\x08\n\
    \r\n\x05\x04\x11\x02\x02\x01\x12\x04\xf6\x1d\t\x0f\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\xf6\x1d\x12\x13\n7\n\x02\x04\x12\x12\x06\xfa\x1d\0\x81\
    \x1e\x01\x1a)\x20Search\x20over\x20the\x20available\x20applications.\n\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xfa\x1d\x08\x1f\n\x0c\n\x04\x04\x12\x02\0\
    \x12\x04\xfb\x1d\x02,\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xfb\x1d\x02\
    \x1b\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xfb\x1d\x1c'\n\r\n\x05\x04\x12\
    \x02\0\x03\x12\x04\xfb\x1d*+\n(\n\x04\x04\x12\x02\x01\x12\x04\xfd\x1d\
    \x02\x19\x1a\x1a\x20The\x20body\x20of\x20the\x20request.\n\n\r\n\x05\x04\
    \x12\x02\x01\x06\x12\x04\xfd\x1d\x02\n\n\r\n\x05\x04\x12\x02\x01\x01\x12\
    \x04\xfd\x1d\x0b\x14\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xfd\x1d\x17\
    \x18\n]\n\x04\x04\x12\x02\x02\x12\x04\x80\x1e\x02\x1c\x1aO\x20Pagination\
    \x20parameters\x20here\x20since\x20there\x20are\x20no\x20url\x20args\x20\
    in\x20this\n\x20POST\x20request.\n\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\
    \x80\x1e\x02\x0c\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x80\x1e\r\x17\n\r\
    \n\x05\x04\x12\x02\x02\x03\x12\x04\x80\x1e\x1a\x1b\n!\n\x02\x04\x13\x12\
    \x06\x84\x1e\0\x87\x1e\x01\x1a\x13\x20SingleAppResponse\n\n\x0b\n\x03\
    \x04\x13\x01\x12\x04\x84\x1e\x08\x19\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \x85\x1e\x02(\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\x85\x1e\x02\x1c\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\x85\x1e\x1d#\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\x85\x1e&'\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x86\x1e\x02\x0e\n\
    \r\n\x05\x04\x13\x02\x01\x06\x12\x04\x86\x1e\x02\x05\n\r\n\x05\x04\x13\
    \x02\x01\x01\x12\x04\x86\x1e\x06\t\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \x86\x1e\x0c\r\n\x20\n\x02\x04\x14\x12\x06\x8a\x1e\0\x8d\x1e\x01\x1a\x12\
    \x20MultiAppResponse\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x8a\x1e\x08\x18\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\x8b\x1e\x02(\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\x8b\x1e\x02\x1c\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x8b\x1e\
    \x1d#\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x8b\x1e&'\n\x0c\n\x04\x04\x14\
    \x02\x01\x12\x04\x8c\x1e\x02G\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x8c\
    \x1e\x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\x8c\x1e\x0b\x0e\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\x8c\x1e\x0f\x13\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\x8c\x1e\x16\x17\n\r\n\x05\x04\x14\x02\x01\x08\x12\x04\
    \x8c\x1e\x18F\n\x10\n\x08\x04\x14\x02\x01\x08\xd0\x86\x03\x12\x04\x8c\
    \x1e\x19E\n(\n\x02\x04\x15\x12\x06\x90\x1e\0\x9b\x1e\x01\x1a\x1a\x20List\
    CollaboratorsRequest\n\n\x0b\n\x03\x04\x15\x01\x12\x04\x90\x1e\x08\x20\n\
    \x0c\n\x04\x04\x15\x02\0\x12\x04\x91\x1e\x02,\n\r\n\x05\x04\x15\x02\0\
    \x06\x12\x04\x91\x1e\x02\x1b\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x91\x1e\
    \x1c'\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x91\x1e*+\n\x88\x01\n\x04\x04\
    \x15\x02\x01\x12\x04\x94\x1e\x02\"\x1az\x20Set\x20this\x20flag\x20to\x20\
    list\x20both\x20deleted\x20and\x20not\x20deleted\x20collaborators\n\x20b\
    y\x20default\x20it's\x20listing\x20only\x20not\x20deleted\x20collaborato\
    rs\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x94\x1e\x02\x06\n\r\n\x05\x04\
    \x15\x02\x01\x01\x12\x04\x94\x1e\x07\x1d\n\r\n\x05\x04\x15\x02\x01\x03\
    \x12\x04\x94\x1e\x20!\n~\n\x04\x04\x15\x02\x02\x12\x04\x97\x1e\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x97\
    \x1e\x02\x08\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x97\x1e\t\r\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\x97\x1e\x10\x11\nu\n\x04\x04\x15\x02\x03\
    \x12\x04\x9a\x1e\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x15\x02\x03\
    \x05\x12\x04\x9a\x1e\x02\x08\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\x9a\
    \x1e\t\x11\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\x9a\x1e\x14\x15\n(\n\
    \x02\x04\x16\x12\x06\x9e\x1e\0\xa1\x1e\x01\x1a\x1a\x20PostCollaboratorsR\
    equest\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x9e\x1e\x08\x20\n\x0c\n\x04\x04\
    \x16\x02\0\x12\x04\x9f\x1e\x02,\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x9f\
    \x1e\x02\x1b\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x9f\x1e\x1c'\n\r\n\x05\
    \x04\x16\x02\0\x03\x12\x04\x9f\x1e*+\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\
    \xa0\x1e\x02*\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xa0\x1e\x02\n\n\r\n\
    \x05\x04\x16\x02\x01\x06\x12\x04\xa0\x1e\x0b\x17\n\r\n\x05\x04\x16\x02\
    \x01\x01\x12\x04\xa0\x1e\x18%\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xa0\
    \x1e()\n)\n\x02\x04\x17\x12\x06\xa4\x1e\0\xab\x1e\x01\x1a\x1b\x20PatchCo\
    llaboratorsRequest\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xa4\x1e\x08!\n\x0c\
    \n\x04\x04\x17\x02\0\x12\x04\xa5\x1e\x02,\n\r\n\x05\x04\x17\x02\0\x06\
    \x12\x04\xa5\x1e\x02\x1b\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xa5\x1e\x1c\
    '\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xa5\x1e*+\n\x0c\n\x04\x04\x17\x02\
    \x01\x12\x04\xa6\x1e\x02*\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xa6\x1e\
    \x02\n\n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\xa6\x1e\x0b\x17\n\r\n\x05\
    \x04\x17\x02\x01\x01\x12\x04\xa6\x1e\x18%\n\r\n\x05\x04\x17\x02\x01\x03\
    \x12\x04\xa6\x1e()\nj\n\x04\x04\x17\x02\x02\x12\x04\xaa\x1e\x02\x14\x1a\
    \\\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\
    \n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\
    \r\n\x05\x04\x17\x02\x02\x05\x12\x04\xaa\x1e\x02\x08\n\r\n\x05\x04\x17\
    \x02\x02\x01\x12\x04\xaa\x1e\t\x0f\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\
    \xaa\x1e\x12\x13\n*\n\x02\x04\x18\x12\x06\xae\x1e\0\xb2\x1e\x01\x1a\x1c\
    \x20DeleteCollaboratorsRequest\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xae\x1e\
    \x08\"\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xaf\x1e\x02,\n\r\n\x05\x04\x18\
    \x02\0\x06\x12\x04\xaf\x1e\x02\x1b\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xaf\x1e\x1c'\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xaf\x1e*+\n\x0c\n\x04\
    \x04\x18\x02\x01\x12\x04\xb0\x1e\x02'\n\r\n\x05\x04\x18\x02\x01\x04\x12\
    \x04\xb0\x1e\x02\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xb0\x1e\x0b\x11\
    \n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xb0\x1e\x12\"\n\r\n\x05\x04\x18\
    \x02\x01\x03\x12\x04\xb0\x1e%&\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xb1\
    \x1e\x02\"\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xb1\x1e\x02\n\n\r\n\x05\
    \x04\x18\x02\x02\x05\x12\x04\xb1\x1e\x0b\x11\n\r\n\x05\x04\x18\x02\x02\
    \x01\x12\x04\xb1\x1e\x12\x1d\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xb1\
    \x1e\x20!\n*\n\x02\x04\x19\x12\x06\xb5\x1e\0\xb8\x1e\x01\x1a\x1c\x20Mult\
    iCollaboratorsResponse\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xb5\x1e\x08\"\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xb6\x1e\x02(\n\r\n\x05\x04\x19\x02\0\
    \x06\x12\x04\xb6\x1e\x02\x1c\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xb6\x1e\
    \x1d#\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xb6\x1e&'\n\x0c\n\x04\x04\x19\
    \x02\x01\x12\x04\xb7\x1e\x02Y\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xb7\
    \x1e\x02\n\n\r\n\x05\x04\x19\x02\x01\x06\x12\x04\xb7\x1e\x0b\x17\n\r\n\
    \x05\x04\x19\x02\x01\x01\x12\x04\xb7\x1e\x18%\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xb7\x1e()\n\r\n\x05\x04\x19\x02\x01\x08\x12\x04\xb7\x1e*X\n\
    \x10\n\x08\x04\x19\x02\x01\x08\xd0\x86\x03\x12\x04\xb7\x1e+W\n)\n\x02\
    \x04\x1a\x12\x06\xbb\x1e\0\xc3\x1e\x01\x1a\x1b\x20ListCollaborationsRequ\
    est\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xbb\x1e\x08!\n\x0c\n\x04\x04\x1a\
    \x02\0\x12\x04\xbc\x1e\x02,\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xbc\x1e\
    \x02\x1b\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xbc\x1e\x1c'\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\xbc\x1e*+\n~\n\x04\x04\x1a\x02\x01\x12\x04\xbf\
    \x1e\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20nu\
    mber.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20in\
    to\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x1a\x02\x01\x05\
    \x12\x04\xbf\x1e\x02\x08\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xbf\x1e\t\
    \r\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xbf\x1e\x10\x11\nu\n\x04\x04\
    \x1a\x02\x02\x12\x04\xc2\x1e\x02\x16\x1ag\x20(optional\x20URL\x20paramet\
    er)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x1a\
    \x02\x02\x05\x12\x04\xc2\x1e\x02\x08\n\r\n\x05\x04\x1a\x02\x02\x01\x12\
    \x04\xc2\x1e\t\x11\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xc2\x1e\x14\x15\
    \n+\n\x02\x04\x1b\x12\x06\xc6\x1e\0\xc9\x1e\x01\x1a\x1d\x20MultiCollabor\
    ationsResponse\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xc6\x1e\x08#\n\x0c\n\
    \x04\x04\x1b\x02\0\x12\x04\xc7\x1e\x02(\n\r\n\x05\x04\x1b\x02\0\x06\x12\
    \x04\xc7\x1e\x02\x1c\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xc7\x1e\x1d#\n\
    \r\n\x05\x04\x1b\x02\0\x03\x12\x04\xc7\x1e&'\n\x0c\n\x04\x04\x1b\x02\x01\
    \x12\x04\xc8\x1e\x02[\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xc8\x1e\x02\
    \n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xc8\x1e\x0b\x18\n\r\n\x05\x04\
    \x1b\x02\x01\x01\x12\x04\xc8\x1e\x19'\n\r\n\x05\x04\x1b\x02\x01\x03\x12\
    \x04\xc8\x1e*+\n\r\n\x05\x04\x1b\x02\x01\x08\x12\x04\xc8\x1e,Z\n\x10\n\
    \x08\x04\x1b\x02\x01\x08\xd0\x86\x03\x12\x04\xc8\x1e-Y\n$\n\x02\x04\x1c\
    \x12\x06\xed\x1e\0\xef\x1e\x01\x1a\x16\x20GetStatusCodeRequest\n\n\x0b\n\
    \x03\x04\x1c\x01\x12\x04\xed\x1e\x08\x1c\n\x0c\n\x04\x04\x1c\x02\0\x12\
    \x04\xee\x1e\x02\x1c\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xee\x1e\x02\x08\
    \n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xee\x1e\t\x17\n\r\n\x05\x04\x1c\x02\
    \0\x03\x12\x04\xee\x1e\x1a\x1b\n&\n\x02\x04\x1d\x12\x06\xf2\x1e\0\xf3\
    \x1e\x01\x1a\x18\x20ListStatusCodesRequest\n\n\x0b\n\x03\x04\x1d\x01\x12\
    \x04\xf2\x1e\x08\x1e\n(\n\x02\x04\x1e\x12\x06\xf6\x1e\0\xf9\x1e\x01\x1a\
    \x1a\x20SingleStatusCodeResponse\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xf6\
    \x1e\x08\x20\n'\n\x04\x04\x1e\x02\0\x12\x04\xf8\x1e\x02(\x1a\x19\x20Stat\
    us\x20of\x20this\x20request.\n\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xf8\
    \x1e\x02\x1c\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xf8\x1e\x1d#\n\r\n\x05\
    \x04\x1e\x02\0\x03\x12\x04\xf8\x1e&'\n'\n\x02\x04\x1f\x12\x06\xfc\x1e\0\
    \xff\x1e\x01\x1a\x19\x20MultiStatusCodeResponse\n\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\xfc\x1e\x08\x1f\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xfd\x1e\
    \x02(\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xfd\x1e\x02\x1c\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\xfd\x1e\x1d#\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \xfd\x1e&'\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xfe\x1e\x023\n\r\n\x05\
    \x04\x1f\x02\x01\x04\x12\x04\xfe\x1e\x02\n\n\r\n\x05\x04\x1f\x02\x01\x06\
    \x12\x04\xfe\x1e\x0b%\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xfe\x1e&.\n\
    \r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xfe\x1e12\n!\n\x02\x04\x20\x12\x06\
    \x82\x1f\0\x86\x1f\x01\x1a\x13\x20GetConceptRequest\n\n\x0b\n\x03\x04\
    \x20\x01\x12\x04\x82\x1f\x08\x19\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x83\
    \x1f\x02,\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\x83\x1f\x02\x1b\n\r\n\x05\
    \x04\x20\x02\0\x01\x12\x04\x83\x1f\x1c'\n\r\n\x05\x04\x20\x02\0\x03\x12\
    \x04\x83\x1f*+\n!\n\x04\x04\x20\x02\x01\x12\x04\x85\x1f\x02\x18\x1a\x13\
    \x20The\x20concept's\x20id.\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x85\
    \x1f\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x85\x1f\t\x13\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\x85\x1f\x16\x17\n#\n\x02\x04!\x12\x06\
    \x89\x1f\0\x91\x1f\x01\x1a\x15\x20ListConceptsRequest\n\n\x0b\n\x03\x04!\
    \x01\x12\x04\x89\x1f\x08\x1b\n\x0c\n\x04\x04!\x02\0\x12\x04\x8a\x1f\x02,\
    \n\r\n\x05\x04!\x02\0\x06\x12\x04\x8a\x1f\x02\x1b\n\r\n\x05\x04!\x02\0\
    \x01\x12\x04\x8a\x1f\x1c'\n\r\n\x05\x04!\x02\0\x03\x12\x04\x8a\x1f*+\n~\
    \n\x04\x04!\x02\x01\x12\x04\x8d\x1f\x02\x12\x1ap\x20(optional\x20URL\x20\
    parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\
    \x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\
    \n\n\r\n\x05\x04!\x02\x01\x05\x12\x04\x8d\x1f\x02\x08\n\r\n\x05\x04!\x02\
    \x01\x01\x12\x04\x8d\x1f\t\r\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x8d\x1f\
    \x10\x11\nu\n\x04\x04!\x02\x02\x12\x04\x90\x1f\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\r\n\x05\x04!\x02\x02\x05\x12\x04\x90\x1f\x02\x08\n\r\n\x05\x04!\x02\
    \x02\x01\x12\x04\x90\x1f\t\x11\n\r\n\x05\x04!\x02\x02\x03\x12\x04\x90\
    \x1f\x14\x15\n(\n\x02\x04\"\x12\x06\x94\x1f\0\xa1\x1f\x01\x1a\x1a\x20Lis\
    tModelConceptsRequest\n\n\x0b\n\x03\x04\"\x01\x12\x04\x94\x1f\x08\x20\n\
    \x0c\n\x04\x04\"\x02\0\x12\x04\x95\x1f\x02,\n\r\n\x05\x04\"\x02\0\x06\
    \x12\x04\x95\x1f\x02\x1b\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x95\x1f\x1c'\
    \n\r\n\x05\x04\"\x02\0\x03\x12\x04\x95\x1f*+\n\x18\n\x04\x04\"\x02\x01\
    \x12\x04\x97\x1f\x02\x16\x1a\n\x20Model\x20id\n\n\r\n\x05\x04\"\x02\x01\
    \x05\x12\x04\x97\x1f\x02\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x97\x1f\
    \t\x11\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\x97\x1f\x14\x15\nY\n\x04\x04\
    \"\x02\x02\x12\x04\x99\x1f\x02\x18\x1aK\x20Model\x20version\x20Id.\x20Op\
    tional,\x20if\x20not\x20provided\x20latest\x20model\x20version\x20is\x20\
    used.\n\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\x99\x1f\x02\x08\n\r\n\x05\
    \x04\"\x02\x02\x01\x12\x04\x99\x1f\t\x13\n\r\n\x05\x04\"\x02\x02\x03\x12\
    \x04\x99\x1f\x16\x17\n~\n\x04\x04\"\x02\x03\x12\x04\x9d\x1f\x02\x12\x1ap\
    \x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginati\
    on\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\x9d\x1f\
    \x02\x08\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\x9d\x1f\t\r\n\r\n\x05\x04\"\
    \x02\x03\x03\x12\x04\x9d\x1f\x10\x11\nu\n\x04\x04\"\x02\x04\x12\x04\xa0\
    \x1f\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\"\x02\x04\x05\x12\x04\xa0\
    \x1f\x02\x08\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xa0\x1f\t\x11\n\r\n\x05\
    \x04\"\x02\x04\x03\x12\x04\xa0\x1f\x14\x15\n+\n\x02\x04#\x12\x06\xa4\x1f\
    \0\xb0\x1f\x01\x1a\x1d\x20PostConceptsSearchesRequest\n\n\x0b\n\x03\x04#\
    \x01\x12\x04\xa4\x1f\x08#\n6\n\x04\x04#\x02\0\x12\x04\xa6\x1f\x02,\x1a(\
    \x20Ids\x20present\x20in\x20the\x20url\x20of\x20the\x20request.\n\n\r\n\
    \x05\x04#\x02\0\x06\x12\x04\xa6\x1f\x02\x1b\n\r\n\x05\x04#\x02\0\x01\x12\
    \x04\xa6\x1f\x1c'\n\r\n\x05\x04#\x02\0\x03\x12\x04\xa6\x1f*+\n(\n\x04\
    \x04#\x02\x01\x12\x04\xa8\x1f\x02!\x1a\x1a\x20The\x20body\x20of\x20the\
    \x20request.\n\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xa8\x1f\x02\x0e\n\r\n\
    \x05\x04#\x02\x01\x01\x12\x04\xa8\x1f\x0f\x1c\n\r\n\x05\x04#\x02\x01\x03\
    \x12\x04\xa8\x1f\x1f\x20\nY\n\x04\x04#\x02\x02\x12\x04\xab\x1f\x02)\x1aK\
    \x20Request\x20additional\x20info\x20to\x20be\x20retrieved\x20for\x20eac\
    h\x20concept\x20in\x20the\x20response.\n\n\r\n\x05\x04#\x02\x02\x06\x12\
    \x04\xab\x1f\x02\x19\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xab\x1f\x1a$\n\r\
    \n\x05\x04#\x02\x02\x03\x12\x04\xab\x1f'(\n]\n\x04\x04#\x02\x03\x12\x04\
    \xaf\x1f\x02\x1c\x1aO\x20Pagination\x20parameters\x20here\x20since\x20th\
    ere\x20are\x20no\x20url\x20args\x20in\x20this\n\x20POST\x20request.\n\n\
    \r\n\x05\x04#\x02\x03\x06\x12\x04\xaf\x1f\x02\x0c\n\r\n\x05\x04#\x02\x03\
    \x01\x12\x04\xaf\x1f\r\x17\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xaf\x1f\
    \x1a\x1b\n\x0c\n\x02\x04$\x12\x06\xb2\x1f\0\xbb\x1f\x01\n\x0b\n\x03\x04$\
    \x01\x12\x04\xb2\x1f\x08\x1f\n\xd8\x01\n\x04\x04$\x02\0\x12\x04\xba\x1f\
    \x02\x1b\x1a\xc9\x01\x20Determine\x20if\x20the\x20concept\x20is\x20searc\
    hable\x20by\x20rank\x20using\x20this\x20model.\n\x20Currently,\x20only\
    \x20embedder\x20models\x20are\x20supported.\n\x20##########\x20Supported\
    \x20fields\x20##########\n\x20-\x20app_id\n\x20-\x20id\n\x20-\x20model_v\
    ersion.id\n\x20-\x20user_id\n\n\r\n\x05\x04$\x02\0\x06\x12\x04\xba\x1f\
    \x02\x07\n\r\n\x05\x04$\x02\0\x01\x12\x04\xba\x1f\x08\x16\n\r\n\x05\x04$\
    \x02\0\x03\x12\x04\xba\x1f\x19\x1a\n#\n\x02\x04%\x12\x06\xbe\x1f\0\xc2\
    \x1f\x01\x1a\x15\x20PostConceptsRequest\n\n\x0b\n\x03\x04%\x01\x12\x04\
    \xbe\x1f\x08\x1b\n\x0c\n\x04\x04%\x02\0\x12\x04\xbf\x1f\x02,\n\r\n\x05\
    \x04%\x02\0\x06\x12\x04\xbf\x1f\x02\x1b\n\r\n\x05\x04%\x02\0\x01\x12\x04\
    \xbf\x1f\x1c'\n\r\n\x05\x04%\x02\0\x03\x12\x04\xbf\x1f*+\n$\n\x04\x04%\
    \x02\x01\x12\x04\xc1\x1f\x02\x20\x1a\x16\x20The\x20concepts\x20to\x20add\
    .\n\n\r\n\x05\x04%\x02\x01\x04\x12\x04\xc1\x1f\x02\n\n\r\n\x05\x04%\x02\
    \x01\x06\x12\x04\xc1\x1f\x0b\x12\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xc1\
    \x1f\x13\x1b\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xc1\x1f\x1e\x1f\n$\n\x02\
    \x04&\x12\x06\xc5\x1f\0\xcd\x1f\x01\x1a\x16\x20PatchConceptsRequest\n\n\
    \x0b\n\x03\x04&\x01\x12\x04\xc5\x1f\x08\x1c\n\x0c\n\x04\x04&\x02\0\x12\
    \x04\xc6\x1f\x02,\n\r\n\x05\x04&\x02\0\x06\x12\x04\xc6\x1f\x02\x1b\n\r\n\
    \x05\x04&\x02\0\x01\x12\x04\xc6\x1f\x1c'\n\r\n\x05\x04&\x02\0\x03\x12\
    \x04\xc6\x1f*+\n&\n\x04\x04&\x02\x01\x12\x04\xc8\x1f\x02\x20\x1a\x18\x20\
    The\x20concepts\x20to\x20patch.\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xc8\
    \x1f\x02\n\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xc8\x1f\x0b\x12\n\r\n\x05\
    \x04&\x02\x01\x01\x12\x04\xc8\x1f\x13\x1b\n\r\n\x05\x04&\x02\x01\x03\x12\
    \x04\xc8\x1f\x1e\x1f\ni\n\x04\x04&\x02\x02\x12\x04\xcc\x1f\x02\x14\x1a[\
    \x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\
    \x20For\x20now\x20ony\x20action\x20'overwrite'\x20is\x20supported\n\n\r\
    \n\x05\x04&\x02\x02\x05\x12\x04\xcc\x1f\x02\x08\n\r\n\x05\x04&\x02\x02\
    \x01\x12\x04\xcc\x1f\t\x0f\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xcc\x1f\
    \x12\x13\n'\n\x02\x04'\x12\x06\xd0\x1f\0\xd8\x1f\x01\x1a\x19\x20GetConce\
    ptCountsRequest\n\n\x0b\n\x03\x04'\x01\x12\x04\xd0\x1f\x08\x1f\n\x0c\n\
    \x04\x04'\x02\0\x12\x04\xd1\x1f\x02,\n\r\n\x05\x04'\x02\0\x06\x12\x04\
    \xd1\x1f\x02\x1b\n\r\n\x05\x04'\x02\0\x01\x12\x04\xd1\x1f\x1c'\n\r\n\x05\
    \x04'\x02\0\x03\x12\x04\xd1\x1f*+\n~\n\x04\x04'\x02\x01\x12\x04\xd4\x1f\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04'\x02\x01\x05\x12\
    \x04\xd4\x1f\x02\x08\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xd4\x1f\t\r\n\r\
    \n\x05\x04'\x02\x01\x03\x12\x04\xd4\x1f\x10\x11\nu\n\x04\x04'\x02\x02\
    \x12\x04\xd7\x1f\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04'\x02\x02\x05\
    \x12\x04\xd7\x1f\x02\x08\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xd7\x1f\t\
    \x11\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xd7\x1f\x14\x15\n%\n\x02\x04(\
    \x12\x06\xdb\x1f\0\xe0\x1f\x01\x1a\x17\x20SingleConceptResponse\n\n\x0b\
    \n\x03\x04(\x01\x12\x04\xdb\x1f\x08\x1d\n$\n\x04\x04(\x02\0\x12\x04\xdd\
    \x1f\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x04(\x02\0\
    \x06\x12\x04\xdd\x1f\x02\x1c\n\r\n\x05\x04(\x02\0\x01\x12\x04\xdd\x1f\
    \x1d#\n\r\n\x05\x04(\x02\0\x03\x12\x04\xdd\x1f&'\n%\n\x04\x04(\x02\x01\
    \x12\x04\xdf\x1f\x02\x16\x1a\x17\x20The\x20returned\x20concept.\n\n\r\n\
    \x05\x04(\x02\x01\x06\x12\x04\xdf\x1f\x02\t\n\r\n\x05\x04(\x02\x01\x01\
    \x12\x04\xdf\x1f\n\x11\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xdf\x1f\x14\
    \x15\n$\n\x02\x04)\x12\x06\xe3\x1f\0\xe8\x1f\x01\x1a\x16\x20MultiConcept\
    Response\n\n\x0b\n\x03\x04)\x01\x12\x04\xe3\x1f\x08\x1c\n$\n\x04\x04)\
    \x02\0\x12\x04\xe5\x1f\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\
    \n\x05\x04)\x02\0\x06\x12\x04\xe5\x1f\x02\x1c\n\r\n\x05\x04)\x02\0\x01\
    \x12\x04\xe5\x1f\x1d#\n\r\n\x05\x04)\x02\0\x03\x12\x04\xe5\x1f&'\n&\n\
    \x04\x04)\x02\x01\x12\x04\xe7\x1f\x02O\x1a\x18\x20The\x20returned\x20con\
    cepts.\n\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xe7\x1f\x02\n\n\r\n\x05\x04)\
    \x02\x01\x06\x12\x04\xe7\x1f\x0b\x12\n\r\n\x05\x04)\x02\x01\x01\x12\x04\
    \xe7\x1f\x13\x1b\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xe7\x1f\x1e\x1f\n\r\
    \n\x05\x04)\x02\x01\x08\x12\x04\xe7\x1f\x20N\n\x10\n\x08\x04)\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xe7\x1f!M\n)\n\x02\x04*\x12\x06\xeb\x1f\0\xf0\
    \x1f\x01\x1a\x1b\x20MultiConceptCountResponse\n\n\x0b\n\x03\x04*\x01\x12\
    \x04\xeb\x1f\x08!\n$\n\x04\x04*\x02\0\x12\x04\xed\x1f\x02(\x1a\x16\x20Th\
    e\x20response\x20status.\n\n\r\n\x05\x04*\x02\0\x06\x12\x04\xed\x1f\x02\
    \x1c\n\r\n\x05\x04*\x02\0\x01\x12\x04\xed\x1f\x1d#\n\r\n\x05\x04*\x02\0\
    \x03\x12\x04\xed\x1f&'\n,\n\x04\x04*\x02\x01\x12\x04\xef\x1f\x02Z\x1a\
    \x1e\x20The\x20returned\x20concept\x20counts.\n\n\r\n\x05\x04*\x02\x01\
    \x04\x12\x04\xef\x1f\x02\n\n\r\n\x05\x04*\x02\x01\x06\x12\x04\xef\x1f\
    \x0b\x17\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xef\x1f\x18&\n\r\n\x05\x04*\
    \x02\x01\x03\x12\x04\xef\x1f)*\n\r\n\x05\x04*\x02\x01\x08\x12\x04\xef\
    \x1f+Y\n\x10\n\x08\x04*\x02\x01\x08\xd0\x86\x03\x12\x04\xef\x1f,X\n`\n\
    \x02\x04+\x12\x06\xf3\x1f\0\x9b\x20\x01\x1aR\x20GET\x20all\x20relations\
    \x20such\x20that\x20the\x20concept_id\x20refers\x20to\x20the\x20subject\
    \x20of\x20the\x20relation\n\n\x0b\n\x03\x04+\x01\x12\x04\xf3\x1f\x08#\n3\
    \n\x04\x04+\x02\0\x12\x04\xf5\x1f\x02,\x1a%\x20The\x20user_id\x20and\x20\
    app_id\x20information.\n\n\r\n\x05\x04+\x02\0\x06\x12\x04\xf5\x1f\x02\
    \x1b\n\r\n\x05\x04+\x02\0\x01\x12\x04\xf5\x1f\x1c'\n\r\n\x05\x04+\x02\0\
    \x03\x12\x04\xf5\x1f*+\n\xb9\x07\n\x04\x04+\x02\x01\x12\x04\x85\x20\x02\
    \x18\x1a\xaa\x07\x20The\x20subject\x20concept\x20id\x20in\x20your\x20app\
    \x20to\x20get\x20all\x20the\x20relationships\x20for.\n\x20Leave\x20as\
    \x20an\x20empty\x20string\x20(GET\x20/concepts/relations)\x20to\x20list\
    \x20ALL\x20the\x20relations\x20in\x20the\x20app.\n\n\x20When\x20listing\
    \x20all\x20the\x20relations\x20it\x20will\x20only\x20return\x20one\x20di\
    rection\x20of\x20the\x20relationship\n\x20with\x20the\x20predicate\x20ac\
    ting\x20on\x20the\x20subject\x20and\x20not\x20the\x20inverse\x20like\x20\
    is\x20done\x20when\x20providing\x20a\n\x20concept_id\x20so\x20that\x20we\
    \x20can\x20return\x20a\x20reliable\x20page\x20size\x20always.\n\n\x20Whe\
    n\x20providing\x20a\x20concept_id,\x20if\x20a\x20hyponym\x20is\x20presen\
    t\x20in\x20the\x20DB\x20such\x20as:\n\x20'honey'\x20(subject),\x20'hypon\
    ym'\x20(predicate\x20for\x20\"is\x20a\x20kind\x20of\"),\x20'food'\x20(ob\
    ject)\n\x20then\x20you\x20can\x20list\x20the\x20concept\x20relations\x20\
    for\x20'honey'\x20and\x20get\x20hyponym\x20predicate\x20with\x20'food'\n\
    \x20object.\n\x20But\x20you\x20can\x20also\x20list\x20the\x20concept\x20\
    relations\x20for\x20'food'\x20and\x20it\x20will\x20return\x20the\x20same\
    \x20hyponym\n\x20relationship\x20with\x20'honey'\x20as\x20object\x20and\
    \x20'hypernym'\x20as\x20predicate.\n\x20Synonyms\x20by\x20nature\x20are\
    \x20symmetrical\x20relationships\x20so\x20either\x20side\x20can\x20be\
    \x20the\x20concept_id\x20(subject)\n\x20when\x20listing\x20the\x20relati\
    ons.\n\n\r\n\x05\x04+\x02\x01\x05\x12\x04\x85\x20\x02\x08\n\r\n\x05\x04+\
    \x02\x01\x01\x12\x04\x85\x20\t\x13\n\r\n\x05\x04+\x02\x01\x03\x12\x04\
    \x85\x20\x16\x17\n\xed\x02\n\x04\x04+\x02\x02\x12\x04\x90\x20\x02\x17\
    \x1a\xde\x02\x20If\x20predicate\x20is\x20provided\x20then\x20only\x20lis\
    t\x20relations\x20with\x20that\x20predicate.\n\n\x20Note\x20that\x20if\
    \x20no\x20subject\x20is\x20set\x20in\x20concept_id\x20and\x20predicate\
    \x20is\x20set\x20to\n\x20'hypernym',\x20then\x20it\x20will\x20return\x20\
    any\x20stored\x20hyponyms\x20as\x20hypernyms\x20with\n\x20just\x20the\
    \x20subject\x20and\x20object\x20swapped\x20since\x20they\x20are\x20rever\
    sed\x20relations.\n\n\x20Valid\x20predicates\x20are:\n\x20-\x20'hypernym\
    '\n\x20-\x20'hyponym'\n\x20-\x20'synonym'\n\n\r\n\x05\x04+\x02\x02\x05\
    \x12\x04\x90\x20\x02\x08\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x90\x20\t\
    \x12\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x90\x20\x15\x16\n\x8b\x02\n\x04\
    \x04+\x02\x03\x12\x04\x94\x20\x02\x20\x1a\xfc\x01\x20If\x20knowledge_gra\
    ph_id\x20is\x20provided\x20then\x20just\x20list\x20relations\x20from\x20\
    that\x20knowledge\x20graph.\n\x20If\x20not\x20provided\x20then\x20list\
    \x20relations\x20from\x20all\x20knowledge\x20graphs\x20including\x20the\
    \x20global\x20one\x20for\x20this\n\x20app\x20one\x20(ie.\x20knowledge_gr\
    aph\x20\"\")\x20and\x20any\x20specific\x20ones\x20in\x20the\x20app.\n\n\
    \r\n\x05\x04+\x02\x03\x05\x12\x04\x94\x20\x02\x08\n\r\n\x05\x04+\x02\x03\
    \x01\x12\x04\x94\x20\t\x1b\n\r\n\x05\x04+\x02\x03\x03\x12\x04\x94\x20\
    \x1e\x1f\n~\n\x04\x04+\x02\x04\x12\x04\x97\x20\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\r\n\x05\x04+\x02\x04\x05\x12\x04\x97\x20\x02\x08\n\r\n\
    \x05\x04+\x02\x04\x01\x12\x04\x97\x20\t\r\n\r\n\x05\x04+\x02\x04\x03\x12\
    \x04\x97\x20\x10\x11\nu\n\x04\x04+\x02\x05\x12\x04\x9a\x20\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\r\n\x05\x04+\x02\x05\x05\x12\x04\x9a\x20\x02\x08\n\r\n\
    \x05\x04+\x02\x05\x01\x12\x04\x9a\x20\t\x11\n\r\n\x05\x04+\x02\x05\x03\
    \x12\x04\x9a\x20\x14\x15\n*\n\x02\x04,\x12\x06\x9e\x20\0\xa5\x20\x01\x1a\
    \x1c\x20POST\x20new\x20concept\x20relations\n\n\x0b\n\x03\x04,\x01\x12\
    \x04\x9e\x20\x08#\n3\n\x04\x04,\x02\0\x12\x04\xa0\x20\x02,\x1a%\x20The\
    \x20user_id\x20and\x20app_id\x20information.\n\n\r\n\x05\x04,\x02\0\x06\
    \x12\x04\xa0\x20\x02\x1b\n\r\n\x05\x04,\x02\0\x01\x12\x04\xa0\x20\x1c'\n\
    \r\n\x05\x04,\x02\0\x03\x12\x04\xa0\x20*+\nI\n\x04\x04,\x02\x01\x12\x04\
    \xa2\x20\x02\x18\x1a;\x20The\x20subject\x20concept\x20id\x20you're\x20go\
    ing\x20to\x20add\x20relations\x20for.\n\n\r\n\x05\x04,\x02\x01\x05\x12\
    \x04\xa2\x20\x02\x08\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xa2\x20\t\x13\n\
    \r\n\x05\x04,\x02\x01\x03\x12\x04\xa2\x20\x16\x17\n6\n\x04\x04,\x02\x02\
    \x12\x04\xa4\x20\x021\x1a(\x20The\x20relationships\x20you're\x20going\
    \x20to\x20add.\n\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xa4\x20\x02\n\n\r\n\
    \x05\x04,\x02\x02\x06\x12\x04\xa4\x20\x0b\x1a\n\r\n\x05\x04,\x02\x02\x01\
    \x12\x04\xa4\x20\x1b,\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xa4\x20/0\n(\n\
    \x02\x04-\x12\x06\xa8\x20\0\xaf\x20\x01\x1a\x1a\x20DELETE\x20concept\x20\
    relations\n\n\x0b\n\x03\x04-\x01\x12\x04\xa8\x20\x08%\n3\n\x04\x04-\x02\
    \0\x12\x04\xaa\x20\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20infor\
    mation.\n\n\r\n\x05\x04-\x02\0\x06\x12\x04\xaa\x20\x02\x1b\n\r\n\x05\x04\
    -\x02\0\x01\x12\x04\xaa\x20\x1c'\n\r\n\x05\x04-\x02\0\x03\x12\x04\xaa\
    \x20*+\n7\n\x04\x04-\x02\x01\x12\x04\xac\x20\x02\x18\x1a)\x20The\x20conc\
    ept\x20to\x20delete\x20relationship\x20for.\n\n\r\n\x05\x04-\x02\x01\x05\
    \x12\x04\xac\x20\x02\x08\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xac\x20\t\
    \x13\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xac\x20\x16\x17\n7\n\x04\x04-\
    \x02\x02\x12\x04\xae\x20\x02\x1a\x1a)\x20The\x20concept\x20relationship\
    \x20ids\x20to\x20delete.\n\n\r\n\x05\x04-\x02\x02\x04\x12\x04\xae\x20\
    \x02\n\n\r\n\x05\x04-\x02\x02\x05\x12\x04\xae\x20\x0b\x11\n\r\n\x05\x04-\
    \x02\x02\x01\x12\x04\xae\x20\x12\x15\n\r\n\x05\x04-\x02\x02\x03\x12\x04\
    \xae\x20\x18\x19\n(\n\x02\x04.\x12\x06\xb2\x20\0\xb5\x20\x01\x1a\x1a\x20\
    GET\x20all\x20knowledge\x20graphs\n\n\x0b\n\x03\x04.\x01\x12\x04\xb2\x20\
    \x08\"\n3\n\x04\x04.\x02\0\x12\x04\xb4\x20\x02,\x1a%\x20The\x20user_id\
    \x20and\x20app_id\x20information.\n\n\r\n\x05\x04.\x02\0\x06\x12\x04\xb4\
    \x20\x02\x1b\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb4\x20\x1c'\n\r\n\x05\x04\
    .\x02\0\x03\x12\x04\xb4\x20*+\n)\n\x02\x04/\x12\x06\xb8\x20\0\xbc\x20\
    \x01\x1a\x1b\x20POST\x20new\x20knowledge\x20graphs\n\n\x0b\n\x03\x04/\
    \x01\x12\x04\xb8\x20\x08\"\n3\n\x04\x04/\x02\0\x12\x04\xba\x20\x02,\x1a%\
    \x20The\x20user_id\x20and\x20app_id\x20information.\n\n\r\n\x05\x04/\x02\
    \0\x06\x12\x04\xba\x20\x02\x1b\n\r\n\x05\x04/\x02\0\x01\x12\x04\xba\x20\
    \x1c'\n\r\n\x05\x04/\x02\0\x03\x12\x04\xba\x20*+\n\x0c\n\x04\x04/\x02\
    \x01\x12\x04\xbb\x20\x02/\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xbb\x20\x02\
    \n\n\r\n\x05\x04/\x02\x01\x06\x12\x04\xbb\x20\x0b\x19\n\r\n\x05\x04/\x02\
    \x01\x01\x12\x04\xbb\x20\x1a*\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xbb\x20\
    -.\n*\n\x02\x040\x12\x06\xc1\x20\0\xc6\x20\x01\x1a\x1c\x20Start\x20conce\
    pt\x20mapping\x20jobs\n\n\x0b\n\x03\x040\x01\x12\x04\xc1\x20\x08%\n3\n\
    \x04\x040\x02\0\x12\x04\xc3\x20\x02,\x1a%\x20The\x20user_id\x20and\x20ap\
    p_id\x20information.\n\n\r\n\x05\x040\x02\0\x06\x12\x04\xc3\x20\x02\x1b\
    \n\r\n\x05\x040\x02\0\x01\x12\x04\xc3\x20\x1c'\n\r\n\x05\x040\x02\0\x03\
    \x12\x04\xc3\x20*+\n?\n\x04\x040\x02\x01\x12\x04\xc5\x20\x026\x1a1\x20Th\
    e\x20concept\x20mapping\x20jobs\x20that\x20are\x20being\x20started\n\n\r\
    \n\x05\x040\x02\x01\x04\x12\x04\xc5\x20\x02\n\n\r\n\x05\x040\x02\x01\x06\
    \x12\x04\xc5\x20\x0b\x1c\n\r\n\x05\x040\x02\x01\x01\x12\x04\xc5\x20\x1d1\
    \n\r\n\x05\x040\x02\x01\x03\x12\x04\xc5\x2045\n,\n\x02\x041\x12\x06\xca\
    \x20\0\xcf\x20\x01\x1a\x1e\x20MultiConceptRelationResponse\n\n\x0b\n\x03\
    \x041\x01\x12\x04\xca\x20\x08$\n$\n\x04\x041\x02\0\x12\x04\xcc\x20\x02(\
    \x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x041\x02\0\x06\x12\
    \x04\xcc\x20\x02\x1c\n\r\n\x05\x041\x02\0\x01\x12\x04\xcc\x20\x1d#\n\r\n\
    \x05\x041\x02\0\x03\x12\x04\xcc\x20&'\n/\n\x04\x041\x02\x01\x12\x04\xce\
    \x20\x02`\x1a!\x20The\x20returned\x20concept\x20relations.\n\n\r\n\x05\
    \x041\x02\x01\x04\x12\x04\xce\x20\x02\n\n\r\n\x05\x041\x02\x01\x06\x12\
    \x04\xce\x20\x0b\x1a\n\r\n\x05\x041\x02\x01\x01\x12\x04\xce\x20\x1b,\n\r\
    \n\x05\x041\x02\x01\x03\x12\x04\xce\x20/0\n\r\n\x05\x041\x02\x01\x08\x12\
    \x04\xce\x201_\n\x10\n\x08\x041\x02\x01\x08\xd0\x86\x03\x12\x04\xce\x202\
    ^\n+\n\x02\x042\x12\x06\xd3\x20\0\xd8\x20\x01\x1a\x1d\x20MultiKnowledgeG\
    raphResponse\n\n\x0b\n\x03\x042\x01\x12\x04\xd3\x20\x08#\n$\n\x04\x042\
    \x02\0\x12\x04\xd5\x20\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\
    \n\x05\x042\x02\0\x06\x12\x04\xd5\x20\x02\x1c\n\r\n\x05\x042\x02\0\x01\
    \x12\x04\xd5\x20\x1d#\n\r\n\x05\x042\x02\0\x03\x12\x04\xd5\x20&'\n.\n\
    \x04\x042\x02\x01\x12\x04\xd7\x20\x02^\x1a\x20\x20The\x20returned\x20kno\
    wledge\x20graphs.\n\n\r\n\x05\x042\x02\x01\x04\x12\x04\xd7\x20\x02\n\n\r\
    \n\x05\x042\x02\x01\x06\x12\x04\xd7\x20\x0b\x19\n\r\n\x05\x042\x02\x01\
    \x01\x12\x04\xd7\x20\x1a*\n\r\n\x05\x042\x02\x01\x03\x12\x04\xd7\x20-.\n\
    \r\n\x05\x042\x02\x01\x08\x12\x04\xd7\x20/]\n\x10\n\x08\x042\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xd7\x200\\\n.\n\x02\x043\x12\x06\xde\x20\0\xe3\x20\
    \x01\x1a\x20\x20MultiConceptMappingJobResponse\n\n\x0b\n\x03\x043\x01\
    \x12\x04\xde\x20\x08&\n$\n\x04\x043\x02\0\x12\x04\xe0\x20\x02(\x1a\x16\
    \x20The\x20response\x20status.\n\n\r\n\x05\x043\x02\0\x06\x12\x04\xe0\
    \x20\x02\x1c\n\r\n\x05\x043\x02\0\x01\x12\x04\xe0\x20\x1d#\n\r\n\x05\x04\
    3\x02\0\x03\x12\x04\xe0\x20&'\n=\n\x04\x043\x02\x01\x12\x04\xe2\x20\x02\
    \x1a\x1a/\x20The\x20ids\x20of\x20the\x20concept\x20mapping\x20jobs\x20un\
    derway.\n\n\r\n\x05\x043\x02\x01\x04\x12\x04\xe2\x20\x02\n\n\r\n\x05\x04\
    3\x02\x01\x05\x12\x04\xe2\x20\x0b\x11\n\r\n\x05\x043\x02\x01\x01\x12\x04\
    \xe2\x20\x12\x15\n\r\n\x05\x043\x02\x01\x03\x12\x04\xe2\x20\x18\x19\nB\n\
    \x02\x044\x12\x06\xe6\x20\0\xeb\x20\x01\x1a4\x20GET\x20single\x20concept\
    \x20language\x20for\x20the\x20given\x20concept.\n\n\x0b\n\x03\x044\x01\
    \x12\x04\xe6\x20\x08!\n\x0c\n\x04\x044\x02\0\x12\x04\xe7\x20\x02,\n\r\n\
    \x05\x044\x02\0\x06\x12\x04\xe7\x20\x02\x1b\n\r\n\x05\x044\x02\0\x01\x12\
    \x04\xe7\x20\x1c'\n\r\n\x05\x044\x02\0\x03\x12\x04\xe7\x20*+\n\x0c\n\x04\
    \x044\x02\x01\x12\x04\xe8\x20\x02\x18\n\r\n\x05\x044\x02\x01\x05\x12\x04\
    \xe8\x20\x02\x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\xe8\x20\t\x13\n\r\n\
    \x05\x044\x02\x01\x03\x12\x04\xe8\x20\x16\x17\n0\n\x04\x044\x02\x02\x12\
    \x04\xea\x20\x02\x16\x1a\"\x20This\x20is\x20the\x20language\x20identifie\
    r.\n\n\r\n\x05\x044\x02\x02\x05\x12\x04\xea\x20\x02\x08\n\r\n\x05\x044\
    \x02\x02\x01\x12\x04\xea\x20\t\x11\n\r\n\x05\x044\x02\x02\x03\x12\x04\
    \xea\x20\x14\x15\nF\n\x02\x045\x12\x06\xee\x20\0\xf7\x20\x01\x1a8\x20Lis\
    t\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\
    \n\n\x0b\n\x03\x045\x01\x12\x04\xee\x20\x08#\n\x0c\n\x04\x045\x02\0\x12\
    \x04\xef\x20\x02,\n\r\n\x05\x045\x02\0\x06\x12\x04\xef\x20\x02\x1b\n\r\n\
    \x05\x045\x02\0\x01\x12\x04\xef\x20\x1c'\n\r\n\x05\x045\x02\0\x03\x12\
    \x04\xef\x20*+\n\x0c\n\x04\x045\x02\x01\x12\x04\xf0\x20\x02\x18\n\r\n\
    \x05\x045\x02\x01\x05\x12\x04\xf0\x20\x02\x08\n\r\n\x05\x045\x02\x01\x01\
    \x12\x04\xf0\x20\t\x13\n\r\n\x05\x045\x02\x01\x03\x12\x04\xf0\x20\x16\
    \x17\n~\n\x04\x045\x02\x02\x12\x04\xf3\x20\x02\x12\x1ap\x20(optional\x20\
    URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\r\n\x05\x045\x02\x02\x05\x12\x04\xf3\x20\x02\x08\n\r\n\x05\
    \x045\x02\x02\x01\x12\x04\xf3\x20\t\r\n\r\n\x05\x045\x02\x02\x03\x12\x04\
    \xf3\x20\x10\x11\nu\n\x04\x045\x02\x03\x12\x04\xf6\x20\x02\x16\x1ag\x20(\
    optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x045\x02\x03\x05\x12\x04\xf6\x20\x02\x08\n\r\n\x05\
    \x045\x02\x03\x01\x12\x04\xf6\x20\t\x11\n\r\n\x05\x045\x02\x03\x03\x12\
    \x04\xf6\x20\x14\x15\nG\n\x02\x046\x12\x06\xfa\x20\0\x80!\x01\x1a9\x20PA\
    TCH\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20concep\
    t.\n\n\x0b\n\x03\x046\x01\x12\x04\xfa\x20\x08$\n\x0c\n\x04\x046\x02\0\
    \x12\x04\xfb\x20\x02,\n\r\n\x05\x046\x02\0\x06\x12\x04\xfb\x20\x02\x1b\n\
    \r\n\x05\x046\x02\0\x01\x12\x04\xfb\x20\x1c'\n\r\n\x05\x046\x02\0\x03\
    \x12\x04\xfb\x20*+\n\x0c\n\x04\x046\x02\x01\x12\x04\xfc\x20\x02\x18\n\r\
    \n\x05\x046\x02\x01\x05\x12\x04\xfc\x20\x02\x08\n\r\n\x05\x046\x02\x01\
    \x01\x12\x04\xfc\x20\t\x13\n\r\n\x05\x046\x02\x01\x03\x12\x04\xfc\x20\
    \x16\x17\n\x0c\n\x04\x046\x02\x02\x12\x04\xfd\x20\x021\n\r\n\x05\x046\
    \x02\x02\x04\x12\x04\xfd\x20\x02\n\n\r\n\x05\x046\x02\x02\x06\x12\x04\
    \xfd\x20\x0b\x1a\n\r\n\x05\x046\x02\x02\x01\x12\x04\xfd\x20\x1b,\n\r\n\
    \x05\x046\x02\x02\x03\x12\x04\xfd\x20/0\nD\n\x04\x046\x02\x03\x12\x04\
    \xff\x20\x02\x14\x1a6\x20The\x20action\x20to\x20perform\x20with\x20the\
    \x20objects\x20in\x20the\x20PATCH.\n\n\r\n\x05\x046\x02\x03\x05\x12\x04\
    \xff\x20\x02\x08\n\r\n\x05\x046\x02\x03\x01\x12\x04\xff\x20\t\x0f\n\r\n\
    \x05\x046\x02\x03\x03\x12\x04\xff\x20\x12\x13\n\xb9\x04\n\x02\x047\x12\
    \x06\x96!\0\x9a!\x01\x1a8\x20POST\x20multiple\x20concept\x20languages\
    \x20for\x20the\x20given\x20concept.\n2\xeb\x01\x20//\x20DELETE\x20multip\
    le\x20concept\x20languages\x20for\x20the\x20given\x20concept.\n\x20messa\
    ge\x20DeleteConceptLanguageRequest\x20{\n\x20\x20\x20clarifai.api.UserAp\
    pIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20concept_id\x20=\
    \x202;\n\x20\x20\x20//\x20The\x20language\x20code\x20to\x20delete.\n\x20\
    \x20\x20string\x20language\x20=\x203;\n\x20}\n2\x82\x02\x20//\x20DELETE\
    \x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\
    \n\x20message\x20DeleteConceptLanguagesRequest\x20{\n\x20\x20\x20clarifa\
    i.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20conc\
    ept_id\x20=\x202;\n\x20\x20\x20//\x20The\x20language\x20code(s)\x20to\
    \x20delete.\n\x20\x20\x20string\x20ids\x20=\x203;\n\x20\x20\x20bool\x20d\
    elete_all\x20=\x204;\n\x20}\n\n\x0b\n\x03\x047\x01\x12\x04\x96!\x08#\n\
    \x0c\n\x04\x047\x02\0\x12\x04\x97!\x02,\n\r\n\x05\x047\x02\0\x06\x12\x04\
    \x97!\x02\x1b\n\r\n\x05\x047\x02\0\x01\x12\x04\x97!\x1c'\n\r\n\x05\x047\
    \x02\0\x03\x12\x04\x97!*+\n\x0c\n\x04\x047\x02\x01\x12\x04\x98!\x02\x18\
    \n\r\n\x05\x047\x02\x01\x05\x12\x04\x98!\x02\x08\n\r\n\x05\x047\x02\x01\
    \x01\x12\x04\x98!\t\x13\n\r\n\x05\x047\x02\x01\x03\x12\x04\x98!\x16\x17\
    \n\x0c\n\x04\x047\x02\x02\x12\x04\x99!\x021\n\r\n\x05\x047\x02\x02\x04\
    \x12\x04\x99!\x02\n\n\r\n\x05\x047\x02\x02\x06\x12\x04\x99!\x0b\x1a\n\r\
    \n\x05\x047\x02\x02\x01\x12\x04\x99!\x1b,\n\r\n\x05\x047\x02\x02\x03\x12\
    \x04\x99!/0\n-\n\x02\x048\x12\x06\x9d!\0\xa0!\x01\x1a\x1f\x20SingleConce\
    ptLanguageResponse\n\n\x0b\n\x03\x048\x01\x12\x04\x9d!\x08%\n\x0c\n\x04\
    \x048\x02\0\x12\x04\x9e!\x02(\n\r\n\x05\x048\x02\0\x06\x12\x04\x9e!\x02\
    \x1c\n\r\n\x05\x048\x02\0\x01\x12\x04\x9e!\x1d#\n\r\n\x05\x048\x02\0\x03\
    \x12\x04\x9e!&'\n\x0c\n\x04\x048\x02\x01\x12\x04\x9f!\x02'\n\r\n\x05\x04\
    8\x02\x01\x06\x12\x04\x9f!\x02\x11\n\r\n\x05\x048\x02\x01\x01\x12\x04\
    \x9f!\x12\"\n\r\n\x05\x048\x02\x01\x03\x12\x04\x9f!%&\n,\n\x02\x049\x12\
    \x06\xa3!\0\xa6!\x01\x1a\x1e\x20MultiConceptLanguageResponse\n\n\x0b\n\
    \x03\x049\x01\x12\x04\xa3!\x08$\n\x0c\n\x04\x049\x02\0\x12\x04\xa4!\x02(\
    \n\r\n\x05\x049\x02\0\x06\x12\x04\xa4!\x02\x1c\n\r\n\x05\x049\x02\0\x01\
    \x12\x04\xa4!\x1d#\n\r\n\x05\x049\x02\0\x03\x12\x04\xa4!&'\n\x0c\n\x04\
    \x049\x02\x01\x12\x04\xa5!\x02`\n\r\n\x05\x049\x02\x01\x04\x12\x04\xa5!\
    \x02\n\n\r\n\x05\x049\x02\x01\x06\x12\x04\xa5!\x0b\x1a\n\r\n\x05\x049\
    \x02\x01\x01\x12\x04\xa5!\x1b,\n\r\n\x05\x049\x02\x01\x03\x12\x04\xa5!/0\
    \n\r\n\x05\x049\x02\x01\x08\x12\x04\xa5!1_\n\x10\n\x08\x049\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xa5!2^\n\x1f\n\x02\x04:\x12\x06\xae!\0\xb1!\x01\x1a\
    \x11\x20GetInputRequest\n\n\x0b\n\x03\x04:\x01\x12\x04\xae!\x08\x17\n\
    \x0c\n\x04\x04:\x02\0\x12\x04\xaf!\x02,\n\r\n\x05\x04:\x02\0\x06\x12\x04\
    \xaf!\x02\x1b\n\r\n\x05\x04:\x02\0\x01\x12\x04\xaf!\x1c'\n\r\n\x05\x04:\
    \x02\0\x03\x12\x04\xaf!*+\n\x0c\n\x04\x04:\x02\x01\x12\x04\xb0!\x02\x16\
    \n\r\n\x05\x04:\x02\x01\x05\x12\x04\xb0!\x02\x08\n\r\n\x05\x04:\x02\x01\
    \x01\x12\x04\xb0!\t\x11\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xb0!\x14\x15\
    \n\x0c\n\x02\x04;\x12\x06\xb2!\0\xb5!\x01\n\x0b\n\x03\x04;\x01\x12\x04\
    \xb2!\x08\x1f\n\x0c\n\x04\x04;\x02\0\x12\x04\xb3!\x02,\n\r\n\x05\x04;\
    \x02\0\x06\x12\x04\xb3!\x02\x1b\n\r\n\x05\x04;\x02\0\x01\x12\x04\xb3!\
    \x1c'\n\r\n\x05\x04;\x02\0\x03\x12\x04\xb3!*+\n\x0c\n\x04\x04;\x02\x01\
    \x12\x04\xb4!\x02\x16\n\r\n\x05\x04;\x02\x01\x05\x12\x04\xb4!\x02\x08\n\
    \r\n\x05\x04;\x02\x01\x01\x12\x04\xb4!\t\x11\n\r\n\x05\x04;\x02\x01\x03\
    \x12\x04\xb4!\x14\x15\n&\n\x02\x04<\x12\x06\xb8!\0\xbd!\x01\x1a\x18\x20G\
    etInputSamplesRequest\n\n\x0b\n\x03\x04<\x01\x12\x04\xb8!\x08\x1e\n\x0c\
    \n\x04\x04<\x02\0\x12\x04\xb9!\x02,\n\r\n\x05\x04<\x02\0\x06\x12\x04\xb9\
    !\x02\x1b\n\r\n\x05\x04<\x02\0\x01\x12\x04\xb9!\x1c'\n\r\n\x05\x04<\x02\
    \0\x03\x12\x04\xb9!*+\n\x0c\n\x04\x04<\x02\x01\x12\x04\xba!\x02\x15\n\r\
    \n\x05\x04<\x02\x01\x05\x12\x04\xba!\x02\x08\n\r\n\x05\x04<\x02\x01\x01\
    \x12\x04\xba!\t\x10\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xba!\x13\x14\nN\n\
    \x04\x04<\x02\x02\x12\x04\xbc!\x02\x1f\x1a@\x20URL\x20param.\x20If\x20ze\
    ro\x20ids\x20provided,\x20returns\x20for\x20all\x20task\x20labelers\n\n\
    \r\n\x05\x04<\x02\x02\x04\x12\x04\xbc!\x02\n\n\r\n\x05\x04<\x02\x02\x05\
    \x12\x04\xbc!\x0b\x11\n\r\n\x05\x04<\x02\x02\x01\x12\x04\xbc!\x12\x1a\n\
    \r\n\x05\x04<\x02\x02\x03\x12\x04\xbc!\x1d\x1e\n!\n\x02\x04=\x12\x06\xc0\
    !\0\xcd!\x01\x1a\x13\x20ListInputsRequest\n\n\x0b\n\x03\x04=\x01\x12\x04\
    \xc0!\x08\x19\n\x0c\n\x04\x04=\x02\0\x12\x04\xc1!\x02,\n\r\n\x05\x04=\
    \x02\0\x06\x12\x04\xc1!\x02\x1b\n\r\n\x05\x04=\x02\0\x01\x12\x04\xc1!\
    \x1c'\n\r\n\x05\x04=\x02\0\x03\x12\x04\xc1!*+\n~\n\x04\x04=\x02\x01\x12\
    \x04\xc4!\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04=\x02\x01\
    \x05\x12\x04\xc4!\x02\x08\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xc4!\t\r\n\
    \r\n\x05\x04=\x02\x01\x03\x12\x04\xc4!\x10\x11\nu\n\x04\x04=\x02\x02\x12\
    \x04\xc7!\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numbe\
    r\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20p\
    age.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04=\x02\x02\x05\x12\x04\
    \xc7!\x02\x08\n\r\n\x05\x04=\x02\x02\x01\x12\x04\xc7!\t\x11\n\r\n\x05\
    \x04=\x02\x02\x03\x12\x04\xc7!\x14\x15\n.\n\x04\x04=\x02\x03\x12\x04\xca\
    !\x02(\x1a\x20\x20Set\x20status\x20to\x20filter\x20by\x20status\n\n\r\n\
    \x05\x04=\x02\x03\x06\x12\x04\xca!\x02\x1c\n\r\n\x05\x04=\x02\x03\x01\
    \x12\x04\xca!\x1d#\n\r\n\x05\x04=\x02\x03\x03\x12\x04\xca!&'\n\x0c\n\x04\
    \x04=\x02\x04\x12\x04\xcc!\x02\x1a\n\r\n\x05\x04=\x02\x04\x04\x12\x04\
    \xcc!\x02\n\n\r\n\x05\x04=\x02\x04\x05\x12\x04\xcc!\x0b\x11\n\r\n\x05\
    \x04=\x02\x04\x01\x12\x04\xcc!\x12\x15\n\r\n\x05\x04=\x02\x04\x03\x12\
    \x04\xcc!\x18\x19\n#\n\x02\x04>\x12\x06\xd0!\0\xdb!\x01\x1a\x15\x20Strea\
    mInputsRequest\n\n\x0b\n\x03\x04>\x01\x12\x04\xd0!\x08\x1b\n\x0c\n\x04\
    \x04>\x02\0\x12\x04\xd1!\x02,\n\r\n\x05\x04>\x02\0\x06\x12\x04\xd1!\x02\
    \x1b\n\r\n\x05\x04>\x02\0\x01\x12\x04\xd1!\x1c'\n\r\n\x05\x04>\x02\0\x03\
    \x12\x04\xd1!*+\nt\n\x04\x04>\x02\x01\x12\x04\xd4!\x02\x16\x1af\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x2020.\
    \n\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xd4!\x02\x08\n\r\n\x05\x04>\x02\
    \x01\x01\x12\x04\xd4!\t\x11\n\r\n\x05\x04>\x02\x01\x03\x12\x04\xd4!\x14\
    \x15\n\x0c\n\x04\x04>\x02\x02\x12\x04\xd5!\x02\x15\n\r\n\x05\x04>\x02\
    \x02\x05\x12\x04\xd5!\x02\x08\n\r\n\x05\x04>\x02\x02\x01\x12\x04\xd5!\t\
    \x10\n\r\n\x05\x04>\x02\x02\x03\x12\x04\xd5!\x13\x14\n\x8a\x01\n\x04\x04\
    >\x02\x03\x12\x04\xd9!\x02\x17\x1a|\x20By\x20default,\x20the\x20endpoint\
    \x20return\x20inputs\x20by\x20the\x20time\x20when\x20it\x20is\x20added.\
    \n\x20If\x20this\x20is\x20set\x20to\x20true,\x20we\x20will\x20return\x20\
    inputs\x20by\x20id.\n\n\r\n\x05\x04>\x02\x03\x05\x12\x04\xd9!\x02\x06\n\
    \r\n\x05\x04>\x02\x03\x01\x12\x04\xd9!\x07\x12\n\r\n\x05\x04>\x02\x03\
    \x03\x12\x04\xd9!\x15\x16\n\x0c\n\x04\x04>\x02\x04\x12\x04\xda!\x02\x16\
    \n\r\n\x05\x04>\x02\x04\x05\x12\x04\xda!\x02\x06\n\r\n\x05\x04>\x02\x04\
    \x01\x12\x04\xda!\x07\x11\n\r\n\x05\x04>\x02\x04\x03\x12\x04\xda!\x14\
    \x15\n!\n\x02\x04?\x12\x06\xde!\0\xf0!\x01\x1a\x13\x20PostInputsRequest\
    \n\n\x0b\n\x03\x04?\x01\x12\x04\xde!\x08\x19\n\x0c\n\x04\x04?\x02\0\x12\
    \x04\xdf!\x02,\n\r\n\x05\x04?\x02\0\x06\x12\x04\xdf!\x02\x1b\n\r\n\x05\
    \x04?\x02\0\x01\x12\x04\xdf!\x1c'\n\r\n\x05\x04?\x02\0\x03\x12\x04\xdf!*\
    +\nt\n\x04\x04?\x02\x01\x12\x04\xe6!\x02\x1c\x1af\x20List\x20of\x20input\
    s\x20to\x20post.\n\x20For\x20each\x20input,\x20the\x20following\x20field\
    s\x20are\x20used:\n\x20*\x20id\n\x20*\x20data\n\x20*\x20dataset_ids\n\n\
    \r\n\x05\x04?\x02\x01\x04\x12\x04\xe6!\x02\n\n\r\n\x05\x04?\x02\x01\x06\
    \x12\x04\xe6!\x0b\x10\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xe6!\x11\x17\n\
    \r\n\x05\x04?\x02\x01\x03\x12\x04\xe6!\x1a\x1b\n\xc9\x02\n\x04\x04?\x02\
    \x02\x12\x04\xec!\x02\x1f\x1a\xba\x02\x20Collect\x20statistics\x20about\
    \x20created\x20inputs\x20in\x20job\x20with\x20given\x20ID.\n\x20*\x20If\
    \x20job\x20ID\x20is\x20empty,\x20then\x20job\x20is\x20not\x20created.\n\
    \x20*\x20If\x20job\x20ID\x20is\x20non-empty\x20and\x20doesn't\x20already\
    \x20exist,\x20then\x20a\x20new\x20job\x20will\x20be\x20created\x20with\
    \x20given\x20ID.\n\x20*\x20If\x20job\x20ID\x20does\x20already\x20exist,\
    \x20then\x20new\x20inputs\x20statistics\x20are\x20merged\x20with\x20prev\
    ious\x20inputs\x20statistics.\n\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xec!\
    \x02\x08\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xec!\t\x1a\n\r\n\x05\x04?\
    \x02\x02\x03\x12\x04\xec!\x1d\x1e\n1\n\x04\x04?\x02\x03\x12\x04\xef!\x02\
    =\x1a#\x20How\x20to\x20handle\x20input\x20ID\x20conflicts.\n\n\r\n\x05\
    \x04?\x02\x03\x06\x12\x04\xef!\x02\x1b\n\r\n\x05\x04?\x02\x03\x01\x12\
    \x04\xef!\x1c8\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xef!;<\n\"\n\x02\x04@\
    \x12\x06\xf7!\0\x83\"\x01\x1a\x14\x20PatchInputsRequest\n\n\x0b\n\x03\
    \x04@\x01\x12\x04\xf7!\x08\x1a\n\x0c\n\x04\x04@\x02\0\x12\x04\xf8!\x02,\
    \n\r\n\x05\x04@\x02\0\x06\x12\x04\xf8!\x02\x1b\n\r\n\x05\x04@\x02\0\x01\
    \x12\x04\xf8!\x1c'\n\r\n\x05\x04@\x02\0\x03\x12\x04\xf8!*+\n\x89\x01\n\
    \x04\x04@\x02\x01\x12\x04\xfe!\x02\x1c\x1a{\x20List\x20of\x20inputs\x20t\
    o\x20patch.\n\x20Inputs\x20are\x20identified\x20by\x20id\x20field.\n\x20\
    For\x20each\x20input,\x20the\x20following\x20fields\x20are\x20patchable:\
    \n\x20*\x20data\n\n\r\n\x05\x04@\x02\x01\x04\x12\x04\xfe!\x02\n\n\r\n\
    \x05\x04@\x02\x01\x06\x12\x04\xfe!\x0b\x10\n\r\n\x05\x04@\x02\x01\x01\
    \x12\x04\xfe!\x11\x17\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xfe!\x1a\x1b\n~\
    \n\x04\x04@\x02\x02\x12\x04\x82\"\x02\x14\x1ap\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20action\
    s\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\
    \r\n\x05\x04@\x02\x02\x05\x12\x04\x82\"\x02\x08\n\r\n\x05\x04@\x02\x02\
    \x01\x12\x04\x82\"\t\x0f\n\r\n\x05\x04@\x02\x02\x03\x12\x04\x82\"\x12\
    \x13\n\"\n\x02\x04A\x12\x06\x86\"\0\x89\"\x01\x1a\x14\x20DeleteInputRequ\
    est\n\n\x0b\n\x03\x04A\x01\x12\x04\x86\"\x08\x1a\n\x0c\n\x04\x04A\x02\0\
    \x12\x04\x87\"\x02,\n\r\n\x05\x04A\x02\0\x06\x12\x04\x87\"\x02\x1b\n\r\n\
    \x05\x04A\x02\0\x01\x12\x04\x87\"\x1c'\n\r\n\x05\x04A\x02\0\x03\x12\x04\
    \x87\"*+\n\x0c\n\x04\x04A\x02\x01\x12\x04\x88\"\x02\x16\n\r\n\x05\x04A\
    \x02\x01\x05\x12\x04\x88\"\x02\x08\n\r\n\x05\x04A\x02\x01\x01\x12\x04\
    \x88\"\t\x11\n\r\n\x05\x04A\x02\x01\x03\x12\x04\x88\"\x14\x15\nD\n\x02\
    \x04B\x12\x06\x8c\"\0\x91\"\x01\x1a6\x20Request\x20to\x20delete\x20sever\
    al\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04B\x01\
    \x12\x04\x8c\"\x08\x1b\n\x0b\n\x03\x04B\t\x12\x04\x8d\"\x02\r\n\x0c\n\
    \x04\x04B\t\0\x12\x04\x8d\"\x0b\x0c\n\r\n\x05\x04B\t\0\x01\x12\x04\x8d\"\
    \x0b\x0c\n\r\n\x05\x04B\t\0\x02\x12\x04\x8d\"\x0b\x0c\n\x0c\n\x04\x04B\
    \x02\0\x12\x04\x8f\"\x02,\n\r\n\x05\x04B\x02\0\x06\x12\x04\x8f\"\x02\x1b\
    \n\r\n\x05\x04B\x02\0\x01\x12\x04\x8f\"\x1c'\n\r\n\x05\x04B\x02\0\x03\
    \x12\x04\x8f\"*+\n\x0c\n\x04\x04B\x02\x01\x12\x04\x90\"\x02\x1a\n\r\n\
    \x05\x04B\x02\x01\x04\x12\x04\x90\"\x02\n\n\r\n\x05\x04B\x02\x01\x05\x12\
    \x04\x90\"\x0b\x11\n\r\n\x05\x04B\x02\x01\x01\x12\x04\x90\"\x12\x15\n\r\
    \n\x05\x04B\x02\x01\x03\x12\x04\x90\"\x18\x19\n#\n\x02\x04C\x12\x06\x94\
    \"\0\x97\"\x01\x1a\x15\x20SingleInputResponse\n\n\x0b\n\x03\x04C\x01\x12\
    \x04\x94\"\x08\x1b\n\x0c\n\x04\x04C\x02\0\x12\x04\x95\"\x02(\n\r\n\x05\
    \x04C\x02\0\x06\x12\x04\x95\"\x02\x1c\n\r\n\x05\x04C\x02\0\x01\x12\x04\
    \x95\"\x1d#\n\r\n\x05\x04C\x02\0\x03\x12\x04\x95\"&'\n\x0c\n\x04\x04C\
    \x02\x01\x12\x04\x96\"\x02\x12\n\r\n\x05\x04C\x02\x01\x06\x12\x04\x96\"\
    \x02\x07\n\r\n\x05\x04C\x02\x01\x01\x12\x04\x96\"\x08\r\n\r\n\x05\x04C\
    \x02\x01\x03\x12\x04\x96\"\x10\x11\n\x0c\n\x02\x04D\x12\x06\x99\"\0\xa0\
    \"\x01\n\x0b\n\x03\x04D\x01\x12\x04\x99\"\x08\x20\n\x0c\n\x04\x04D\x02\0\
    \x12\x04\x9a\"\x02(\n\r\n\x05\x04D\x02\0\x06\x12\x04\x9a\"\x02\x1c\n\r\n\
    \x05\x04D\x02\0\x01\x12\x04\x9a\"\x1d#\n\r\n\x05\x04D\x02\0\x03\x12\x04\
    \x9a\"&'\n\x95\x01\n\x04\x04D\x02\x01\x12\x04\x9f\"\x02\x1a\x1a\x86\x01\
    \x20MPEG-dash\x20manifest\x20as\x20data-URI,\x20base64-encoded\n\x20Can\
    \x20be\x20empty\x20if\x20status\x20is\x20FAILED\n\x20Can\x20be\x20fallba\
    ck\x20manifest\x20if\x20status\x20is\x20MIXED_STATUS\n\n\r\n\x05\x04D\
    \x02\x01\x05\x12\x04\x9f\"\x02\x08\n\r\n\x05\x04D\x02\x01\x01\x12\x04\
    \x9f\"\t\x15\n\r\n\x05\x04D\x02\x01\x03\x12\x04\x9f\"\x18\x19\n\"\n\x02\
    \x04E\x12\x06\xa3\"\0\xa9\"\x01\x1a\x14\x20MultiInputResponse\n\n\x0b\n\
    \x03\x04E\x01\x12\x04\xa3\"\x08\x1a\n\x0c\n\x04\x04E\x02\0\x12\x04\xa5\"\
    \x02(\n\r\n\x05\x04E\x02\0\x06\x12\x04\xa5\"\x02\x1c\n\r\n\x05\x04E\x02\
    \0\x01\x12\x04\xa5\"\x1d#\n\r\n\x05\x04E\x02\0\x03\x12\x04\xa5\"&'\n\x0c\
    \n\x04\x04E\x02\x01\x12\x04\xa6\"\x02K\n\r\n\x05\x04E\x02\x01\x04\x12\
    \x04\xa6\"\x02\n\n\r\n\x05\x04E\x02\x01\x06\x12\x04\xa6\"\x0b\x10\n\r\n\
    \x05\x04E\x02\x01\x01\x12\x04\xa6\"\x11\x17\n\r\n\x05\x04E\x02\x01\x03\
    \x12\x04\xa6\"\x1a\x1b\n\r\n\x05\x04E\x02\x01\x08\x12\x04\xa6\"\x1cJ\n\
    \x10\n\x08\x04E\x02\x01\x08\xd0\x86\x03\x12\x04\xa6\"\x1dI\n\x0c\n\x04\
    \x04E\x02\x02\x12\x04\xa8\"\x02\"\n\r\n\x05\x04E\x02\x02\x06\x12\x04\xa8\
    \"\x02\x0e\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xa8\"\x0f\x1d\n\r\n\x05\
    \x04E\x02\x02\x03\x12\x04\xa8\"\x20!\n,\n\x02\x04F\x12\x06\xac\"\0\xb0\"\
    \x01\x1a\x1e\x20MultiInputAnnotationResponse\n\n\x0b\n\x03\x04F\x01\x12\
    \x04\xac\"\x08$\n\x0c\n\x04\x04F\x02\0\x12\x04\xae\"\x02(\n\r\n\x05\x04F\
    \x02\0\x06\x12\x04\xae\"\x02\x1c\n\r\n\x05\x04F\x02\0\x01\x12\x04\xae\"\
    \x1d#\n\r\n\x05\x04F\x02\0\x03\x12\x04\xae\"&'\n\x0c\n\x04\x04F\x02\x01\
    \x12\x04\xaf\"\x02G\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xaf\"\x02\n\n\r\n\
    \x05\x04F\x02\x01\x06\x12\x04\xaf\"\x0b\x0e\n\r\n\x05\x04F\x02\x01\x01\
    \x12\x04\xaf\"\x0f\x13\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xaf\"\x16\x17\
    \n\r\n\x05\x04F\x02\x01\x08\x12\x04\xaf\"\x18F\n\x10\n\x08\x04F\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xaf\"\x19E\n(\n\x02\x04G\x12\x06\xb3\"\0\xb7\"\
    \x01\x1a\x1a\x20SingleInputCountResponse\n\n\x0b\n\x03\x04G\x01\x12\x04\
    \xb3\"\x08\x20\n\x0c\n\x04\x04G\x02\0\x12\x04\xb4\"\x02(\n\r\n\x05\x04G\
    \x02\0\x06\x12\x04\xb4\"\x02\x1c\n\r\n\x05\x04G\x02\0\x01\x12\x04\xb4\"\
    \x1d#\n\r\n\x05\x04G\x02\0\x03\x12\x04\xb4\"&'\n\x0c\n\x04\x04G\x02\x01\
    \x12\x04\xb6\"\x02\x18\n\r\n\x05\x04G\x02\x01\x06\x12\x04\xb6\"\x02\x0c\
    \n\r\n\x05\x04G\x02\x01\x01\x12\x04\xb6\"\r\x13\n\r\n\x05\x04G\x02\x01\
    \x03\x12\x04\xb6\"\x16\x17\n$\n\x02\x04H\x12\x06\xba\"\0\xbc\"\x01\x1a\
    \x16\x20GetInputCountRequest\n\n\x0b\n\x03\x04H\x01\x12\x04\xba\"\x08\
    \x1c\n\x0c\n\x04\x04H\x02\0\x12\x04\xbb\"\x02,\n\r\n\x05\x04H\x02\0\x06\
    \x12\x04\xbb\"\x02\x1b\n\r\n\x05\x04H\x02\0\x01\x12\x04\xbb\"\x1c'\n\r\n\
    \x05\x04H\x02\0\x03\x12\x04\xbb\"*+\n#\n\x02\x04I\x12\x06\xbf\"\0\xd8\"\
    \x01\x1a\x15\x20ListDatasetsRequest\n\n\x0b\n\x03\x04I\x01\x12\x04\xbf\"\
    \x08\x1b\n\x0c\n\x04\x04I\x02\0\x12\x04\xc0\"\x02,\n\r\n\x05\x04I\x02\0\
    \x06\x12\x04\xc0\"\x02\x1b\n\r\n\x05\x04I\x02\0\x01\x12\x04\xc0\"\x1c'\n\
    \r\n\x05\x04I\x02\0\x03\x12\x04\xc0\"*+\n~\n\x04\x04I\x02\x01\x12\x04\
    \xc3\"\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20\
    number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20\
    into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04I\x02\x01\x05\
    \x12\x04\xc3\"\x02\x08\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xc3\"\t\r\n\r\
    \n\x05\x04I\x02\x01\x03\x12\x04\xc3\"\x10\x11\nu\n\x04\x04I\x02\x02\x12\
    \x04\xc6\"\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numb\
    er\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20\
    page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04I\x02\x02\x05\x12\x04\
    \xc6\"\x02\x08\n\r\n\x05\x04I\x02\x02\x01\x12\x04\xc6\"\t\x11\n\r\n\x05\
    \x04I\x02\x02\x03\x12\x04\xc6\"\x14\x15\n\x0c\n\x04\x04I\x02\x03\x12\x04\
    \xc7\"\x02\x18\n\r\n\x05\x04I\x02\x03\x05\x12\x04\xc7\"\x02\x06\n\r\n\
    \x05\x04I\x02\x03\x01\x12\x04\xc7\"\x07\x13\n\r\n\x05\x04I\x02\x03\x03\
    \x12\x04\xc7\"\x16\x17\n\x0c\n\x04\x04I\x02\x04\x12\x04\xc8\"\x02(\n\r\n\
    \x05\x04I\x02\x04\x04\x12\x04\xc8\"\x02\n\n\r\n\x05\x04I\x02\x04\x05\x12\
    \x04\xc8\"\x0b\x11\n\r\n\x05\x04I\x02\x04\x01\x12\x04\xc8\"\x12#\n\r\n\
    \x05\x04I\x02\x04\x03\x12\x04\xc8\"&'\no\n\x04\x04I\x02\x05\x12\x04\xcb\
    \"\x02\x1a\x1aa\x20Sorting\x20opitons:\n\x20Whether\x20to\x20sort\x20in\
    \x20ascending\x20order.\x20If\x20false,\x20will\x20order\x20in\x20descen\
    ding\x20order.\n\n\r\n\x05\x04I\x02\x05\x05\x12\x04\xcb\"\x02\x06\n\r\n\
    \x05\x04I\x02\x05\x01\x12\x04\xcb\"\x07\x15\n\r\n\x05\x04I\x02\x05\x03\
    \x12\x04\xcb\"\x18\x19\n\x0e\n\x04\x04I\x08\0\x12\x06\xcc\"\x02\xd5\"\
    \x03\n\r\n\x05\x04I\x08\0\x01\x12\x04\xcc\"\x08\x0f\n8\n\x04\x04I\x02\
    \x06\x12\x04\xce\"\x04\x20\x1a*\x20Whether\x20to\x20order\x20by\x20the\
    \x20created_at\x20time.\n\n\r\n\x05\x04I\x02\x06\x05\x12\x04\xce\"\x04\
    \x08\n\r\n\x05\x04I\x02\x06\x01\x12\x04\xce\"\t\x1b\n\r\n\x05\x04I\x02\
    \x06\x03\x12\x04\xce\"\x1e\x1f\nF\n\x04\x04I\x02\x07\x12\x04\xd0\"\x04\
    \x20\x1a8\x20Whether\x20to\x20order\x20by\x20the\x20number\x20of\x20user\
    s\x20stared\x20the\x20app\n\n\r\n\x05\x04I\x02\x07\x05\x12\x04\xd0\"\x04\
    \x08\n\r\n\x05\x04I\x02\x07\x01\x12\x04\xd0\"\t\x1b\n\r\n\x05\x04I\x02\
    \x07\x03\x12\x04\xd0\"\x1e\x1f\nP\n\x04\x04I\x02\x08\x12\x04\xd2\"\x04!\
    \x1aB\x20If\x20neither\x20sort\x20option\x20is\x20set\x20to\x20true,\x20\
    will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04I\x02\x08\x05\x12\x04\
    \xd2\"\x04\x08\n\r\n\x05\x04I\x02\x08\x01\x12\x04\xd2\"\t\x1c\n\r\n\x05\
    \x04I\x02\x08\x03\x12\x04\xd2\"\x1f\x20\n3\n\x04\x04I\x02\t\x12\x04\xd4\
    \"\x04\x19\x1a%\x20Whether\x20to\x20order\x20by\x20the\x20external\x20id\
    \n\n\r\n\x05\x04I\x02\t\x05\x12\x04\xd4\"\x04\x08\n\r\n\x05\x04I\x02\t\
    \x01\x12\x04\xd4\"\t\x13\n\r\n\x05\x04I\x02\t\x03\x12\x04\xd4\"\x16\x18\
    \n~\n\x04\x04I\x02\n\x12\x04\xd7\"\x02\x15\x1ap\x20Filter\x20datasets\
    \x20by\x20bookmark.\x20If\x20set,\x20only\x20return\x20bookmarked\x20dat\
    asets.\x20Otherwise\x20none\x20bookmarked\x20datasets\x20only.\n\n\r\n\
    \x05\x04I\x02\n\x05\x12\x04\xd7\"\x02\x06\n\r\n\x05\x04I\x02\n\x01\x12\
    \x04\xd7\"\x07\x0f\n\r\n\x05\x04I\x02\n\x03\x12\x04\xd7\"\x12\x14\n!\n\
    \x02\x04J\x12\x06\xdb\"\0\xe1\"\x01\x1a\x13\x20GetDatasetRequest\n\n\x0b\
    \n\x03\x04J\x01\x12\x04\xdb\"\x08\x19\n\x0c\n\x04\x04J\x02\0\x12\x04\xdc\
    \"\x02,\n\r\n\x05\x04J\x02\0\x06\x12\x04\xdc\"\x02\x1b\n\r\n\x05\x04J\
    \x02\0\x01\x12\x04\xdc\"\x1c'\n\r\n\x05\x04J\x02\0\x03\x12\x04\xdc\"*+\n\
    '\n\x04\x04J\x02\x01\x12\x04\xdf\"\x02\x18\x1a\x19\x20Identify\x20datase\
    t\x20by\x20id.\n\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xdf\"\x02\x08\n\r\n\
    \x05\x04J\x02\x01\x01\x12\x04\xdf\"\t\x13\n\r\n\x05\x04J\x02\x01\x03\x12\
    \x04\xdf\"\x16\x17\n\x0c\n\x04\x04J\x02\x02\x12\x04\xe0\"\x02(\n\r\n\x05\
    \x04J\x02\x02\x04\x12\x04\xe0\"\x02\n\n\r\n\x05\x04J\x02\x02\x05\x12\x04\
    \xe0\"\x0b\x11\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xe0\"\x12#\n\r\n\x05\
    \x04J\x02\x02\x03\x12\x04\xe0\"&'\n4\n\x02\x04K\x12\x06\xe4\"\0\xe9\"\
    \x01\x1a&\x20Request\x20to\x20add\x20one\x20or\x20more\x20datasets.\n\n\
    \x0b\n\x03\x04K\x01\x12\x04\xe4\"\x08\x1b\n\x0c\n\x04\x04K\x02\0\x12\x04\
    \xe5\"\x02,\n\r\n\x05\x04K\x02\0\x06\x12\x04\xe5\"\x02\x1b\n\r\n\x05\x04\
    K\x02\0\x01\x12\x04\xe5\"\x1c'\n\r\n\x05\x04K\x02\0\x03\x12\x04\xe5\"*+\
    \n@\n\x04\x04K\x02\x01\x12\x04\xe8\"\x02\x20\x1a2\x20List\x20of\x20datas\
    ets\x20that\x20are\x20requested\x20to\x20be\x20added.\n\n\r\n\x05\x04K\
    \x02\x01\x04\x12\x04\xe8\"\x02\n\n\r\n\x05\x04K\x02\x01\x06\x12\x04\xe8\
    \"\x0b\x12\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xe8\"\x13\x1b\n\r\n\x05\
    \x04K\x02\x01\x03\x12\x04\xe8\"\x1e\x1f\n2\n\x02\x04L\x12\x06\xec\"\0\
    \xf5\"\x01\x1a$\x20Request\x20to\x20patch\x20several\x20datasets.\n\n\
    \x0b\n\x03\x04L\x01\x12\x04\xec\"\x08\x1c\n\x0c\n\x04\x04L\x02\0\x12\x04\
    \xed\"\x02,\n\r\n\x05\x04L\x02\0\x06\x12\x04\xed\"\x02\x1b\n\r\n\x05\x04\
    L\x02\0\x01\x12\x04\xed\"\x1c'\n\r\n\x05\x04L\x02\0\x03\x12\x04\xed\"*+\
    \nB\n\x04\x04L\x02\x01\x12\x04\xf0\"\x02\x20\x1a4\x20List\x20of\x20datas\
    ets\x20that\x20are\x20requested\x20to\x20be\x20updated.\n\n\r\n\x05\x04L\
    \x02\x01\x04\x12\x04\xf0\"\x02\n\n\r\n\x05\x04L\x02\x01\x06\x12\x04\xf0\
    \"\x0b\x12\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xf0\"\x13\x1b\n\r\n\x05\
    \x04L\x02\x01\x03\x12\x04\xf0\"\x1e\x1f\ng\n\x04\x04L\x02\x02\x12\x04\
    \xf4\"\x02\x14\x1aY\x20The\x20action\x20to\x20perform\x20on\x20the\x20pa\
    tched\x20objects\n\x20Supported\x20values:\x20'overwrite'\x20and\x20'mer\
    ge'\n\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xf4\"\x02\x08\n\r\n\x05\x04L\
    \x02\x02\x01\x12\x04\xf4\"\t\x0f\n\r\n\x05\x04L\x02\x02\x03\x12\x04\xf4\
    \"\x12\x13\nB\n\x02\x04M\x12\x06\xf8\"\0\xfb\"\x01\x1a4\x20Request\x20to\
    \x20delete\x20several\x20datasets\x20by\x20list\x20of\x20ids.\n\n\x0b\n\
    \x03\x04M\x01\x12\x04\xf8\"\x08\x1d\n\x0c\n\x04\x04M\x02\0\x12\x04\xf9\"\
    \x02,\n\r\n\x05\x04M\x02\0\x06\x12\x04\xf9\"\x02\x1b\n\r\n\x05\x04M\x02\
    \0\x01\x12\x04\xf9\"\x1c'\n\r\n\x05\x04M\x02\0\x03\x12\x04\xf9\"*+\n\x0c\
    \n\x04\x04M\x02\x01\x12\x04\xfa\"\x02\"\n\r\n\x05\x04M\x02\x01\x04\x12\
    \x04\xfa\"\x02\n\n\r\n\x05\x04M\x02\x01\x05\x12\x04\xfa\"\x0b\x11\n\r\n\
    \x05\x04M\x02\x01\x01\x12\x04\xfa\"\x12\x1d\n\r\n\x05\x04M\x02\x01\x03\
    \x12\x04\xfa\"\x20!\n$\n\x02\x04N\x12\x06\xfe\"\0\x81#\x01\x1a\x16\x20Mu\
    ltiDatasetResponse\n\n\x0b\n\x03\x04N\x01\x12\x04\xfe\"\x08\x1c\n\x0c\n\
    \x04\x04N\x02\0\x12\x04\xff\"\x02(\n\r\n\x05\x04N\x02\0\x06\x12\x04\xff\
    \"\x02\x1c\n\r\n\x05\x04N\x02\0\x01\x12\x04\xff\"\x1d#\n\r\n\x05\x04N\
    \x02\0\x03\x12\x04\xff\"&'\n\x0c\n\x04\x04N\x02\x01\x12\x04\x80#\x02O\n\
    \r\n\x05\x04N\x02\x01\x04\x12\x04\x80#\x02\n\n\r\n\x05\x04N\x02\x01\x06\
    \x12\x04\x80#\x0b\x12\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x80#\x13\x1b\n\
    \r\n\x05\x04N\x02\x01\x03\x12\x04\x80#\x1e\x1f\n\r\n\x05\x04N\x02\x01\
    \x08\x12\x04\x80#\x20N\n\x10\n\x08\x04N\x02\x01\x08\xd0\x86\x03\x12\x04\
    \x80#!M\n%\n\x02\x04O\x12\x06\x84#\0\x87#\x01\x1a\x17\x20SingleDatasetRe\
    sponse\n\n\x0b\n\x03\x04O\x01\x12\x04\x84#\x08\x1d\n\x0c\n\x04\x04O\x02\
    \0\x12\x04\x85#\x02(\n\r\n\x05\x04O\x02\0\x06\x12\x04\x85#\x02\x1c\n\r\n\
    \x05\x04O\x02\0\x01\x12\x04\x85#\x1d#\n\r\n\x05\x04O\x02\0\x03\x12\x04\
    \x85#&'\n\x0c\n\x04\x04O\x02\x01\x12\x04\x86#\x02\x16\n\r\n\x05\x04O\x02\
    \x01\x06\x12\x04\x86#\x02\t\n\r\n\x05\x04O\x02\x01\x01\x12\x04\x86#\n\
    \x11\n\r\n\x05\x04O\x02\x01\x03\x12\x04\x86#\x14\x15\n(\n\x02\x04P\x12\
    \x06\x8a#\0\x94#\x01\x1a\x1a\x20ListDatasetInputsRequest\n\n\x0b\n\x03\
    \x04P\x01\x12\x04\x8a#\x08\x20\n\x0c\n\x04\x04P\x02\0\x12\x04\x8b#\x02,\
    \n\r\n\x05\x04P\x02\0\x06\x12\x04\x8b#\x02\x1b\n\r\n\x05\x04P\x02\0\x01\
    \x12\x04\x8b#\x1c'\n\r\n\x05\x04P\x02\0\x03\x12\x04\x8b#*+\n'\n\x04\x04P\
    \x02\x01\x12\x04\x8d#\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id\
    .\n\n\r\n\x05\x04P\x02\x01\x05\x12\x04\x8d#\x02\x08\n\r\n\x05\x04P\x02\
    \x01\x01\x12\x04\x8d#\t\x13\n\r\n\x05\x04P\x02\x01\x03\x12\x04\x8d#\x16\
    \x17\n~\n\x04\x04P\x02\x02\x12\x04\x90#\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\r\n\x05\x04P\x02\x02\x05\x12\x04\x90#\x02\x08\n\r\n\x05\x04P\x02\
    \x02\x01\x12\x04\x90#\t\r\n\r\n\x05\x04P\x02\x02\x03\x12\x04\x90#\x10\
    \x11\nu\n\x04\x04P\x02\x03\x12\x04\x93#\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04P\x02\x03\x05\x12\x04\x93#\x02\x08\n\r\n\x05\x04P\x02\x03\x01\
    \x12\x04\x93#\t\x11\n\r\n\x05\x04P\x02\x03\x03\x12\x04\x93#\x14\x15\n&\n\
    \x02\x04Q\x12\x06\x97#\0\x9f#\x01\x1a\x18\x20GetDatasetInputRequest\n\n\
    \x0b\n\x03\x04Q\x01\x12\x04\x97#\x08\x1e\n\x0c\n\x04\x04Q\x02\0\x12\x04\
    \x98#\x02,\n\r\n\x05\x04Q\x02\0\x06\x12\x04\x98#\x02\x1b\n\r\n\x05\x04Q\
    \x02\0\x01\x12\x04\x98#\x1c'\n\r\n\x05\x04Q\x02\0\x03\x12\x04\x98#*+\n'\
    \n\x04\x04Q\x02\x01\x12\x04\x9b#\x02\x18\x1a\x19\x20Identify\x20dataset\
    \x20by\x20id.\n\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\x9b#\x02\x08\n\r\n\
    \x05\x04Q\x02\x01\x01\x12\x04\x9b#\t\x13\n\r\n\x05\x04Q\x02\x01\x03\x12\
    \x04\x9b#\x16\x17\n-\n\x04\x04Q\x02\x02\x12\x04\x9e#\x02\x16\x1a\x1f\x20\
    Identify\x20dataset\x20input\x20by\x20id.\n\n\r\n\x05\x04Q\x02\x02\x05\
    \x12\x04\x9e#\x02\x08\n\r\n\x05\x04Q\x02\x02\x01\x12\x04\x9e#\t\x11\n\r\
    \n\x05\x04Q\x02\x02\x03\x12\x04\x9e#\x14\x15\n4\n\x02\x04R\x12\x06\xa2#\
    \0\xae#\x01\x1a&\x20Request\x20to\x20add\x20one\x20or\x20more\x20dataset\
    s.\n\n\x0b\n\x03\x04R\x01\x12\x04\xa2#\x08\x20\n\x0c\n\x04\x04R\x02\0\
    \x12\x04\xa3#\x02,\n\r\n\x05\x04R\x02\0\x06\x12\x04\xa3#\x02\x1b\n\r\n\
    \x05\x04R\x02\0\x01\x12\x04\xa3#\x1c'\n\r\n\x05\x04R\x02\0\x03\x12\x04\
    \xa3#*+\n'\n\x04\x04R\x02\x01\x12\x04\xa6#\x02\x18\x1a\x19\x20Identify\
    \x20dataset\x20by\x20id.\n\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xa6#\x02\
    \x08\n\r\n\x05\x04R\x02\x01\x01\x12\x04\xa6#\t\x13\n\r\n\x05\x04R\x02\
    \x01\x03\x12\x04\xa6#\x16\x17\n\x96\x01\n\x04\x04R\x02\x02\x12\x04\xaa#\
    \x02+\x1a\x87\x01\x20List\x20of\x20inputs\x20that\x20are\x20requested\
    \x20to\x20be\x20added\x20to\x20this\x20dataset.\n\x20Identify\x20each\
    \x20input\x20by\x20id\x20field.\x20All\x20other\x20inputs\x20fields\x20a\
    re\x20ignored.\n\n\r\n\x05\x04R\x02\x02\x04\x12\x04\xaa#\x02\n\n\r\n\x05\
    \x04R\x02\x02\x06\x12\x04\xaa#\x0b\x17\n\r\n\x05\x04R\x02\x02\x01\x12\
    \x04\xaa#\x18&\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xaa#)*\nC\n\x04\x04R\
    \x02\x03\x12\x04\xad#\x02\x14\x1a5\x20Query\x20to\x20search\x20inputs\
    \x20to\x20be\x20added\x20to\x20this\x20dataset.\n\n\r\n\x05\x04R\x02\x03\
    \x06\x12\x04\xad#\x02\x08\n\r\n\x05\x04R\x02\x03\x01\x12\x04\xad#\t\x0f\
    \n\r\n\x05\x04R\x02\x03\x03\x12\x04\xad#\x12\x13\nH\n\x02\x04S\x12\x06\
    \xb1#\0\xb9#\x01\x1a:\x20Request\x20to\x20delete\x20several\x20dataset\
    \x20inputs\x20by\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04S\x01\x12\x04\
    \xb1#\x08\"\n\x0c\n\x04\x04S\x02\0\x12\x04\xb2#\x02,\n\r\n\x05\x04S\x02\
    \0\x06\x12\x04\xb2#\x02\x1b\n\r\n\x05\x04S\x02\0\x01\x12\x04\xb2#\x1c'\n\
    \r\n\x05\x04S\x02\0\x03\x12\x04\xb2#*+\n'\n\x04\x04S\x02\x01\x12\x04\xb5\
    #\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\x05\x04S\
    \x02\x01\x05\x12\x04\xb5#\x02\x08\n\r\n\x05\x04S\x02\x01\x01\x12\x04\xb5\
    #\t\x13\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xb5#\x16\x17\n<\n\x04\x04S\
    \x02\x02\x12\x04\xb8#\x02\x20\x1a.\x20Specify\x20which\x20inputs\x20to\
    \x20delete\x20from\x20dataset.\n\n\r\n\x05\x04S\x02\x02\x04\x12\x04\xb8#\
    \x02\n\n\r\n\x05\x04S\x02\x02\x05\x12\x04\xb8#\x0b\x11\n\r\n\x05\x04S\
    \x02\x02\x01\x12\x04\xb8#\x12\x1b\n\r\n\x05\x04S\x02\x02\x03\x12\x04\xb8\
    #\x1e\x1f\n)\n\x02\x04T\x12\x06\xbc#\0\xc0#\x01\x1a\x1b\x20MultiDatasetI\
    nputResponse\n\n\x0b\n\x03\x04T\x01\x12\x04\xbc#\x08!\n\x0c\n\x04\x04T\
    \x02\0\x12\x04\xbd#\x02(\n\r\n\x05\x04T\x02\0\x06\x12\x04\xbd#\x02\x1c\n\
    \r\n\x05\x04T\x02\0\x01\x12\x04\xbd#\x1d#\n\r\n\x05\x04T\x02\0\x03\x12\
    \x04\xbd#&'\n\x0c\n\x04\x04T\x02\x01\x12\x04\xbe#\x02Z\n\r\n\x05\x04T\
    \x02\x01\x04\x12\x04\xbe#\x02\n\n\r\n\x05\x04T\x02\x01\x06\x12\x04\xbe#\
    \x0b\x17\n\r\n\x05\x04T\x02\x01\x01\x12\x04\xbe#\x18&\n\r\n\x05\x04T\x02\
    \x01\x03\x12\x04\xbe#)*\n\r\n\x05\x04T\x02\x01\x08\x12\x04\xbe#+Y\n\x10\
    \n\x08\x04T\x02\x01\x08\xd0\x86\x03\x12\x04\xbe#,X\n\x0c\n\x04\x04T\x02\
    \x02\x12\x04\xbf#\x02>\n\r\n\x05\x04T\x02\x02\x06\x12\x04\xbf#\x02\x1b\n\
    \r\n\x05\x04T\x02\x02\x01\x12\x04\xbf#\x1c9\n\r\n\x05\x04T\x02\x02\x03\
    \x12\x04\xbf#<=\n*\n\x02\x04U\x12\x06\xc3#\0\xc6#\x01\x1a\x1c\x20SingleD\
    atasetInputResponse\n\n\x0b\n\x03\x04U\x01\x12\x04\xc3#\x08\"\n\x0c\n\
    \x04\x04U\x02\0\x12\x04\xc4#\x02(\n\r\n\x05\x04U\x02\0\x06\x12\x04\xc4#\
    \x02\x1c\n\r\n\x05\x04U\x02\0\x01\x12\x04\xc4#\x1d#\n\r\n\x05\x04U\x02\0\
    \x03\x12\x04\xc4#&'\n\x0c\n\x04\x04U\x02\x01\x12\x04\xc5#\x02!\n\r\n\x05\
    \x04U\x02\x01\x06\x12\x04\xc5#\x02\x0e\n\r\n\x05\x04U\x02\x01\x01\x12\
    \x04\xc5#\x0f\x1c\n\r\n\x05\x04U\x02\x01\x03\x12\x04\xc5#\x1f\x20\n*\n\
    \x02\x04V\x12\x06\xc9#\0\xd6#\x01\x1a\x1c\x20ListDatasetVersionsRequest\
    \n\n\x0b\n\x03\x04V\x01\x12\x04\xc9#\x08\"\n\x0c\n\x04\x04V\x02\0\x12\
    \x04\xca#\x02,\n\r\n\x05\x04V\x02\0\x06\x12\x04\xca#\x02\x1b\n\r\n\x05\
    \x04V\x02\0\x01\x12\x04\xca#\x1c'\n\r\n\x05\x04V\x02\0\x03\x12\x04\xca#*\
    +\n'\n\x04\x04V\x02\x01\x12\x04\xcd#\x02\x18\x1a\x19\x20Identify\x20data\
    set\x20by\x20id.\n\n\r\n\x05\x04V\x02\x01\x05\x12\x04\xcd#\x02\x08\n\r\n\
    \x05\x04V\x02\x01\x01\x12\x04\xcd#\t\x13\n\r\n\x05\x04V\x02\x01\x03\x12\
    \x04\xcd#\x16\x17\n~\n\x04\x04V\x02\x02\x12\x04\xd1#\x02\x12\x1ap\x20(op\
    tional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20i\
    s\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defau\
    lts\x20to\x201.\n\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xd1#\x02\x08\n\r\n\
    \x05\x04V\x02\x02\x01\x12\x04\xd1#\t\r\n\r\n\x05\x04V\x02\x02\x03\x12\
    \x04\xd1#\x10\x11\nu\n\x04\x04V\x02\x03\x12\x04\xd5#\x02\x16\x1ag\x20(op\
    tional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x04V\x02\x03\x05\x12\x04\xd5#\x02\x08\n\r\n\x05\x04\
    V\x02\x03\x01\x12\x04\xd5#\t\x11\n\r\n\x05\x04V\x02\x03\x03\x12\x04\xd5#\
    \x14\x15\n(\n\x02\x04W\x12\x06\xd9#\0\xe1#\x01\x1a\x1a\x20GetDatasetVers\
    ionRequest\n\n\x0b\n\x03\x04W\x01\x12\x04\xd9#\x08\x20\n\x0c\n\x04\x04W\
    \x02\0\x12\x04\xda#\x02,\n\r\n\x05\x04W\x02\0\x06\x12\x04\xda#\x02\x1b\n\
    \r\n\x05\x04W\x02\0\x01\x12\x04\xda#\x1c'\n\r\n\x05\x04W\x02\0\x03\x12\
    \x04\xda#*+\n'\n\x04\x04W\x02\x01\x12\x04\xdd#\x02\x18\x1a\x19\x20Identi\
    fy\x20dataset\x20by\x20id.\n\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xdd#\x02\
    \x08\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xdd#\t\x13\n\r\n\x05\x04W\x02\
    \x01\x03\x12\x04\xdd#\x16\x17\n/\n\x04\x04W\x02\x02\x12\x04\xe0#\x02\x20\
    \x1a!\x20Identify\x20dataset\x20version\x20by\x20id.\n\n\r\n\x05\x04W\
    \x02\x02\x05\x12\x04\xe0#\x02\x08\n\r\n\x05\x04W\x02\x02\x01\x12\x04\xe0\
    #\t\x1b\n\r\n\x05\x04W\x02\x02\x03\x12\x04\xe0#\x1e\x1f\n6\n\x02\x04X\
    \x12\x06\xe4#\0\xfc#\x01\x1a(\x20ListDatasetVersionMetricsGroupsRequest\
    \n\n\x0b\n\x03\x04X\x01\x12\x04\xe4#\x08.\n\x0c\n\x04\x04X\x02\0\x12\x04\
    \xe5#\x02,\n\r\n\x05\x04X\x02\0\x06\x12\x04\xe5#\x02\x1b\n\r\n\x05\x04X\
    \x02\0\x01\x12\x04\xe5#\x1c'\n\r\n\x05\x04X\x02\0\x03\x12\x04\xe5#*+\n'\
    \n\x04\x04X\x02\x01\x12\x04\xe8#\x02\x18\x1a\x19\x20Identify\x20dataset\
    \x20by\x20id.\n\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xe8#\x02\x08\n\r\n\
    \x05\x04X\x02\x01\x01\x12\x04\xe8#\t\x13\n\r\n\x05\x04X\x02\x01\x03\x12\
    \x04\xe8#\x16\x17\n/\n\x04\x04X\x02\x02\x12\x04\xeb#\x02\x20\x1a!\x20Ide\
    ntify\x20dataset\x20version\x20by\x20id.\n\n\r\n\x05\x04X\x02\x02\x05\
    \x12\x04\xeb#\x02\x08\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xeb#\t\x1b\n\r\
    \n\x05\x04X\x02\x02\x03\x12\x04\xeb#\x1e\x1f\n~\n\x04\x04X\x02\x03\x12\
    \x04\xef#\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04X\x02\x03\
    \x05\x12\x04\xef#\x02\x08\n\r\n\x05\x04X\x02\x03\x01\x12\x04\xef#\t\r\n\
    \r\n\x05\x04X\x02\x03\x03\x12\x04\xef#\x10\x11\nu\n\x04\x04X\x02\x04\x12\
    \x04\xf2#\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numbe\
    r\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20p\
    age.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04X\x02\x04\x05\x12\x04\
    \xf2#\x02\x08\n\r\n\x05\x04X\x02\x04\x01\x12\x04\xf2#\t\x11\n\r\n\x05\
    \x04X\x02\x04\x03\x12\x04\xf2#\x14\x15\nh\n\x04\x04X\x02\x05\x12\x04\xf5\
    #\x02#\x1aZ\x20Filter\x20by\x20parent\x20path.\x20Multiple\x20parent\x20\
    paths\x20are\x20OR-ed.\x20Empty\x20list\x20results\x20in\x20no\x20filter\
    .\n\n\r\n\x05\x04X\x02\x05\x04\x12\x04\xf5#\x02\n\n\r\n\x05\x04X\x02\x05\
    \x05\x12\x04\xf5#\x0b\x11\n\r\n\x05\x04X\x02\x05\x01\x12\x04\xf5#\x12\
    \x1e\n\r\n\x05\x04X\x02\x05\x03\x12\x04\xf5#!\"\na\n\x04\x04X\x02\x06\
    \x12\x04\xf8#\x024\x1aS\x20Filter\x20by\x20parent\x20type.\x20Multiple\
    \x20types\x20are\x20OR-ed.\x20Empty\x20list\x20results\x20in\x20no\x20fi\
    lter.\n\n\r\n\x05\x04X\x02\x06\x04\x12\x04\xf8#\x02\n\n\r\n\x05\x04X\x02\
    \x06\x06\x12\x04\xf8#\x0b)\n\r\n\x05\x04X\x02\x06\x01\x12\x04\xf8#*/\n\r\
    \n\x05\x04X\x02\x06\x03\x12\x04\xf8#23\n\\\n\x04\x04X\x02\x07\x12\x04\
    \xfb#\x02,\x1aN\x20Filter\x20by\x20value.\x20Multiple\x20values\x20are\
    \x20OR-ed.\x20Empty\x20list\x20results\x20in\x20no\x20filter.\n\n\r\n\
    \x05\x04X\x02\x07\x04\x12\x04\xfb#\x02\n\n\r\n\x05\x04X\x02\x07\x06\x12\
    \x04\xfb#\x0b\x20\n\r\n\x05\x04X\x02\x07\x01\x12\x04\xfb#!'\n\r\n\x05\
    \x04X\x02\x07\x03\x12\x04\xfb#*+\n<\n\x02\x04Y\x12\x06\xff#\0\x87$\x01\
    \x1a.\x20Request\x20to\x20add\x20one\x20or\x20more\x20dataset\x20version\
    s.\n\n\x0b\n\x03\x04Y\x01\x12\x04\xff#\x08\"\n\x0c\n\x04\x04Y\x02\0\x12\
    \x04\x80$\x02,\n\r\n\x05\x04Y\x02\0\x06\x12\x04\x80$\x02\x1b\n\r\n\x05\
    \x04Y\x02\0\x01\x12\x04\x80$\x1c'\n\r\n\x05\x04Y\x02\0\x03\x12\x04\x80$*\
    +\n'\n\x04\x04Y\x02\x01\x12\x04\x83$\x02\x18\x1a\x19\x20Identify\x20data\
    set\x20by\x20id.\n\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\x83$\x02\x08\n\r\n\
    \x05\x04Y\x02\x01\x01\x12\x04\x83$\t\x13\n\r\n\x05\x04Y\x02\x01\x03\x12\
    \x04\x83$\x16\x17\nH\n\x04\x04Y\x02\x02\x12\x04\x86$\x02/\x1a:\x20List\
    \x20of\x20dataset\x20versions\x20that\x20are\x20requested\x20to\x20be\
    \x20added.\n\n\r\n\x05\x04Y\x02\x02\x04\x12\x04\x86$\x02\n\n\r\n\x05\x04\
    Y\x02\x02\x06\x12\x04\x86$\x0b\x19\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\
    \x86$\x1a*\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\x86$-.\n:\n\x02\x04Z\x12\
    \x06\x8a$\0\x96$\x01\x1a,\x20Request\x20to\x20patch\x20several\x20datase\
    t\x20versions.\n\n\x0b\n\x03\x04Z\x01\x12\x04\x8a$\x08#\n\x0c\n\x04\x04Z\
    \x02\0\x12\x04\x8b$\x02,\n\r\n\x05\x04Z\x02\0\x06\x12\x04\x8b$\x02\x1b\n\
    \r\n\x05\x04Z\x02\0\x01\x12\x04\x8b$\x1c'\n\r\n\x05\x04Z\x02\0\x03\x12\
    \x04\x8b$*+\n'\n\x04\x04Z\x02\x01\x12\x04\x8e$\x02\x18\x1a\x19\x20Identi\
    fy\x20dataset\x20by\x20id.\n\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\x8e$\x02\
    \x08\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\x8e$\t\x13\n\r\n\x05\x04Z\x02\
    \x01\x03\x12\x04\x8e$\x16\x17\nJ\n\x04\x04Z\x02\x02\x12\x04\x91$\x02/\
    \x1a<\x20List\x20of\x20dataset\x20versions\x20that\x20are\x20requested\
    \x20to\x20be\x20updated.\n\n\r\n\x05\x04Z\x02\x02\x04\x12\x04\x91$\x02\n\
    \n\r\n\x05\x04Z\x02\x02\x06\x12\x04\x91$\x0b\x19\n\r\n\x05\x04Z\x02\x02\
    \x01\x12\x04\x91$\x1a*\n\r\n\x05\x04Z\x02\x02\x03\x12\x04\x91$-.\nk\n\
    \x04\x04Z\x02\x03\x12\x04\x95$\x02\x14\x1a]\x20The\x20action\x20to\x20pe\
    rform\x20on\x20the\x20patched\x20objects\n\x20For\x20now,\x20only\x20'ov\
    erwrite'\x20action\x20is\x20supported\n\n\r\n\x05\x04Z\x02\x03\x05\x12\
    \x04\x95$\x02\x08\n\r\n\x05\x04Z\x02\x03\x01\x12\x04\x95$\t\x0f\n\r\n\
    \x05\x04Z\x02\x03\x03\x12\x04\x95$\x12\x13\nJ\n\x02\x04[\x12\x06\x99$\0\
    \xa0$\x01\x1a<\x20Request\x20to\x20delete\x20several\x20dataset\x20versi\
    ons\x20by\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04[\x01\x12\x04\x99$\x08$\
    \n\x0c\n\x04\x04[\x02\0\x12\x04\x9a$\x02,\n\r\n\x05\x04[\x02\0\x06\x12\
    \x04\x9a$\x02\x1b\n\r\n\x05\x04[\x02\0\x01\x12\x04\x9a$\x1c'\n\r\n\x05\
    \x04[\x02\0\x03\x12\x04\x9a$*+\n'\n\x04\x04[\x02\x01\x12\x04\x9d$\x02\
    \x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\x05\x04[\x02\
    \x01\x05\x12\x04\x9d$\x02\x08\n\r\n\x05\x04[\x02\x01\x01\x12\x04\x9d$\t\
    \x13\n\r\n\x05\x04[\x02\x01\x03\x12\x04\x9d$\x16\x17\n\x0c\n\x04\x04[\
    \x02\x02\x12\x04\x9f$\x02*\n\r\n\x05\x04[\x02\x02\x04\x12\x04\x9f$\x02\n\
    \n\r\n\x05\x04[\x02\x02\x05\x12\x04\x9f$\x0b\x11\n\r\n\x05\x04[\x02\x02\
    \x01\x12\x04\x9f$\x12%\n\r\n\x05\x04[\x02\x02\x03\x12\x04\x9f$()\n?\n\
    \x02\x04\\\x12\x06\xa3$\0\xaf$\x01\x1a1\x20Request\x20to\x20create\x20ex\
    ports\x20of\x20a\x20dataset\x20version.\n\n\x0b\n\x03\x04\\\x01\x12\x04\
    \xa3$\x08'\n\x0c\n\x04\x04\\\x02\0\x12\x04\xa4$\x02,\n\r\n\x05\x04\\\x02\
    \0\x06\x12\x04\xa4$\x02\x1b\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xa4$\x1c'\
    \n\r\n\x05\x04\\\x02\0\x03\x12\x04\xa4$*+\n'\n\x04\x04\\\x02\x01\x12\x04\
    \xa7$\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\x05\
    \x04\\\x02\x01\x05\x12\x04\xa7$\x02\x08\n\r\n\x05\x04\\\x02\x01\x01\x12\
    \x04\xa7$\t\x13\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\xa7$\x16\x17\n/\n\
    \x04\x04\\\x02\x02\x12\x04\xaa$\x02\x20\x1a!\x20Identify\x20dataset\x20v\
    ersion\x20by\x20id.\n\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\xaa$\x02\x08\n\
    \r\n\x05\x04\\\x02\x02\x01\x12\x04\xaa$\t\x1b\n\r\n\x05\x04\\\x02\x02\
    \x03\x12\x04\xaa$\x1e\x1f\n\x86\x01\n\x04\x04\\\x02\x03\x12\x04\xae$\x02\
    ,\x1ax\x20exports\x20is\x20the\x20list\x20of\x20requested\x20dataset\x20\
    version\x20exports.\n\x20Only\x20setting\x20the\x20'format'\x20field\x20\
    of\x20the\x20export\x20is\x20supported.\n\n\r\n\x05\x04\\\x02\x03\x04\
    \x12\x04\xae$\x02\n\n\r\n\x05\x04\\\x02\x03\x06\x12\x04\xae$\x0b\x1f\n\r\
    \n\x05\x04\\\x02\x03\x01\x12\x04\xae$\x20'\n\r\n\x05\x04\\\x02\x03\x03\
    \x12\x04\xae$*+\n\x0c\n\x02\x04]\x12\x06\xb1$\0\xb4$\x01\n\x0b\n\x03\x04\
    ]\x01\x12\x04\xb1$\x08#\n\x0c\n\x04\x04]\x02\0\x12\x04\xb2$\x02(\n\r\n\
    \x05\x04]\x02\0\x06\x12\x04\xb2$\x02\x1c\n\r\n\x05\x04]\x02\0\x01\x12\
    \x04\xb2$\x1d#\n\r\n\x05\x04]\x02\0\x03\x12\x04\xb2$&'\n\x0c\n\x04\x04]\
    \x02\x01\x12\x04\xb3$\x02^\n\r\n\x05\x04]\x02\x01\x04\x12\x04\xb3$\x02\n\
    \n\r\n\x05\x04]\x02\x01\x06\x12\x04\xb3$\x0b\x19\n\r\n\x05\x04]\x02\x01\
    \x01\x12\x04\xb3$\x1a*\n\r\n\x05\x04]\x02\x01\x03\x12\x04\xb3$-.\n\r\n\
    \x05\x04]\x02\x01\x08\x12\x04\xb3$/]\n\x10\n\x08\x04]\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xb3$0\\\n\x0c\n\x02\x04^\x12\x06\xb6$\0\xb9$\x01\n\x0b\
    \n\x03\x04^\x01\x12\x04\xb6$\x08)\n\x0c\n\x04\x04^\x02\0\x12\x04\xb7$\
    \x02(\n\r\n\x05\x04^\x02\0\x06\x12\x04\xb7$\x02\x1c\n\r\n\x05\x04^\x02\0\
    \x01\x12\x04\xb7$\x1d#\n\r\n\x05\x04^\x02\0\x03\x12\x04\xb7$&'\n\x0c\n\
    \x04\x04^\x02\x01\x12\x04\xb8$\x02[\n\r\n\x05\x04^\x02\x01\x04\x12\x04\
    \xb8$\x02\n\n\r\n\x05\x04^\x02\x01\x06\x12\x04\xb8$\x0b\x1f\n\r\n\x05\
    \x04^\x02\x01\x01\x12\x04\xb8$\x20'\n\r\n\x05\x04^\x02\x01\x03\x12\x04\
    \xb8$*+\n\r\n\x05\x04^\x02\x01\x08\x12\x04\xb8$,Z\n\x10\n\x08\x04^\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xb8$-Y\n\x0c\n\x02\x04_\x12\x06\xbb$\0\xbe$\
    \x01\n\x0b\n\x03\x04_\x01\x12\x04\xbb$\x08/\n\x0c\n\x04\x04_\x02\0\x12\
    \x04\xbc$\x02(\n\r\n\x05\x04_\x02\0\x06\x12\x04\xbc$\x02\x1c\n\r\n\x05\
    \x04_\x02\0\x01\x12\x04\xbc$\x1d#\n\r\n\x05\x04_\x02\0\x03\x12\x04\xbc$&\
    '\n\x0c\n\x04\x04_\x02\x01\x12\x04\xbd$\x02x\n\r\n\x05\x04_\x02\x01\x04\
    \x12\x04\xbd$\x02\n\n\r\n\x05\x04_\x02\x01\x06\x12\x04\xbd$\x0b%\n\r\n\
    \x05\x04_\x02\x01\x01\x12\x04\xbd$&D\n\r\n\x05\x04_\x02\x01\x03\x12\x04\
    \xbd$GH\n\r\n\x05\x04_\x02\x01\x08\x12\x04\xbd$Iw\n\x10\n\x08\x04_\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xbd$Jv\n\x0c\n\x02\x04`\x12\x06\xc0$\0\xc3$\
    \x01\n\x0b\n\x03\x04`\x01\x12\x04\xc0$\x08$\n\x0c\n\x04\x04`\x02\0\x12\
    \x04\xc1$\x02(\n\r\n\x05\x04`\x02\0\x06\x12\x04\xc1$\x02\x1c\n\r\n\x05\
    \x04`\x02\0\x01\x12\x04\xc1$\x1d#\n\r\n\x05\x04`\x02\0\x03\x12\x04\xc1$&\
    '\n\x0c\n\x04\x04`\x02\x01\x12\x04\xc2$\x02%\n\r\n\x05\x04`\x02\x01\x06\
    \x12\x04\xc2$\x02\x10\n\r\n\x05\x04`\x02\x01\x01\x12\x04\xc2$\x11\x20\n\
    \r\n\x05\x04`\x02\x01\x03\x12\x04\xc2$#$\n\x0c\n\x02\x04a\x12\x06\xc5$\0\
    \xc9$\x01\n\x0b\n\x03\x04a\x01\x12\x04\xc5$\x08+\n\x0c\n\x04\x04a\x02\0\
    \x12\x04\xc6$\x02,\n\r\n\x05\x04a\x02\0\x06\x12\x04\xc6$\x02\x1b\n\r\n\
    \x05\x04a\x02\0\x01\x12\x04\xc6$\x1c'\n\r\n\x05\x04a\x02\0\x03\x12\x04\
    \xc6$*+\n\x0c\n\x04\x04a\x02\x01\x12\x04\xc8$\x02\x14\n\r\n\x05\x04a\x02\
    \x01\x05\x12\x04\xc8$\x02\x08\n\r\n\x05\x04a\x02\x01\x01\x12\x04\xc8$\t\
    \x0f\n\r\n\x05\x04a\x02\x01\x03\x12\x04\xc8$\x12\x13\n\x0c\n\x02\x04b\
    \x12\x06\xcb$\0\xcf$\x01\n\x0b\n\x03\x04b\x01\x12\x04\xcb$\x08/\n\x0c\n\
    \x04\x04b\x02\0\x12\x04\xcc$\x02(\n\r\n\x05\x04b\x02\0\x06\x12\x04\xcc$\
    \x02\x1c\n\r\n\x05\x04b\x02\0\x01\x12\x04\xcc$\x1d#\n\r\n\x05\x04b\x02\0\
    \x03\x12\x04\xcc$&'\n\x0c\n\x04\x04b\x02\x01\x12\x04\xce$\x02$\n\r\n\x05\
    \x04b\x02\x01\x06\x12\x04\xce$\x02\x1b\n\r\n\x05\x04b\x02\x01\x01\x12\
    \x04\xce$\x1c\x1f\n\r\n\x05\x04b\x02\x01\x03\x12\x04\xce$\"#\n\xcb\x01\n\
    \x02\x04c\x12\x06\xd5$\0\xdd$\x01\x1a\xbc\x01///////////////////////////\
    ///////////////////////\n\x20Model\x20prediction\x20related\x20stuff\x20\
    needs\x20inputs\x20and\x20produces\x20outputs.\n////////////////////////\
    //////////////////////////\n\x20Model\x20prediction.\n\n\x0b\n\x03\x04c\
    \x01\x12\x04\xd5$\x08\x1f\n\x0c\n\x04\x04c\x02\0\x12\x04\xd6$\x02,\n\r\n\
    \x05\x04c\x02\0\x06\x12\x04\xd6$\x02\x1b\n\r\n\x05\x04c\x02\0\x01\x12\
    \x04\xd6$\x1c'\n\r\n\x05\x04c\x02\0\x03\x12\x04\xd6$*+\n\x0c\n\x04\x04c\
    \x02\x01\x12\x04\xd7$\x02\x16\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xd7$\
    \x02\x08\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xd7$\t\x11\n\r\n\x05\x04c\
    \x02\x01\x03\x12\x04\xd7$\x14\x15\n\x0c\n\x04\x04c\x02\x02\x12\x04\xd8$\
    \x02\x18\n\r\n\x05\x04c\x02\x02\x05\x12\x04\xd8$\x02\x08\n\r\n\x05\x04c\
    \x02\x02\x01\x12\x04\xd8$\t\x13\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xd8$\
    \x16\x17\n\x0c\n\x04\x04c\x02\x03\x12\x04\xd9$\x02\x1c\n\r\n\x05\x04c\
    \x02\x03\x04\x12\x04\xd9$\x02\n\n\r\n\x05\x04c\x02\x03\x06\x12\x04\xd9$\
    \x0b\x10\n\r\n\x05\x04c\x02\x03\x01\x12\x04\xd9$\x11\x17\n\r\n\x05\x04c\
    \x02\x03\x03\x12\x04\xd9$\x1a\x1b\n\x88\x01\n\x04\x04c\x02\x04\x12\x04\
    \xdc$\x02\x12\x1az\x20This\x20allows\x20you\x20to\x20specify\x20config\
    \x20options\x20for\x20the\x20model\x20such\x20as\n\x20the\x20language\
    \x20which\x20appear's\x20in\x20the\x20model's\x20output_info.\n\n\r\n\
    \x05\x04c\x02\x04\x06\x12\x04\xdc$\x02\x07\n\r\n\x05\x04c\x02\x04\x01\
    \x12\x04\xdc$\x08\r\n\r\n\x05\x04c\x02\x04\x03\x12\x04\xdc$\x10\x11\nF\n\
    \x02\x04d\x12\x06\xe0$\0\xea$\x01\x1a8\x20Listing\x20the\x20inputs\x20th\
    at\x20went\x20into\x20training\x20this\x20model.\n\n\x0b\n\x03\x04d\x01\
    \x12\x04\xe0$\x08\x1e\n\x0c\n\x04\x04d\x02\0\x12\x04\xe1$\x02,\n\r\n\x05\
    \x04d\x02\0\x06\x12\x04\xe1$\x02\x1b\n\r\n\x05\x04d\x02\0\x01\x12\x04\
    \xe1$\x1c'\n\r\n\x05\x04d\x02\0\x03\x12\x04\xe1$*+\n\x0c\n\x04\x04d\x02\
    \x01\x12\x04\xe2$\x02\x16\n\r\n\x05\x04d\x02\x01\x05\x12\x04\xe2$\x02\
    \x08\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xe2$\t\x11\n\r\n\x05\x04d\x02\
    \x01\x03\x12\x04\xe2$\x14\x15\n\x0c\n\x04\x04d\x02\x02\x12\x04\xe3$\x02\
    \x18\n\r\n\x05\x04d\x02\x02\x05\x12\x04\xe3$\x02\x08\n\r\n\x05\x04d\x02\
    \x02\x01\x12\x04\xe3$\t\x13\n\r\n\x05\x04d\x02\x02\x03\x12\x04\xe3$\x16\
    \x17\n~\n\x04\x04d\x02\x03\x12\x04\xe6$\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\r\n\x05\x04d\x02\x03\x05\x12\x04\xe6$\x02\x08\n\r\n\x05\x04d\x02\
    \x03\x01\x12\x04\xe6$\t\r\n\r\n\x05\x04d\x02\x03\x03\x12\x04\xe6$\x10\
    \x11\nu\n\x04\x04d\x02\x04\x12\x04\xe9$\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04d\x02\x04\x05\x12\x04\xe9$\x02\x08\n\r\n\x05\x04d\x02\x04\x01\
    \x12\x04\xe9$\t\x11\n\r\n\x05\x04d\x02\x04\x03\x12\x04\xe9$\x14\x15\n\
    \x1d\n\x02\x04e\x12\x06\xed$\0\xf0$\x01\x1a\x0f\x20GetKeyRequest\n\n\x0b\
    \n\x03\x04e\x01\x12\x04\xed$\x08\x15\n\x0c\n\x04\x04e\x02\0\x12\x04\xee$\
    \x02,\n\r\n\x05\x04e\x02\0\x06\x12\x04\xee$\x02\x1b\n\r\n\x05\x04e\x02\0\
    \x01\x12\x04\xee$\x1c'\n\r\n\x05\x04e\x02\0\x03\x12\x04\xee$*+\n\x0c\n\
    \x04\x04e\x02\x01\x12\x04\xef$\x02\x14\n\r\n\x05\x04e\x02\x01\x05\x12\
    \x04\xef$\x02\x08\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xef$\t\x0f\n\r\n\
    \x05\x04e\x02\x01\x03\x12\x04\xef$\x12\x13\n\x1f\n\x02\x04f\x12\x06\xf3$\
    \0\xfe$\x01\x1a\x11\x20ListKeysRequest\n\n\x0b\n\x03\x04f\x01\x12\x04\
    \xf3$\x08\x17\n\x0c\n\x04\x04f\x02\0\x12\x04\xf4$\x02,\n\r\n\x05\x04f\
    \x02\0\x06\x12\x04\xf4$\x02\x1b\n\r\n\x05\x04f\x02\0\x01\x12\x04\xf4$\
    \x1c'\n\r\n\x05\x04f\x02\0\x03\x12\x04\xf4$*+\n~\n\x04\x04f\x02\x01\x12\
    \x04\xf7$\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04f\x02\x01\
    \x05\x12\x04\xf7$\x02\x08\n\r\n\x05\x04f\x02\x01\x01\x12\x04\xf7$\t\r\n\
    \r\n\x05\x04f\x02\x01\x03\x12\x04\xf7$\x10\x11\nu\n\x04\x04f\x02\x02\x12\
    \x04\xfa$\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numbe\
    r\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20p\
    age.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04f\x02\x02\x05\x12\x04\
    \xfa$\x02\x08\n\r\n\x05\x04f\x02\x02\x01\x12\x04\xfa$\t\x11\n\r\n\x05\
    \x04f\x02\x02\x03\x12\x04\xfa$\x14\x15\n\x0c\n\x04\x04f\x02\x03\x12\x04\
    \xfb$\x02\x17\n\r\n\x05\x04f\x02\x03\x05\x12\x04\xfb$\x02\x06\n\r\n\x05\
    \x04f\x02\x03\x01\x12\x04\xfb$\x07\x12\n\r\n\x05\x04f\x02\x03\x03\x12\
    \x04\xfb$\x15\x16\n\x0c\n\x04\x04f\x02\x04\x12\x04\xfc$\x02\x1d\n\r\n\
    \x05\x04f\x02\x04\x04\x12\x04\xfc$\x02\n\n\r\n\x05\x04f\x02\x04\x05\x12\
    \x04\xfc$\x0b\x11\n\r\n\x05\x04f\x02\x04\x01\x12\x04\xfc$\x12\x18\n\r\n\
    \x05\x04f\x02\x04\x03\x12\x04\xfc$\x1b\x1c\n\x0c\n\x04\x04f\x02\x05\x12\
    \x04\xfd$\x02\x20\n\r\n\x05\x04f\x02\x05\x04\x12\x04\xfd$\x02\n\n\r\n\
    \x05\x04f\x02\x05\x05\x12\x04\xfd$\x0b\x11\n\r\n\x05\x04f\x02\x05\x01\
    \x12\x04\xfd$\x12\x1b\n\r\n\x05\x04f\x02\x05\x03\x12\x04\xfd$\x1e\x1f\n\
    \"\n\x02\x04g\x12\x06\x81%\0\x89%\x01\x1a\x14\x20ListAppKeysRequest\n\n\
    \x0b\n\x03\x04g\x01\x12\x04\x81%\x08\x1a\n\x0c\n\x04\x04g\x02\0\x12\x04\
    \x82%\x02,\n\r\n\x05\x04g\x02\0\x06\x12\x04\x82%\x02\x1b\n\r\n\x05\x04g\
    \x02\0\x01\x12\x04\x82%\x1c'\n\r\n\x05\x04g\x02\0\x03\x12\x04\x82%*+\n~\
    \n\x04\x04g\x02\x01\x12\x04\x85%\x02\x12\x1ap\x20(optional\x20URL\x20par\
    ameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20s\
    plit\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04g\x02\x01\x05\x12\x04\x85%\x02\x08\n\r\n\x05\x04g\x02\x01\
    \x01\x12\x04\x85%\t\r\n\r\n\x05\x04g\x02\x01\x03\x12\x04\x85%\x10\x11\nu\
    \n\x04\x04g\x02\x02\x12\x04\x88%\x02\x16\x1ag\x20(optional\x20URL\x20par\
    ameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20conta\
    ined\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04g\
    \x02\x02\x05\x12\x04\x88%\x02\x08\n\r\n\x05\x04g\x02\x02\x01\x12\x04\x88\
    %\t\x11\n\r\n\x05\x04g\x02\x02\x03\x12\x04\x88%\x14\x15\n\x1f\n\x02\x04h\
    \x12\x06\x8c%\0\x8f%\x01\x1a\x11\x20PostKeysRequest\n\n\x0b\n\x03\x04h\
    \x01\x12\x04\x8c%\x08\x17\n\x0c\n\x04\x04h\x02\0\x12\x04\x8d%\x02,\n\r\n\
    \x05\x04h\x02\0\x06\x12\x04\x8d%\x02\x1b\n\r\n\x05\x04h\x02\0\x01\x12\
    \x04\x8d%\x1c'\n\r\n\x05\x04h\x02\0\x03\x12\x04\x8d%*+\n\x0c\n\x04\x04h\
    \x02\x01\x12\x04\x8e%\x02\x18\n\r\n\x05\x04h\x02\x01\x04\x12\x04\x8e%\
    \x02\n\n\r\n\x05\x04h\x02\x01\x06\x12\x04\x8e%\x0b\x0e\n\r\n\x05\x04h\
    \x02\x01\x01\x12\x04\x8e%\x0f\x13\n\r\n\x05\x04h\x02\x01\x03\x12\x04\x8e\
    %\x16\x17\n\x20\n\x02\x04i\x12\x06\x92%\0\x95%\x01\x1a\x12\x20DeleteKeyR\
    equest\n\n\x0b\n\x03\x04i\x01\x12\x04\x92%\x08\x18\n\x0c\n\x04\x04i\x02\
    \0\x12\x04\x93%\x02,\n\r\n\x05\x04i\x02\0\x06\x12\x04\x93%\x02\x1b\n\r\n\
    \x05\x04i\x02\0\x01\x12\x04\x93%\x1c'\n\r\n\x05\x04i\x02\0\x03\x12\x04\
    \x93%*+\n\x0c\n\x04\x04i\x02\x01\x12\x04\x94%\x02\x14\n\r\n\x05\x04i\x02\
    \x01\x05\x12\x04\x94%\x02\x08\n\r\n\x05\x04i\x02\x01\x01\x12\x04\x94%\t\
    \x0f\n\r\n\x05\x04i\x02\x01\x03\x12\x04\x94%\x12\x13\n\x20\n\x02\x04j\
    \x12\x06\x98%\0\x9f%\x01\x1a\x12\x20PatchKeysRequest\n\n\x0b\n\x03\x04j\
    \x01\x12\x04\x98%\x08\x18\n\x0c\n\x04\x04j\x02\0\x12\x04\x99%\x02,\n\r\n\
    \x05\x04j\x02\0\x06\x12\x04\x99%\x02\x1b\n\r\n\x05\x04j\x02\0\x01\x12\
    \x04\x99%\x1c'\n\r\n\x05\x04j\x02\0\x03\x12\x04\x99%*+\n\x0c\n\x04\x04j\
    \x02\x01\x12\x04\x9a%\x02\x18\n\r\n\x05\x04j\x02\x01\x04\x12\x04\x9a%\
    \x02\n\n\r\n\x05\x04j\x02\x01\x06\x12\x04\x9a%\x0b\x0e\n\r\n\x05\x04j\
    \x02\x01\x01\x12\x04\x9a%\x0f\x13\n\r\n\x05\x04j\x02\x01\x03\x12\x04\x9a\
    %\x16\x17\nj\n\x04\x04j\x02\x02\x12\x04\x9e%\x02\x14\x1a\\\x20The\x20act\
    ion\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\
    \x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04j\
    \x02\x02\x05\x12\x04\x9e%\x02\x08\n\r\n\x05\x04j\x02\x02\x01\x12\x04\x9e\
    %\t\x0f\n\r\n\x05\x04j\x02\x02\x03\x12\x04\x9e%\x12\x13\n!\n\x02\x04k\
    \x12\x06\xa2%\0\xa5%\x01\x1a\x13\x20SingleKeyResponse\n\n\x0b\n\x03\x04k\
    \x01\x12\x04\xa2%\x08\x19\n\x0c\n\x04\x04k\x02\0\x12\x04\xa3%\x02(\n\r\n\
    \x05\x04k\x02\0\x06\x12\x04\xa3%\x02\x1c\n\r\n\x05\x04k\x02\0\x01\x12\
    \x04\xa3%\x1d#\n\r\n\x05\x04k\x02\0\x03\x12\x04\xa3%&'\n\x0c\n\x04\x04k\
    \x02\x01\x12\x04\xa4%\x02\x0e\n\r\n\x05\x04k\x02\x01\x06\x12\x04\xa4%\
    \x02\x05\n\r\n\x05\x04k\x02\x01\x01\x12\x04\xa4%\x06\t\n\r\n\x05\x04k\
    \x02\x01\x03\x12\x04\xa4%\x0c\r\n\x20\n\x02\x04l\x12\x06\xa8%\0\xab%\x01\
    \x1a\x12\x20MultiKeyResponse\n\n\x0b\n\x03\x04l\x01\x12\x04\xa8%\x08\x18\
    \n\x0c\n\x04\x04l\x02\0\x12\x04\xa9%\x02(\n\r\n\x05\x04l\x02\0\x06\x12\
    \x04\xa9%\x02\x1c\n\r\n\x05\x04l\x02\0\x01\x12\x04\xa9%\x1d#\n\r\n\x05\
    \x04l\x02\0\x03\x12\x04\xa9%&'\n\x0c\n\x04\x04l\x02\x01\x12\x04\xaa%\x02\
    G\n\r\n\x05\x04l\x02\x01\x04\x12\x04\xaa%\x02\n\n\r\n\x05\x04l\x02\x01\
    \x06\x12\x04\xaa%\x0b\x0e\n\r\n\x05\x04l\x02\x01\x01\x12\x04\xaa%\x0f\
    \x13\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xaa%\x16\x17\n\r\n\x05\x04l\x02\
    \x01\x08\x12\x04\xaa%\x18F\n\x10\n\x08\x04l\x02\x01\x08\xd0\x86\x03\x12\
    \x04\xaa%\x19E\n\x1f\n\x02\x04m\x12\x06\xb6%\0\xc0%\x01\x1a\x11\x20GetMo\
    delRequest\n\n\x0b\n\x03\x04m\x01\x12\x04\xb6%\x08\x17\n\x0c\n\x04\x04m\
    \x02\0\x12\x04\xb7%\x02,\n\r\n\x05\x04m\x02\0\x06\x12\x04\xb7%\x02\x1b\n\
    \r\n\x05\x04m\x02\0\x01\x12\x04\xb7%\x1c'\n\r\n\x05\x04m\x02\0\x03\x12\
    \x04\xb7%*+\n\x0c\n\x04\x04m\x02\x01\x12\x04\xb8%\x02\x16\n\r\n\x05\x04m\
    \x02\x01\x05\x12\x04\xb8%\x02\x08\n\r\n\x05\x04m\x02\x01\x01\x12\x04\xb8\
    %\t\x11\n\r\n\x05\x04m\x02\x01\x03\x12\x04\xb8%\x14\x15\nw\n\x04\x04m\
    \x02\x02\x12\x04\xbb%\x02\x18\x1ai\x20This\x20is\x20included\x20so\x20th\
    at\x20we\x20can\x20re-use\x20this\x20request\x20for\x20multiple\n\x20rpc\
    s\x20with\x20and\x20without\x20the\x20version_id.\n\n\r\n\x05\x04m\x02\
    \x02\x05\x12\x04\xbb%\x02\x08\n\r\n\x05\x04m\x02\x02\x01\x12\x04\xbb%\t\
    \x13\n\r\n\x05\x04m\x02\x02\x03\x12\x04\xbb%\x16\x17\n\x0c\n\x04\x04m\
    \x02\x03\x12\x04\xbc%\x02\x16\n\r\n\x05\x04m\x02\x03\x05\x12\x04\xbc%\
    \x02\x08\n\r\n\x05\x04m\x02\x03\x01\x12\x04\xbc%\t\x11\n\r\n\x05\x04m\
    \x02\x03\x03\x12\x04\xbc%\x14\x15\n\x0c\n\x04\x04m\x02\x04\x12\x04\xbd%\
    \x02\x1a\n\r\n\x05\x04m\x02\x04\x05\x12\x04\xbd%\x02\x06\n\r\n\x05\x04m\
    \x02\x04\x01\x12\x04\xbd%\x07\x15\n\r\n\x05\x04m\x02\x04\x03\x12\x04\xbd\
    %\x18\x19\n\x95\x01\n\x04\x04m\x02\x05\x12\x04\xbf%\x02)\x1a\x86\x01\x20\
    (optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20\
    to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20supported\
    :\x20all,\x20stars,\x20outputs,\x20presets\n\n\r\n\x05\x04m\x02\x05\x04\
    \x12\x04\xbf%\x02\n\n\r\n\x05\x04m\x02\x05\x05\x12\x04\xbf%\x0b\x11\n\r\
    \n\x05\x04m\x02\x05\x01\x12\x04\xbf%\x12#\n\r\n\x05\x04m\x02\x05\x03\x12\
    \x04\xbf%&(\n!\n\x02\x04n\x12\x06\xc3%\0\x86&\x01\x1a\x13\x20ListModelsR\
    equest\n\n\x0b\n\x03\x04n\x01\x12\x04\xc3%\x08\x19\n\x0b\n\x03\x04n\t\
    \x12\x04\xc4%\x02\r\n\x0c\n\x04\x04n\t\0\x12\x04\xc4%\x0b\x0c\n\r\n\x05\
    \x04n\t\0\x01\x12\x04\xc4%\x0b\x0c\n\r\n\x05\x04n\t\0\x02\x12\x04\xc4%\
    \x0b\x0c\n\x0c\n\x04\x04n\x02\0\x12\x04\xc5%\x02,\n\r\n\x05\x04n\x02\0\
    \x06\x12\x04\xc5%\x02\x1b\n\r\n\x05\x04n\x02\0\x01\x12\x04\xc5%\x1c'\n\r\
    \n\x05\x04n\x02\0\x03\x12\x04\xc5%*+\n~\n\x04\x04n\x02\x01\x12\x04\xc8%\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04n\x02\x01\x05\x12\
    \x04\xc8%\x02\x08\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xc8%\t\r\n\r\n\x05\
    \x04n\x02\x01\x03\x12\x04\xc8%\x10\x11\nu\n\x04\x04n\x02\x02\x12\x04\xcb\
    %\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\
    \x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04n\x02\x02\x05\x12\x04\xcb%\
    \x02\x08\n\r\n\x05\x04n\x02\x02\x01\x12\x04\xcb%\t\x11\n\r\n\x05\x04n\
    \x02\x02\x03\x12\x04\xcb%\x14\x15\no\n\x04\x04n\x02\x03\x12\x04\xcf%\x02\
    \x1b\x1aa\x20Sorting\x20options:\n\x20Whether\x20to\x20sort\x20in\x20asc\
    ending\x20order.\x20If\x20false,\x20will\x20order\x20in\x20descending\
    \x20order.\n\n\r\n\x05\x04n\x02\x03\x05\x12\x04\xcf%\x02\x06\n\r\n\x05\
    \x04n\x02\x03\x01\x12\x04\xcf%\x07\x15\n\r\n\x05\x04n\x02\x03\x03\x12\
    \x04\xcf%\x18\x1a\n\x0e\n\x04\x04n\x08\0\x12\x06\xd0%\x02\xdc%\x03\n\r\n\
    \x05\x04n\x08\0\x01\x12\x04\xd0%\x08\x0f\n,\n\x04\x04n\x02\x04\x12\x04\
    \xd2%\x04\x1b\x1a\x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\
    \r\n\x05\x04n\x02\x04\x05\x12\x04\xd2%\x04\x08\n\r\n\x05\x04n\x02\x04\
    \x01\x12\x04\xd2%\t\x15\n\r\n\x05\x04n\x02\x04\x03\x12\x04\xd2%\x18\x1a\
    \nA\n\x04\x04n\x02\x05\x12\x04\xd4%\x04!\x1a3\x20Whether\x20to\x20order\
    \x20by\x20the\x20number\x20of\x20training\x20inputs\n\n\r\n\x05\x04n\x02\
    \x05\x05\x12\x04\xd4%\x04\x08\n\r\n\x05\x04n\x02\x05\x01\x12\x04\xd4%\t\
    \x1b\n\r\n\x05\x04n\x02\x05\x03\x12\x04\xd4%\x1e\x20\n\x9d\x01\n\x04\x04\
    n\x02\x06\x12\x04\xd7%\x04\"\x1a\x8e\x01\x20Whether\x20to\x20order\x20by\
    \x20the\x20modified_at\x20time\x20of\x20the\x20latest\x20model\x20versio\
    n.\n\x20If\x20none\x20of\x20the\x20sort\x20options\x20is\x20set\x20to\
    \x20true,\x20will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04n\x02\x06\
    \x05\x12\x04\xd7%\x04\x08\n\r\n\x05\x04n\x02\x06\x01\x12\x04\xd7%\t\x1c\
    \n\r\n\x05\x04n\x02\x06\x03\x12\x04\xd7%\x1f!\n2\n\x04\x04n\x02\x07\x12\
    \x04\xd9%\x04!\x1a$\x20Whether\x20to\x20order\x20by\x20the\x20created_at\
    \n\n\r\n\x05\x04n\x02\x07\x05\x12\x04\xd9%\x04\x08\n\r\n\x05\x04n\x02\
    \x07\x01\x12\x04\xd9%\t\x1b\n\r\n\x05\x04n\x02\x07\x03\x12\x04\xd9%\x1e\
    \x20\n2\n\x04\x04n\x02\x08\x12\x04\xdb%\x04!\x1a$\x20Whether\x20to\x20or\
    der\x20by\x20count\x20of\x20stars\n\n\r\n\x05\x04n\x02\x08\x05\x12\x04\
    \xdb%\x04\x08\n\r\n\x05\x04n\x02\x08\x01\x12\x04\xdb%\t\x1b\n\r\n\x05\
    \x04n\x02\x08\x03\x12\x04\xdb%\x1e\x20\n\xd1\x01\n\x04\x04n\x02\t\x12\
    \x04\xe0%\x02\x14\x1a\xc2\x01\x20Filtering\x20options:\n\x20Query\x20nam\
    e,\x20description\x20and\x20id\x20fields,\x20that\x20can\x20contain\x20t\
    he\x20words\x20in\x20the\x20query\x20string.\x20Does\x20NOT\x20support\
    \x20wildcards\x20-\x20full\x20words\x20only.\x20Supports\x20operators\
    \x20\"OR\"\x20and\x20\"-\"\x20as\x20NOT.\n\n\r\n\x05\x04n\x02\t\x05\x12\
    \x04\xe0%\x02\x08\n\r\n\x05\x04n\x02\t\x01\x12\x04\xe0%\t\x0e\n\r\n\x05\
    \x04n\x02\t\x03\x12\x04\xe0%\x11\x13\n\x8b\x01\n\x04\x04n\x02\n\x12\x04\
    \xe2%\x02\x12\x1a}\x20Filter\x20by\x20the\x20description\x20and\x20id\
    \x20of\x20the\x20model.\x20This\x20supports\x20wildcard\x20queries\x20li\
    ke\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\n\
    \r\n\x05\x04n\x02\n\x05\x12\x04\xe2%\x02\x08\n\r\n\x05\x04n\x02\n\x01\
    \x12\x04\xe2%\t\r\n\r\n\x05\x04n\x02\n\x03\x12\x04\xe2%\x10\x11\nr\n\x04\
    \x04n\x02\x0b\x12\x04\xe4%\x02\x1e\x1ad\x20Extends\x20the\x20name\x20fil\
    ter\x20to\x20include\x20the\x20user_id\x20of\x20the\x20application\x20ow\
    ner\x20that\x20the\x20model\x20belongs\x20to.\n\n\r\n\x05\x04n\x02\x0b\
    \x05\x12\x04\xe4%\x02\x06\n\r\n\x05\x04n\x02\x0b\x01\x12\x04\xe4%\x07\
    \x18\n\r\n\x05\x04n\x02\x0b\x03\x12\x04\xe4%\x1b\x1d\nz\n\x04\x04n\x02\
    \x0c\x12\x04\xe7%\x02\x1b\x1al\x20Filter\x20models\x20by\x20the\x20speci\
    fic\x20model_type_id.\x20See\x20ListModelTypes\x20for\x20the\x20list\x20\
    of\x20ModelType.Id's\n\x20supported.\n\n\r\n\x05\x04n\x02\x0c\x05\x12\
    \x04\xe7%\x02\x08\n\r\n\x05\x04n\x02\x0c\x01\x12\x04\xe7%\t\x16\n\r\n\
    \x05\x04n\x02\x0c\x03\x12\x04\xe7%\x19\x1a\n|\n\x04\x04n\x02\r\x12\x04\
    \xe9%\x02\x18\x1an\x20If\x20true,\x20we\x20only\x20return\x20models\x20t\
    hat\x20have\x20the\x20status\x20MODEL_TRAINED,\x20which\x20includes\x20n\
    on-trainable\x20model\x20types.\n\n\r\n\x05\x04n\x02\r\x05\x12\x04\xe9%\
    \x02\x06\n\r\n\x05\x04n\x02\r\x01\x12\x04\xe9%\x07\x13\n\r\n\x05\x04n\
    \x02\r\x03\x12\x04\xe9%\x16\x17\n\xb5\x01\n\x04\x04n\x02\x0e\x12\x04\xec\
    %\x02#\x1a\xa6\x01\x20The\x20list\x20of\x20input\x20fields\x20to\x20the\
    \x20model.\n\x20For\x20example,\x20you\x20can\x20specify\x20'image',\x20\
    which\x20will\x20return\x20models\x20that\x20make\x20inferences\x20on\
    \x20images\x20like\x20visual-classifier\x20models.\n\n\r\n\x05\x04n\x02\
    \x0e\x04\x12\x04\xec%\x02\n\n\r\n\x05\x04n\x02\x0e\x05\x12\x04\xec%\x0b\
    \x11\n\r\n\x05\x04n\x02\x0e\x01\x12\x04\xec%\x12\x1e\n\r\n\x05\x04n\x02\
    \x0e\x03\x12\x04\xec%!\"\n\x9e\x01\n\x04\x04n\x02\x0f\x12\x04\xef%\x02$\
    \x1a\x8f\x01\x20The\x20list\x20of\x20output\x20fields\x20to\x20the\x20mo\
    del.\n\x20For\x20example,\x20you\x20can\x20specify\x20'regions[...].data\
    .concepts',\x20which\x20will\x20return\x20visual-detector\x20models.\n\n\
    \r\n\x05\x04n\x02\x0f\x04\x12\x04\xef%\x02\n\n\r\n\x05\x04n\x02\x0f\x05\
    \x12\x04\xef%\x0b\x11\n\r\n\x05\x04n\x02\x0f\x01\x12\x04\xef%\x12\x1f\n\
    \r\n\x05\x04n\x02\x0f\x03\x12\x04\xef%\"#\n:\n\x04\x04n\x02\x10\x12\x04\
    \xf1%\x02\x16\x1a,\x20Filter\x20by\x20the\x20license\x20of\x20the\x20mod\
    el\x20version\n\n\r\n\x05\x04n\x02\x10\x05\x12\x04\xf1%\x02\x08\n\r\n\
    \x05\x04n\x02\x10\x01\x12\x04\xf1%\t\x10\n\r\n\x05\x04n\x02\x10\x03\x12\
    \x04\xf1%\x13\x15\nT\n\x04\x04n\x02\x11\x12\x04\xf3%\x02\x1a\x1aF\x20If\
    \x20true,\x20we\x20only\x20return\x20models\x20that\x20are\x20handpicked\
    \x20by\x20clarifai\x20staff\n\n\r\n\x05\x04n\x02\x11\x05\x12\x04\xf3%\
    \x02\x06\n\r\n\x05\x04n\x02\x11\x01\x12\x04\xf3%\x07\x14\n\r\n\x05\x04n\
    \x02\x11\x03\x12\x04\xf3%\x17\x19\nV\n\x04\x04n\x02\x12\x12\x04\xf5%\x02\
    \x19\x1aH\x20If\x20true,\x20we\x20only\x20return\x20models\x20that\x20ar\
    e\x20starred\x20by\x20the\x20requesting\x20user\n\n\r\n\x05\x04n\x02\x12\
    \x05\x12\x04\xf5%\x02\x06\n\r\n\x05\x04n\x02\x12\x01\x12\x04\xf5%\x07\
    \x13\n\r\n\x05\x04n\x02\x12\x03\x12\x04\xf5%\x16\x18\n1\n\x04\x04n\x02\
    \x13\x12\x04\xf7%\x02\x20\x1a#\x20List\x20of\x20toolkit\x20tags\x20to\
    \x20filter\x20by\n\n\r\n\x05\x04n\x02\x13\x04\x12\x04\xf7%\x02\n\n\r\n\
    \x05\x04n\x02\x13\x05\x12\x04\xf7%\x0b\x11\n\r\n\x05\x04n\x02\x13\x01\
    \x12\x04\xf7%\x12\x1a\n\r\n\x05\x04n\x02\x13\x03\x12\x04\xf7%\x1d\x1f\n2\
    \n\x04\x04n\x02\x14\x12\x04\xf9%\x02!\x1a$\x20List\x20of\x20use_case\x20\
    tags\x20to\x20filter\x20by\n\n\r\n\x05\x04n\x02\x14\x04\x12\x04\xf9%\x02\
    \n\n\r\n\x05\x04n\x02\x14\x05\x12\x04\xf9%\x0b\x11\n\r\n\x05\x04n\x02\
    \x14\x01\x12\x04\xf9%\x12\x1b\n\r\n\x05\x04n\x02\x14\x03\x12\x04\xf9%\
    \x1e\x20\n2\n\x04\x04n\x02\x15\x12\x04\xfb%\x02!\x1a$\x20List\x20of\x20l\
    anguage\x20tags\x20to\x20filter\x20by\n\n\r\n\x05\x04n\x02\x15\x04\x12\
    \x04\xfb%\x02\n\n\r\n\x05\x04n\x02\x15\x05\x12\x04\xfb%\x0b\x11\n\r\n\
    \x05\x04n\x02\x15\x01\x12\x04\xfb%\x12\x1b\n\r\n\x05\x04n\x02\x15\x03\
    \x12\x04\xfb%\x1e\x20\n\x95\x01\n\x04\x04n\x02\x16\x12\x04\xfd%\x02)\x1a\
    \x86\x01\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\
    \x20fields\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currentl\
    y\x20supported:\x20all,\x20stars,\x20outputs,\x20presets\n\n\r\n\x05\x04\
    n\x02\x16\x04\x12\x04\xfd%\x02\n\n\r\n\x05\x04n\x02\x16\x05\x12\x04\xfd%\
    \x0b\x11\n\r\n\x05\x04n\x02\x16\x01\x12\x04\xfd%\x12#\n\r\n\x05\x04n\x02\
    \x16\x03\x12\x04\xfd%&(\n\x96\x02\n\x04\x04n\x02\x17\x12\x04\x80&\x02!\
    \x1a\x87\x02\x20Old\x20API\x20behavior\x20resulted\x20in\x20returning\
    \x20clarifai\x20main\x20models\x20when\x20calling\x20ListModels\x20while\
    \x20scoped\x20to\x20an\x20app.\x20While\x20we\x20transition\n\x20away\
    \x20from\x20that,\x20we\x20can\x20use\x20this\x20flag\x20to\x20not\x20al\
    ways\x20fetch\x20clarifai\x20main\x20models,\x20unless\x20that\x20is\x20\
    the\x20app\x20we\x20are\x20explicitly\x20listing\x20for.\n\n\r\n\x05\x04\
    n\x02\x17\x05\x12\x04\x80&\x02\x06\n\r\n\x05\x04n\x02\x17\x01\x12\x04\
    \x80&\x07\x1b\n\r\n\x05\x04n\x02\x17\x03\x12\x04\x80&\x1e\x20\n\x88\x02\
    \n\x04\x04n\x02\x18\x12\x04\x85&\x02\x15\x1a\xf9\x01\x20Filter\x20models\
    \x20by\x20bookmark.\x20If\x20set,\x20only\x20return\x20bookmarked\x20mod\
    els.\x20Otherwise\x20none\x20bookmarked\x20models\x20only.\n\x20Note:\
    \x20you\x20can\x20not\x20filter\x20`trained_only`\x20and\x20bookmark\x20\
    at\x20the\x20same\x20time.\n\x20When\x20filter\x20by\x20bookmark,\x20we\
    \x20will\x20return\x20trained\x20and\x20untrained\x20models.\n\n\r\n\x05\
    \x04n\x02\x18\x05\x12\x04\x85&\x02\x06\n\r\n\x05\x04n\x02\x18\x01\x12\
    \x04\x85&\x07\x0f\n\r\n\x05\x04n\x02\x18\x03\x12\x04\x85&\x12\x14\n$\n\
    \x02\x04o\x12\x06\x89&\0\x8b&\x01\x1a\x16\x20ResourceCountRequest\n\n\
    \x0b\n\x03\x04o\x01\x12\x04\x89&\x08\x20\n\x0c\n\x04\x04o\x02\0\x12\x04\
    \x8a&\x02,\n\r\n\x05\x04o\x02\0\x06\x12\x04\x8a&\x02\x1b\n\r\n\x05\x04o\
    \x02\0\x01\x12\x04\x8a&\x1c'\n\r\n\x05\x04o\x02\0\x03\x12\x04\x8a&*+\n%\
    \n\x02\x04p\x12\x06\x8e&\0\x94&\x01\x1a\x17\x20ResourceCountResponse\n\n\
    \x0b\n\x03\x04p\x01\x12\x04\x8e&\x08!\n\x0c\n\x04\x04p\x02\0\x12\x04\x8f\
    &\x02(\n\r\n\x05\x04p\x02\0\x06\x12\x04\x8f&\x02\x1c\n\r\n\x05\x04p\x02\
    \0\x01\x12\x04\x8f&\x1d#\n\r\n\x05\x04p\x02\0\x03\x12\x04\x8f&&'\n\x0c\n\
    \x04\x04p\x02\x01\x12\x04\x90&\x02\x15\n\r\n\x05\x04p\x02\x01\x05\x12\
    \x04\x90&\x02\x07\n\r\n\x05\x04p\x02\x01\x01\x12\x04\x90&\x08\x10\n\r\n\
    \x05\x04p\x02\x01\x03\x12\x04\x90&\x13\x14\n\x0c\n\x04\x04p\x02\x02\x12\
    \x04\x91&\x02\x13\n\r\n\x05\x04p\x02\x02\x05\x12\x04\x91&\x02\x07\n\r\n\
    \x05\x04p\x02\x02\x01\x12\x04\x91&\x08\x0e\n\r\n\x05\x04p\x02\x02\x03\
    \x12\x04\x91&\x11\x12\n\x0c\n\x04\x04p\x02\x03\x12\x04\x92&\x02\x16\n\r\
    \n\x05\x04p\x02\x03\x05\x12\x04\x92&\x02\x07\n\r\n\x05\x04p\x02\x03\x01\
    \x12\x04\x92&\x08\x11\n\r\n\x05\x04p\x02\x03\x03\x12\x04\x92&\x14\x15\n\
    \x0c\n\x04\x04p\x02\x04\x12\x04\x93&\x02\x14\n\r\n\x05\x04p\x02\x04\x05\
    \x12\x04\x93&\x02\x07\n\r\n\x05\x04p\x02\x04\x01\x12\x04\x93&\x08\x0f\n\
    \r\n\x05\x04p\x02\x04\x03\x12\x04\x93&\x12\x13\n\x0c\n\x02\x04q\x12\x06\
    \x96&\0\x9e&\x01\n\x0b\n\x03\x04q\x01\x12\x04\x96&\x08!\n\x0c\n\x04\x04q\
    \x02\0\x12\x04\x97&\x02,\n\r\n\x05\x04q\x02\0\x06\x12\x04\x97&\x02\x1b\n\
    \r\n\x05\x04q\x02\0\x01\x12\x04\x97&\x1c'\n\r\n\x05\x04q\x02\0\x03\x12\
    \x04\x97&*+\n\x0c\n\x04\x04q\x02\x01\x12\x04\x99&\x02\x16\n\r\n\x05\x04q\
    \x02\x01\x05\x12\x04\x99&\x02\x08\n\r\n\x05\x04q\x02\x01\x01\x12\x04\x99\
    &\t\x11\n\r\n\x05\x04q\x02\x01\x03\x12\x04\x99&\x14\x15\n\x0c\n\x04\x04q\
    \x02\x02\x12\x04\x9b&\x02\x1f\n\r\n\x05\x04q\x02\x02\x04\x12\x04\x9b&\
    \x02\n\n\r\n\x05\x04q\x02\x02\x05\x12\x04\x9b&\x0b\x11\n\r\n\x05\x04q\
    \x02\x02\x01\x12\x04\x9b&\x12\x1a\n\r\n\x05\x04q\x02\x02\x03\x12\x04\x9b\
    &\x1d\x1e\n\"\n\x04\x04q\x02\x03\x12\x04\x9d&\x02\x14\x1a\x14overwrite\
    \x20supported\n\n\r\n\x05\x04q\x02\x03\x05\x12\x04\x9d&\x02\x08\n\r\n\
    \x05\x04q\x02\x03\x01\x12\x04\x9d&\t\x0f\n\r\n\x05\x04q\x02\x03\x03\x12\
    \x04\x9d&\x12\x13\n.\n\x02\x04r\x12\x06\xa1&\0\xa9&\x01\x1a\x20\x20Patch\
    ModelCheckConsentsRequest\n\n\x0b\n\x03\x04r\x01\x12\x04\xa1&\x08&\n\x0c\
    \n\x04\x04r\x02\0\x12\x04\xa2&\x02,\n\r\n\x05\x04r\x02\0\x06\x12\x04\xa2\
    &\x02\x1b\n\r\n\x05\x04r\x02\0\x01\x12\x04\xa2&\x1c'\n\r\n\x05\x04r\x02\
    \0\x03\x12\x04\xa2&*+\n\x1c\n\x04\x04r\x02\x01\x12\x04\xa4&\x02\x16\x1a\
    \x0e\x20the\x20model\x20id\n\n\r\n\x05\x04r\x02\x01\x05\x12\x04\xa4&\x02\
    \x08\n\r\n\x05\x04r\x02\x01\x01\x12\x04\xa4&\t\x11\n\r\n\x05\x04r\x02\
    \x01\x03\x12\x04\xa4&\x14\x15\n\x1c\n\x04\x04r\x02\x02\x12\x04\xa6&\x02%\
    \x1a\x0e\x20the\x20consents\n\n\r\n\x05\x04r\x02\x02\x04\x12\x04\xa6&\
    \x02\n\n\r\n\x05\x04r\x02\x02\x05\x12\x04\xa6&\x0b\x11\n\r\n\x05\x04r\
    \x02\x02\x01\x12\x04\xa6&\x12\x20\n\r\n\x05\x04r\x02\x02\x03\x12\x04\xa6\
    &#$\n\"\n\x04\x04r\x02\x03\x12\x04\xa8&\x02\x14\x1a\x14overwrite\x20supp\
    orted\n\n\r\n\x05\x04r\x02\x03\x05\x12\x04\xa8&\x02\x08\n\r\n\x05\x04r\
    \x02\x03\x01\x12\x04\xa8&\t\x0f\n\r\n\x05\x04r\x02\x03\x03\x12\x04\xa8&\
    \x12\x13\n\x0c\n\x02\x04s\x12\x06\xab&\0\xb3&\x01\n\x0b\n\x03\x04s\x01\
    \x12\x04\xab&\x08!\n\x0c\n\x04\x04s\x02\0\x12\x04\xac&\x02,\n\r\n\x05\
    \x04s\x02\0\x06\x12\x04\xac&\x02\x1b\n\r\n\x05\x04s\x02\0\x01\x12\x04\
    \xac&\x1c'\n\r\n\x05\x04s\x02\0\x03\x12\x04\xac&*+\n\x0c\n\x04\x04s\x02\
    \x01\x12\x04\xae&\x02\x16\n\r\n\x05\x04s\x02\x01\x05\x12\x04\xae&\x02\
    \x08\n\r\n\x05\x04s\x02\x01\x01\x12\x04\xae&\t\x11\n\r\n\x05\x04s\x02\
    \x01\x03\x12\x04\xae&\x14\x15\n\x0c\n\x04\x04s\x02\x02\x12\x04\xb0&\x02\
    \x1f\n\r\n\x05\x04s\x02\x02\x04\x12\x04\xb0&\x02\n\n\r\n\x05\x04s\x02\
    \x02\x05\x12\x04\xb0&\x0b\x11\n\r\n\x05\x04s\x02\x02\x01\x12\x04\xb0&\
    \x12\x1a\n\r\n\x05\x04s\x02\x02\x03\x12\x04\xb0&\x1d\x1e\n\"\n\x04\x04s\
    \x02\x03\x12\x04\xb2&\x02\x14\x1a\x14overwrite\x20supported\n\n\r\n\x05\
    \x04s\x02\x03\x05\x12\x04\xb2&\x02\x08\n\r\n\x05\x04s\x02\x03\x01\x12\
    \x04\xb2&\t\x0f\n\r\n\x05\x04s\x02\x03\x03\x12\x04\xb2&\x12\x13\n\x0c\n\
    \x02\x04t\x12\x06\xb5&\0\xbd&\x01\n\x0b\n\x03\x04t\x01\x12\x04\xb5&\x08\
    \"\n\x0c\n\x04\x04t\x02\0\x12\x04\xb6&\x02,\n\r\n\x05\x04t\x02\0\x06\x12\
    \x04\xb6&\x02\x1b\n\r\n\x05\x04t\x02\0\x01\x12\x04\xb6&\x1c'\n\r\n\x05\
    \x04t\x02\0\x03\x12\x04\xb6&*+\n\x0c\n\x04\x04t\x02\x01\x12\x04\xb8&\x02\
    \x16\n\r\n\x05\x04t\x02\x01\x05\x12\x04\xb8&\x02\x08\n\r\n\x05\x04t\x02\
    \x01\x01\x12\x04\xb8&\t\x11\n\r\n\x05\x04t\x02\x01\x03\x12\x04\xb8&\x14\
    \x15\n\x0c\n\x04\x04t\x02\x02\x12\x04\xba&\x02\x20\n\r\n\x05\x04t\x02\
    \x02\x04\x12\x04\xba&\x02\n\n\r\n\x05\x04t\x02\x02\x05\x12\x04\xba&\x0b\
    \x11\n\r\n\x05\x04t\x02\x02\x01\x12\x04\xba&\x12\x1b\n\r\n\x05\x04t\x02\
    \x02\x03\x12\x04\xba&\x1e\x1f\n(\n\x04\x04t\x02\x03\x12\x04\xbc&\x02\x14\
    \x1a\x1a\x20Only\x20overwrite\x20supported\n\n\r\n\x05\x04t\x02\x03\x05\
    \x12\x04\xbc&\x02\x08\n\r\n\x05\x04t\x02\x03\x01\x12\x04\xbc&\t\x0f\n\r\
    \n\x05\x04t\x02\x03\x03\x12\x04\xbc&\x12\x13\n\x0c\n\x02\x04u\x12\x06\
    \xc1&\0\xc4&\x01\n\x0b\n\x03\x04u\x01\x12\x04\xc1&\x08!\n\x0c\n\x04\x04u\
    \x02\0\x12\x04\xc2&\x02(\n\r\n\x05\x04u\x02\0\x06\x12\x04\xc2&\x02\x1c\n\
    \r\n\x05\x04u\x02\0\x01\x12\x04\xc2&\x1d#\n\r\n\x05\x04u\x02\0\x03\x12\
    \x04\xc2&&'\n\x0c\n\x04\x04u\x02\x01\x12\x04\xc3&\x02\x1f\n\r\n\x05\x04u\
    \x02\x01\x04\x12\x04\xc3&\x02\n\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xc3&\
    \x0b\x11\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xc3&\x12\x1a\n\r\n\x05\x04u\
    \x02\x01\x03\x12\x04\xc3&\x1d\x1e\n\x0c\n\x02\x04v\x12\x06\xc6&\0\xc9&\
    \x01\n\x0b\n\x03\x04v\x01\x12\x04\xc6&\x08&\n\x0c\n\x04\x04v\x02\0\x12\
    \x04\xc7&\x02(\n\r\n\x05\x04v\x02\0\x06\x12\x04\xc7&\x02\x1c\n\r\n\x05\
    \x04v\x02\0\x01\x12\x04\xc7&\x1d#\n\r\n\x05\x04v\x02\0\x03\x12\x04\xc7&&\
    '\n\x0c\n\x04\x04v\x02\x01\x12\x04\xc8&\x02%\n\r\n\x05\x04v\x02\x01\x04\
    \x12\x04\xc8&\x02\n\n\r\n\x05\x04v\x02\x01\x05\x12\x04\xc8&\x0b\x11\n\r\
    \n\x05\x04v\x02\x01\x01\x12\x04\xc8&\x12\x20\n\r\n\x05\x04v\x02\x01\x03\
    \x12\x04\xc8&#$\n\x0c\n\x02\x04w\x12\x06\xcb&\0\xce&\x01\n\x0b\n\x03\x04\
    w\x01\x12\x04\xcb&\x08!\n\x0c\n\x04\x04w\x02\0\x12\x04\xcc&\x02(\n\r\n\
    \x05\x04w\x02\0\x06\x12\x04\xcc&\x02\x1c\n\r\n\x05\x04w\x02\0\x01\x12\
    \x04\xcc&\x1d#\n\r\n\x05\x04w\x02\0\x03\x12\x04\xcc&&'\n\x0c\n\x04\x04w\
    \x02\x01\x12\x04\xcd&\x02\x1f\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xcd&\
    \x02\n\n\r\n\x05\x04w\x02\x01\x05\x12\x04\xcd&\x0b\x11\n\r\n\x05\x04w\
    \x02\x01\x01\x12\x04\xcd&\x12\x1a\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xcd\
    &\x1d\x1e\n\x0c\n\x02\x04x\x12\x06\xd0&\0\xd3&\x01\n\x0b\n\x03\x04x\x01\
    \x12\x04\xd0&\x08\"\n\x0c\n\x04\x04x\x02\0\x12\x04\xd1&\x02(\n\r\n\x05\
    \x04x\x02\0\x06\x12\x04\xd1&\x02\x1c\n\r\n\x05\x04x\x02\0\x01\x12\x04\
    \xd1&\x1d#\n\r\n\x05\x04x\x02\0\x03\x12\x04\xd1&&'\n\x0c\n\x04\x04x\x02\
    \x01\x12\x04\xd2&\x02\x20\n\r\n\x05\x04x\x02\x01\x04\x12\x04\xd2&\x02\n\
    \n\r\n\x05\x04x\x02\x01\x05\x12\x04\xd2&\x0b\x11\n\r\n\x05\x04x\x02\x01\
    \x01\x12\x04\xd2&\x12\x1b\n\r\n\x05\x04x\x02\x01\x03\x12\x04\xd2&\x1e\
    \x1f\n!\n\x02\x04y\x12\x06\xd6&\0\xe0&\x01\x1a\x13\x20PostModelsRequest\
    \n\n\x0b\n\x03\x04y\x01\x12\x04\xd6&\x08\x19\n\x0c\n\x04\x04y\x02\0\x12\
    \x04\xd7&\x02,\n\r\n\x05\x04y\x02\0\x06\x12\x04\xd7&\x02\x1b\n\r\n\x05\
    \x04y\x02\0\x01\x12\x04\xd7&\x1c'\n\r\n\x05\x04y\x02\0\x03\x12\x04\xd7&*\
    +\n\x91\x02\n\x04\x04y\x02\x01\x12\x04\xdd&\x02&\x1a\x82\x02\x20NOTE:\
    \x20inconsistent\x20since\x20\"model\"\x20is\x20not\x20plural,\x20please\
    \x20use\x20\"models\"\x20below.\n\x20Previously\x20you\x20could\x20only\
    \x20create\x20one\x20model\x20at\x20a\x20time.\n\x20We\x20still\x20suppo\
    rt\x20this\x20but\x20you\x20should\x20pass\x20it\x20as\x20models=[model]\
    \x20so\n\x20that\x20this\x20endpoint\x20is\x20consistent\x20with\x20the\
    \x20rest\x20of\x20our\x20API.\n\n\r\n\x05\x04y\x02\x01\x06\x12\x04\xdd&\
    \x02\x07\n\r\n\x05\x04y\x02\x01\x01\x12\x04\xdd&\x08\r\n\r\n\x05\x04y\
    \x02\x01\x03\x12\x04\xdd&\x10\x11\n\r\n\x05\x04y\x02\x01\x08\x12\x04\xdd\
    &\x12%\n\x0e\n\x06\x04y\x02\x01\x08\x03\x12\x04\xdd&\x13$\nU\n\x04\x04y\
    \x02\x02\x12\x04\xdf&\x02\x1c\x1aG\x20This\x20allows\x20you\x20to\x20cre\
    ate\x20one\x20or\x20more\x20model\x20by\x20posting\x20it\x20to\x20the\
    \x20API.\n\n\r\n\x05\x04y\x02\x02\x04\x12\x04\xdf&\x02\n\n\r\n\x05\x04y\
    \x02\x02\x06\x12\x04\xdf&\x0b\x10\n\r\n\x05\x04y\x02\x02\x01\x12\x04\xdf\
    &\x11\x17\n\r\n\x05\x04y\x02\x02\x03\x12\x04\xdf&\x1a\x1b\n\"\n\x02\x04z\
    \x12\x06\xe3&\0\xea&\x01\x1a\x14\x20PatchModelsRequest\n\n\x0b\n\x03\x04\
    z\x01\x12\x04\xe3&\x08\x1a\n\x0c\n\x04\x04z\x02\0\x12\x04\xe4&\x02,\n\r\
    \n\x05\x04z\x02\0\x06\x12\x04\xe4&\x02\x1b\n\r\n\x05\x04z\x02\0\x01\x12\
    \x04\xe4&\x1c'\n\r\n\x05\x04z\x02\0\x03\x12\x04\xe4&*+\n\x0c\n\x04\x04z\
    \x02\x01\x12\x04\xe5&\x02\x1c\n\r\n\x05\x04z\x02\x01\x04\x12\x04\xe5&\
    \x02\n\n\r\n\x05\x04z\x02\x01\x06\x12\x04\xe5&\x0b\x10\n\r\n\x05\x04z\
    \x02\x01\x01\x12\x04\xe5&\x11\x17\n\r\n\x05\x04z\x02\x01\x03\x12\x04\xe5\
    &\x1a\x1b\n~\n\x04\x04z\x02\x02\x12\x04\xe9&\x02\x14\x1ap\x20The\x20acti\
    on\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\
    \x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20sup\
    ported\n\n\r\n\x05\x04z\x02\x02\x05\x12\x04\xe9&\x02\x08\n\r\n\x05\x04z\
    \x02\x02\x01\x12\x04\xe9&\t\x0f\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xe9&\
    \x12\x13\n\x0c\n\x02\x04{\x12\x06\xec&\0\xf1&\x01\n\x0b\n\x03\x04{\x01\
    \x12\x04\xec&\x08\x16\n\x15\n\x04\x04{\x02\0\x12\x04\xee&\x02\x10\x1a\
    \x07old\x20id\n\n\r\n\x05\x04{\x02\0\x05\x12\x04\xee&\x02\x08\n\r\n\x05\
    \x04{\x02\0\x01\x12\x04\xee&\t\x0b\n\r\n\x05\x04{\x02\0\x03\x12\x04\xee&\
    \x0e\x0f\n\x15\n\x04\x04{\x02\x01\x12\x04\xf0&\x02\x14\x1a\x07new\x20id\
    \n\n\r\n\x05\x04{\x02\x01\x05\x12\x04\xf0&\x02\x08\n\r\n\x05\x04{\x02\
    \x01\x01\x12\x04\xf0&\t\x0f\n\r\n\x05\x04{\x02\x01\x03\x12\x04\xf0&\x12\
    \x13\n$\n\x02\x04|\x12\x06\xf4&\0\xfd&\x01\x1a\x16\x20PatchModelIdsReque\
    st\n\n\x0b\n\x03\x04|\x01\x12\x04\xf4&\x08\x1c\n\x0c\n\x04\x04|\x02\0\
    \x12\x04\xf5&\x02,\n\r\n\x05\x04|\x02\0\x06\x12\x04\xf5&\x02\x1b\n\r\n\
    \x05\x04|\x02\0\x01\x12\x04\xf5&\x1c'\n\r\n\x05\x04|\x02\0\x03\x12\x04\
    \xf5&*+\n(\n\x04\x04|\x02\x01\x12\x04\xf8&\x02\"\x1a\x1a\x20Array\x20con\
    taining\x201\x20entry\n\n\r\n\x05\x04|\x02\x01\x04\x12\x04\xf8&\x02\n\n\
    \r\n\x05\x04|\x02\x01\x06\x12\x04\xf8&\x0b\x19\n\r\n\x05\x04|\x02\x01\
    \x01\x12\x04\xf8&\x1a\x1d\n\r\n\x05\x04|\x02\x01\x03\x12\x04\xf8&\x20!\n\
    [\n\x04\x04|\x02\x02\x12\x04\xfc&\x02\x14\x1aM\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20Only\x20'overwrite'\
    \x20is\x20supported\n\n\r\n\x05\x04|\x02\x02\x05\x12\x04\xfc&\x02\x08\n\
    \r\n\x05\x04|\x02\x02\x01\x12\x04\xfc&\t\x0f\n\r\n\x05\x04|\x02\x02\x03\
    \x12\x04\xfc&\x12\x13\n\"\n\x02\x04}\x12\x06\x80'\0\x83'\x01\x1a\x14\x20\
    DeleteModelRequest\n\n\x0b\n\x03\x04}\x01\x12\x04\x80'\x08\x1a\n\x0c\n\
    \x04\x04}\x02\0\x12\x04\x81'\x02,\n\r\n\x05\x04}\x02\0\x06\x12\x04\x81'\
    \x02\x1b\n\r\n\x05\x04}\x02\0\x01\x12\x04\x81'\x1c'\n\r\n\x05\x04}\x02\0\
    \x03\x12\x04\x81'*+\n\x0c\n\x04\x04}\x02\x01\x12\x04\x82'\x02\x16\n\r\n\
    \x05\x04}\x02\x01\x05\x12\x04\x82'\x02\x08\n\r\n\x05\x04}\x02\x01\x01\
    \x12\x04\x82'\t\x11\n\r\n\x05\x04}\x02\x01\x03\x12\x04\x82'\x14\x15\nD\n\
    \x02\x04~\x12\x06\x86'\0\x8a'\x01\x1a6\x20Request\x20to\x20delete\x20sev\
    eral\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04~\x01\
    \x12\x04\x86'\x08\x1b\n\x0c\n\x04\x04~\x02\0\x12\x04\x87'\x02,\n\r\n\x05\
    \x04~\x02\0\x06\x12\x04\x87'\x02\x1b\n\r\n\x05\x04~\x02\0\x01\x12\x04\
    \x87'\x1c'\n\r\n\x05\x04~\x02\0\x03\x12\x04\x87'*+\n\x0c\n\x04\x04~\x02\
    \x01\x12\x04\x88'\x02\x1a\n\r\n\x05\x04~\x02\x01\x04\x12\x04\x88'\x02\n\
    \n\r\n\x05\x04~\x02\x01\x05\x12\x04\x88'\x0b\x11\n\r\n\x05\x04~\x02\x01\
    \x01\x12\x04\x88'\x12\x15\n\r\n\x05\x04~\x02\x01\x03\x12\x04\x88'\x18\
    \x19\n\x0c\n\x04\x04~\x02\x02\x12\x04\x89'\x02\x16\n\r\n\x05\x04~\x02\
    \x02\x05\x12\x04\x89'\x02\x06\n\r\n\x05\x04~\x02\x02\x01\x12\x04\x89'\
    \x07\x11\n\r\n\x05\x04~\x02\x02\x03\x12\x04\x89'\x14\x15\n1\n\x02\x04\
    \x7f\x12\x06\x8d'\0\x95'\x01\x1a#\x20Search\x20over\x20the\x20available\
    \x20models.\n\n\x0b\n\x03\x04\x7f\x01\x12\x04\x8d'\x08!\n6\n\x04\x04\x7f\
    \x02\0\x12\x04\x8f'\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20o\
    f\x20the\x20request.\n\n\r\n\x05\x04\x7f\x02\0\x06\x12\x04\x8f'\x02\x1b\
    \n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\x8f'\x1c'\n\r\n\x05\x04\x7f\x02\0\
    \x03\x12\x04\x8f'*+\n(\n\x04\x04\x7f\x02\x01\x12\x04\x91'\x02\x1d\x1a\
    \x1a\x20The\x20body\x20of\x20the\x20request.\n\n\r\n\x05\x04\x7f\x02\x01\
    \x06\x12\x04\x91'\x02\x0c\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\x91'\r\
    \x18\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\x91'\x1b\x1c\n]\n\x04\x04\x7f\
    \x02\x02\x12\x04\x94'\x02\x1c\x1aO\x20Pagination\x20parameters\x20here\
    \x20since\x20there\x20are\x20no\x20url\x20args\x20in\x20this\n\x20POST\
    \x20request.\n\n\r\n\x05\x04\x7f\x02\x02\x06\x12\x04\x94'\x02\x0c\n\r\n\
    \x05\x04\x7f\x02\x02\x01\x12\x04\x94'\r\x17\n\r\n\x05\x04\x7f\x02\x02\
    \x03\x12\x04\x94'\x1a\x1b\n$\n\x03\x04\x80\x01\x12\x06\x98'\0\x9b'\x01\
    \x1a\x15\x20SingleModelResponse\n\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\
    \x98'\x08\x1b\n\r\n\x05\x04\x80\x01\x02\0\x12\x04\x99'\x02(\n\x0e\n\x06\
    \x04\x80\x01\x02\0\x06\x12\x04\x99'\x02\x1c\n\x0e\n\x06\x04\x80\x01\x02\
    \0\x01\x12\x04\x99'\x1d#\n\x0e\n\x06\x04\x80\x01\x02\0\x03\x12\x04\x99'&\
    '\n\r\n\x05\x04\x80\x01\x02\x01\x12\x04\x9a'\x02\x12\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x06\x12\x04\x9a'\x02\x07\n\x0e\n\x06\x04\x80\x01\x02\x01\
    \x01\x12\x04\x9a'\x08\r\n\x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\x9a'\
    \x10\x11\n#\n\x03\x04\x81\x01\x12\x06\x9e'\0\xa1'\x01\x1a\x14\x20MultiMo\
    delResponse\n\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\x9e'\x08\x1a\n\r\n\x05\
    \x04\x81\x01\x02\0\x12\x04\x9f'\x02(\n\x0e\n\x06\x04\x81\x01\x02\0\x06\
    \x12\x04\x9f'\x02\x1c\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\x9f'\x1d\
    #\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\x9f'&'\n\r\n\x05\x04\x81\x01\
    \x02\x01\x12\x04\xa0'\x02K\n\x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\
    \xa0'\x02\n\n\x0e\n\x06\x04\x81\x01\x02\x01\x06\x12\x04\xa0'\x0b\x10\n\
    \x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\x04\xa0'\x11\x17\n\x0e\n\x06\x04\
    \x81\x01\x02\x01\x03\x12\x04\xa0'\x1a\x1b\n\x0e\n\x06\x04\x81\x01\x02\
    \x01\x08\x12\x04\xa0'\x1cJ\n\x11\n\t\x04\x81\x01\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xa0'\x1dI\n*\n\x03\x04\x82\x01\x12\x06\xa4'\0\xab'\x01\x1a\x1b\
    \x20PatchModelVersionsRequest\n\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\xa4'\
    \x08!\n\r\n\x05\x04\x82\x01\x02\0\x12\x04\xa5'\x02,\n\x0e\n\x06\x04\x82\
    \x01\x02\0\x06\x12\x04\xa5'\x02\x1b\n\x0e\n\x06\x04\x82\x01\x02\0\x01\
    \x12\x04\xa5'\x1c'\n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\x04\xa5'*+\n\r\
    \n\x05\x04\x82\x01\x02\x01\x12\x04\xa6'\x02\x16\n\x0e\n\x06\x04\x82\x01\
    \x02\x01\x05\x12\x04\xa6'\x02\x08\n\x0e\n\x06\x04\x82\x01\x02\x01\x01\
    \x12\x04\xa6'\t\x11\n\x0e\n\x06\x04\x82\x01\x02\x01\x03\x12\x04\xa6'\x14\
    \x15\n\r\n\x05\x04\x82\x01\x02\x02\x12\x04\xa7'\x02+\n\x0e\n\x06\x04\x82\
    \x01\x02\x02\x04\x12\x04\xa7'\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x02\x06\
    \x12\x04\xa7'\x0b\x17\n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\xa7'\
    \x18&\n\x0e\n\x06\x04\x82\x01\x02\x02\x03\x12\x04\xa7')*\n\x7f\n\x05\x04\
    \x82\x01\x02\x03\x12\x04\xaa'\x02\x14\x1ap\x20The\x20action\x20to\x20per\
    form\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'm\
    erge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\
    \x06\x04\x82\x01\x02\x03\x05\x12\x04\xaa'\x02\x08\n\x0e\n\x06\x04\x82\
    \x01\x02\x03\x01\x12\x04\xaa'\t\x0f\n\x0e\n\x06\x04\x82\x01\x02\x03\x03\
    \x12\x04\xaa'\x12\x13\n;\n\x03\x04\x83\x01\x12\x06\xae'\0\xb2'\x01\x1a,\
    \x20request\x20for\x20different\x20endpoints\x20currently.\n\n\x0c\n\x04\
    \x04\x83\x01\x01\x12\x04\xae'\x08\x1e\n\r\n\x05\x04\x83\x01\x02\0\x12\
    \x04\xaf'\x02,\n\x0e\n\x06\x04\x83\x01\x02\0\x06\x12\x04\xaf'\x02\x1b\n\
    \x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xaf'\x1c'\n\x0e\n\x06\x04\x83\
    \x01\x02\0\x03\x12\x04\xaf'*+\n\r\n\x05\x04\x83\x01\x02\x01\x12\x04\xb0'\
    \x02\x16\n\x0e\n\x06\x04\x83\x01\x02\x01\x05\x12\x04\xb0'\x02\x08\n\x0e\
    \n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xb0'\t\x11\n\x0e\n\x06\x04\x83\
    \x01\x02\x01\x03\x12\x04\xb0'\x14\x15\n\r\n\x05\x04\x83\x01\x02\x02\x12\
    \x04\xb1'\x02\x18\n\x0e\n\x06\x04\x83\x01\x02\x02\x05\x12\x04\xb1'\x02\
    \x08\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\xb1'\t\x13\n\x0e\n\x06\
    \x04\x83\x01\x02\x02\x03\x12\x04\xb1'\x16\x17\n)\n\x03\x04\x84\x01\x12\
    \x06\xb5'\0\xd3'\x01\x1a\x1a\x20ListModelVersionsRequest\n\n\x0c\n\x04\
    \x04\x84\x01\x01\x12\x04\xb5'\x08\x20\n\r\n\x05\x04\x84\x01\x02\0\x12\
    \x04\xb6'\x02,\n\x0e\n\x06\x04\x84\x01\x02\0\x06\x12\x04\xb6'\x02\x1b\n\
    \x0e\n\x06\x04\x84\x01\x02\0\x01\x12\x04\xb6'\x1c'\n\x0e\n\x06\x04\x84\
    \x01\x02\0\x03\x12\x04\xb6'*+\n\r\n\x05\x04\x84\x01\x02\x01\x12\x04\xb7'\
    \x02\x16\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\x12\x04\xb7'\x02\x08\n\x0e\
    \n\x06\x04\x84\x01\x02\x01\x01\x12\x04\xb7'\t\x11\n\x0e\n\x06\x04\x84\
    \x01\x02\x01\x03\x12\x04\xb7'\x14\x15\n\x7f\n\x05\x04\x84\x01\x02\x02\
    \x12\x04\xba'\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20p\
    age\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resu\
    lts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x84\
    \x01\x02\x02\x05\x12\x04\xba'\x02\x08\n\x0e\n\x06\x04\x84\x01\x02\x02\
    \x01\x12\x04\xba'\t\r\n\x0e\n\x06\x04\x84\x01\x02\x02\x03\x12\x04\xba'\
    \x10\x11\nv\n\x05\x04\x84\x01\x02\x03\x12\x04\xbd'\x02\x16\x1ag\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128\
    .\n\n\x0e\n\x06\x04\x84\x01\x02\x03\x05\x12\x04\xbd'\x02\x08\n\x0e\n\x06\
    \x04\x84\x01\x02\x03\x01\x12\x04\xbd'\t\x11\n\x0e\n\x06\x04\x84\x01\x02\
    \x03\x03\x12\x04\xbd'\x14\x15\nq\n\x05\x04\x84\x01\x02\x04\x12\x04\xc1'\
    \x02\"\x1ab\x20Filtering\x20options:\n\x20To\x20list\x20only\x20the\x20m\
    odel\x20versions\x20that\x20have\x20these\x20concept\x20ids\x20present\
    \x20in\x20them.\n\n\x0e\n\x06\x04\x84\x01\x02\x04\x04\x12\x04\xc1'\x02\n\
    \n\x0e\n\x06\x04\x84\x01\x02\x04\x05\x12\x04\xc1'\x0b\x11\n\x0e\n\x06\
    \x04\x84\x01\x02\x04\x01\x12\x04\xc1'\x12\x1d\n\x0e\n\x06\x04\x84\x01\
    \x02\x04\x03\x12\x04\xc1'\x20!\nH\n\x05\x04\x84\x01\x02\x05\x12\x04\xc3'\
    \x02\x18\x1a9\x20To\x20list\x20only\x20the\x20model\x20versions\x20that\
    \x20have\x20been\x20trained.\n\n\x0e\n\x06\x04\x84\x01\x02\x05\x05\x12\
    \x04\xc3'\x02\x06\n\x0e\n\x06\x04\x84\x01\x02\x05\x01\x12\x04\xc3'\x07\
    \x13\n\x0e\n\x06\x04\x84\x01\x02\x05\x03\x12\x04\xc3'\x16\x17\np\n\x05\
    \x04\x84\x01\x02\x06\x12\x04\xc7'\x02\x1a\x1aa\x20Sorting\x20options:\n\
    \x20Whether\x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\
    \x20will\x20order\x20in\x20descending\x20order.\n\n\x0e\n\x06\x04\x84\
    \x01\x02\x06\x05\x12\x04\xc7'\x02\x06\n\x0e\n\x06\x04\x84\x01\x02\x06\
    \x01\x12\x04\xc7'\x07\x15\n\x0e\n\x06\x04\x84\x01\x02\x06\x03\x12\x04\
    \xc7'\x18\x19\n\x0f\n\x05\x04\x84\x01\x08\0\x12\x06\xc8'\x02\xd2'\x03\n\
    \x0e\n\x06\x04\x84\x01\x08\0\x01\x12\x04\xc8'\x08\x0f\n4\n\x05\x04\x84\
    \x01\x02\x07\x12\x04\xca'\x04!\x1a%\x20Whether\x20to\x20order\x20by\x20t\
    he\x20status\x20code\n\n\x0e\n\x06\x04\x84\x01\x02\x07\x05\x12\x04\xca'\
    \x04\x08\n\x0e\n\x06\x04\x84\x01\x02\x07\x01\x12\x04\xca'\t\x1c\n\x0e\n\
    \x06\x04\x84\x01\x02\x07\x03\x12\x04\xca'\x1f\x20\nB\n\x05\x04\x84\x01\
    \x02\x08\x12\x04\xcc'\x04\x20\x1a3\x20Whether\x20to\x20order\x20by\x20th\
    e\x20number\x20of\x20training\x20inputs\n\n\x0e\n\x06\x04\x84\x01\x02\
    \x08\x05\x12\x04\xcc'\x04\x08\n\x0e\n\x06\x04\x84\x01\x02\x08\x01\x12\
    \x04\xcc'\t\x1b\n\x0e\n\x06\x04\x84\x01\x02\x08\x03\x12\x04\xcc'\x1e\x1f\
    \n3\n\x05\x04\x84\x01\x02\t\x12\x04\xce'\x04\"\x1a$\x20Whether\x20to\x20\
    sort\x20by\x20the\x20description\n\n\x0e\n\x06\x04\x84\x01\x02\t\x05\x12\
    \x04\xce'\x04\x08\n\x0e\n\x06\x04\x84\x01\x02\t\x01\x12\x04\xce'\t\x1c\n\
    \x0e\n\x06\x04\x84\x01\x02\t\x03\x12\x04\xce'\x1f!\ny\n\x05\x04\x84\x01\
    \x02\n\x12\x04\xd1'\x04!\x1aj\x20Whether\x20to\x20order\x20by\x20the\x20\
    created_at\x20time\n\x20If\x20neither\x20sort\x20option\x20is\x20set\x20\
    to\x20true,\x20will\x20sort\x20by\x20created_at.\n\n\x0e\n\x06\x04\x84\
    \x01\x02\n\x05\x12\x04\xd1'\x04\x08\n\x0e\n\x06\x04\x84\x01\x02\n\x01\
    \x12\x04\xd1'\t\x1b\n\x0e\n\x06\x04\x84\x01\x02\n\x03\x12\x04\xd1'\x1e\
    \x20\n*\n\x03\x04\x85\x01\x12\x06\xd6'\0\xda'\x01\x1a\x1b\x20DeleteModel\
    VersionRequest\n\n\x0c\n\x04\x04\x85\x01\x01\x12\x04\xd6'\x08!\n\r\n\x05\
    \x04\x85\x01\x02\0\x12\x04\xd7'\x02,\n\x0e\n\x06\x04\x85\x01\x02\0\x06\
    \x12\x04\xd7'\x02\x1b\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xd7'\x1c\
    '\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\xd7'*+\n\r\n\x05\x04\x85\x01\
    \x02\x01\x12\x04\xd8'\x02\x16\n\x0e\n\x06\x04\x85\x01\x02\x01\x05\x12\
    \x04\xd8'\x02\x08\n\x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\x04\xd8'\t\x11\
    \n\x0e\n\x06\x04\x85\x01\x02\x01\x03\x12\x04\xd8'\x14\x15\n\r\n\x05\x04\
    \x85\x01\x02\x02\x12\x04\xd9'\x02\x18\n\x0e\n\x06\x04\x85\x01\x02\x02\
    \x05\x12\x04\xd9'\x02\x08\n\x0e\n\x06\x04\x85\x01\x02\x02\x01\x12\x04\
    \xd9'\t\x13\n\x0e\n\x06\x04\x85\x01\x02\x02\x03\x12\x04\xd9'\x16\x17\n+\
    \n\x03\x04\x86\x01\x12\x06\xdd'\0\xe0'\x01\x1a\x1c\x20SingleModelVersion\
    Response\n\n\x0c\n\x04\x04\x86\x01\x01\x12\x04\xdd'\x08\"\n\r\n\x05\x04\
    \x86\x01\x02\0\x12\x04\xde'\x02(\n\x0e\n\x06\x04\x86\x01\x02\0\x06\x12\
    \x04\xde'\x02\x1c\n\x0e\n\x06\x04\x86\x01\x02\0\x01\x12\x04\xde'\x1d#\n\
    \x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\xde'&'\n\r\n\x05\x04\x86\x01\
    \x02\x01\x12\x04\xdf'\x02!\n\x0e\n\x06\x04\x86\x01\x02\x01\x06\x12\x04\
    \xdf'\x02\x0e\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\xdf'\x0f\x1c\n\
    \x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\x04\xdf'\x1f\x20\n*\n\x03\x04\x87\
    \x01\x12\x06\xe3'\0\xe6'\x01\x1a\x1b\x20MultiModelVersionResponse\n\n\
    \x0c\n\x04\x04\x87\x01\x01\x12\x04\xe3'\x08!\n\r\n\x05\x04\x87\x01\x02\0\
    \x12\x04\xe4'\x02(\n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\x04\xe4'\x02\
    \x1c\n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\xe4'\x1d#\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x03\x12\x04\xe4'&'\n\r\n\x05\x04\x87\x01\x02\x01\x12\x04\
    \xe5'\x02Z\n\x0e\n\x06\x04\x87\x01\x02\x01\x04\x12\x04\xe5'\x02\n\n\x0e\
    \n\x06\x04\x87\x01\x02\x01\x06\x12\x04\xe5'\x0b\x17\n\x0e\n\x06\x04\x87\
    \x01\x02\x01\x01\x12\x04\xe5'\x18&\n\x0e\n\x06\x04\x87\x01\x02\x01\x03\
    \x12\x04\xe5')*\n\x0e\n\x06\x04\x87\x01\x02\x01\x08\x12\x04\xe5'+Y\n\x11\
    \n\t\x04\x87\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xe5',X\n4\n\x03\x04\x88\
    \x01\x12\x06\xe9'\0\xf6'\x01\x1a%\x20Create\x20(train)\x20a\x20new\x20mo\
    del\x20version.\n\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xe9'\x08\x20\n\x0c\
    \n\x04\x04\x88\x01\t\x12\x04\xea'\x02\x19\n\r\n\x05\x04\x88\x01\t\0\x12\
    \x04\xea'\x0b\x0c\n\x0e\n\x06\x04\x88\x01\t\0\x01\x12\x04\xea'\x0b\x0c\n\
    \x0e\n\x06\x04\x88\x01\t\0\x02\x12\x04\xea'\x0b\x0c\n\r\n\x05\x04\x88\
    \x01\t\x01\x12\x04\xea'\x0e\x0f\n\x0e\n\x06\x04\x88\x01\t\x01\x01\x12\
    \x04\xea'\x0e\x0f\n\x0e\n\x06\x04\x88\x01\t\x01\x02\x12\x04\xea'\x0e\x0f\
    \n\r\n\x05\x04\x88\x01\t\x02\x12\x04\xea'\x11\x12\n\x0e\n\x06\x04\x88\
    \x01\t\x02\x01\x12\x04\xea'\x11\x12\n\x0e\n\x06\x04\x88\x01\t\x02\x02\
    \x12\x04\xea'\x11\x12\n\r\n\x05\x04\x88\x01\t\x03\x12\x04\xea'\x14\x15\n\
    \x0e\n\x06\x04\x88\x01\t\x03\x01\x12\x04\xea'\x14\x15\n\x0e\n\x06\x04\
    \x88\x01\t\x03\x02\x12\x04\xea'\x14\x15\n\r\n\x05\x04\x88\x01\t\x04\x12\
    \x04\xea'\x17\x18\n\x0e\n\x06\x04\x88\x01\t\x04\x01\x12\x04\xea'\x17\x18\
    \n\x0e\n\x06\x04\x88\x01\t\x04\x02\x12\x04\xea'\x17\x18\n\r\n\x05\x04\
    \x88\x01\x02\0\x12\x04\xeb'\x02,\n\x0e\n\x06\x04\x88\x01\x02\0\x06\x12\
    \x04\xeb'\x02\x1b\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xeb'\x1c'\n\
    \x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xeb'*+\n\r\n\x05\x04\x88\x01\
    \x02\x01\x12\x04\xec'\x02\x16\n\x0e\n\x06\x04\x88\x01\x02\x01\x05\x12\
    \x04\xec'\x02\x08\n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\xec'\t\x11\
    \n\x0e\n\x06\x04\x88\x01\x02\x01\x03\x12\x04\xec'\x14\x15\n\r\n\x05\x04\
    \x88\x01\x02\x02\x12\x04\xee'\x02+\n\x0e\n\x06\x04\x88\x01\x02\x02\x04\
    \x12\x04\xee'\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x02\x06\x12\x04\xee'\x0b\
    \x17\n\x0e\n\x06\x04\x88\x01\x02\x02\x01\x12\x04\xee'\x18&\n\x0e\n\x06\
    \x04\x88\x01\x02\x02\x03\x12\x04\xee')*\n4\n\x05\x04\x88\x01\x02\x03\x12\
    \x04\xf1'\x02\x19\x1a%\x20Description\x20about\x20this\x20training\x20ru\
    n\n\n\x0e\n\x06\x04\x88\x01\x02\x03\x05\x12\x04\xf1'\x02\x08\n\x0e\n\x06\
    \x04\x88\x01\x02\x03\x01\x12\x04\xf1'\t\x14\n\x0e\n\x06\x04\x88\x01\x02\
    \x03\x03\x12\x04\xf1'\x17\x18\n\xa2\x01\n\x05\x04\x88\x01\x02\x04\x12\
    \x04\xf5'\x02\x1a\x1a\x92\x01\x20When\x20evaluate_after_training\x20set\
    \x20to\x20true,\x20we\x20will\x20do\x20evaluation\x20immediately\x20afte\
    r\x20training\x20finishes.\n\x20We\x20will\x20merge\x20this\x20with\x20d\
    efault_eval_info.\n\n\x0e\n\x06\x04\x88\x01\x02\x04\x06\x12\x04\xf5'\x02\
    \n\n\x0e\n\x06\x04\x88\x01\x02\x04\x01\x12\x04\xf5'\x0b\x14\n\x0e\n\x06\
    \x04\x88\x01\x02\x04\x03\x12\x04\xf5'\x17\x19\n\r\n\x03\x04\x89\x01\x12\
    \x06\xf8'\0\xfc'\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\xf8'\x08,\n\r\n\
    \x05\x04\x89\x01\x02\0\x12\x04\xf9'\x02,\n\x0e\n\x06\x04\x89\x01\x02\0\
    \x06\x12\x04\xf9'\x02\x1b\n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\xf9'\
    \x1c'\n\x0e\n\x06\x04\x89\x01\x02\0\x03\x12\x04\xf9'*+\n\r\n\x05\x04\x89\
    \x01\x02\x01\x12\x04\xfa'\x02\x19\n\x0e\n\x06\x04\x89\x01\x02\x01\x05\
    \x12\x04\xfa'\x02\x08\n\x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\xfa'\t\
    \x14\n\x0e\n\x06\x04\x89\x01\x02\x01\x03\x12\x04\xfa'\x17\x18\n\r\n\x05\
    \x04\x89\x01\x02\x02\x12\x04\xfb'\x02<\n\x0e\n\x06\x04\x89\x01\x02\x02\
    \x04\x12\x04\xfb'\x02\n\n\x0e\n\x06\x04\x89\x01\x02\x02\x06\x12\x04\xfb'\
    \x0b*\n\x0e\n\x06\x04\x89\x01\x02\x02\x01\x12\x04\xfb'+7\n\x0e\n\x06\x04\
    \x89\x01\x02\x02\x03\x12\x04\xfb':;\n\r\n\x03\x04\x8a\x01\x12\x06\x80(\0\
    \x84(\x01\n\x0c\n\x04\x04\x8a\x01\x01\x12\x04\x80(\x08*\n\r\n\x05\x04\
    \x8a\x01\x02\0\x12\x04\x81(\x02,\n\x0e\n\x06\x04\x8a\x01\x02\0\x06\x12\
    \x04\x81(\x02\x1b\n\x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\x81(\x1c'\n\
    \x0e\n\x06\x04\x8a\x01\x02\0\x03\x12\x04\x81(*+\n\r\n\x05\x04\x8a\x01\
    \x02\x01\x12\x04\x82(\x02\x19\n\x0e\n\x06\x04\x8a\x01\x02\x01\x05\x12\
    \x04\x82(\x02\x08\n\x0e\n\x06\x04\x8a\x01\x02\x01\x01\x12\x04\x82(\t\x14\
    \n\x0e\n\x06\x04\x8a\x01\x02\x01\x03\x12\x04\x82(\x17\x18\n\r\n\x05\x04\
    \x8a\x01\x02\x02\x12\x04\x83(\x02:\n\x0e\n\x06\x04\x8a\x01\x02\x02\x04\
    \x12\x04\x83(\x02\n\n\x0e\n\x06\x04\x8a\x01\x02\x02\x06\x12\x04\x83(\x0b\
    (\n\x0e\n\x06\x04\x8a\x01\x02\x02\x01\x12\x04\x83()5\n\x0e\n\x06\x04\x8a\
    \x01\x02\x02\x03\x12\x04\x83(89\n\r\n\x03\x04\x8b\x01\x12\x06\x86(\0\x88\
    (\x01\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\x86(\x08%\n\r\n\x05\x04\x8b\
    \x01\x02\0\x12\x04\x87(\x02\x18\n\x0e\n\x06\x04\x8b\x01\x02\0\x05\x12\
    \x04\x87(\x02\x08\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\x87(\t\x13\n\
    \x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\x87(\x16\x17\n\r\n\x03\x04\x8c\
    \x01\x12\x06\x8a(\0\x8c(\x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\x8a(\
    \x08'\n\r\n\x05\x04\x8c\x01\x02\0\x12\x04\x8b(\x02\x18\n\x0e\n\x06\x04\
    \x8c\x01\x02\0\x05\x12\x04\x8b(\x02\x08\n\x0e\n\x06\x04\x8c\x01\x02\0\
    \x01\x12\x04\x8b(\t\x13\n\x0e\n\x06\x04\x8c\x01\x02\0\x03\x12\x04\x8b(\
    \x16\x17\n+\n\x03\x04\x8d\x01\x12\x06\x8f(\0\x91(\x01\x1a\x1c\x20ModelVe\
    rsionPublishRequest\n\n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\x8f(\x08\"\n\r\
    \n\x05\x04\x8d\x01\x02\0\x12\x04\x90(\x02\x18\n\x0e\n\x06\x04\x8d\x01\
    \x02\0\x05\x12\x04\x90(\x02\x08\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\
    \x04\x90(\t\x13\n\x0e\n\x06\x04\x8d\x01\x02\0\x03\x12\x04\x90(\x16\x17\n\
    0\n\x03\x04\x8e\x01\x12\x06\x94(\0\x98(\x01\x1a!\x20PostModelVersionsPub\
    lishRequest\n\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\x94(\x08'\n\r\n\x05\
    \x04\x8e\x01\x02\0\x12\x04\x95(\x02,\n\x0e\n\x06\x04\x8e\x01\x02\0\x06\
    \x12\x04\x95(\x02\x1b\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\x95(\x1c\
    '\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\x95(*+\n\r\n\x05\x04\x8e\x01\
    \x02\x01\x12\x04\x96(\x02\x16\n\x0e\n\x06\x04\x8e\x01\x02\x01\x05\x12\
    \x04\x96(\x02\x08\n\x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\x96(\t\x11\
    \n\x0e\n\x06\x04\x8e\x01\x02\x01\x03\x12\x04\x96(\x14\x15\n\r\n\x05\x04\
    \x8e\x01\x02\x02\x12\x04\x97(\x027\n\x0e\n\x06\x04\x8e\x01\x02\x02\x04\
    \x12\x04\x97(\x02\n\n\x0e\n\x06\x04\x8e\x01\x02\x02\x06\x12\x04\x97(\x0b\
    %\n\x0e\n\x06\x04\x8e\x01\x02\x02\x01\x12\x04\x97(&2\n\x0e\n\x06\x04\x8e\
    \x01\x02\x02\x03\x12\x04\x97(56\n-\n\x03\x04\x8f\x01\x12\x06\x9b(\0\x9d(\
    \x01\x1a\x1e\x20ModelVersionUnpublishRequest\n\n\x0c\n\x04\x04\x8f\x01\
    \x01\x12\x04\x9b(\x08$\n\r\n\x05\x04\x8f\x01\x02\0\x12\x04\x9c(\x02\x18\
    \n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\x04\x9c(\x02\x08\n\x0e\n\x06\x04\
    \x8f\x01\x02\0\x01\x12\x04\x9c(\t\x13\n\x0e\n\x06\x04\x8f\x01\x02\0\x03\
    \x12\x04\x9c(\x16\x17\n2\n\x03\x04\x90\x01\x12\x06\xa0(\0\xa4(\x01\x1a#\
    \x20PostModelVersionsUnPublishRequest\n\n\x0c\n\x04\x04\x90\x01\x01\x12\
    \x04\xa0(\x08)\n\r\n\x05\x04\x90\x01\x02\0\x12\x04\xa1(\x02,\n\x0e\n\x06\
    \x04\x90\x01\x02\0\x06\x12\x04\xa1(\x02\x1b\n\x0e\n\x06\x04\x90\x01\x02\
    \0\x01\x12\x04\xa1(\x1c'\n\x0e\n\x06\x04\x90\x01\x02\0\x03\x12\x04\xa1(*\
    +\n\r\n\x05\x04\x90\x01\x02\x01\x12\x04\xa2(\x02\x16\n\x0e\n\x06\x04\x90\
    \x01\x02\x01\x05\x12\x04\xa2(\x02\x08\n\x0e\n\x06\x04\x90\x01\x02\x01\
    \x01\x12\x04\xa2(\t\x11\n\x0e\n\x06\x04\x90\x01\x02\x01\x03\x12\x04\xa2(\
    \x14\x15\n\r\n\x05\x04\x90\x01\x02\x02\x12\x04\xa3(\x029\n\x0e\n\x06\x04\
    \x90\x01\x02\x02\x04\x12\x04\xa3(\x02\n\n\x0e\n\x06\x04\x90\x01\x02\x02\
    \x06\x12\x04\xa3(\x0b'\n\x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\xa3((\
    4\n\x0e\n\x06\x04\x90\x01\x02\x02\x03\x12\x04\xa3(78\n+\n\x03\x04\x91\
    \x01\x12\x06\xa7(\0\xac(\x01\x1a\x1c\x20Evaluate\x20this\x20model\x20ves\
    ion\n\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xa7(\x08\x1e\n\r\n\x05\x04\x91\
    \x01\x02\0\x12\x04\xa8(\x02,\n\x0e\n\x06\x04\x91\x01\x02\0\x06\x12\x04\
    \xa8(\x02\x1b\n\x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xa8(\x1c'\n\x0e\
    \n\x06\x04\x91\x01\x02\0\x03\x12\x04\xa8(*+\n\xd0\x01\n\x05\x04\x91\x01\
    \x02\x01\x12\x04\xab(\x02(\x1a\xc0\x01\x20eval_info,\x20id,\x20model,\
    \x20and\x20ground_truth_dataset\x20will\x20be\x20used\x20when\x20creatin\
    g\x20the\x20evaluation\n\x20If\x20no\x20dataset\x20is\x20provided,\x20al\
    l\x20app\x20data\x20that\x20is\x20annotated\x20with\x20concepts\x20from\
    \x20the\x20model\x20will\x20be\x20used.\n\n\x0e\n\x06\x04\x91\x01\x02\
    \x01\x04\x12\x04\xab(\x02\n\n\x0e\n\x06\x04\x91\x01\x02\x01\x06\x12\x04\
    \xab(\x0b\x16\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\xab(\x17#\n\
    \x0e\n\x06\x04\x91\x01\x02\x01\x03\x12\x04\xab(&'\n\r\n\x03\x04\x92\x01\
    \x12\x06\xae(\0\xd3(\x01\n\x0c\n\x04\x04\x92\x01\x01\x12\x04\xae(\x08\
    \x1e\n\r\n\x05\x04\x92\x01\x02\0\x12\x04\xaf(\x02,\n\x0e\n\x06\x04\x92\
    \x01\x02\0\x06\x12\x04\xaf(\x02\x1b\n\x0e\n\x06\x04\x92\x01\x02\0\x01\
    \x12\x04\xaf(\x1c'\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\x04\xaf(*+\n\
    \x7f\n\x05\x04\x92\x01\x02\x01\x12\x04\xb2(\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\x92\x01\x02\x01\x05\x12\x04\xb2(\x02\x08\
    \n\x0e\n\x06\x04\x92\x01\x02\x01\x01\x12\x04\xb2(\t\r\n\x0e\n\x06\x04\
    \x92\x01\x02\x01\x03\x12\x04\xb2(\x10\x11\nv\n\x05\x04\x92\x01\x02\x02\
    \x12\x04\xb5(\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x92\x01\x02\x02\
    \x05\x12\x04\xb5(\x02\x08\n\x0e\n\x06\x04\x92\x01\x02\x02\x01\x12\x04\
    \xb5(\t\x11\n\x0e\n\x06\x04\x92\x01\x02\x02\x03\x12\x04\xb5(\x14\x15\nV\
    \n\x05\x04\x92\x01\x02\x03\x12\x04\xb7(\x02\x1a\x1aG\x20If\x20true,\x20s\
    ort\x20in\x20ascending\x20order,\x20otherwise\x20sort\x20in\x20descendin\
    g\x20order.\n\n\x0e\n\x06\x04\x92\x01\x02\x03\x05\x12\x04\xb7(\x02\x06\n\
    \x0e\n\x06\x04\x92\x01\x02\x03\x01\x12\x04\xb7(\x07\x15\n\x0e\n\x06\x04\
    \x92\x01\x02\x03\x03\x12\x04\xb7(\x18\x19\n\x0f\n\x05\x04\x92\x01\x08\0\
    \x12\x06\xb8(\x02\xca(\x03\n\x0e\n\x06\x04\x92\x01\x08\0\x01\x12\x04\xb8\
    (\x08\x0f\n3\n\x05\x04\x92\x01\x02\x04\x12\x04\xba(\x04\x1c\x1a$\x20Whet\
    her\x20to\x20order\x20by\x20application\x20id\n\n\x0e\n\x06\x04\x92\x01\
    \x02\x04\x05\x12\x04\xba(\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\x04\x01\
    \x12\x04\xba(\t\x17\n\x0e\n\x06\x04\x92\x01\x02\x04\x03\x12\x04\xba(\x1a\
    \x1b\nJ\n\x05\x04\x92\x01\x02\x05\x12\x04\xbc(\x04\x1d\x1a;\x20Whether\
    \x20to\x20order\x20by\x20eval\x20metric\x20summary.macro_avg_roc_auc\n\n\
    \x0e\n\x06\x04\x92\x01\x02\x05\x05\x12\x04\xbc(\x04\x08\n\x0e\n\x06\x04\
    \x92\x01\x02\x05\x01\x12\x04\xbc(\t\x18\n\x0e\n\x06\x04\x92\x01\x02\x05\
    \x03\x12\x04\xbc(\x1b\x1c\n;\n\x05\x04\x92\x01\x02\x06\x12\x04\xbe(\x04\
    \x18\x1a,\x20Whether\x20to\x20order\x20by\x20eval\x20metric\x20summary.f\
    1\n\n\x0e\n\x06\x04\x92\x01\x02\x06\x05\x12\x04\xbe(\x04\x08\n\x0e\n\x06\
    \x04\x92\x01\x02\x06\x01\x12\x04\xbe(\t\x13\n\x0e\n\x06\x04\x92\x01\x02\
    \x06\x03\x12\x04\xbe(\x16\x17\n@\n\x05\x04\x92\x01\x02\x07\x12\x04\xc0(\
    \x04\x20\x1a1\x20Whether\x20to\x20order\x20by\x20when\x20the\x20metric\
    \x20was\x20created\n\n\x0e\n\x06\x04\x92\x01\x02\x07\x05\x12\x04\xc0(\
    \x04\x08\n\x0e\n\x06\x04\x92\x01\x02\x07\x01\x12\x04\xc0(\t\x1b\n\x0e\n\
    \x06\x04\x92\x01\x02\x07\x03\x12\x04\xc0(\x1e\x1f\nR\n\x05\x04\x92\x01\
    \x02\x08\x12\x04\xc2(\x04(\x1aC\x20Whether\x20to\x20order\x20by\x20eval\
    \x20metric\x20summary.mean_avg_precision_iou_50\n\n\x0e\n\x06\x04\x92\
    \x01\x02\x08\x05\x12\x04\xc2(\x04\x08\n\x0e\n\x06\x04\x92\x01\x02\x08\
    \x01\x12\x04\xc2(\t#\n\x0e\n\x06\x04\x92\x01\x02\x08\x03\x12\x04\xc2(&'\
    \nL\n\x05\x04\x92\x01\x02\t\x12\x04\xc4(\x04\x20\x1a=\x20Whether\x20to\
    \x20order\x20by\x20eval\x20metric\x20summary.macro_avg_precision\n\n\x0e\
    \n\x06\x04\x92\x01\x02\t\x05\x12\x04\xc4(\x04\x08\n\x0e\n\x06\x04\x92\
    \x01\x02\t\x01\x12\x04\xc4(\t\x1a\n\x0e\n\x06\x04\x92\x01\x02\t\x03\x12\
    \x04\xc4(\x1d\x1f\nI\n\x05\x04\x92\x01\x02\n\x12\x04\xc6(\x04\x1d\x1a:\
    \x20Whether\x20to\x20order\x20by\x20eval\x20metric\x20summary.macro_avg_\
    recall\n\n\x0e\n\x06\x04\x92\x01\x02\n\x05\x12\x04\xc6(\x04\x08\n\x0e\n\
    \x06\x04\x92\x01\x02\n\x01\x12\x04\xc6(\t\x17\n\x0e\n\x06\x04\x92\x01\
    \x02\n\x03\x12\x04\xc6(\x1a\x1c\n\r\n\x05\x04\x92\x01\x02\x0b\x12\x04\
    \xc7(\x04\x1f\n\x0e\n\x06\x04\x92\x01\x02\x0b\x05\x12\x04\xc7(\x04\x08\n\
    \x0e\n\x06\x04\x92\x01\x02\x0b\x01\x12\x04\xc7(\t\x19\n\x0e\n\x06\x04\
    \x92\x01\x02\x0b\x03\x12\x04\xc7(\x1c\x1e\n\r\n\x05\x04\x92\x01\x02\x0c\
    \x12\x04\xc8(\x04&\n\x0e\n\x06\x04\x92\x01\x02\x0c\x05\x12\x04\xc8(\x04\
    \x08\n\x0e\n\x06\x04\x92\x01\x02\x0c\x01\x12\x04\xc8(\t\x20\n\x0e\n\x06\
    \x04\x92\x01\x02\x0c\x03\x12\x04\xc8(#%\n\r\n\x05\x04\x92\x01\x02\r\x12\
    \x04\xc9(\x04'\n\x0e\n\x06\x04\x92\x01\x02\r\x05\x12\x04\xc9(\x04\x08\n\
    \x0e\n\x06\x04\x92\x01\x02\r\x01\x12\x04\xc9(\t!\n\x0e\n\x06\x04\x92\x01\
    \x02\r\x03\x12\x04\xc9($&\n(\n\x05\x04\x92\x01\x02\x0e\x12\x04\xcc(\x02\
    \x1c\x1a\x19\x20Filter\x20on\x20model\x20type\x20id\n\n\x0e\n\x06\x04\
    \x92\x01\x02\x0e\x05\x12\x04\xcc(\x02\x08\n\x0e\n\x06\x04\x92\x01\x02\
    \x0e\x01\x12\x04\xcc(\t\x16\n\x0e\n\x06\x04\x92\x01\x02\x0e\x03\x12\x04\
    \xcc(\x19\x1b\n\\\n\x05\x04\x92\x01\x02\x0f\x12\x04\xce(\x02(\x1aM\x20Fi\
    lter\x20on\x20dataset\x20ID\x20of\x20the\x20dataset\x20version\x20specif\
    ied\x20in\x20the\x20metric\x20version\n\n\x0e\n\x06\x04\x92\x01\x02\x0f\
    \x04\x12\x04\xce(\x02\n\n\x0e\n\x06\x04\x92\x01\x02\x0f\x05\x12\x04\xce(\
    \x0b\x11\n\x0e\n\x06\x04\x92\x01\x02\x0f\x01\x12\x04\xce(\x12\"\n\x0e\n\
    \x06\x04\x92\x01\x02\x0f\x03\x12\x04\xce(%'\n[\n\x05\x04\x92\x01\x02\x10\
    \x12\x04\xd0(\x02)\x1aL\x20Filter\x20on\x20dataset\x20ID\x20of\x20the\
    \x20dataset\x20version\x20specified\x20by\x20the\x20model\x20version\n\n\
    \x0e\n\x06\x04\x92\x01\x02\x10\x04\x12\x04\xd0(\x02\n\n\x0e\n\x06\x04\
    \x92\x01\x02\x10\x05\x12\x04\xd0(\x0b\x11\n\x0e\n\x06\x04\x92\x01\x02\
    \x10\x01\x12\x04\xd0(\x12#\n\x0e\n\x06\x04\x92\x01\x02\x10\x03\x12\x04\
    \xd0(&(\nT\n\x05\x04\x92\x01\x02\x11\x12\x04\xd2(\x02#\x1aE\x20Filter\
    \x20on\x20concept\x20IDs\x20specified\x20in\x20the\x20modele\x20version'\
    s\x20output_info\n\n\x0e\n\x06\x04\x92\x01\x02\x11\x04\x12\x04\xd2(\x02\
    \n\n\x0e\n\x06\x04\x92\x01\x02\x11\x05\x12\x04\xd2(\x0b\x11\n\x0e\n\x06\
    \x04\x92\x01\x02\x11\x01\x12\x04\xd2(\x12\x1d\n\x0e\n\x06\x04\x92\x01\
    \x02\x11\x03\x12\x04\xd2(\x20\"\n\r\n\x03\x04\x93\x01\x12\x06\xd5(\0\xdb\
    (\x01\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\xd5(\x08\x1c\n\r\n\x05\x04\x93\
    \x01\x02\0\x12\x04\xd6(\x02,\n\x0e\n\x06\x04\x93\x01\x02\0\x06\x12\x04\
    \xd6(\x02\x1b\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xd6(\x1c'\n\x0e\
    \n\x06\x04\x93\x01\x02\0\x03\x12\x04\xd6(*+\n\r\n\x05\x04\x93\x01\x02\
    \x01\x12\x04\xd7(\x02\x1b\n\x0e\n\x06\x04\x93\x01\x02\x01\x05\x12\x04\
    \xd7(\x02\x08\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\xd7(\t\x16\n\
    \x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\xd7(\x19\x1a\no\n\x05\x04\x93\
    \x01\x02\x02\x12\x04\xda(\x02\x19\x1a`\x20Any\x20of\x20the\x20fields\x20\
    you\x20wish\x20to\x20return\x20in\x20the\x20metrics\n\x20By\x20default,\
    \x20only\x20the\x20summary\x20is\x20returned.\n\n\x0e\n\x06\x04\x93\x01\
    \x02\x02\x06\x12\x04\xda(\x02\r\n\x0e\n\x06\x04\x93\x01\x02\x02\x01\x12\
    \x04\xda(\x0e\x14\n\x0e\n\x06\x04\x93\x01\x02\x02\x03\x12\x04\xda(\x17\
    \x18\n+\n\x03\x04\x94\x01\x12\x06\xe0(\0\xe6(\x01\x1a\x1c\x20Evaluate\
    \x20this\x20model\x20vesion\n\n\x0c\n\x04\x04\x94\x01\x01\x12\x04\xe0(\
    \x08*\n\r\n\x05\x04\x94\x01\x02\0\x12\x04\xe1(\x02,\n\x0e\n\x06\x04\x94\
    \x01\x02\0\x06\x12\x04\xe1(\x02\x1b\n\x0e\n\x06\x04\x94\x01\x02\0\x01\
    \x12\x04\xe1(\x1c'\n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\xe1(*+\n\r\
    \n\x05\x04\x94\x01\x02\x01\x12\x04\xe2(\x02\x16\n\x0e\n\x06\x04\x94\x01\
    \x02\x01\x05\x12\x04\xe2(\x02\x08\n\x0e\n\x06\x04\x94\x01\x02\x01\x01\
    \x12\x04\xe2(\t\x11\n\x0e\n\x06\x04\x94\x01\x02\x01\x03\x12\x04\xe2(\x14\
    \x15\n\r\n\x05\x04\x94\x01\x02\x02\x12\x04\xe3(\x02\x1e\n\x0e\n\x06\x04\
    \x94\x01\x02\x02\x05\x12\x04\xe3(\x02\x08\n\x0e\n\x06\x04\x94\x01\x02\
    \x02\x01\x12\x04\xe3(\t\x19\n\x0e\n\x06\x04\x94\x01\x02\x02\x03\x12\x04\
    \xe3(\x1c\x1d\nJ\n\x05\x04\x94\x01\x02\x03\x12\x04\xe5(\x02(\x1a;\x20Eva\
    lInfo\x20and\x20ID\x20will\x20be\x20used\x20when\x20creating\x20the\x20e\
    valuation\n\n\x0e\n\x06\x04\x94\x01\x02\x03\x04\x12\x04\xe5(\x02\n\n\x0e\
    \n\x06\x04\x94\x01\x02\x03\x06\x12\x04\xe5(\x0b\x16\n\x0e\n\x06\x04\x94\
    \x01\x02\x03\x01\x12\x04\xe5(\x17#\n\x0e\n\x06\x04\x94\x01\x02\x03\x03\
    \x12\x04\xe5(&'\n\r\n\x03\x04\x95\x01\x12\x06\xe8(\0\xf4(\x01\n\x0c\n\
    \x04\x04\x95\x01\x01\x12\x04\xe8(\x08*\n\r\n\x05\x04\x95\x01\x02\0\x12\
    \x04\xe9(\x02,\n\x0e\n\x06\x04\x95\x01\x02\0\x06\x12\x04\xe9(\x02\x1b\n\
    \x0e\n\x06\x04\x95\x01\x02\0\x01\x12\x04\xe9(\x1c'\n\x0e\n\x06\x04\x95\
    \x01\x02\0\x03\x12\x04\xe9(*+\n\r\n\x05\x04\x95\x01\x02\x01\x12\x04\xea(\
    \x02\x16\n\x0e\n\x06\x04\x95\x01\x02\x01\x05\x12\x04\xea(\x02\x08\n\x0e\
    \n\x06\x04\x95\x01\x02\x01\x01\x12\x04\xea(\t\x11\n\x0e\n\x06\x04\x95\
    \x01\x02\x01\x03\x12\x04\xea(\x14\x15\n\r\n\x05\x04\x95\x01\x02\x02\x12\
    \x04\xeb(\x02\x1e\n\x0e\n\x06\x04\x95\x01\x02\x02\x05\x12\x04\xeb(\x02\
    \x08\n\x0e\n\x06\x04\x95\x01\x02\x02\x01\x12\x04\xeb(\t\x19\n\x0e\n\x06\
    \x04\x95\x01\x02\x02\x03\x12\x04\xeb(\x1c\x1d\n\x7f\n\x05\x04\x95\x01\
    \x02\x03\x12\x04\xef(\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20\
    The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\x95\x01\x02\x03\x05\x12\x04\xef(\x02\x08\n\x0e\n\x06\x04\x95\x01\
    \x02\x03\x01\x12\x04\xef(\t\r\n\x0e\n\x06\x04\x95\x01\x02\x03\x03\x12\
    \x04\xef(\x10\x11\nv\n\x05\x04\x95\x01\x02\x04\x12\x04\xf3(\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\x95\x01\x02\x04\x05\x12\x04\xf3(\x02\x08\n\
    \x0e\n\x06\x04\x95\x01\x02\x04\x01\x12\x04\xf3(\t\x11\n\x0e\n\x06\x04\
    \x95\x01\x02\x04\x03\x12\x04\xf3(\x14\x15\n\r\n\x03\x04\x96\x01\x12\x06\
    \xf6(\0\xff(\x01\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xf6(\x08(\n\r\n\x05\
    \x04\x96\x01\x02\0\x12\x04\xf7(\x02,\n\x0e\n\x06\x04\x96\x01\x02\0\x06\
    \x12\x04\xf7(\x02\x1b\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\xf7(\x1c\
    '\n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\x04\xf7(*+\n\r\n\x05\x04\x96\x01\
    \x02\x01\x12\x04\xf8(\x02\x16\n\x0e\n\x06\x04\x96\x01\x02\x01\x05\x12\
    \x04\xf8(\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x01\x01\x12\x04\xf8(\t\x11\
    \n\x0e\n\x06\x04\x96\x01\x02\x01\x03\x12\x04\xf8(\x14\x15\n\r\n\x05\x04\
    \x96\x01\x02\x02\x12\x04\xf9(\x02\x1e\n\x0e\n\x06\x04\x96\x01\x02\x02\
    \x05\x12\x04\xf9(\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x02\x01\x12\x04\
    \xf9(\t\x19\n\x0e\n\x06\x04\x96\x01\x02\x02\x03\x12\x04\xf9(\x1c\x1d\n\r\
    \n\x05\x04\x96\x01\x02\x03\x12\x04\xfa(\x02\x1b\n\x0e\n\x06\x04\x96\x01\
    \x02\x03\x05\x12\x04\xfa(\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x03\x01\
    \x12\x04\xfa(\t\x16\n\x0e\n\x06\x04\x96\x01\x02\x03\x03\x12\x04\xfa(\x19\
    \x1a\nx\n\x05\x04\x96\x01\x02\x04\x12\x04\xfe(\x02\x19\x1ai\x20Any\x20of\
    \x20the\x20fields\x20you\x20wish\x20to\x20return\x20from\x20multiclass_m\
    etrics\n\x20By\x20default,\x20only\x20the\x20summary\x20is\x20returned.\
    \n\n\x0e\n\x06\x04\x96\x01\x02\x04\x06\x12\x04\xfe(\x02\r\n\x0e\n\x06\
    \x04\x96\x01\x02\x04\x01\x12\x04\xfe(\x0e\x14\n\x0e\n\x06\x04\x96\x01\
    \x02\x04\x03\x12\x04\xfe(\x17\x18\n\r\n\x03\x04\x97\x01\x12\x06\x81)\0\
    \x84)\x01\n\x0c\n\x04\x04\x97\x01\x01\x12\x04\x81)\x08!\n\r\n\x05\x04\
    \x97\x01\x02\0\x12\x04\x82)\x02(\n\x0e\n\x06\x04\x97\x01\x02\0\x06\x12\
    \x04\x82)\x02\x1c\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\x82)\x1d#\n\
    \x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\x82)&'\n\r\n\x05\x04\x97\x01\
    \x02\x01\x12\x04\x83)\x02\x1f\n\x0e\n\x06\x04\x97\x01\x02\x01\x06\x12\
    \x04\x83)\x02\r\n\x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\x04\x83)\x0e\x1a\
    \n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\x04\x83)\x1d\x1e\n\r\n\x03\x04\
    \x98\x01\x12\x06\x86)\0\x89)\x01\n\x0c\n\x04\x04\x98\x01\x01\x12\x04\x86\
    )\x08\x20\n\r\n\x05\x04\x98\x01\x02\0\x12\x04\x87)\x02(\n\x0e\n\x06\x04\
    \x98\x01\x02\0\x06\x12\x04\x87)\x02\x1c\n\x0e\n\x06\x04\x98\x01\x02\0\
    \x01\x12\x04\x87)\x1d#\n\x0e\n\x06\x04\x98\x01\x02\0\x03\x12\x04\x87)&'\
    \n\r\n\x05\x04\x98\x01\x02\x01\x12\x04\x88)\x02(\n\x0e\n\x06\x04\x98\x01\
    \x02\x01\x04\x12\x04\x88)\x02\n\n\x0e\n\x06\x04\x98\x01\x02\x01\x06\x12\
    \x04\x88)\x0b\x16\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\x12\x04\x88)\x17#\
    \n\x0e\n\x06\x04\x98\x01\x02\x01\x03\x12\x04\x88)&'\n-\n\x03\x04\x99\x01\
    \x12\x06\x8c)\0\x97)\x01\x1a\x1e\x20Evaluate\x20this\x20model\x20version\
    .\n\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\x8c)\x08&\n\x0c\n\x04\x04\x99\
    \x01\t\x12\x04\x8d)\x02\r\n\r\n\x05\x04\x99\x01\t\0\x12\x04\x8d)\x0b\x0c\
    \n\x0e\n\x06\x04\x99\x01\t\0\x01\x12\x04\x8d)\x0b\x0c\n\x0e\n\x06\x04\
    \x99\x01\t\0\x02\x12\x04\x8d)\x0b\x0c\n\r\n\x05\x04\x99\x01\x02\0\x12\
    \x04\x8e)\x02,\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\x8e)\x02\x1b\n\
    \x0e\n\x06\x04\x99\x01\x02\0\x01\x12\x04\x8e)\x1c'\n\x0e\n\x06\x04\x99\
    \x01\x02\0\x03\x12\x04\x8e)*+\n\r\n\x05\x04\x99\x01\x02\x01\x12\x04\x8f)\
    \x02\x16\n\x0e\n\x06\x04\x99\x01\x02\x01\x05\x12\x04\x8f)\x02\x08\n\x0e\
    \n\x06\x04\x99\x01\x02\x01\x01\x12\x04\x8f)\t\x11\n\x0e\n\x06\x04\x99\
    \x01\x02\x01\x03\x12\x04\x8f)\x14\x15\n\r\n\x05\x04\x99\x01\x02\x02\x12\
    \x04\x90)\x02\x18\n\x0e\n\x06\x04\x99\x01\x02\x02\x05\x12\x04\x90)\x02\
    \x08\n\x0e\n\x06\x04\x99\x01\x02\x02\x01\x12\x04\x90)\t\x13\n\x0e\n\x06\
    \x04\x99\x01\x02\x02\x03\x12\x04\x90)\x16\x17\nF\n\x05\x04\x99\x01\x02\
    \x03\x12\x04\x93)\x02&\x1a7\x20Use\x20this\x20to\x20filter\x20inputs\x20\
    that\x20are\x20used\x20in\x20evaluation\n\n\x0e\n\x06\x04\x99\x01\x02\
    \x03\x06\x12\x04\x93)\x02\x15\n\x0e\n\x06\x04\x99\x01\x02\x03\x01\x12\
    \x04\x93)\x16!\n\x0e\n\x06\x04\x99\x01\x02\x03\x03\x12\x04\x93)$%\nF\n\
    \x05\x04\x99\x01\x02\x04\x12\x04\x96)\x02\x1a\x1a7\x20evaluation\x20info\
    .\x20Such\x20as\x20dataset\x20used\x20for\x20evaluation.\n\n\x0e\n\x06\
    \x04\x99\x01\x02\x04\x06\x12\x04\x96)\x02\n\n\x0e\n\x06\x04\x99\x01\x02\
    \x04\x01\x12\x04\x96)\x0b\x14\n\x0e\n\x06\x04\x99\x01\x02\x04\x03\x12\
    \x04\x96)\x17\x19\nU\n\x03\x04\x9a\x01\x12\x06\x9b)\0\xa3)\x01\x1aF\x20G\
    et\x20the\x20already\x20computed\x20evaluation\x20metrics\x20for\x20this\
    \x20model\n\x20version.\n\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\x9b)\x08%\
    \n\r\n\x05\x04\x9a\x01\x02\0\x12\x04\x9c)\x02,\n\x0e\n\x06\x04\x9a\x01\
    \x02\0\x06\x12\x04\x9c)\x02\x1b\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\
    \x04\x9c)\x1c'\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\x12\x04\x9c)*+\n\r\n\
    \x05\x04\x9a\x01\x02\x01\x12\x04\x9d)\x02\x16\n\x0e\n\x06\x04\x9a\x01\
    \x02\x01\x05\x12\x04\x9d)\x02\x08\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\
    \x12\x04\x9d)\t\x11\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\x9d)\x14\
    \x15\n\r\n\x05\x04\x9a\x01\x02\x02\x12\x04\x9e)\x02\x18\n\x0e\n\x06\x04\
    \x9a\x01\x02\x02\x05\x12\x04\x9e)\x02\x08\n\x0e\n\x06\x04\x9a\x01\x02\
    \x02\x01\x12\x04\x9e)\t\x13\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\
    \x9e)\x16\x17\n|\n\x05\x04\x9a\x01\x02\x03\x12\x04\xa2)\x02\x19\x1am\x20\
    Any\x20of\x20the\x20fields\x20you\x20wish\x20to\x20return\x20from\x20mul\
    ticlass_metrics\n\x20By\x20default,\x20only\x20the\x20summary\x20will\
    \x20be\x20returned\n\n\x0e\n\x06\x04\x9a\x01\x02\x03\x06\x12\x04\xa2)\
    \x02\r\n\x0e\n\x06\x04\x9a\x01\x02\x03\x01\x12\x04\xa2)\x0e\x14\n\x0e\n\
    \x06\x04\x9a\x01\x02\x03\x03\x12\x04\xa2)\x17\x18\n\xeb\x01\n\x03\x04\
    \x9b\x01\x12\x06\xb0)\0\xb5)\x01\x1a\x15\x20GetModelTypeRequest\n2\xc4\
    \x01\x20//\x20Request\x20to\x20delete\x20several\x20things\x20by\x20the\
    \x20list\x20of\x20ids.\n\x20message\x20DeleteModelVersionsRequest\x20{\n\
    \x20\x20\x20clarifai.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\
    \x20\x20repeated\x20string\x20ids\x20=\x202;\n\x20\x20\x20bool\x20delete\
    _all\x20=\x203;\n\x20}\n\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\xb0)\x08\
    \x1b\nl\n\x05\x04\x9b\x01\x02\0\x12\x04\xb2)\x02,\x1a]\x20use\x20and\x20\
    app\x20combo.\x20Not\x20really\x20used\x20for\x20this\x20endpoint\x20at\
    \x20this\x20time\x20so\x20may\x20go\x20away\x20in\x20future.\n\n\x0e\n\
    \x06\x04\x9b\x01\x02\0\x06\x12\x04\xb2)\x02\x1b\n\x0e\n\x06\x04\x9b\x01\
    \x02\0\x01\x12\x04\xb2)\x1c'\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\x04\
    \xb2)*+\n@\n\x05\x04\x9b\x01\x02\x01\x12\x04\xb4)\x02\x1b\x1a1\x20The\
    \x20specific\x20ModelType.Id\x20you\x20want\x20to\x20retrieve.\n\n\x0e\n\
    \x06\x04\x9b\x01\x02\x01\x05\x12\x04\xb4)\x02\x08\n\x0e\n\x06\x04\x9b\
    \x01\x02\x01\x01\x12\x04\xb4)\t\x16\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\
    \x12\x04\xb4)\x19\x1a\n&\n\x03\x04\x9c\x01\x12\x06\xb8)\0\xc1)\x01\x1a\
    \x17\x20ListModelTypesRequest\n\n\x0c\n\x04\x04\x9c\x01\x01\x12\x04\xb8)\
    \x08\x1d\nl\n\x05\x04\x9c\x01\x02\0\x12\x04\xba)\x02,\x1a]\x20use\x20and\
    \x20app\x20combo.\x20Not\x20really\x20used\x20for\x20this\x20endpoint\
    \x20at\x20this\x20time\x20so\x20may\x20go\x20away\x20in\x20future.\n\n\
    \x0e\n\x06\x04\x9c\x01\x02\0\x06\x12\x04\xba)\x02\x1b\n\x0e\n\x06\x04\
    \x9c\x01\x02\0\x01\x12\x04\xba)\x1c'\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\
    \x12\x04\xba)*+\n\x7f\n\x05\x04\x9c\x01\x02\x01\x12\x04\xbd)\x02\x12\x1a\
    p\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginat\
    ion\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\
    \xbd)\x02\x08\n\x0e\n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\xbd)\t\r\n\x0e\
    \n\x06\x04\x9c\x01\x02\x01\x03\x12\x04\xbd)\x10\x11\nv\n\x05\x04\x9c\x01\
    \x02\x02\x12\x04\xc0)\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x9c\x01\
    \x02\x02\x05\x12\x04\xc0)\x02\x08\n\x0e\n\x06\x04\x9c\x01\x02\x02\x01\
    \x12\x04\xc0)\t\x11\n\x0e\n\x06\x04\x9c\x01\x02\x02\x03\x12\x04\xc0)\x14\
    \x15\n,\n\x03\x04\x9d\x01\x12\x04\xc4)\0(\x1a\x1f\x20ListOpenSourceLicen\
    sesRequest\n\n\x0c\n\x04\x04\x9d\x01\x01\x12\x04\xc4)\x08%\n/\n\x03\x04\
    \x9e\x01\x12\x06\xc7)\0\xca)\x01\x1a\x20\x20ListOpenSourceLicensesRespon\
    se\n\n\x0c\n\x04\x04\x9e\x01\x01\x12\x04\xc7)\x08&\n\r\n\x05\x04\x9e\x01\
    \x02\0\x12\x04\xc8)\x02(\n\x0e\n\x06\x04\x9e\x01\x02\0\x06\x12\x04\xc8)\
    \x02\x1c\n\x0e\n\x06\x04\x9e\x01\x02\0\x01\x12\x04\xc8)\x1d#\n\x0e\n\x06\
    \x04\x9e\x01\x02\0\x03\x12\x04\xc8)&'\n\r\n\x05\x04\x9e\x01\x02\x01\x12\
    \x04\xc9)\x02\x1f\n\x0e\n\x06\x04\x9e\x01\x02\x01\x04\x12\x04\xc9)\x02\n\
    \n\x0e\n\x06\x04\x9e\x01\x02\x01\x05\x12\x04\xc9)\x0b\x11\n\x0e\n\x06\
    \x04\x9e\x01\x02\x01\x01\x12\x04\xc9)\x12\x1a\n\x0e\n\x06\x04\x9e\x01\
    \x02\x01\x03\x12\x04\xc9)\x1d\x1e\n(\n\x03\x04\x9f\x01\x12\x06\xcd)\0\
    \xd2)\x01\x1a\x19\x20SingleModelTypeResponse\n\n\x0c\n\x04\x04\x9f\x01\
    \x01\x12\x04\xcd)\x08\x1f\n(\n\x05\x04\x9f\x01\x02\0\x12\x04\xcf)\x02(\
    \x1a\x19\x20Status\x20of\x20the\x20response.\n\n\x0e\n\x06\x04\x9f\x01\
    \x02\0\x06\x12\x04\xcf)\x02\x1c\n\x0e\n\x06\x04\x9f\x01\x02\0\x01\x12\
    \x04\xcf)\x1d#\n\x0e\n\x06\x04\x9f\x01\x02\0\x03\x12\x04\xcf)&'\n2\n\x05\
    \x04\x9f\x01\x02\x01\x12\x04\xd1)\x02J\x1a#\x20The\x20retrieved\x20Model\
    Type\x20object.\x20.\n\n\x0e\n\x06\x04\x9f\x01\x02\x01\x06\x12\x04\xd1)\
    \x02\x0b\n\x0e\n\x06\x04\x9f\x01\x02\x01\x01\x12\x04\xd1)\x0c\x16\n\x0e\
    \n\x06\x04\x9f\x01\x02\x01\x03\x12\x04\xd1)\x19\x1a\n\x0e\n\x06\x04\x9f\
    \x01\x02\x01\x08\x12\x04\xd1)\x1bI\n\x11\n\t\x04\x9f\x01\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xd1)\x1cH\n'\n\x03\x04\xa0\x01\x12\x06\xd5)\0\xde)\x01\
    \x1a\x18\x20MultiModelTypeResponse\n\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\
    \xd5)\x08\x1e\n(\n\x05\x04\xa0\x01\x02\0\x12\x04\xd7)\x02(\x1a\x19\x20St\
    atus\x20of\x20the\x20response.\n\n\x0e\n\x06\x04\xa0\x01\x02\0\x06\x12\
    \x04\xd7)\x02\x1c\n\x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\xd7)\x1d#\n\
    \x0e\n\x06\x04\xa0\x01\x02\0\x03\x12\x04\xd7)&'\n+\n\x05\x04\xa0\x01\x02\
    \x01\x12\x04\xd9)\x02T\x1a\x1c\x20List\x20of\x20ModelType\x20objects.\n\
    \n\x0e\n\x06\x04\xa0\x01\x02\x01\x04\x12\x04\xd9)\x02\n\n\x0e\n\x06\x04\
    \xa0\x01\x02\x01\x06\x12\x04\xd9)\x0b\x14\n\x0e\n\x06\x04\xa0\x01\x02\
    \x01\x01\x12\x04\xd9)\x15\x20\n\x0e\n\x06\x04\xa0\x01\x02\x01\x03\x12\
    \x04\xd9)#$\n\x0e\n\x06\x04\xa0\x01\x02\x01\x08\x12\x04\xd9)%S\n\x11\n\t\
    \x04\xa0\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xd9)&R\n(\n\x05\x04\xa0\x01\
    \x02\x02\x12\x04\xdb)\x02%\x1a\x19\x20List\x20of\x20model\x20importers\n\
    \n\x0e\n\x06\x04\xa0\x01\x02\x02\x06\x12\x04\xdb)\x02\x10\n\x0e\n\x06\
    \x04\xa0\x01\x02\x02\x01\x12\x04\xdb)\x11\x20\n\x0e\n\x06\x04\xa0\x01\
    \x02\x02\x03\x12\x04\xdb)#$\nD\n\x05\x04\xa0\x01\x02\x03\x12\x04\xdd)\
    \x028\x1a5\x20Triton\x20model\x20envs\x20that\x20can\x20be\x20used\x20fo\
    r\x20model\x20upload\n\n\x0e\n\x06\x04\xa0\x01\x02\x03\x04\x12\x04\xdd)\
    \x02\n\n\x0e\n\x06\x04\xa0\x01\x02\x03\x06\x12\x04\xdd)\x0b\x1d\n\x0e\n\
    \x06\x04\xa0\x01\x02\x03\x01\x12\x04\xdd)\x1e4\n\x0e\n\x06\x04\xa0\x01\
    \x02\x03\x03\x12\x04\xdd)67\n3\n\x03\x04\xa1\x01\x12\x06\xe1)\0\xea)\x01\
    \x1a$\x20GetModelVersionInputExampleRequest\n\n\x0c\n\x04\x04\xa1\x01\
    \x01\x12\x04\xe1)\x08*\nA\n\x05\x04\xa1\x01\x02\0\x12\x04\xe3)\x02,\x1a2\
    \x20authorization\x20field\x20\x20(contains\x20app/user\x20id\x20info)\n\
    \n\x0e\n\x06\x04\xa1\x01\x02\0\x06\x12\x04\xe3)\x02\x1b\n\x0e\n\x06\x04\
    \xa1\x01\x02\0\x01\x12\x04\xe3)\x1c'\n\x0e\n\x06\x04\xa1\x01\x02\0\x03\
    \x12\x04\xe3)*+\n3\n\x05\x04\xa1\x01\x02\x01\x12\x04\xe5)\x02\x16\x1a$\
    \x20id\x20of\x20model\x20the\x20example\x20belongs\x20to\n\n\x0e\n\x06\
    \x04\xa1\x01\x02\x01\x05\x12\x04\xe5)\x02\x08\n\x0e\n\x06\x04\xa1\x01\
    \x02\x01\x01\x12\x04\xe5)\t\x11\n\x0e\n\x06\x04\xa1\x01\x02\x01\x03\x12\
    \x04\xe5)\x14\x15\n8\n\x05\x04\xa1\x01\x02\x02\x12\x04\xe7)\x02\x1e\x1a)\
    \x20specific\x20version\x20the\x20example\x20belongs\x20to\n\n\x0e\n\x06\
    \x04\xa1\x01\x02\x02\x05\x12\x04\xe7)\x02\x08\n\x0e\n\x06\x04\xa1\x01\
    \x02\x02\x01\x12\x04\xe7)\t\x19\n\x0e\n\x06\x04\xa1\x01\x02\x02\x03\x12\
    \x04\xe7)\x1c\x1d\n'\n\x05\x04\xa1\x01\x02\x03\x12\x04\xe9)\x02\x18\x1a\
    \x18\x20Id\x20of\x20example\x20to\x20fetch\n\n\x0e\n\x06\x04\xa1\x01\x02\
    \x03\x05\x12\x04\xe9)\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x03\x01\x12\
    \x04\xe9)\t\x13\n\x0e\n\x06\x04\xa1\x01\x02\x03\x03\x12\x04\xe9)\x16\x17\
    \n5\n\x03\x04\xa2\x01\x12\x06\xed)\0\xf8)\x01\x1a&\x20ListModelVersionIn\
    putExamplesRequest\n\n\x0c\n\x04\x04\xa2\x01\x01\x12\x04\xed)\x08,\nA\n\
    \x05\x04\xa2\x01\x02\0\x12\x04\xef)\x02,\x1a2\x20authorization\x20field\
    \x20\x20(contains\x20app/user\x20id\x20info)\n\n\x0e\n\x06\x04\xa2\x01\
    \x02\0\x06\x12\x04\xef)\x02\x1b\n\x0e\n\x06\x04\xa2\x01\x02\0\x01\x12\
    \x04\xef)\x1c'\n\x0e\n\x06\x04\xa2\x01\x02\0\x03\x12\x04\xef)*+\n3\n\x05\
    \x04\xa2\x01\x02\x01\x12\x04\xf1)\x02\x16\x1a$\x20id\x20of\x20model\x20t\
    he\x20example\x20belongs\x20to\n\n\x0e\n\x06\x04\xa2\x01\x02\x01\x05\x12\
    \x04\xf1)\x02\x08\n\x0e\n\x06\x04\xa2\x01\x02\x01\x01\x12\x04\xf1)\t\x11\
    \n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\x12\x04\xf1)\x14\x15\n8\n\x05\x04\
    \xa2\x01\x02\x02\x12\x04\xf3)\x02\x1e\x1a)\x20specific\x20version\x20the\
    \x20example\x20belongs\x20to\n\n\x0e\n\x06\x04\xa2\x01\x02\x02\x05\x12\
    \x04\xf3)\x02\x08\n\x0e\n\x06\x04\xa2\x01\x02\x02\x01\x12\x04\xf3)\t\x19\
    \n\x0e\n\x06\x04\xa2\x01\x02\x02\x03\x12\x04\xf3)\x1c\x1d\n)\n\x05\x04\
    \xa2\x01\x02\x03\x12\x04\xf5)\x02\x12\x1a\x1a\x20Optional,\x20defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xa2\x01\x02\x03\x05\x12\x04\xf5)\x02\x08\
    \n\x0e\n\x06\x04\xa2\x01\x02\x03\x01\x12\x04\xf5)\t\r\n\x0e\n\x06\x04\
    \xa2\x01\x02\x03\x03\x12\x04\xf5)\x10\x11\n?\n\x05\x04\xa2\x01\x02\x04\
    \x12\x04\xf7)\x02\x16\x1a0\x20Optional,\x20defaults\x20to\x20128\x20refe\
    rences\x20per\x20page.\n\n\x0e\n\x06\x04\xa2\x01\x02\x04\x05\x12\x04\xf7\
    )\x02\x08\n\x0e\n\x06\x04\xa2\x01\x02\x04\x01\x12\x04\xf7)\t\x11\n\x0e\n\
    \x06\x04\xa2\x01\x02\x04\x03\x12\x04\xf7)\x14\x15\n7\n\x03\x04\xa3\x01\
    \x12\x06\xfd)\0\x82*\x01\x1a(\x20SingleModelVersionInputExampleResponse\
    \n\n\x0c\n\x04\x04\xa3\x01\x01\x12\x04\xfd)\x08.\n#\n\x05\x04\xa3\x01\
    \x02\0\x12\x04\xff)\x02(\x1a\x14\x20status\x20of\x20response\n\n\x0e\n\
    \x06\x04\xa3\x01\x02\0\x06\x12\x04\xff)\x02\x1c\n\x0e\n\x06\x04\xa3\x01\
    \x02\0\x01\x12\x04\xff)\x1d#\n\x0e\n\x06\x04\xa3\x01\x02\0\x03\x12\x04\
    \xff)&'\n,\n\x05\x04\xa3\x01\x02\x01\x12\x04\x81*\x02;\x1a\x1d\x20model\
    \x20input\x20example\x20message\n\n\x0e\n\x06\x04\xa3\x01\x02\x01\x06\
    \x12\x04\x81*\x02\x1a\n\x0e\n\x06\x04\xa3\x01\x02\x01\x01\x12\x04\x81*\
    \x1b6\n\x0e\n\x06\x04\xa3\x01\x02\x01\x03\x12\x04\x81*9:\n6\n\x03\x04\
    \xa4\x01\x12\x06\x85*\0\x8a*\x01\x1a'\x20MultiModelVersionInputExampleRe\
    sponse\n\n\x0c\n\x04\x04\xa4\x01\x01\x12\x04\x85*\x08-\n#\n\x05\x04\xa4\
    \x01\x02\0\x12\x04\x87*\x02(\x1a\x14\x20status\x20of\x20response\n\n\x0e\
    \n\x06\x04\xa4\x01\x02\0\x06\x12\x04\x87*\x02\x1c\n\x0e\n\x06\x04\xa4\
    \x01\x02\0\x01\x12\x04\x87*\x1d#\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\
    \x04\x87*&'\n-\n\x05\x04\xa4\x01\x02\x01\x12\x04\x89*\x02E\x1a\x1e\x20mo\
    del\x20input\x20example\x20messages\n\n\x0e\n\x06\x04\xa4\x01\x02\x01\
    \x04\x12\x04\x89*\x02\n\n\x0e\n\x06\x04\xa4\x01\x02\x01\x06\x12\x04\x89*\
    \x0b#\n\x0e\n\x06\x04\xa4\x01\x02\x01\x01\x12\x04\x89*$@\n\x0e\n\x06\x04\
    \xa4\x01\x02\x01\x03\x12\x04\x89*CD\n+\n\x03\x04\xa5\x01\x12\x06\x8d*\0\
    \x95*\x01\x1a\x1c\x20ListModelReferencesRequest\n\n\x0c\n\x04\x04\xa5\
    \x01\x01\x12\x04\x8d*\x08\"\n\r\n\x05\x04\xa5\x01\x02\0\x12\x04\x8e*\x02\
    ,\n\x0e\n\x06\x04\xa5\x01\x02\0\x06\x12\x04\x8e*\x02\x1b\n\x0e\n\x06\x04\
    \xa5\x01\x02\0\x01\x12\x04\x8e*\x1c'\n\x0e\n\x06\x04\xa5\x01\x02\0\x03\
    \x12\x04\x8e**+\n\r\n\x05\x04\xa5\x01\x02\x01\x12\x04\x90*\x02\x16\n\x0e\
    \n\x06\x04\xa5\x01\x02\x01\x05\x12\x04\x90*\x02\x08\n\x0e\n\x06\x04\xa5\
    \x01\x02\x01\x01\x12\x04\x90*\t\x11\n\x0e\n\x06\x04\xa5\x01\x02\x01\x03\
    \x12\x04\x90*\x14\x15\n)\n\x05\x04\xa5\x01\x02\x02\x12\x04\x92*\x02\x12\
    \x1a\x1a\x20Optional,\x20defaults\x20to\x201.\n\n\x0e\n\x06\x04\xa5\x01\
    \x02\x02\x05\x12\x04\x92*\x02\x08\n\x0e\n\x06\x04\xa5\x01\x02\x02\x01\
    \x12\x04\x92*\t\r\n\x0e\n\x06\x04\xa5\x01\x02\x02\x03\x12\x04\x92*\x10\
    \x11\n?\n\x05\x04\xa5\x01\x02\x03\x12\x04\x94*\x02\x16\x1a0\x20Optional,\
    \x20defaults\x20to\x20128\x20references\x20per\x20page.\n\n\x0e\n\x06\
    \x04\xa5\x01\x02\x03\x05\x12\x04\x94*\x02\x08\n\x0e\n\x06\x04\xa5\x01\
    \x02\x03\x01\x12\x04\x94*\t\x11\n\x0e\n\x06\x04\xa5\x01\x02\x03\x03\x12\
    \x04\x94*\x14\x15\n,\n\x03\x04\xa6\x01\x12\x06\x9a*\0\x9d*\x01\x1a\x1d\
    \x20MultiModelReferenceResponse\n\n\x0c\n\x04\x04\xa6\x01\x01\x12\x04\
    \x9a*\x08#\n\r\n\x05\x04\xa6\x01\x02\0\x12\x04\x9b*\x02(\n\x0e\n\x06\x04\
    \xa6\x01\x02\0\x06\x12\x04\x9b*\x02\x1c\n\x0e\n\x06\x04\xa6\x01\x02\0\
    \x01\x12\x04\x9b*\x1d#\n\x0e\n\x06\x04\xa6\x01\x02\0\x03\x12\x04\x9b*&'\
    \n\r\n\x05\x04\xa6\x01\x02\x01\x12\x04\x9c*\x02/\n\x0e\n\x06\x04\xa6\x01\
    \x02\x01\x04\x12\x04\x9c*\x02\n\n\x0e\n\x06\x04\xa6\x01\x02\x01\x06\x12\
    \x04\x9c*\x0b\x19\n\x0e\n\x06\x04\xa6\x01\x02\x01\x01\x12\x04\x9c*\x1a*\
    \n\x0e\n\x06\x04\xa6\x01\x02\x01\x03\x12\x04\x9c*-.\n$\n\x03\x04\xa7\x01\
    \x12\x06\xa0*\0\xa3*\x01\x1a\x15\x20MultiOutputResponse\n\n\x0c\n\x04\
    \x04\xa7\x01\x01\x12\x04\xa0*\x08\x1b\n\r\n\x05\x04\xa7\x01\x02\0\x12\
    \x04\xa1*\x02(\n\x0e\n\x06\x04\xa7\x01\x02\0\x06\x12\x04\xa1*\x02\x1c\n\
    \x0e\n\x06\x04\xa7\x01\x02\0\x01\x12\x04\xa1*\x1d#\n\x0e\n\x06\x04\xa7\
    \x01\x02\0\x03\x12\x04\xa1*&'\n\r\n\x05\x04\xa7\x01\x02\x01\x12\x04\xa2*\
    \x02M\n\x0e\n\x06\x04\xa7\x01\x02\x01\x04\x12\x04\xa2*\x02\n\n\x0e\n\x06\
    \x04\xa7\x01\x02\x01\x06\x12\x04\xa2*\x0b\x11\n\x0e\n\x06\x04\xa7\x01\
    \x02\x01\x01\x12\x04\xa2*\x12\x19\n\x0e\n\x06\x04\xa7\x01\x02\x01\x03\
    \x12\x04\xa2*\x1c\x1d\n\x0e\n\x06\x04\xa7\x01\x02\x01\x08\x12\x04\xa2*\
    \x1eL\n\x11\n\t\x04\xa7\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xa2*\x1fK\n\
    \"\n\x03\x04\xa8\x01\x12\x06\xa6*\0\xad*\x01\x1a\x13\x20ListScopesReques\
    t\n\n\x0c\n\x04\x04\xa8\x01\x01\x12\x04\xa6*\x08\x19\n\xc3\x01\n\x05\x04\
    \xa8\x01\x02\0\x12\x04\xa9*\x02\x16\x1a\xb3\x01\x20If\x20\"personal_acce\
    ss_token\"\x20include\x20scopes\x20and\x20endpoints\x20available\x20to\
    \x20personal\x20access\x20tokens.\n\x20If\x20\"api_key\"\x20include\x20s\
    copes\x20and\x20endpoints\x20available\x20to\x20app-specific\x20keys.\
    \x20(default)\n\n\x0e\n\x06\x04\xa8\x01\x02\0\x05\x12\x04\xa9*\x02\x08\n\
    \x0e\n\x06\x04\xa8\x01\x02\0\x01\x12\x04\xa9*\t\x11\n\x0e\n\x06\x04\xa8\
    \x01\x02\0\x03\x12\x04\xa9*\x14\x15\np\n\x05\x04\xa8\x01\x02\x01\x12\x04\
    \xac*\x02,\x1aa\x20For\x20all\x20user\x20specific\x20information\x20we\
    \x20include\x20user_app_id\x20to\x20get\x20the\x20user_id\x20in\x20a\x20\
    consistent\x20way\n\n\x0e\n\x06\x04\xa8\x01\x02\x01\x06\x12\x04\xac*\x02\
    \x1b\n\x0e\n\x06\x04\xa8\x01\x02\x01\x01\x12\x04\xac*\x1c'\n\x0e\n\x06\
    \x04\xa8\x01\x02\x01\x03\x12\x04\xac**+\n\x20\n\x03\x04\xa9\x01\x12\x06\
    \xb0*\0\xb2*\x01\x1a\x11\x20MyScopesRequest\n\n\x0c\n\x04\x04\xa9\x01\
    \x01\x12\x04\xb0*\x08\x17\n\r\n\x05\x04\xa9\x01\x02\0\x12\x04\xb1*\x02,\
    \n\x0e\n\x06\x04\xa9\x01\x02\0\x06\x12\x04\xb1*\x02\x1b\n\x0e\n\x06\x04\
    \xa9\x01\x02\0\x01\x12\x04\xb1*\x1c'\n\x0e\n\x06\x04\xa9\x01\x02\0\x03\
    \x12\x04\xb1**+\n$\n\x03\x04\xaa\x01\x12\x06\xb5*\0\xb7*\x01\x1a\x15\x20\
    MyScopesUserRequest\n\n\x0c\n\x04\x04\xaa\x01\x01\x12\x04\xb5*\x08\x1b\n\
    \r\n\x05\x04\xaa\x01\x02\0\x12\x04\xb6*\x02,\n\x0e\n\x06\x04\xaa\x01\x02\
    \0\x06\x12\x04\xb6*\x02\x1b\n\x0e\n\x06\x04\xaa\x01\x02\0\x01\x12\x04\
    \xb6*\x1c'\n\x0e\n\x06\x04\xaa\x01\x02\0\x03\x12\x04\xb6**+\n$\n\x03\x04\
    \xab\x01\x12\x06\xba*\0\xbb*\x01\x1a\x15\x20MyScopesRootRequest\n\n\x0c\
    \n\x04\x04\xab\x01\x01\x12\x04\xba*\x08\x1b\n'\n\x03\x04\xac\x01\x12\x06\
    \xbe*\0\xc7*\x01\x1a\x18\x20MultiScopeDepsResponse\n\n\x0c\n\x04\x04\xac\
    \x01\x01\x12\x04\xbe*\x08\x1e\n+\n\x05\x04\xac\x01\x02\0\x12\x04\xc0*\
    \x02(\x1a\x1c\x20The\x20status\x20of\x20the\x20request.\n\n\x0e\n\x06\
    \x04\xac\x01\x02\0\x06\x12\x04\xc0*\x02\x1c\n\x0e\n\x06\x04\xac\x01\x02\
    \0\x01\x12\x04\xc0*\x1d#\n\x0e\n\x06\x04\xac\x01\x02\0\x03\x12\x04\xc0*&\
    '\nM\n\x05\x04\xac\x01\x02\x01\x12\x04\xc2*\x02$\x1a>\x20scopes\x20is\
    \x20a\x20list\x20of\x20low-level\x20scopes\x20and\x20their\x20dependenci\
    es.\n\n\x0e\n\x06\x04\xac\x01\x02\x01\x04\x12\x04\xc2*\x02\n\n\x0e\n\x06\
    \x04\xac\x01\x02\x01\x06\x12\x04\xc2*\x0b\x14\n\x0e\n\x06\x04\xac\x01\
    \x02\x01\x01\x12\x04\xc2*\x15\x1f\n\x0e\n\x06\x04\xac\x01\x02\x01\x03\
    \x12\x04\xc2*\"#\n\xc3\x01\n\x05\x04\xac\x01\x02\x02\x12\x04\xc6*\x02*\
    \x1a\xb3\x01\x20endpoint_scopes\x20is\x20a\x20listof\x20all\x20the\x20pu\
    blicly\x20available\x20endponts\x20which\x20can\x20be\n\x20used\x20as\
    \x20scopes\x20as\x20well.\x20A\x20call\x20to\x20each\x20of\x20those\x20e\
    ndpoint\x20depends\x20on\x20a\x20subset\n\x20of\x20the\x20above\x20\"sco\
    pes\"\n\n\x0e\n\x06\x04\xac\x01\x02\x02\x04\x12\x04\xc6*\x02\n\n\x0e\n\
    \x06\x04\xac\x01\x02\x02\x06\x12\x04\xc6*\x0b\x17\n\x0e\n\x06\x04\xac\
    \x01\x02\x02\x01\x12\x04\xc6*\x18%\n\x0e\n\x06\x04\xac\x01\x02\x02\x03\
    \x12\x04\xc6*()\n#\n\x03\x04\xad\x01\x12\x06\xca*\0\xd4*\x01\x1a\x14\x20\
    MultiScopeResponse\n\n\x0c\n\x04\x04\xad\x01\x01\x12\x04\xca*\x08\x1a\n+\
    \n\x05\x04\xad\x01\x02\0\x12\x04\xcc*\x02(\x1a\x1c\x20The\x20status\x20o\
    f\x20the\x20request.\n\n\x0e\n\x06\x04\xad\x01\x02\0\x06\x12\x04\xcc*\
    \x02\x1c\n\x0e\n\x06\x04\xad\x01\x02\0\x01\x12\x04\xcc*\x1d#\n\x0e\n\x06\
    \x04\xad\x01\x02\0\x03\x12\x04\xcc*&'\n@\n\x05\x04\xad\x01\x02\x01\x12\
    \x04\xce*\x02\x1d\x1a1\x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\
    \x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\
    \x12\x04\xce*\x02\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x05\x12\x04\xce*\x0b\
    \x11\n\x0e\n\x06\x04\xad\x01\x02\x01\x01\x12\x04\xce*\x12\x18\n\x0e\n\
    \x06\x04\xad\x01\x02\x01\x03\x12\x04\xce*\x1b\x1c\n4\n\x05\x04\xad\x01\
    \x02\x02\x12\x04\xd0*\x02\x0e\x1a%\x20The\x20app\x20that\x20the\x20key\
    \x20has\x20access\x20to.\n\n\x0e\n\x06\x04\xad\x01\x02\x02\x06\x12\x04\
    \xd0*\x02\x05\n\x0e\n\x06\x04\xad\x01\x02\x02\x01\x12\x04\xd0*\x06\t\n\
    \x0e\n\x06\x04\xad\x01\x02\x02\x03\x12\x04\xd0*\x0c\r\nJ\n\x05\x04\xad\
    \x01\x02\x03\x12\x04\xd2*\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\
    \x20endpoint\x20permissions\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\
    \x04\xad\x01\x02\x03\x04\x12\x04\xd2*\x02\n\n\x0e\n\x06\x04\xad\x01\x02\
    \x03\x05\x12\x04\xd2*\x0b\x11\n\x0e\n\x06\x04\xad\x01\x02\x03\x01\x12\
    \x04\xd2*\x12\x1b\n\x0e\n\x06\x04\xad\x01\x02\x03\x03\x12\x04\xd2*\x1e\
    \x1f\n\r\n\x05\x04\xad\x01\x02\x04\x12\x04\xd3*\x02\x20\n\x0e\n\x06\x04\
    \xad\x01\x02\x04\x05\x12\x04\xd3*\x02\x08\n\x0e\n\x06\x04\xad\x01\x02\
    \x04\x01\x12\x04\xd3*\t\x1b\n\x0e\n\x06\x04\xad\x01\x02\x04\x03\x12\x04\
    \xd3*\x1e\x1f\n'\n\x03\x04\xae\x01\x12\x06\xd7*\0\xdf*\x01\x1a\x18\x20Mu\
    ltiScopeUserResponse\n\n\x0c\n\x04\x04\xae\x01\x01\x12\x04\xd7*\x08\x1e\
    \n+\n\x05\x04\xae\x01\x02\0\x12\x04\xd9*\x02(\x1a\x1c\x20The\x20status\
    \x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xae\x01\x02\0\x06\x12\x04\
    \xd9*\x02\x1c\n\x0e\n\x06\x04\xae\x01\x02\0\x01\x12\x04\xd9*\x1d#\n\x0e\
    \n\x06\x04\xae\x01\x02\0\x03\x12\x04\xd9*&'\n@\n\x05\x04\xae\x01\x02\x01\
    \x12\x04\xdb*\x02\x1d\x1a1\x20This\x20is\x20a\x20list\x20of\x20the\x20sc\
    opes\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xae\x01\x02\x01\
    \x04\x12\x04\xdb*\x02\n\n\x0e\n\x06\x04\xae\x01\x02\x01\x05\x12\x04\xdb*\
    \x0b\x11\n\x0e\n\x06\x04\xae\x01\x02\x01\x01\x12\x04\xdb*\x12\x18\n\x0e\
    \n\x06\x04\xae\x01\x02\x01\x03\x12\x04\xdb*\x1b\x1c\nJ\n\x05\x04\xae\x01\
    \x02\x02\x12\x04\xdd*\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20e\
    ndpoint\x20permissions\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\
    \xae\x01\x02\x02\x04\x12\x04\xdd*\x02\n\n\x0e\n\x06\x04\xae\x01\x02\x02\
    \x05\x12\x04\xdd*\x0b\x11\n\x0e\n\x06\x04\xae\x01\x02\x02\x01\x12\x04\
    \xdd*\x12\x1b\n\x0e\n\x06\x04\xae\x01\x02\x02\x03\x12\x04\xdd*\x1e\x1f\n\
    \r\n\x05\x04\xae\x01\x02\x03\x12\x04\xde*\x02\x20\n\x0e\n\x06\x04\xae\
    \x01\x02\x03\x05\x12\x04\xde*\x02\x08\n\x0e\n\x06\x04\xae\x01\x02\x03\
    \x01\x12\x04\xde*\t\x1b\n\x0e\n\x06\x04\xae\x01\x02\x03\x03\x12\x04\xde*\
    \x1e\x1f\n'\n\x03\x04\xaf\x01\x12\x06\xe2*\0\xea*\x01\x1a\x18\x20MultiSc\
    opeRootResponse\n\n\x0c\n\x04\x04\xaf\x01\x01\x12\x04\xe2*\x08\x1e\n+\n\
    \x05\x04\xaf\x01\x02\0\x12\x04\xe4*\x02(\x1a\x1c\x20The\x20status\x20of\
    \x20the\x20request.\n\n\x0e\n\x06\x04\xaf\x01\x02\0\x06\x12\x04\xe4*\x02\
    \x1c\n\x0e\n\x06\x04\xaf\x01\x02\0\x01\x12\x04\xe4*\x1d#\n\x0e\n\x06\x04\
    \xaf\x01\x02\0\x03\x12\x04\xe4*&'\n@\n\x05\x04\xaf\x01\x02\x01\x12\x04\
    \xe6*\x02\x1d\x1a1\x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\x20\
    that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xaf\x01\x02\x01\x04\x12\
    \x04\xe6*\x02\n\n\x0e\n\x06\x04\xaf\x01\x02\x01\x05\x12\x04\xe6*\x0b\x11\
    \n\x0e\n\x06\x04\xaf\x01\x02\x01\x01\x12\x04\xe6*\x12\x18\n\x0e\n\x06\
    \x04\xaf\x01\x02\x01\x03\x12\x04\xe6*\x1b\x1c\nJ\n\x05\x04\xaf\x01\x02\
    \x02\x12\x04\xe8*\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpo\
    int\x20permissions\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\x04\xaf\
    \x01\x02\x02\x04\x12\x04\xe8*\x02\n\n\x0e\n\x06\x04\xaf\x01\x02\x02\x05\
    \x12\x04\xe8*\x0b\x11\n\x0e\n\x06\x04\xaf\x01\x02\x02\x01\x12\x04\xe8*\
    \x12\x1b\n\x0e\n\x06\x04\xaf\x01\x02\x02\x03\x12\x04\xe8*\x1e\x1f\n\r\n\
    \x05\x04\xaf\x01\x02\x03\x12\x04\xe9*\x02\x20\n\x0e\n\x06\x04\xaf\x01\
    \x02\x03\x05\x12\x04\xe9*\x02\x08\n\x0e\n\x06\x04\xaf\x01\x02\x03\x01\
    \x12\x04\xe9*\t\x1b\n\x0e\n\x06\x04\xaf\x01\x02\x03\x03\x12\x04\xe9*\x1e\
    \x1f\n!\n\x03\x04\xb0\x01\x12\x06\xed*\0\xf0*\x01\x1a\x12\x20GetSearchRe\
    quest\n\n\x0c\n\x04\x04\xb0\x01\x01\x12\x04\xed*\x08\x18\n\r\n\x05\x04\
    \xb0\x01\x02\0\x12\x04\xee*\x02,\n\x0e\n\x06\x04\xb0\x01\x02\0\x06\x12\
    \x04\xee*\x02\x1b\n\x0e\n\x06\x04\xb0\x01\x02\0\x01\x12\x04\xee*\x1c'\n\
    \x0e\n\x06\x04\xb0\x01\x02\0\x03\x12\x04\xee**+\n\r\n\x05\x04\xb0\x01\
    \x02\x01\x12\x04\xef*\x02\x10\n\x0e\n\x06\x04\xb0\x01\x02\x01\x05\x12\
    \x04\xef*\x02\x08\n\x0e\n\x06\x04\xb0\x01\x02\x01\x01\x12\x04\xef*\t\x0b\
    \n\x0e\n\x06\x04\xb0\x01\x02\x01\x03\x12\x04\xef*\x0e\x0f\n$\n\x03\x04\
    \xb1\x01\x12\x06\xf3*\0\xfb*\x01\x1a\x15\x20ListSearchesRequest\n\n\x0c\
    \n\x04\x04\xb1\x01\x01\x12\x04\xf3*\x08\x1b\n\r\n\x05\x04\xb1\x01\x02\0\
    \x12\x04\xf4*\x02,\n\x0e\n\x06\x04\xb1\x01\x02\0\x06\x12\x04\xf4*\x02\
    \x1b\n\x0e\n\x06\x04\xb1\x01\x02\0\x01\x12\x04\xf4*\x1c'\n\x0e\n\x06\x04\
    \xb1\x01\x02\0\x03\x12\x04\xf4**+\n\x7f\n\x05\x04\xb1\x01\x02\x01\x12\
    \x04\xf7*\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xb1\x01\
    \x02\x01\x05\x12\x04\xf7*\x02\x08\n\x0e\n\x06\x04\xb1\x01\x02\x01\x01\
    \x12\x04\xf7*\t\r\n\x0e\n\x06\x04\xb1\x01\x02\x01\x03\x12\x04\xf7*\x10\
    \x11\nv\n\x05\x04\xb1\x01\x02\x02\x12\x04\xfa*\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\xb1\x01\x02\x02\x05\x12\x04\xfa*\x02\x08\n\x0e\n\x06\
    \x04\xb1\x01\x02\x02\x01\x12\x04\xfa*\t\x11\n\x0e\n\x06\x04\xb1\x01\x02\
    \x02\x03\x12\x04\xfa*\x14\x15\n$\n\x03\x04\xb2\x01\x12\x06\xfe*\0\x8c+\
    \x01\x1a\x15\x20PostSearchesRequest\n\n\x0c\n\x04\x04\xb2\x01\x01\x12\
    \x04\xfe*\x08\x1b\n6\n\x05\x04\xb2\x01\x02\0\x12\x04\x80+\x02,\x1a'\x20T\
    he\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\
    \xb2\x01\x02\0\x06\x12\x04\x80+\x02\x1b\n\x0e\n\x06\x04\xb2\x01\x02\0\
    \x01\x12\x04\x80+\x1c'\n\x0e\n\x06\x04\xb2\x01\x02\0\x03\x12\x04\x80+*+\
    \nk\n\x05\x04\xb2\x01\x02\x01\x12\x04\x84+\x02$\x1a\\\x20The\x20query;\
    \x20this\x20specifies\x20how\x20the\x20data\x20to\x20be\x20searched\n\
    \x20this\x20will\x20be\x20replaced\x20by\x20\"Searches\"\n\n\x0e\n\x06\
    \x04\xb2\x01\x02\x01\x06\x12\x04\x84+\x02\x07\n\x0e\n\x06\x04\xb2\x01\
    \x02\x01\x01\x12\x04\x84+\x08\r\n\x0e\n\x06\x04\xb2\x01\x02\x01\x03\x12\
    \x04\x84+\x10\x11\n\x0e\n\x06\x04\xb2\x01\x02\x01\x08\x12\x04\x84+\x12#\
    \n\x0f\n\x07\x04\xb2\x01\x02\x01\x08\x03\x12\x04\x84+\x13\"\n\x85\x01\n\
    \x05\x04\xb2\x01\x02\x02\x12\x04\x88+\x02\x1f\x1av\x20The\x20searched\
    \x20to\x20be\x20executed\x20or\x20saved\n\x20Eventually\x20the\x20reques\
    t\x20level\x20fields\x20will\x20be\x20deprecated\x20in\x20favor\x20of\
    \x20this\x20object\n\n\x0e\n\x06\x04\xb2\x01\x02\x02\x04\x12\x04\x88+\
    \x02\n\n\x0e\n\x06\x04\xb2\x01\x02\x02\x06\x12\x04\x88+\x0b\x11\n\x0e\n\
    \x06\x04\xb2\x01\x02\x02\x01\x12\x04\x88+\x12\x1a\n\x0e\n\x06\x04\xb2\
    \x01\x02\x02\x03\x12\x04\x88+\x1d\x1e\nO\n\x05\x04\xb2\x01\x02\x03\x12\
    \x04\x8b+\x02\x1c\x1a@\x20Pagination\x20information\x20to\x20paginate\
    \x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\xb2\x01\x02\
    \x03\x06\x12\x04\x8b+\x02\x0c\n\x0e\n\x06\x04\xb2\x01\x02\x03\x01\x12\
    \x04\x8b+\r\x17\n\x0e\n\x06\x04\xb2\x01\x02\x03\x03\x12\x04\x8b+\x1a\x1b\
    \n\r\n\x03\x04\xb3\x01\x12\x06\x8e+\0\x98+\x01\n\x0c\n\x04\x04\xb3\x01\
    \x01\x12\x04\x8e+\x08\"\n6\n\x05\x04\xb3\x01\x02\0\x12\x04\x90+\x02,\x1a\
    '\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\
    \x06\x04\xb3\x01\x02\0\x06\x12\x04\x90+\x02\x1b\n\x0e\n\x06\x04\xb3\x01\
    \x02\0\x01\x12\x04\x90+\x1c'\n\x0e\n\x06\x04\xb3\x01\x02\0\x03\x12\x04\
    \x90+*+\n+\n\x05\x04\xb3\x01\x02\x01\x12\x04\x93+\x02\x1f\x1a\x1c\x20The\
    \x20searches\x20to\x20be\x20patched\n\n\x0e\n\x06\x04\xb3\x01\x02\x01\
    \x04\x12\x04\x93+\x02\n\n\x0e\n\x06\x04\xb3\x01\x02\x01\x06\x12\x04\x93+\
    \x0b\x11\n\x0e\n\x06\x04\xb3\x01\x02\x01\x01\x12\x04\x93+\x12\x1a\n\x0e\
    \n\x06\x04\xb3\x01\x02\x01\x03\x12\x04\x93+\x1d\x1e\nr\n\x05\x04\xb3\x01\
    \x02\x02\x12\x04\x97+\x02\x14\x1ac\x20The\x20action\x20to\x20perform\x20\
    on\x20the\x20patched\x20Search\x20objects\n\x20For\x20now\x20only\x20act\
    ion\x20'overwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\xb3\x01\x02\x02\
    \x05\x12\x04\x97+\x02\x08\n\x0e\n\x06\x04\xb3\x01\x02\x02\x01\x12\x04\
    \x97+\t\x0f\n\x0e\n\x06\x04\xb3\x01\x02\x02\x03\x12\x04\x97+\x12\x13\n\r\
    \n\x03\x04\xb4\x01\x12\x06\x9a+\0\xa4+\x01\n\x0c\n\x04\x04\xb4\x01\x01\
    \x12\x04\x9a+\x08'\n6\n\x05\x04\xb4\x01\x02\0\x12\x04\x9c+\x02,\x1a'\x20\
    The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\
    \x04\xb4\x01\x02\0\x06\x12\x04\x9c+\x02\x1b\n\x0e\n\x06\x04\xb4\x01\x02\
    \0\x01\x12\x04\x9c+\x1c'\n\x0e\n\x06\x04\xb4\x01\x02\0\x03\x12\x04\x9c+*\
    +\n+\n\x05\x04\xb4\x01\x02\x01\x12\x04\x9f+\x02\x1f\x1a\x1c\x20The\x20se\
    arches\x20to\x20be\x20patched\n\n\x0e\n\x06\x04\xb4\x01\x02\x01\x04\x12\
    \x04\x9f+\x02\n\n\x0e\n\x06\x04\xb4\x01\x02\x01\x06\x12\x04\x9f+\x0b\x11\
    \n\x0e\n\x06\x04\xb4\x01\x02\x01\x01\x12\x04\x9f+\x12\x1a\n\x0e\n\x06\
    \x04\xb4\x01\x02\x01\x03\x12\x04\x9f+\x1d\x1e\nr\n\x05\x04\xb4\x01\x02\
    \x02\x12\x04\xa3+\x02\x14\x1ac\x20The\x20action\x20to\x20perform\x20on\
    \x20the\x20patched\x20Search\x20objects\n\x20For\x20now\x20only\x20actio\
    n\x20'overwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\xb4\x01\x02\x02\
    \x05\x12\x04\xa3+\x02\x08\n\x0e\n\x06\x04\xb4\x01\x02\x02\x01\x12\x04\
    \xa3+\t\x0f\n\x0e\n\x06\x04\xb4\x01\x02\x02\x03\x12\x04\xa3+\x12\x13\n%\
    \n\x03\x04\xb5\x01\x12\x06\xa7+\0\xb1+\x01\x1a\x16\x20PatchSearchesReque\
    st\n\n\x0c\n\x04\x04\xb5\x01\x01\x12\x04\xa7+\x08\x1c\n6\n\x05\x04\xb5\
    \x01\x02\0\x12\x04\xa9+\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20\
    to\x20query\x20from.\n\n\x0e\n\x06\x04\xb5\x01\x02\0\x06\x12\x04\xa9+\
    \x02\x1b\n\x0e\n\x06\x04\xb5\x01\x02\0\x01\x12\x04\xa9+\x1c'\n\x0e\n\x06\
    \x04\xb5\x01\x02\0\x03\x12\x04\xa9+*+\n+\n\x05\x04\xb5\x01\x02\x01\x12\
    \x04\xac+\x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\n\n\
    \x0e\n\x06\x04\xb5\x01\x02\x01\x04\x12\x04\xac+\x02\n\n\x0e\n\x06\x04\
    \xb5\x01\x02\x01\x06\x12\x04\xac+\x0b\x11\n\x0e\n\x06\x04\xb5\x01\x02\
    \x01\x01\x12\x04\xac+\x12\x1a\n\x0e\n\x06\x04\xb5\x01\x02\x01\x03\x12\
    \x04\xac+\x1d\x1e\nr\n\x05\x04\xb5\x01\x02\x02\x12\x04\xb0+\x02\x14\x1ac\
    \x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20Search\x20\
    objects\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20suppor\
    ted\n\n\x0e\n\x06\x04\xb5\x01\x02\x02\x05\x12\x04\xb0+\x02\x08\n\x0e\n\
    \x06\x04\xb5\x01\x02\x02\x01\x12\x04\xb0+\t\x0f\n\x0e\n\x06\x04\xb5\x01\
    \x02\x02\x03\x12\x04\xb0+\x12\x13\n`\n\x03\x04\xb6\x01\x12\x06\xb4+\0\
    \xbc+\x01\x1aQ\x20PostSearchesByIDRequest\x20performs\x20returns\x20resu\
    lts\x20of\x20a\x20saved\x20search\x20given\x20its\x20ID\n\n\x0c\n\x04\
    \x04\xb6\x01\x01\x12\x04\xb4+\x08\x1f\n\r\n\x05\x04\xb6\x01\x02\0\x12\
    \x04\xb5+\x02,\n\x0e\n\x06\x04\xb6\x01\x02\0\x06\x12\x04\xb5+\x02\x1b\n\
    \x0e\n\x06\x04\xb6\x01\x02\0\x01\x12\x04\xb5+\x1c'\n\x0e\n\x06\x04\xb6\
    \x01\x02\0\x03\x12\x04\xb5+*+\n3\n\x05\x04\xb6\x01\x02\x01\x12\x04\xb8+\
    \x02\x10\x1a$\x20ID\x20for\x20saves\x20search\x20to\x20be\x20executed\n\
    \n\x0e\n\x06\x04\xb6\x01\x02\x01\x05\x12\x04\xb8+\x02\x08\n\x0e\n\x06\
    \x04\xb6\x01\x02\x01\x01\x12\x04\xb8+\t\x0b\n\x0e\n\x06\x04\xb6\x01\x02\
    \x01\x03\x12\x04\xb8+\x0e\x0f\nO\n\x05\x04\xb6\x01\x02\x02\x12\x04\xbb+\
    \x02\x1c\x1a@\x20Pagination\x20information\x20to\x20paginate\x20through\
    \x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\xb6\x01\x02\x02\x06\x12\
    \x04\xbb+\x02\x0c\n\x0e\n\x06\x04\xb6\x01\x02\x02\x01\x12\x04\xbb+\r\x17\
    \n\x0e\n\x06\x04\xb6\x01\x02\x02\x03\x12\x04\xbb+\x1a\x1b\n$\n\x03\x04\
    \xb7\x01\x12\x06\xbf+\0\xc2+\x01\x1a\x15\x20DeleteSearchRequest\n\n\x0c\
    \n\x04\x04\xb7\x01\x01\x12\x04\xbf+\x08\x1b\n\r\n\x05\x04\xb7\x01\x02\0\
    \x12\x04\xc0+\x02,\n\x0e\n\x06\x04\xb7\x01\x02\0\x06\x12\x04\xc0+\x02\
    \x1b\n\x0e\n\x06\x04\xb7\x01\x02\0\x01\x12\x04\xc0+\x1c'\n\x0e\n\x06\x04\
    \xb7\x01\x02\0\x03\x12\x04\xc0+*+\n\r\n\x05\x04\xb7\x01\x02\x01\x12\x04\
    \xc1+\x02\x10\n\x0e\n\x06\x04\xb7\x01\x02\x01\x05\x12\x04\xc1+\x02\x08\n\
    \x0e\n\x06\x04\xb7\x01\x02\x01\x01\x12\x04\xc1+\t\x0b\n\x0e\n\x06\x04\
    \xb7\x01\x02\x01\x03\x12\x04\xc1+\x0e\x0f\n\x87\x01\n\x03\x04\xb8\x01\
    \x12\x06\xc7+\0\xd0+\x01\x1ax\x20Execute\x20a\x20new\x20annotation\x20se\
    arch\x20and\x20optionally\x20save\x20it\n\x20annotation\x20search\x20ove\
    r\x20annotations\x20using\x20rank\x20and\x20filter\x20proto\n\n\x0c\n\
    \x04\x04\xb8\x01\x01\x12\x04\xc7+\x08&\n6\n\x05\x04\xb8\x01\x02\0\x12\
    \x04\xc9+\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\
    \x20from.\n\n\x0e\n\x06\x04\xb8\x01\x02\0\x06\x12\x04\xc9+\x02\x1b\n\x0e\
    \n\x06\x04\xb8\x01\x02\0\x01\x12\x04\xc9+\x1c'\n\x0e\n\x06\x04\xb8\x01\
    \x02\0\x03\x12\x04\xc9+*+\n5\n\x05\x04\xb8\x01\x02\x01\x12\x04\xcc+\x02\
    \x1f\x1a&\x20The\x20searched\x20to\x20be\x20executed\x20or\x20saved\n\n\
    \x0e\n\x06\x04\xb8\x01\x02\x01\x04\x12\x04\xcc+\x02\n\n\x0e\n\x06\x04\
    \xb8\x01\x02\x01\x06\x12\x04\xcc+\x0b\x11\n\x0e\n\x06\x04\xb8\x01\x02\
    \x01\x01\x12\x04\xcc+\x12\x1a\n\x0e\n\x06\x04\xb8\x01\x02\x01\x03\x12\
    \x04\xcc+\x1d\x1e\nO\n\x05\x04\xb8\x01\x02\x02\x12\x04\xcf+\x02\x1c\x1a@\
    \x20Pagination\x20information\x20to\x20paginate\x20through\x20search\x20\
    result\x20Hits.\n\n\x0e\n\x06\x04\xb8\x01\x02\x02\x06\x12\x04\xcf+\x02\
    \x0c\n\x0e\n\x06\x04\xb8\x01\x02\x02\x01\x12\x04\xcf+\r\x17\n\x0e\n\x06\
    \x04\xb8\x01\x02\x02\x03\x12\x04\xcf+\x1a\x1b\n5\n\x03\x04\xb9\x01\x12\
    \x06\xd3+\0\xd6+\x01\x1a&\x20DeleteAnnotationSearchMetricsRequest\n\n\
    \x0c\n\x04\x04\xb9\x01\x01\x12\x04\xd3+\x08,\n\r\n\x05\x04\xb9\x01\x02\0\
    \x12\x04\xd4+\x02,\n\x0e\n\x06\x04\xb9\x01\x02\0\x06\x12\x04\xd4+\x02\
    \x1b\n\x0e\n\x06\x04\xb9\x01\x02\0\x01\x12\x04\xd4+\x1c'\n\x0e\n\x06\x04\
    \xb9\x01\x02\0\x03\x12\x04\xd4+*+\n\r\n\x05\x04\xb9\x01\x02\x01\x12\x04\
    \xd5+\x02\x10\n\x0e\n\x06\x04\xb9\x01\x02\x01\x05\x12\x04\xd5+\x02\x08\n\
    \x0e\n\x06\x04\xb9\x01\x02\x01\x01\x12\x04\xd5+\t\x0b\n\x0e\n\x06\x04\
    \xb9\x01\x02\x01\x03\x12\x04\xd5+\x0e\x0f\nB\n\x03\x04\xba\x01\x12\x06\
    \xd9+\0\xe6+\x01\x1a3\x20Execute\x20a\x20new\x20input\x20search\x20and\
    \x20optionally\x20save\x20it\n\n\x0c\n\x04\x04\xba\x01\x01\x12\x04\xd9+\
    \x08!\n6\n\x05\x04\xba\x01\x02\0\x12\x04\xdb+\x02,\x1a'\x20The\x20user_i\
    d\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\xba\x01\x02\
    \0\x06\x12\x04\xdb+\x02\x1b\n\x0e\n\x06\x04\xba\x01\x02\0\x01\x12\x04\
    \xdb+\x1c'\n\x0e\n\x06\x04\xba\x01\x02\0\x03\x12\x04\xdb+*+\n5\n\x05\x04\
    \xba\x01\x02\x01\x12\x04\xde+\x02\x1f\x1a&\x20The\x20searched\x20to\x20b\
    e\x20executed\x20or\x20saved\n\n\x0e\n\x06\x04\xba\x01\x02\x01\x04\x12\
    \x04\xde+\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x01\x06\x12\x04\xde+\x0b\x11\
    \n\x0e\n\x06\x04\xba\x01\x02\x01\x01\x12\x04\xde+\x12\x1a\n\x0e\n\x06\
    \x04\xba\x01\x02\x01\x03\x12\x04\xde+\x1d\x1e\nO\n\x05\x04\xba\x01\x02\
    \x02\x12\x04\xe1+\x02\x1c\x1a@\x20Pagination\x20information\x20to\x20pag\
    inate\x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\xba\x01\
    \x02\x02\x06\x12\x04\xe1+\x02\x0c\n\x0e\n\x06\x04\xba\x01\x02\x02\x01\
    \x12\x04\xe1+\r\x17\n\x0e\n\x06\x04\xba\x01\x02\x02\x03\x12\x04\xe1+\x1a\
    \x1b\nh\n\x05\x04\xba\x01\x02\x03\x12\x04\xe5+\x02\x16\x1aY\x20If\x20onl\
    y_count\x20is\x20set,\x20then\x20the\x20response\x20will\x20not\x20conta\
    in\x20hits,\n\x20but\x20hit_counts\x20instead.\n\n\x0e\n\x06\x04\xba\x01\
    \x02\x03\x05\x12\x04\xe5+\x02\x06\n\x0e\n\x06\x04\xba\x01\x02\x03\x01\
    \x12\x04\xe5+\x07\x11\n\x0e\n\x06\x04\xba\x01\x02\x03\x03\x12\x04\xe5+\
    \x14\x15\nZ\n\x03\x04\xbb\x01\x12\x06\xe9+\0\xed+\x01\x1aK\x20SingleSear\
    chResponse\x20returns\x20saved\x20search\x20in\x20response\x20to\x20GetS\
    earchRequest\n\n\x0c\n\x04\x04\xbb\x01\x01\x12\x04\xe9+\x08\x1c\n=\n\x05\
    \x04\xbb\x01\x02\0\x12\x04\xeb+\x02(\x1a.\x20Status\x20of\x20whether\x20\
    the\x20search\x20was\x20successful.\n\n\x0e\n\x06\x04\xbb\x01\x02\0\x06\
    \x12\x04\xeb+\x02\x1c\n\x0e\n\x06\x04\xbb\x01\x02\0\x01\x12\x04\xeb+\x1d\
    #\n\x0e\n\x06\x04\xbb\x01\x02\0\x03\x12\x04\xeb+&'\n\r\n\x05\x04\xbb\x01\
    \x02\x01\x12\x04\xec+\x02\x14\n\x0e\n\x06\x04\xbb\x01\x02\x01\x06\x12\
    \x04\xec+\x02\x08\n\x0e\n\x06\x04\xbb\x01\x02\x01\x01\x12\x04\xec+\t\x0f\
    \n\x0e\n\x06\x04\xbb\x01\x02\x01\x03\x12\x04\xec+\x12\x13\n$\n\x03\x04\
    \xbc\x01\x12\x06\xf0+\0\x83,\x01\x1a\x15\x20MultiSearchResponse\n\n\x0c\
    \n\x04\x04\xbc\x01\x01\x12\x04\xf0+\x08\x1b\n=\n\x05\x04\xbc\x01\x02\0\
    \x12\x04\xf2+\x02(\x1a.\x20Status\x20of\x20whether\x20the\x20search\x20w\
    as\x20successful.\n\n\x0e\n\x06\x04\xbc\x01\x02\0\x06\x12\x04\xf2+\x02\
    \x1c\n\x0e\n\x06\x04\xbc\x01\x02\0\x01\x12\x04\xf2+\x1d#\n\x0e\n\x06\x04\
    \xbc\x01\x02\0\x03\x12\x04\xf2+&'\n?\n\x05\x04\xbc\x01\x02\x01\x12\x04\
    \xf5+\x02\x10\x1a0\x20A\x20unique\x20id\x20which\x20uniquely\x20identifi\
    es\x20a\x20search\n\n\x0e\n\x06\x04\xbc\x01\x02\x01\x05\x12\x04\xf5+\x02\
    \x08\n\x0e\n\x06\x04\xbc\x01\x02\x01\x01\x12\x04\xf5+\t\x0b\n\x0e\n\x06\
    \x04\xbc\x01\x02\x01\x03\x12\x04\xf5+\x0e\x0f\n0\n\x05\x04\xbc\x01\x02\
    \x02\x12\x04\xf8+\x02G\x1a!\x20The\x20list\x20of\x20search\x20result\x20\
    Hits.\n\n\x0e\n\x06\x04\xbc\x01\x02\x02\x04\x12\x04\xf8+\x02\n\n\x0e\n\
    \x06\x04\xbc\x01\x02\x02\x06\x12\x04\xf8+\x0b\x0e\n\x0e\n\x06\x04\xbc\
    \x01\x02\x02\x01\x12\x04\xf8+\x0f\x13\n\x0e\n\x06\x04\xbc\x01\x02\x02\
    \x03\x12\x04\xf8+\x16\x17\n\x0e\n\x06\x04\xbc\x01\x02\x02\x08\x12\x04\
    \xf8+\x18F\n\x11\n\t\x04\xbc\x01\x02\x02\x08\xd0\x86\x03\x12\x04\xf8+\
    \x19E\n<\n\x05\x04\xbc\x01\x02\x03\x12\x04\xfb+\x02\x12\x1a-\x20The\x20o\
    riginal\x20query\x20provided\x20in\x20the\x20request.\n\n\x0e\n\x06\x04\
    \xbc\x01\x02\x03\x06\x12\x04\xfb+\x02\x07\n\x0e\n\x06\x04\xbc\x01\x02\
    \x03\x01\x12\x04\xfb+\x08\r\n\x0e\n\x06\x04\xbc\x01\x02\x03\x03\x12\x04\
    \xfb+\x10\x11\n?\n\x05\x04\xbc\x01\x02\x04\x12\x04\xfe+\x02\x1f\x1a0\x20\
    The\x20original\x20Searches\x20provided\x20in\x20the\x20request.\n\n\x0e\
    \n\x06\x04\xbc\x01\x02\x04\x04\x12\x04\xfe+\x02\n\n\x0e\n\x06\x04\xbc\
    \x01\x02\x04\x06\x12\x04\xfe+\x0b\x11\n\x0e\n\x06\x04\xbc\x01\x02\x04\
    \x01\x12\x04\xfe+\x12\x1a\n\x0e\n\x06\x04\xbc\x01\x02\x04\x03\x12\x04\
    \xfe+\x1d\x1e\n\x81\x01\n\x05\x04\xbc\x01\x02\x05\x12\x04\x82,\x02#\x1ar\
    \x20The\x20counts\x20of\x20hits\x20for\x20each\x20search,\x20in\x20the\
    \x20same\x20order\x20as\x20searches.\n\x20Only\x20returned\x20if\x20the\
    \x20request\x20set\x20only_count.\n\n\x0e\n\x06\x04\xbc\x01\x02\x05\x04\
    \x12\x04\x82,\x02\n\n\x0e\n\x06\x04\xbc\x01\x02\x05\x06\x12\x04\x82,\x0b\
    \x13\n\x0e\n\x06\x04\xbc\x01\x02\x05\x01\x12\x04\x82,\x14\x1e\n\x0e\n\
    \x06\x04\xbc\x01\x02\x05\x03\x12\x04\x82,!\"\n3\n\x03\x04\xbd\x01\x12\
    \x06\x86,\0\x98,\x01\x1a$\x20PostAnnotationSearchMetricsRequest\n\n\x0c\
    \n\x04\x04\xbd\x01\x01\x12\x04\x86,\x08*\n\r\n\x05\x04\xbd\x01\x02\0\x12\
    \x04\x87,\x02,\n\x0e\n\x06\x04\xbd\x01\x02\0\x06\x12\x04\x87,\x02\x1b\n\
    \x0e\n\x06\x04\xbd\x01\x02\0\x01\x12\x04\x87,\x1c'\n\x0e\n\x06\x04\xbd\
    \x01\x02\0\x03\x12\x04\x87,*+\nJ\n\x05\x04\xbd\x01\x02\x01\x12\x04\x8a,\
    \x02\x10\x1a;\x20A\x20unique\x20customer\x20facing\x20id\x20to\x20identi\
    fy\x20this\x20eval\x20request\n\n\x0e\n\x06\x04\xbd\x01\x02\x01\x05\x12\
    \x04\x8a,\x02\x08\n\x0e\n\x06\x04\xbd\x01\x02\x01\x01\x12\x04\x8a,\t\x0b\
    \n\x0e\n\x06\x04\xbd\x01\x02\x01\x03\x12\x04\x8a,\x0e\x0f\n;\n\x05\x04\
    \xbd\x01\x02\x02\x12\x04\x8d,\x02'\x1a,\x20The\x20ground\x20truth\x20we\
    \x20are\x20evaluating\x20against\n\n\x0e\n\x06\x04\xbd\x01\x02\x02\x06\
    \x12\x04\x8d,\x02\x15\n\x0e\n\x06\x04\xbd\x01\x02\x02\x01\x12\x04\x8d,\
    \x16\"\n\x0e\n\x06\x04\xbd\x01\x02\x02\x03\x12\x04\x8d,%&\n*\n\x05\x04\
    \xbd\x01\x02\x03\x12\x04\x90,\x02)\x1a\x1b\x20The\x20set\x20we\x20are\
    \x20evaluating\n\n\x0e\n\x06\x04\xbd\x01\x02\x03\x06\x12\x04\x90,\x02\
    \x15\n\x0e\n\x06\x04\xbd\x01\x02\x03\x01\x12\x04\x90,\x16$\n\x0e\n\x06\
    \x04\xbd\x01\x02\x03\x03\x12\x04\x90,'(\ny\n\x05\x04\xbd\x01\x02\x04\x12\
    \x04\x94,\x02\x10\x1aj\x20List\x20of\x20concepts\x20to\x20evaluate\x20ar\
    e\x20expected\x20to\x20be\x20in\x20data.concepts\n\x20If\x20nil,\x20then\
    \x20all\x20app\x20concepts\x20are\x20used\n\n\x0e\n\x06\x04\xbd\x01\x02\
    \x04\x06\x12\x04\x94,\x02\x06\n\x0e\n\x06\x04\xbd\x01\x02\x04\x01\x12\
    \x04\x94,\x07\x0b\n\x0e\n\x06\x04\xbd\x01\x02\x04\x03\x12\x04\x94,\x0e\
    \x0f\n.\n\x05\x04\xbd\x01\x02\x05\x12\x04\x97,\x02%\x1a\x1f\x20The\x20ty\
    pe\x20of\x20evaluation\x20to\x20use\n\n\x0e\n\x06\x04\xbd\x01\x02\x05\
    \x06\x12\x04\x97,\x02\x10\n\x0e\n\x06\x04\xbd\x01\x02\x05\x01\x12\x04\
    \x97,\x11\x20\n\x0e\n\x06\x04\xbd\x01\x02\x05\x03\x12\x04\x97,#$\n2\n\
    \x03\x04\xbe\x01\x12\x06\x9b,\0\xa0,\x01\x1a#\x20GetAnnotationSearchMetr\
    icsRequest\n\n\x0c\n\x04\x04\xbe\x01\x01\x12\x04\x9b,\x08)\n\r\n\x05\x04\
    \xbe\x01\x02\0\x12\x04\x9c,\x02,\n\x0e\n\x06\x04\xbe\x01\x02\0\x06\x12\
    \x04\x9c,\x02\x1b\n\x0e\n\x06\x04\xbe\x01\x02\0\x01\x12\x04\x9c,\x1c'\n\
    \x0e\n\x06\x04\xbe\x01\x02\0\x03\x12\x04\x9c,*+\nH\n\x05\x04\xbe\x01\x02\
    \x01\x12\x04\x9f,\x02\x10\x1a9\x20Unique\x20custom\x20facing\x20id\x20th\
    at\x20identifies\x20the\x20eval\x20to\x20get\n\n\x0e\n\x06\x04\xbe\x01\
    \x02\x01\x05\x12\x04\x9f,\x02\x08\n\x0e\n\x06\x04\xbe\x01\x02\x01\x01\
    \x12\x04\x9f,\t\x0b\n\x0e\n\x06\x04\xbe\x01\x02\x01\x03\x12\x04\x9f,\x0e\
    \x0f\n3\n\x03\x04\xbf\x01\x12\x06\xa3,\0\xa5,\x01\x1a$\x20ListAnnotation\
    SearchMetricsRequest\n\n\x0c\n\x04\x04\xbf\x01\x01\x12\x04\xa3,\x08*\n\r\
    \n\x05\x04\xbf\x01\x02\0\x12\x04\xa4,\x02,\n\x0e\n\x06\x04\xbf\x01\x02\0\
    \x06\x12\x04\xa4,\x02\x1b\n\x0e\n\x06\x04\xbf\x01\x02\0\x01\x12\x04\xa4,\
    \x1c'\n\x0e\n\x06\x04\xbf\x01\x02\0\x03\x12\x04\xa4,*+\n5\n\x03\x04\xc0\
    \x01\x12\x06\xa8,\0\xac,\x01\x1a&\x20MultiAnnotationSearchMetricsRespons\
    e\n\n\x0c\n\x04\x04\xc0\x01\x01\x12\x04\xa8,\x08,\n&\n\x05\x04\xc0\x01\
    \x02\0\x12\x04\xaa,\x02(\x1a\x17\x20Status\x20of\x20the\x20request\n\n\
    \x0e\n\x06\x04\xc0\x01\x02\0\x06\x12\x04\xaa,\x02\x1c\n\x0e\n\x06\x04\
    \xc0\x01\x02\0\x01\x12\x04\xaa,\x1d#\n\x0e\n\x06\x04\xc0\x01\x02\0\x03\
    \x12\x04\xaa,&'\n\r\n\x05\x04\xc0\x01\x02\x01\x12\x04\xab,\x02A\n\x0e\n\
    \x06\x04\xc0\x01\x02\x01\x04\x12\x04\xab,\x02\n\n\x0e\n\x06\x04\xc0\x01\
    \x02\x01\x06\x12\x04\xab,\x0b\"\n\x0e\n\x06\x04\xc0\x01\x02\x01\x01\x12\
    \x04\xab,#<\n\x0e\n\x06\x04\xc0\x01\x02\x01\x03\x12\x04\xab,?@\n-\n\x03\
    \x04\xc1\x01\x12\x06\xaf,\0\xb7,\x01\x1a\x1e\x20ListAnnotationFiltersReq\
    uest\n\n\x0c\n\x04\x04\xc1\x01\x01\x12\x04\xaf,\x08$\n\r\n\x05\x04\xc1\
    \x01\x02\0\x12\x04\xb0,\x02,\n\x0e\n\x06\x04\xc1\x01\x02\0\x06\x12\x04\
    \xb0,\x02\x1b\n\x0e\n\x06\x04\xc1\x01\x02\0\x01\x12\x04\xb0,\x1c'\n\x0e\
    \n\x06\x04\xc1\x01\x02\0\x03\x12\x04\xb0,*+\n\x7f\n\x05\x04\xc1\x01\x02\
    \x01\x12\x04\xb3,\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\xc1\x01\x02\x01\x05\x12\x04\xb3,\x02\x08\n\x0e\n\x06\x04\xc1\x01\
    \x02\x01\x01\x12\x04\xb3,\t\r\n\x0e\n\x06\x04\xc1\x01\x02\x01\x03\x12\
    \x04\xb3,\x10\x11\nv\n\x05\x04\xc1\x01\x02\x02\x12\x04\xb6,\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\xc1\x01\x02\x02\x05\x12\x04\xb6,\x02\x08\n\
    \x0e\n\x06\x04\xc1\x01\x02\x02\x01\x12\x04\xb6,\t\x11\n\x0e\n\x06\x04\
    \xc1\x01\x02\x02\x03\x12\x04\xb6,\x14\x15\n+\n\x03\x04\xc2\x01\x12\x06\
    \xba,\0\xbf,\x01\x1a\x1c\x20GetAnnotationFilterRequest\n\n\x0c\n\x04\x04\
    \xc2\x01\x01\x12\x04\xba,\x08\"\n\r\n\x05\x04\xc2\x01\x02\0\x12\x04\xbb,\
    \x02,\n\x0e\n\x06\x04\xc2\x01\x02\0\x06\x12\x04\xbb,\x02\x1b\n\x0e\n\x06\
    \x04\xc2\x01\x02\0\x01\x12\x04\xbb,\x1c'\n\x0e\n\x06\x04\xc2\x01\x02\0\
    \x03\x12\x04\xbb,*+\n2\n\x05\x04\xc2\x01\x02\x01\x12\x04\xbe,\x02\"\x1a#\
    \x20Identify\x20annotation\x20filter\x20by\x20id.\n\n\x0e\n\x06\x04\xc2\
    \x01\x02\x01\x05\x12\x04\xbe,\x02\x08\n\x0e\n\x06\x04\xc2\x01\x02\x01\
    \x01\x12\x04\xbe,\t\x1d\n\x0e\n\x06\x04\xc2\x01\x02\x01\x03\x12\x04\xbe,\
    \x20!\n?\n\x03\x04\xc3\x01\x12\x06\xc2,\0\xc7,\x01\x1a0\x20Request\x20to\
    \x20add\x20one\x20or\x20more\x20annotation\x20filters.\n\n\x0c\n\x04\x04\
    \xc3\x01\x01\x12\x04\xc2,\x08$\n\r\n\x05\x04\xc3\x01\x02\0\x12\x04\xc3,\
    \x02,\n\x0e\n\x06\x04\xc3\x01\x02\0\x06\x12\x04\xc3,\x02\x1b\n\x0e\n\x06\
    \x04\xc3\x01\x02\0\x01\x12\x04\xc3,\x1c'\n\x0e\n\x06\x04\xc3\x01\x02\0\
    \x03\x12\x04\xc3,*+\nK\n\x05\x04\xc3\x01\x02\x01\x12\x04\xc6,\x023\x1a<\
    \x20List\x20of\x20annotation\x20filters\x20that\x20are\x20requested\x20t\
    o\x20be\x20added.\n\n\x0e\n\x06\x04\xc3\x01\x02\x01\x04\x12\x04\xc6,\x02\
    \n\n\x0e\n\x06\x04\xc3\x01\x02\x01\x06\x12\x04\xc6,\x0b\x1b\n\x0e\n\x06\
    \x04\xc3\x01\x02\x01\x01\x12\x04\xc6,\x1c.\n\x0e\n\x06\x04\xc3\x01\x02\
    \x01\x03\x12\x04\xc6,12\n=\n\x03\x04\xc4\x01\x12\x06\xca,\0\xd3,\x01\x1a\
    .\x20Request\x20to\x20patch\x20several\x20annotation\x20filters.\n\n\x0c\
    \n\x04\x04\xc4\x01\x01\x12\x04\xca,\x08%\n\r\n\x05\x04\xc4\x01\x02\0\x12\
    \x04\xcb,\x02,\n\x0e\n\x06\x04\xc4\x01\x02\0\x06\x12\x04\xcb,\x02\x1b\n\
    \x0e\n\x06\x04\xc4\x01\x02\0\x01\x12\x04\xcb,\x1c'\n\x0e\n\x06\x04\xc4\
    \x01\x02\0\x03\x12\x04\xcb,*+\nM\n\x05\x04\xc4\x01\x02\x01\x12\x04\xce,\
    \x023\x1a>\x20List\x20of\x20annotation\x20filters\x20that\x20are\x20requ\
    ested\x20to\x20be\x20updated.\n\n\x0e\n\x06\x04\xc4\x01\x02\x01\x04\x12\
    \x04\xce,\x02\n\n\x0e\n\x06\x04\xc4\x01\x02\x01\x06\x12\x04\xce,\x0b\x1b\
    \n\x0e\n\x06\x04\xc4\x01\x02\x01\x01\x12\x04\xce,\x1c.\n\x0e\n\x06\x04\
    \xc4\x01\x02\x01\x03\x12\x04\xce,12\nl\n\x05\x04\xc4\x01\x02\x02\x12\x04\
    \xd2,\x02\x14\x1a]\x20The\x20action\x20to\x20perform\x20on\x20the\x20pat\
    ched\x20objects\n\x20For\x20now,\x20only\x20'overwrite'\x20action\x20is\
    \x20supported\n\n\x0e\n\x06\x04\xc4\x01\x02\x02\x05\x12\x04\xd2,\x02\x08\
    \n\x0e\n\x06\x04\xc4\x01\x02\x02\x01\x12\x04\xd2,\t\x0f\n\x0e\n\x06\x04\
    \xc4\x01\x02\x02\x03\x12\x04\xd2,\x12\x13\nM\n\x03\x04\xc5\x01\x12\x06\
    \xd6,\0\xdb,\x01\x1a>\x20Request\x20to\x20delete\x20several\x20annotatio\
    n\x20filters\x20by\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xc5\x01\x01\
    \x12\x04\xd6,\x08&\n\r\n\x05\x04\xc5\x01\x02\0\x12\x04\xd7,\x02,\n\x0e\n\
    \x06\x04\xc5\x01\x02\0\x06\x12\x04\xd7,\x02\x1b\n\x0e\n\x06\x04\xc5\x01\
    \x02\0\x01\x12\x04\xd7,\x1c'\n\x0e\n\x06\x04\xc5\x01\x02\0\x03\x12\x04\
    \xd7,*+\n1\n\x05\x04\xc5\x01\x02\x01\x12\x04\xda,\x02,\x1a\"\x20Specify\
    \x20which\x20filters\x20to\x20delete.\n\n\x0e\n\x06\x04\xc5\x01\x02\x01\
    \x04\x12\x04\xda,\x02\n\n\x0e\n\x06\x04\xc5\x01\x02\x01\x05\x12\x04\xda,\
    \x0b\x11\n\x0e\n\x06\x04\xc5\x01\x02\x01\x01\x12\x04\xda,\x12'\n\x0e\n\
    \x06\x04\xc5\x01\x02\x01\x03\x12\x04\xda,*+\n.\n\x03\x04\xc6\x01\x12\x06\
    \xde,\0\xe2,\x01\x1a\x1f\x20MultiAnnotationFilterResponse\n\n\x0c\n\x04\
    \x04\xc6\x01\x01\x12\x04\xde,\x08%\n\r\n\x05\x04\xc6\x01\x02\0\x12\x04\
    \xdf,\x02(\n\x0e\n\x06\x04\xc6\x01\x02\0\x06\x12\x04\xdf,\x02\x1c\n\x0e\
    \n\x06\x04\xc6\x01\x02\0\x01\x12\x04\xdf,\x1d#\n\x0e\n\x06\x04\xc6\x01\
    \x02\0\x03\x12\x04\xdf,&'\n\r\n\x05\x04\xc6\x01\x02\x01\x12\x04\xe1,\x02\
    b\n\x0e\n\x06\x04\xc6\x01\x02\x01\x04\x12\x04\xe1,\x02\n\n\x0e\n\x06\x04\
    \xc6\x01\x02\x01\x06\x12\x04\xe1,\x0b\x1b\n\x0e\n\x06\x04\xc6\x01\x02\
    \x01\x01\x12\x04\xe1,\x1c.\n\x0e\n\x06\x04\xc6\x01\x02\x01\x03\x12\x04\
    \xe1,12\n\x0e\n\x06\x04\xc6\x01\x02\x01\x08\x12\x04\xe1,3a\n\x11\n\t\x04\
    \xc6\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xe1,4`\n/\n\x03\x04\xc7\x01\x12\
    \x06\xe5,\0\xe9,\x01\x1a\x20\x20SingleAnnotationFilterResponse\n\n\x0c\n\
    \x04\x04\xc7\x01\x01\x12\x04\xe5,\x08&\n\r\n\x05\x04\xc7\x01\x02\0\x12\
    \x04\xe6,\x02(\n\x0e\n\x06\x04\xc7\x01\x02\0\x06\x12\x04\xe6,\x02\x1c\n\
    \x0e\n\x06\x04\xc7\x01\x02\0\x01\x12\x04\xe6,\x1d#\n\x0e\n\x06\x04\xc7\
    \x01\x02\0\x03\x12\x04\xe6,&'\n\r\n\x05\x04\xc7\x01\x02\x01\x12\x04\xe8,\
    \x02)\n\x0e\n\x06\x04\xc7\x01\x02\x01\x06\x12\x04\xe8,\x02\x12\n\x0e\n\
    \x06\x04\xc7\x01\x02\x01\x01\x12\x04\xe8,\x13$\n\x0e\n\x06\x04\xc7\x01\
    \x02\x01\x03\x12\x04\xe8,'(\n\x1f\n\x03\x04\xc8\x01\x12\x06\x8c-\0\x93-\
    \x01\x1a\x10\x20GetUserRequest\n\n\x0c\n\x04\x04\xc8\x01\x01\x12\x04\x8c\
    -\x08\x16\n\xbe\x01\n\x05\x04\xc8\x01\x02\0\x12\x04\x8f-\x02,\x1a\xae\
    \x01\x20we\x20used\x20to\x20have\x20user_id\x20but\x20moved\x20to\x20the\
    \x20standard\x20convention.\x20Since\x20this\x20endpoint\n\x20hasn't\x20\
    been\x20exposed\x20and\x20only\x20used\x20by\x20portal\x20as\x20a\x20url\
    \x20this\x20won't\x20effect\x20anything\x20external.\n\n\x0e\n\x06\x04\
    \xc8\x01\x02\0\x06\x12\x04\x8f-\x02\x1b\n\x0e\n\x06\x04\xc8\x01\x02\0\
    \x01\x12\x04\x8f-\x1c'\n\x0e\n\x06\x04\xc8\x01\x02\0\x03\x12\x04\x8f-*+\
    \n\x83\x01\n\x05\x04\xc8\x01\x02\x01\x12\x04\x92-\x02(\x1at\x20(optional\
    \x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\
    \x20included\x20in\x20the\x20response.\x20Currently\x20supported:\x20all\
    ,\x20stars\n\n\x0e\n\x06\x04\xc8\x01\x02\x01\x04\x12\x04\x92-\x02\n\n\
    \x0e\n\x06\x04\xc8\x01\x02\x01\x05\x12\x04\x92-\x0b\x11\n\x0e\n\x06\x04\
    \xc8\x01\x02\x01\x01\x12\x04\x92-\x12#\n\x0e\n\x06\x04\xc8\x01\x02\x01\
    \x03\x12\x04\x92-&'\n#\n\x03\x04\xc9\x01\x12\x06\x98-\0\x9b-\x01\x1a\x14\
    \x20SingleUserResponse\n\n\x0c\n\x04\x04\xc9\x01\x01\x12\x04\x98-\x08\
    \x1a\n\r\n\x05\x04\xc9\x01\x02\0\x12\x04\x99-\x02(\n\x0e\n\x06\x04\xc9\
    \x01\x02\0\x06\x12\x04\x99-\x02\x1c\n\x0e\n\x06\x04\xc9\x01\x02\0\x01\
    \x12\x04\x99-\x1d#\n\x0e\n\x06\x04\xc9\x01\x02\0\x03\x12\x04\x99-&'\n\r\
    \n\x05\x04\xc9\x01\x02\x01\x12\x04\x9a-\x02\x10\n\x0e\n\x06\x04\xc9\x01\
    \x02\x01\x06\x12\x04\x9a-\x02\x06\n\x0e\n\x06\x04\xc9\x01\x02\x01\x01\
    \x12\x04\x9a-\x07\x0b\n\x0e\n\x06\x04\xc9\x01\x02\x01\x03\x12\x04\x9a-\
    \x0e\x0f\n,\n\x03\x04\xca\x01\x12\x06\xac-\0\xb0-\x01\x1a\x1d\x20PostVal\
    idatePasswordRequest\n\n\x0c\n\x04\x04\xca\x01\x01\x12\x04\xac-\x08#\n\r\
    \n\x05\x04\xca\x01\x02\0\x12\x04\xad-\x02,\n\x0e\n\x06\x04\xca\x01\x02\0\
    \x06\x12\x04\xad-\x02\x1b\n\x0e\n\x06\x04\xca\x01\x02\0\x01\x12\x04\xad-\
    \x1c'\n\x0e\n\x06\x04\xca\x01\x02\0\x03\x12\x04\xad-*+\n)\n\x05\x04\xca\
    \x01\x02\x01\x12\x04\xaf-\x02\x18\x1a\x1a\x20password\x20to\x20be\x20val\
    idated\n\n\x0e\n\x06\x04\xca\x01\x02\x01\x06\x12\x04\xaf-\x02\n\n\x0e\n\
    \x06\x04\xca\x01\x02\x01\x01\x12\x04\xaf-\x0b\x13\n\x0e\n\x06\x04\xca\
    \x01\x02\x01\x03\x12\x04\xaf-\x16\x17\n1\n\x03\x04\xcb\x01\x12\x06\xb3-\
    \0\xb7-\x01\x1a\"\x20SinglePasswordValidationResponse\n\n\x0c\n\x04\x04\
    \xcb\x01\x01\x12\x04\xb3-\x08(\n.\n\x05\x04\xcb\x01\x02\0\x12\x04\xb5-\
    \x02(\x1a\x1f\x20Standard\x20clarifai\x20status\x20code\n\n\x0e\n\x06\
    \x04\xcb\x01\x02\0\x06\x12\x04\xb5-\x02\x1c\n\x0e\n\x06\x04\xcb\x01\x02\
    \0\x01\x12\x04\xb5-\x1d#\n\x0e\n\x06\x04\xcb\x01\x02\0\x03\x12\x04\xb5-&\
    '\n\r\n\x05\x04\xcb\x01\x02\x01\x12\x04\xb6-\x02-\n\x0e\n\x06\x04\xcb\
    \x01\x02\x01\x06\x12\x04\xb6-\x02\x14\n\x0e\n\x06\x04\xcb\x01\x02\x01\
    \x01\x12\x04\xb6-\x15(\n\x0e\n\x06\x04\xcb\x01\x02\x01\x03\x12\x04\xb6-+\
    ,\n\x0c\n\x02\x05\0\x12\x06\xd2-\0\xd9-\x01\n\x0b\n\x03\x05\0\x01\x12\
    \x04\xd2-\x05!\n\x0c\n\x04\x05\0\x02\0\x12\x04\xd3-\x02\x0e\n\r\n\x05\
    \x05\0\x02\0\x01\x12\x04\xd3-\x02\t\n\r\n\x05\x05\0\x02\0\x02\x12\x04\
    \xd3-\x0c\r\n\x0c\n\x04\x05\0\x02\x01\x12\x04\xd4-\x02\x0e\n\r\n\x05\x05\
    \0\x02\x01\x01\x12\x04\xd4-\x02\t\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\
    \xd4-\x0c\r\n\x0c\n\x04\x05\0\x02\x02\x12\x04\xd5-\x02\x0f\n\r\n\x05\x05\
    \0\x02\x02\x01\x12\x04\xd5-\x02\n\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\
    \xd5-\r\x0e\n\x0c\n\x04\x05\0\x02\x03\x12\x04\xd6-\x02\x10\n\r\n\x05\x05\
    \0\x02\x03\x01\x12\x04\xd6-\x02\x0b\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\
    \xd6-\x0e\x0f\n\x0c\n\x04\x05\0\x02\x04\x12\x04\xd7-\x02\x0f\n\r\n\x05\
    \x05\0\x02\x04\x01\x12\x04\xd7-\x02\n\n\r\n\x05\x05\0\x02\x04\x02\x12\
    \x04\xd7-\r\x0e\n\x0c\n\x04\x05\0\x02\x05\x12\x04\xd8-\x02\x0e\n\r\n\x05\
    \x05\0\x02\x05\x01\x12\x04\xd8-\x02\t\n\r\n\x05\x05\0\x02\x05\x02\x12\
    \x04\xd8-\x0c\r\n#\n\x03\x04\xcc\x01\x12\x06\x8e.\0\x9d.\x01\x1a\x14\x20\
    GetWorkflowRequest\n\n\x0c\n\x04\x04\xcc\x01\x01\x12\x04\x8e.\x08\x1a\n\
    \r\n\x05\x04\xcc\x01\x02\0\x12\x04\x8f.\x02,\n\x0e\n\x06\x04\xcc\x01\x02\
    \0\x06\x12\x04\x8f.\x02\x1b\n\x0e\n\x06\x04\xcc\x01\x02\0\x01\x12\x04\
    \x8f.\x1c'\n\x0e\n\x06\x04\xcc\x01\x02\0\x03\x12\x04\x8f.*+\n\xc9\x01\n\
    \x05\x04\xcc\x01\x02\x01\x12\x04\x94.\x02\x19\x1a\xb9\x01\x20Workflow\
    \x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified\x20we\
    \x20return\x20default\x20workflow\x20of\x20the\x20application\n\x20If\
    \x20an\x20ID\x20is\x20specified\x20by\x20default\x20we\x20first\x20looks\
    \x20into\x20Clarifai\x20workflows\x20for\x20a\x20Workflow\x20ID\n\n\x0e\
    \n\x06\x04\xcc\x01\x02\x01\x05\x12\x04\x94.\x02\x08\n\x0e\n\x06\x04\xcc\
    \x01\x02\x01\x01\x12\x04\x94.\t\x14\n\x0e\n\x06\x04\xcc\x01\x02\x01\x03\
    \x12\x04\x94.\x17\x18\n`\n\x05\x04\xcc\x01\x02\x02\x12\x04\x97.\x02$\x1a\
    Q\x20Use\x20this\x20flag\x20to\x20look\x20into\x20clarifai\x20published\
    \x20workflows\x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\
    \xcc\x01\x02\x02\x05\x12\x04\x97.\x02\x06\n\x0e\n\x06\x04\xcc\x01\x02\
    \x02\x01\x12\x04\x97.\x07\x1f\n\x0e\n\x06\x04\xcc\x01\x02\x02\x03\x12\
    \x04\x97.\"#\n\x83\x01\n\x05\x04\xcc\x01\x02\x03\x12\x04\x99.\x02(\x1at\
    \x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\
    \x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20suppo\
    rted:\x20all,\x20stars\n\n\x0e\n\x06\x04\xcc\x01\x02\x03\x04\x12\x04\x99\
    .\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x03\x05\x12\x04\x99.\x0b\x11\n\x0e\n\
    \x06\x04\xcc\x01\x02\x03\x01\x12\x04\x99.\x12#\n\x0e\n\x06\x04\xcc\x01\
    \x02\x03\x03\x12\x04\x99.&'\nE\n\x05\x04\xcc\x01\x02\x04\x12\x04\x9c.\
    \x02&\x1a6\x20if\x20true\x20will\x20not\x20expand\x20search\x20to\x20cla\
    rifai\x20workflows\n\n\x0e\n\x06\x04\xcc\x01\x02\x04\x05\x12\x04\x9c.\
    \x02\x06\n\x0e\n\x06\x04\xcc\x01\x02\x04\x01\x12\x04\x9c.\x07!\n\x0e\n\
    \x06\x04\xcc\x01\x02\x04\x03\x12\x04\x9c.$%\n%\n\x03\x04\xcd\x01\x12\x06\
    \xa0.\0\xc9.\x01\x1a\x16\x20ListWorkflowsRequest\n\n\x0c\n\x04\x04\xcd\
    \x01\x01\x12\x04\xa0.\x08\x1c\n\r\n\x05\x04\xcd\x01\x02\0\x12\x04\xa1.\
    \x02,\n\x0e\n\x06\x04\xcd\x01\x02\0\x06\x12\x04\xa1.\x02\x1b\n\x0e\n\x06\
    \x04\xcd\x01\x02\0\x01\x12\x04\xa1.\x1c'\n\x0e\n\x06\x04\xcd\x01\x02\0\
    \x03\x12\x04\xa1.*+\n\x7f\n\x05\x04\xcd\x01\x02\x01\x12\x04\xa4.\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xcd\x01\x02\x01\x05\x12\
    \x04\xa4.\x02\x08\n\x0e\n\x06\x04\xcd\x01\x02\x01\x01\x12\x04\xa4.\t\r\n\
    \x0e\n\x06\x04\xcd\x01\x02\x01\x03\x12\x04\xa4.\x10\x11\nv\n\x05\x04\xcd\
    \x01\x02\x02\x12\x04\xa7.\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\
    \x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\
    \xcd\x01\x02\x02\x05\x12\x04\xa7.\x02\x08\n\x0e\n\x06\x04\xcd\x01\x02\
    \x02\x01\x12\x04\xa7.\t\x11\n\x0e\n\x06\x04\xcd\x01\x02\x02\x03\x12\x04\
    \xa7.\x14\x15\np\n\x05\x04\xcd\x01\x02\x03\x12\x04\xab.\x02\x1a\x1aa\x20\
    Sorting\x20options:\n\x20Whether\x20to\x20sort\x20in\x20ascending\x20ord\
    er.\x20If\x20false,\x20will\x20order\x20in\x20descending\x20order.\n\n\
    \x0e\n\x06\x04\xcd\x01\x02\x03\x05\x12\x04\xab.\x02\x06\n\x0e\n\x06\x04\
    \xcd\x01\x02\x03\x01\x12\x04\xab.\x07\x15\n\x0e\n\x06\x04\xcd\x01\x02\
    \x03\x03\x12\x04\xab.\x18\x19\n\x0f\n\x05\x04\xcd\x01\x08\0\x12\x06\xac.\
    \x02\xb6.\x03\n\x0e\n\x06\x04\xcd\x01\x08\0\x01\x12\x04\xac.\x08\x0f\n-\
    \n\x05\x04\xcd\x01\x02\x04\x12\x04\xae.\x04\x18\x1a\x1e\x20Whether\x20to\
    \x20order\x20by\x20the\x20name\n\n\x0e\n\x06\x04\xcd\x01\x02\x04\x05\x12\
    \x04\xae.\x04\x08\n\x0e\n\x06\x04\xcd\x01\x02\x04\x01\x12\x04\xae.\t\x13\
    \n\x0e\n\x06\x04\xcd\x01\x02\x04\x03\x12\x04\xae.\x16\x17\n\x81\x01\n\
    \x05\x04\xcd\x01\x02\x05\x12\x04\xb1.\x04!\x1ar\x20Whether\x20to\x20orde\
    r\x20by\x20the\x20modified_at\x20time.\n\x20If\x20none\x20of\x20the\x20s\
    ort\x20options\x20is\x20set\x20to\x20true,\x20will\x20sort\x20by\x20modi\
    fied_at.\n\n\x0e\n\x06\x04\xcd\x01\x02\x05\x05\x12\x04\xb1.\x04\x08\n\
    \x0e\n\x06\x04\xcd\x01\x02\x05\x01\x12\x04\xb1.\t\x1c\n\x0e\n\x06\x04\
    \xcd\x01\x02\x05\x03\x12\x04\xb1.\x1f\x20\n9\n\x05\x04\xcd\x01\x02\x06\
    \x12\x04\xb3.\x04!\x1a*\x20Whether\x20to\x20order\x20by\x20the\x20create\
    d_at\x20time.\n\n\x0e\n\x06\x04\xcd\x01\x02\x06\x05\x12\x04\xb3.\x04\x08\
    \n\x0e\n\x06\x04\xcd\x01\x02\x06\x01\x12\x04\xb3.\t\x1b\n\x0e\n\x06\x04\
    \xcd\x01\x02\x06\x03\x12\x04\xb3.\x1e\x20\nL\n\x05\x04\xcd\x01\x02\x07\
    \x12\x04\xb5.\x04!\x1a=\x20Whether\x20to\x20order\x20by\x20the\x20number\
    \x20of\x20users\x20stared\x20the\x20workflow\n\n\x0e\n\x06\x04\xcd\x01\
    \x02\x07\x05\x12\x04\xb5.\x04\x08\n\x0e\n\x06\x04\xcd\x01\x02\x07\x01\
    \x12\x04\xb5.\t\x1b\n\x0e\n\x06\x04\xcd\x01\x02\x07\x03\x12\x04\xb5.\x1e\
    \x20\nZ\n\x05\x04\xcd\x01\x02\x08\x12\x04\xb9.\x02\x13\x1aK\x20Query\x20\
    various\x20text\x20fields\x20that\x20can\x20contain\x20the\x20words\x20i\
    n\x20the\x20query\x20string.\n\n\x0e\n\x06\x04\xcd\x01\x02\x08\x05\x12\
    \x04\xb9.\x02\x08\n\x0e\n\x06\x04\xcd\x01\x02\x08\x01\x12\x04\xb9.\t\x0e\
    \n\x0e\n\x06\x04\xcd\x01\x02\x08\x03\x12\x04\xb9.\x11\x12\n\x9d\x01\n\
    \x05\x04\xcd\x01\x02\t\x12\x04\xbc.\x02$\x1a\x8d\x01\x20Filter\x20by\x20\
    the\x20id\x20of\x20the\x20workflow.\x20This\x20supports\x20wilcard\x20qu\
    eries\x20like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20e\
    xample.\n\x20Deprecated\x20in\x20favor\x20of\x20query\n\n\x0e\n\x06\x04\
    \xcd\x01\x02\t\x05\x12\x04\xbc.\x02\x08\n\x0e\n\x06\x04\xcd\x01\x02\t\
    \x01\x12\x04\xbc.\t\x0b\n\x0e\n\x06\x04\xcd\x01\x02\t\x03\x12\x04\xbc.\
    \x0e\x0f\n\x0e\n\x06\x04\xcd\x01\x02\t\x08\x12\x04\xbc.\x10#\n\x0f\n\x07\
    \x04\xcd\x01\x02\t\x08\x03\x12\x04\xbc.\x11\"\nX\n\x05\x04\xcd\x01\x02\n\
    \x12\x04\xbe.\x02\x19\x1aI\x20If\x20true,\x20we\x20only\x20return\x20wor\
    kflows\x20that\x20are\x20handpicked\x20by\x20clarifai\x20staff\n\n\x0e\n\
    \x06\x04\xcd\x01\x02\n\x05\x12\x04\xbe.\x02\x06\n\x0e\n\x06\x04\xcd\x01\
    \x02\n\x01\x12\x04\xbe.\x07\x14\n\x0e\n\x06\x04\xcd\x01\x02\n\x03\x12\
    \x04\xbe.\x17\x18\nZ\n\x05\x04\xcd\x01\x02\x0b\x12\x04\xc0.\x02\x19\x1aK\
    \x20If\x20true,\x20we\x20only\x20return\x20workflows\x20that\x20are\x20s\
    tarred\x20by\x20the\x20requesting\x20user\n\n\x0e\n\x06\x04\xcd\x01\x02\
    \x0b\x05\x12\x04\xc0.\x02\x06\n\x0e\n\x06\x04\xcd\x01\x02\x0b\x01\x12\
    \x04\xc0.\x07\x13\n\x0e\n\x06\x04\xcd\x01\x02\x0b\x03\x12\x04\xc0.\x16\
    \x18\n\x83\x01\n\x05\x04\xcd\x01\x02\x0c\x12\x04\xc2.\x02)\x1at\x20(opti\
    onal\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\
    \x20be\x20included\x20in\x20the\x20response.\x20Currently\x20supported:\
    \x20all,\x20stars\n\n\x0e\n\x06\x04\xcd\x01\x02\x0c\x04\x12\x04\xc2.\x02\
    \n\n\x0e\n\x06\x04\xcd\x01\x02\x0c\x05\x12\x04\xc2.\x0b\x11\n\x0e\n\x06\
    \x04\xcd\x01\x02\x0c\x01\x12\x04\xc2.\x12#\n\x0e\n\x06\x04\xcd\x01\x02\
    \x0c\x03\x12\x04\xc2.&(\n\x83\x01\n\x05\x04\xcd\x01\x02\r\x12\x04\xc5.\
    \x02\x1a\x1at\x20(optional)\x20search_term.\x20Full\x20text\x20and\x20pr\
    efix\x20matching\x20on\x20description,\x20id,\x20owner\x20id.\x20Searcha\
    ble\x20fields\x20may\x20be\x20added\n\n\x0e\n\x06\x04\xcd\x01\x02\r\x05\
    \x12\x04\xc5.\x02\x08\n\x0e\n\x06\x04\xcd\x01\x02\r\x01\x12\x04\xc5.\t\
    \x14\n\x0e\n\x06\x04\xcd\x01\x02\r\x03\x12\x04\xc5.\x17\x19\n\x82\x01\n\
    \x05\x04\xcd\x01\x02\x0e\x12\x04\xc8.\x02\x15\x1as\x20Filter\x20workflow\
    s\x20by\x20bookmark.\x20If\x20set,\x20only\x20return\x20bookmarked\x20wo\
    rkflows.\x20Otherwise\x20none\x20bookmarked\x20workflows\x20only.\n\n\
    \x0e\n\x06\x04\xcd\x01\x02\x0e\x05\x12\x04\xc8.\x02\x06\n\x0e\n\x06\x04\
    \xcd\x01\x02\x0e\x01\x12\x04\xc8.\x07\x0f\n\x0e\n\x06\x04\xcd\x01\x02\
    \x0e\x03\x12\x04\xc8.\x12\x14\n%\n\x03\x04\xce\x01\x12\x06\xcd.\0\xd0.\
    \x01\x1a\x16\x20PostWorkflowsRequest\n\n\x0c\n\x04\x04\xce\x01\x01\x12\
    \x04\xcd.\x08\x1c\n\r\n\x05\x04\xce\x01\x02\0\x12\x04\xce.\x02,\n\x0e\n\
    \x06\x04\xce\x01\x02\0\x06\x12\x04\xce.\x02\x1b\n\x0e\n\x06\x04\xce\x01\
    \x02\0\x01\x12\x04\xce.\x1c'\n\x0e\n\x06\x04\xce\x01\x02\0\x03\x12\x04\
    \xce.*+\n\r\n\x05\x04\xce\x01\x02\x01\x12\x04\xcf.\x02\"\n\x0e\n\x06\x04\
    \xce\x01\x02\x01\x04\x12\x04\xcf.\x02\n\n\x0e\n\x06\x04\xce\x01\x02\x01\
    \x06\x12\x04\xcf.\x0b\x13\n\x0e\n\x06\x04\xce\x01\x02\x01\x01\x12\x04\
    \xcf.\x14\x1d\n\x0e\n\x06\x04\xce\x01\x02\x01\x03\x12\x04\xcf.\x20!\n&\n\
    \x03\x04\xcf\x01\x12\x06\xd3.\0\xda.\x01\x1a\x17\x20PatchWorkflowsReques\
    t\n\n\x0c\n\x04\x04\xcf\x01\x01\x12\x04\xd3.\x08\x1d\n\r\n\x05\x04\xcf\
    \x01\x02\0\x12\x04\xd4.\x02,\n\x0e\n\x06\x04\xcf\x01\x02\0\x06\x12\x04\
    \xd4.\x02\x1b\n\x0e\n\x06\x04\xcf\x01\x02\0\x01\x12\x04\xd4.\x1c'\n\x0e\
    \n\x06\x04\xcf\x01\x02\0\x03\x12\x04\xd4.*+\n\r\n\x05\x04\xcf\x01\x02\
    \x01\x12\x04\xd5.\x02\"\n\x0e\n\x06\x04\xcf\x01\x02\x01\x04\x12\x04\xd5.\
    \x02\n\n\x0e\n\x06\x04\xcf\x01\x02\x01\x06\x12\x04\xd5.\x0b\x13\n\x0e\n\
    \x06\x04\xcf\x01\x02\x01\x01\x12\x04\xd5.\x14\x1d\n\x0e\n\x06\x04\xcf\
    \x01\x02\x01\x03\x12\x04\xd5.\x20!\n\x7f\n\x05\x04\xcf\x01\x02\x02\x12\
    \x04\xd9.\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwr\
    ite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\xcf\x01\
    \x02\x02\x05\x12\x04\xd9.\x02\x08\n\x0e\n\x06\x04\xcf\x01\x02\x02\x01\
    \x12\x04\xd9.\t\x0f\n\x0e\n\x06\x04\xcf\x01\x02\x02\x03\x12\x04\xd9.\x12\
    \x13\n(\n\x03\x04\xd0\x01\x12\x06\xdd.\0\xe6.\x01\x1a\x19\x20PatchWorkfl\
    owIdsRequest\n\n\x0c\n\x04\x04\xd0\x01\x01\x12\x04\xdd.\x08\x1f\n\r\n\
    \x05\x04\xd0\x01\x02\0\x12\x04\xde.\x02,\n\x0e\n\x06\x04\xd0\x01\x02\0\
    \x06\x12\x04\xde.\x02\x1b\n\x0e\n\x06\x04\xd0\x01\x02\0\x01\x12\x04\xde.\
    \x1c'\n\x0e\n\x06\x04\xd0\x01\x02\0\x03\x12\x04\xde.*+\n)\n\x05\x04\xd0\
    \x01\x02\x01\x12\x04\xe1.\x02\"\x1a\x1a\x20Array\x20containing\x201\x20e\
    ntry\n\n\x0e\n\x06\x04\xd0\x01\x02\x01\x04\x12\x04\xe1.\x02\n\n\x0e\n\
    \x06\x04\xd0\x01\x02\x01\x06\x12\x04\xe1.\x0b\x19\n\x0e\n\x06\x04\xd0\
    \x01\x02\x01\x01\x12\x04\xe1.\x1a\x1d\n\x0e\n\x06\x04\xd0\x01\x02\x01\
    \x03\x12\x04\xe1.\x20!\n\\\n\x05\x04\xd0\x01\x02\x02\x12\x04\xe5.\x02\
    \x14\x1aM\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20o\
    bjects\n\x20Only\x20'overwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\xd0\
    \x01\x02\x02\x05\x12\x04\xe5.\x02\x08\n\x0e\n\x06\x04\xd0\x01\x02\x02\
    \x01\x12\x04\xe5.\t\x0f\n\x0e\n\x06\x04\xd0\x01\x02\x02\x03\x12\x04\xe5.\
    \x12\x13\n&\n\x03\x04\xd1\x01\x12\x06\xe9.\0\xec.\x01\x1a\x17\x20DeleteW\
    orkflowRequest\n\n\x0c\n\x04\x04\xd1\x01\x01\x12\x04\xe9.\x08\x1d\n\r\n\
    \x05\x04\xd1\x01\x02\0\x12\x04\xea.\x02,\n\x0e\n\x06\x04\xd1\x01\x02\0\
    \x06\x12\x04\xea.\x02\x1b\n\x0e\n\x06\x04\xd1\x01\x02\0\x01\x12\x04\xea.\
    \x1c'\n\x0e\n\x06\x04\xd1\x01\x02\0\x03\x12\x04\xea.*+\n\r\n\x05\x04\xd1\
    \x01\x02\x01\x12\x04\xeb.\x02\x19\n\x0e\n\x06\x04\xd1\x01\x02\x01\x05\
    \x12\x04\xeb.\x02\x08\n\x0e\n\x06\x04\xd1\x01\x02\x01\x01\x12\x04\xeb.\t\
    \x14\n\x0e\n\x06\x04\xd1\x01\x02\x01\x03\x12\x04\xeb.\x17\x18\nE\n\x03\
    \x04\xd2\x01\x12\x06\xef.\0\xf3.\x01\x1a6\x20Request\x20to\x20delete\x20\
    several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\
    \xd2\x01\x01\x12\x04\xef.\x08\x1e\n\r\n\x05\x04\xd2\x01\x02\0\x12\x04\
    \xf0.\x02,\n\x0e\n\x06\x04\xd2\x01\x02\0\x06\x12\x04\xf0.\x02\x1b\n\x0e\
    \n\x06\x04\xd2\x01\x02\0\x01\x12\x04\xf0.\x1c'\n\x0e\n\x06\x04\xd2\x01\
    \x02\0\x03\x12\x04\xf0.*+\n\r\n\x05\x04\xd2\x01\x02\x01\x12\x04\xf1.\x02\
    \x1a\n\x0e\n\x06\x04\xd2\x01\x02\x01\x04\x12\x04\xf1.\x02\n\n\x0e\n\x06\
    \x04\xd2\x01\x02\x01\x05\x12\x04\xf1.\x0b\x11\n\x0e\n\x06\x04\xd2\x01\
    \x02\x01\x01\x12\x04\xf1.\x12\x15\n\x0e\n\x06\x04\xd2\x01\x02\x01\x03\
    \x12\x04\xf1.\x18\x19\n\r\n\x05\x04\xd2\x01\x02\x02\x12\x04\xf2.\x02\x16\
    \n\x0e\n\x06\x04\xd2\x01\x02\x02\x05\x12\x04\xf2.\x02\x06\n\x0e\n\x06\
    \x04\xd2\x01\x02\x02\x01\x12\x04\xf2.\x07\x11\n\x0e\n\x06\x04\xd2\x01\
    \x02\x02\x03\x12\x04\xf2.\x14\x15\n'\n\x03\x04\xd3\x01\x12\x06\xf6.\0\
    \xf9.\x01\x1a\x18\x20SingleWorkflowResponse\n\n\x0c\n\x04\x04\xd3\x01\
    \x01\x12\x04\xf6.\x08\x1e\n\r\n\x05\x04\xd3\x01\x02\0\x12\x04\xf7.\x02(\
    \n\x0e\n\x06\x04\xd3\x01\x02\0\x06\x12\x04\xf7.\x02\x1c\n\x0e\n\x06\x04\
    \xd3\x01\x02\0\x01\x12\x04\xf7.\x1d#\n\x0e\n\x06\x04\xd3\x01\x02\0\x03\
    \x12\x04\xf7.&'\n\r\n\x05\x04\xd3\x01\x02\x01\x12\x04\xf8.\x02\x18\n\x0e\
    \n\x06\x04\xd3\x01\x02\x01\x06\x12\x04\xf8.\x02\n\n\x0e\n\x06\x04\xd3\
    \x01\x02\x01\x01\x12\x04\xf8.\x0b\x13\n\x0e\n\x06\x04\xd3\x01\x02\x01\
    \x03\x12\x04\xf8.\x16\x17\n&\n\x03\x04\xd4\x01\x12\x06\xfc.\0\xff.\x01\
    \x1a\x17\x20MultiWorkflowResponse\n\n\x0c\n\x04\x04\xd4\x01\x01\x12\x04\
    \xfc.\x08\x1d\n\r\n\x05\x04\xd4\x01\x02\0\x12\x04\xfd.\x02(\n\x0e\n\x06\
    \x04\xd4\x01\x02\0\x06\x12\x04\xfd.\x02\x1c\n\x0e\n\x06\x04\xd4\x01\x02\
    \0\x01\x12\x04\xfd.\x1d#\n\x0e\n\x06\x04\xd4\x01\x02\0\x03\x12\x04\xfd.&\
    '\n\r\n\x05\x04\xd4\x01\x02\x01\x12\x04\xfe.\x02Q\n\x0e\n\x06\x04\xd4\
    \x01\x02\x01\x04\x12\x04\xfe.\x02\n\n\x0e\n\x06\x04\xd4\x01\x02\x01\x06\
    \x12\x04\xfe.\x0b\x13\n\x0e\n\x06\x04\xd4\x01\x02\x01\x01\x12\x04\xfe.\
    \x14\x1d\n\x0e\n\x06\x04\xd4\x01\x02\x01\x03\x12\x04\xfe.\x20!\n\x0e\n\
    \x06\x04\xd4\x01\x02\x01\x08\x12\x04\xfe.\"P\n\x11\n\t\x04\xd4\x01\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xfe.#O\n+\n\x03\x04\xd5\x01\x12\x06\x82/\0\
    \x9e/\x01\x1a\x1c\x20PostWorkflowResultsRequest\n\n\x0c\n\x04\x04\xd5\
    \x01\x01\x12\x04\x82/\x08\"\n\r\n\x05\x04\xd5\x01\x02\0\x12\x04\x83/\x02\
    ,\n\x0e\n\x06\x04\xd5\x01\x02\0\x06\x12\x04\x83/\x02\x1b\n\x0e\n\x06\x04\
    \xd5\x01\x02\0\x01\x12\x04\x83/\x1c'\n\x0e\n\x06\x04\xd5\x01\x02\0\x03\
    \x12\x04\x83/*+\n\xc9\x01\n\x05\x04\xd5\x01\x02\x01\x12\x04\x88/\x02\x19\
    \x1a\xb9\x01\x20Workflow\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20\
    is\x20specified\x20we\x20return\x20default\x20workflow\x20of\x20the\x20a\
    pplication\n\x20If\x20an\x20ID\x20is\x20specified\x20by\x20default\x20we\
    \x20first\x20looks\x20into\x20Clarifai\x20workflows\x20for\x20a\x20Workf\
    low\x20ID\n\n\x0e\n\x06\x04\xd5\x01\x02\x01\x05\x12\x04\x88/\x02\x08\n\
    \x0e\n\x06\x04\xd5\x01\x02\x01\x01\x12\x04\x88/\t\x14\n\x0e\n\x06\x04\
    \xd5\x01\x02\x01\x03\x12\x04\x88/\x17\x18\nh\n\x05\x04\xd5\x01\x02\x02\
    \x12\x04\x8c/\x02\x18\x1aY\x20Workflow\x20version\x20ID\x20to\x20retriev\
    e\n\x20If\x20no\x20ID\x20is\x20specified,\x20latest\x20workflow\x20versi\
    on\x20is\x20used\n\n\x0e\n\x06\x04\xd5\x01\x02\x02\x05\x12\x04\x8c/\x02\
    \x08\n\x0e\n\x06\x04\xd5\x01\x02\x02\x01\x12\x04\x8c/\t\x13\n\x0e\n\x06\
    \x04\xd5\x01\x02\x02\x03\x12\x04\x8c/\x16\x17\n\r\n\x05\x04\xd5\x01\x02\
    \x03\x12\x04\x8e/\x02\x1c\n\x0e\n\x06\x04\xd5\x01\x02\x03\x04\x12\x04\
    \x8e/\x02\n\n\x0e\n\x06\x04\xd5\x01\x02\x03\x06\x12\x04\x8e/\x0b\x10\n\
    \x0e\n\x06\x04\xd5\x01\x02\x03\x01\x12\x04\x8e/\x11\x17\n\x0e\n\x06\x04\
    \xd5\x01\x02\x03\x03\x12\x04\x8e/\x1a\x1b\n\xb4\x04\n\x05\x04\xd5\x01\
    \x02\x04\x12\x04\x95/\x02!\x1a\xa4\x04\x20FIXME(zeiler):\x20the\x20reque\
    st\x20for\x20post\x20workflows\x20is\x20using\x20an\x20outputconfig\x20o\
    bject\x20that\x20is\x20supposed\n\x20to\x20be\x20within\x20models.\x20Th\
    is\x20is\x20not\x20consistent\x20with\x20setting\x20this\x20on\x20the\
    \x20request\x20for\x20post\x20model\n\x20outputs\x20where\x20it\x20is\
    \x20inside\x20a\x20model\x20object.\x20To\x20make\x20this\x20consistent\
    \x20we\x20would\x20send\x20in\x20the\n\x20workflow\x20object\x20so\x20th\
    at\x20each\x20model\x20can\x20have\x20it's\x20own\x20output\x20config.\
    \x20If\x20nobody\x20is\x20setting\n\x20this\x20OutputConfig\x20it\x20wou\
    ld\x20probably\x20be\x20easier\x20to\x20just\x20remove\x20it\x20for\x20n\
    ow\x20to\x20keep\x20things\x20simpler\n\x20and\x20then\x20it's\x20more\
    \x20consistent\x20we\x20just\x20don't\x20support\x20the\x20OutputConfig\
    \x20on\x20workflows.\n\n\x0e\n\x06\x04\xd5\x01\x02\x04\x06\x12\x04\x95/\
    \x02\x0e\n\x0e\n\x06\x04\xd5\x01\x02\x04\x01\x12\x04\x95/\x0f\x1c\n\x0e\
    \n\x06\x04\xd5\x01\x02\x04\x03\x12\x04\x95/\x1f\x20\n`\n\x05\x04\xd5\x01\
    \x02\x05\x12\x04\x98/\x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\x20\
    into\x20clarifai\x20published\x20workflows\x20first\x20for\x20a\x20Workf\
    low\x20ID\n\n\x0e\n\x06\x04\xd5\x01\x02\x05\x05\x12\x04\x98/\x02\x06\n\
    \x0e\n\x06\x04\xd5\x01\x02\x05\x01\x12\x04\x98/\x07\x1f\n\x0e\n\x06\x04\
    \xd5\x01\x02\x05\x03\x12\x04\x98/\"#\n\xf5\x01\n\x05\x04\xd5\x01\x02\x06\
    \x12\x04\x9d/\x02#\x1a\xe5\x01\x20A\x20workflow\x20state\x20to\x20be\x20\
    maintained\x20across\x20PostWorkflowResults\x20requests/responses.\n\x20\
    If\x20it\x20is\x20not\x20sent\x20in\x20the\x20initial\x20request\x20with\
    \x20workflow_state.id\x20=\x20\"init\"\x20then\x20no\n\x20state\x20will\
    \x20be\x20saved\x20or\x20returned\x20in\x20PostWorkflowResultsResponse.\
    \n\n\x0e\n\x06\x04\xd5\x01\x02\x06\x06\x12\x04\x9d/\x02\x0f\n\x0e\n\x06\
    \x04\xd5\x01\x02\x06\x01\x12\x04\x9d/\x10\x1e\n\x0e\n\x06\x04\xd5\x01\
    \x02\x06\x03\x12\x04\x9d/!\"\n,\n\x03\x04\xd6\x01\x12\x06\xa1/\0\xae/\
    \x01\x1a\x1d\x20PostWorkflowResultsResponse\n\n\x0c\n\x04\x04\xd6\x01\
    \x01\x12\x04\xa1/\x08#\n+\n\x05\x04\xd6\x01\x02\0\x12\x04\xa3/\x02(\x1a\
    \x1c\x20The\x20status\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xd6\x01\
    \x02\0\x06\x12\x04\xa3/\x02\x1c\n\x0e\n\x06\x04\xd6\x01\x02\0\x01\x12\
    \x04\xa3/\x1d#\n\x0e\n\x06\x04\xd6\x01\x02\0\x03\x12\x04\xa3/&'\nS\n\x05\
    \x04\xd6\x01\x02\x01\x12\x04\xa5/\x02\x18\x1aD\x20The\x20workflow\x20tha\
    t\x20was\x20used\x20in\x20predictions\x20with\x20PostWorkflowResults\n\n\
    \x0e\n\x06\x04\xd6\x01\x02\x01\x06\x12\x04\xa5/\x02\n\n\x0e\n\x06\x04\
    \xd6\x01\x02\x01\x01\x12\x04\xa5/\x0b\x13\n\x0e\n\x06\x04\xd6\x01\x02\
    \x01\x03\x12\x04\xa5/\x16\x17\nI\n\x05\x04\xd6\x01\x02\x02\x12\x04\xa7/\
    \x02&\x1a:\x20The\x20resulting\x20predictions\x20of\x20all\x20models\x20\
    in\x20the\x20workflow.\n\n\x0e\n\x06\x04\xd6\x01\x02\x02\x04\x12\x04\xa7\
    /\x02\n\n\x0e\n\x06\x04\xd6\x01\x02\x02\x06\x12\x04\xa7/\x0b\x19\n\x0e\n\
    \x06\x04\xd6\x01\x02\x02\x01\x12\x04\xa7/\x1a!\n\x0e\n\x06\x04\xd6\x01\
    \x02\x02\x03\x12\x04\xa7/$%\n\xd3\x02\n\x05\x04\xd6\x01\x02\x03\x12\x04\
    \xad/\x02#\x1a\xc3\x02\x20A\x20workflow\x20state\x20to\x20be\x20maintain\
    ed\x20across\x20PostWorkflowResults\x20requests/responses.\n\x20This\x20\
    WorkflowState\x20should\x20be\x20passed\x20in\x20to\x20subsequent\x20Pos\
    tWorkflowResults\x20calls\n\x20if\x20you\x20want\x20to\x20keep\x20track\
    \x20of\x20state\x20across\x20requests.\n\x20If\x20no\x20WorkflowState\
    \x20was\x20initialized\x20in\x20a\x20request\x20then\x20no\x20WorkflowSt\
    ate\x20will\x20be\x20returned\x20in\x20this\n\x20response.\n\n\x0e\n\x06\
    \x04\xd6\x01\x02\x03\x06\x12\x04\xad/\x02\x0f\n\x0e\n\x06\x04\xd6\x01\
    \x02\x03\x01\x12\x04\xad/\x10\x1e\n\x0e\n\x06\x04\xd6\x01\x02\x03\x03\
    \x12\x04\xad/!\"\n5\n\x03\x04\xd7\x01\x12\x06\xb1/\0\xbf/\x01\x1a&\x20Po\
    stWorkflowResultsSimilarityRequest\n\n\x0c\n\x04\x04\xd7\x01\x01\x12\x04\
    \xb1/\x08,\n\r\n\x05\x04\xd7\x01\x02\0\x12\x04\xb2/\x02,\n\x0e\n\x06\x04\
    \xd7\x01\x02\0\x06\x12\x04\xb2/\x02\x1b\n\x0e\n\x06\x04\xd7\x01\x02\0\
    \x01\x12\x04\xb2/\x1c'\n\x0e\n\x06\x04\xd7\x01\x02\0\x03\x12\x04\xb2/*+\
    \n\r\n\x05\x04\xd7\x01\x02\x01\x12\x04\xb3/\x02\x19\n\x0e\n\x06\x04\xd7\
    \x01\x02\x01\x05\x12\x04\xb3/\x02\x08\n\x0e\n\x06\x04\xd7\x01\x02\x01\
    \x01\x12\x04\xb3/\t\x14\n\x0e\n\x06\x04\xd7\x01\x02\x01\x03\x12\x04\xb3/\
    \x17\x18\nh\n\x05\x04\xd7\x01\x02\x02\x12\x04\xb6/\x02\x18\x1aY\x20Workf\
    low\x20version\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20spec\
    ified,\x20latest\x20workflow\x20version\x20is\x20used\n\n\x0e\n\x06\x04\
    \xd7\x01\x02\x02\x05\x12\x04\xb6/\x02\x08\n\x0e\n\x06\x04\xd7\x01\x02\
    \x02\x01\x12\x04\xb6/\t\x13\n\x0e\n\x06\x04\xd7\x01\x02\x02\x03\x12\x04\
    \xb6/\x16\x17\nJ\n\x05\x04\xd7\x01\x02\x03\x12\x04\xb8/\x02\x1e\x1a;\x20\
    The\x20specific\x20model\x20version\x20whose\x20outputs\x20we\x20are\x20\
    comparing\n\n\x0e\n\x06\x04\xd7\x01\x02\x03\x05\x12\x04\xb8/\x02\x08\n\
    \x0e\n\x06\x04\xd7\x01\x02\x03\x01\x12\x04\xb8/\t\x19\n\x0e\n\x06\x04\
    \xd7\x01\x02\x03\x03\x12\x04\xb8/\x1c\x1d\n@\n\x05\x04\xd7\x01\x02\x04\
    \x12\x04\xba/\x02\"\x1a1\x20Each\x20probe\x20is\x20compared\x20against\
    \x20every\x20pool\x20input\n\n\x0e\n\x06\x04\xd7\x01\x02\x04\x04\x12\x04\
    \xba/\x02\n\n\x0e\n\x06\x04\xd7\x01\x02\x04\x06\x12\x04\xba/\x0b\x10\n\
    \x0e\n\x06\x04\xd7\x01\x02\x04\x01\x12\x04\xba/\x11\x1d\n\x0e\n\x06\x04\
    \xd7\x01\x02\x04\x03\x12\x04\xba/\x20!\nE\n\x05\x04\xd7\x01\x02\x05\x12\
    \x04\xbc/\x02!\x1a6\x20Each\x20pool\x20input\x20is\x20compared\x20agains\
    t\x20ever\x20probe\x20input\n\n\x0e\n\x06\x04\xd7\x01\x02\x05\x04\x12\
    \x04\xbc/\x02\n\n\x0e\n\x06\x04\xd7\x01\x02\x05\x06\x12\x04\xbc/\x0b\x10\
    \n\x0e\n\x06\x04\xd7\x01\x02\x05\x01\x12\x04\xbc/\x11\x1c\n\x0e\n\x06\
    \x04\xd7\x01\x02\x05\x03\x12\x04\xbc/\x1f\x20\n`\n\x05\x04\xd7\x01\x02\
    \x06\x12\x04\xbe/\x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\x20into\
    \x20clarifai\x20published\x20workflows\x20first\x20for\x20a\x20Workflow\
    \x20ID\n\n\x0e\n\x06\x04\xd7\x01\x02\x06\x05\x12\x04\xbe/\x02\x06\n\x0e\
    \n\x06\x04\xd7\x01\x02\x06\x01\x12\x04\xbe/\x07\x1f\n\x0e\n\x06\x04\xd7\
    \x01\x02\x06\x03\x12\x04\xbe/\"#\n6\n\x03\x04\xd8\x01\x12\x06\xc2/\0\xc5\
    /\x01\x1a'\x20PostWorkflowResultsSimilarityResponse\n\n\x0c\n\x04\x04\
    \xd8\x01\x01\x12\x04\xc2/\x08-\n\r\n\x05\x04\xd8\x01\x02\0\x12\x04\xc3/\
    \x02(\n\x0e\n\x06\x04\xd8\x01\x02\0\x06\x12\x04\xc3/\x02\x1c\n\x0e\n\x06\
    \x04\xd8\x01\x02\0\x01\x12\x04\xc3/\x1d#\n\x0e\n\x06\x04\xd8\x01\x02\0\
    \x03\x12\x04\xc3/&'\n\r\n\x05\x04\xd8\x01\x02\x01\x12\x04\xc4/\x021\n\
    \x0e\n\x06\x04\xd8\x01\x02\x01\x04\x12\x04\xc4/\x02\n\n\x0e\n\x06\x04\
    \xd8\x01\x02\x01\x06\x12\x04\xc4/\x0b$\n\x0e\n\x06\x04\xd8\x01\x02\x01\
    \x01\x12\x04\xc4/%,\n\x0e\n\x06\x04\xd8\x01\x02\x01\x03\x12\x04\xc4//0\n\
    ,\n\x03\x04\xd9\x01\x12\x06\xc8/\0\xd2/\x01\x1a\x1d\x20ListWorkflowVersi\
    onsRequest\n\n\x0c\n\x04\x04\xd9\x01\x01\x12\x04\xc8/\x08#\n\r\n\x05\x04\
    \xd9\x01\x02\0\x12\x04\xc9/\x02,\n\x0e\n\x06\x04\xd9\x01\x02\0\x06\x12\
    \x04\xc9/\x02\x1b\n\x0e\n\x06\x04\xd9\x01\x02\0\x01\x12\x04\xc9/\x1c'\n\
    \x0e\n\x06\x04\xd9\x01\x02\0\x03\x12\x04\xc9/*+\nE\n\x05\x04\xd9\x01\x02\
    \x01\x12\x04\xcb/\x02\x19\x1a6\x20List\x20versions\x20for\x20the\x20work\
    flow\x20identified\x20by\x20this\x20id\n\n\x0e\n\x06\x04\xd9\x01\x02\x01\
    \x05\x12\x04\xcb/\x02\x08\n\x0e\n\x06\x04\xd9\x01\x02\x01\x01\x12\x04\
    \xcb/\t\x14\n\x0e\n\x06\x04\xd9\x01\x02\x01\x03\x12\x04\xcb/\x17\x18\n\
    \x7f\n\x05\x04\xd9\x01\x02\x02\x12\x04\xce/\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xd9\x01\x02\x02\x05\x12\x04\xce/\x02\x08\
    \n\x0e\n\x06\x04\xd9\x01\x02\x02\x01\x12\x04\xce/\t\r\n\x0e\n\x06\x04\
    \xd9\x01\x02\x02\x03\x12\x04\xce/\x10\x11\nv\n\x05\x04\xd9\x01\x02\x03\
    \x12\x04\xd1/\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xd9\x01\x02\x03\
    \x05\x12\x04\xd1/\x02\x08\n\x0e\n\x06\x04\xd9\x01\x02\x03\x01\x12\x04\
    \xd1/\t\x11\n\x0e\n\x06\x04\xd9\x01\x02\x03\x03\x12\x04\xd1/\x14\x15\n*\
    \n\x03\x04\xda\x01\x12\x06\xd5/\0\xdb/\x01\x1a\x1b\x20GetWorkflowVersion\
    Request\n\n\x0c\n\x04\x04\xda\x01\x01\x12\x04\xd5/\x08!\n\r\n\x05\x04\
    \xda\x01\x02\0\x12\x04\xd6/\x04.\n\x0e\n\x06\x04\xda\x01\x02\0\x06\x12\
    \x04\xd6/\x04\x1d\n\x0e\n\x06\x04\xda\x01\x02\0\x01\x12\x04\xd6/\x1e)\n\
    \x0e\n\x06\x04\xda\x01\x02\0\x03\x12\x04\xd6/,-\nG\n\x05\x04\xda\x01\x02\
    \x01\x12\x04\xd8/\x04\x1b\x1a8\x20The\x20id\x20of\x20the\x20workflow\x20\
    that\x20has\x20the\x20requested\x20version.\n\n\x0e\n\x06\x04\xda\x01\
    \x02\x01\x05\x12\x04\xd8/\x04\n\n\x0e\n\x06\x04\xda\x01\x02\x01\x01\x12\
    \x04\xd8/\x0b\x16\n\x0e\n\x06\x04\xda\x01\x02\x01\x03\x12\x04\xd8/\x19\
    \x1a\n.\n\x05\x04\xda\x01\x02\x02\x12\x04\xda/\x04#\x1a\x1f\x20Get\x20th\
    e\x20identified\x20by\x20this\x20id\n\n\x0e\n\x06\x04\xda\x01\x02\x02\
    \x05\x12\x04\xda/\x04\n\n\x0e\n\x06\x04\xda\x01\x02\x02\x01\x12\x04\xda/\
    \x0b\x1e\n\x0e\n\x06\x04\xda\x01\x02\x02\x03\x12\x04\xda/!\"\n.\n\x03\
    \x04\xdb\x01\x12\x06\xde/\0\xe4/\x01\x1a\x1f\x20DeleteWorkflowVersionsRe\
    quest\n\n\x0c\n\x04\x04\xdb\x01\x01\x12\x04\xde/\x08%\n\r\n\x05\x04\xdb\
    \x01\x02\0\x12\x04\xdf/\x04.\n\x0e\n\x06\x04\xdb\x01\x02\0\x06\x12\x04\
    \xdf/\x04\x1d\n\x0e\n\x06\x04\xdb\x01\x02\0\x01\x12\x04\xdf/\x1e)\n\x0e\
    \n\x06\x04\xdb\x01\x02\0\x03\x12\x04\xdf/,-\nR\n\x05\x04\xdb\x01\x02\x01\
    \x12\x04\xe1/\x04\x1b\x1aC\x20The\x20id\x20of\x20the\x20workflow\x20that\
    \x20has\x20the\x20requested\x20versions\x20to\x20delete.\n\n\x0e\n\x06\
    \x04\xdb\x01\x02\x01\x05\x12\x04\xe1/\x04\n\n\x0e\n\x06\x04\xdb\x01\x02\
    \x01\x01\x12\x04\xe1/\x0b\x16\n\x0e\n\x06\x04\xdb\x01\x02\x01\x03\x12\
    \x04\xe1/\x19\x1a\n<\n\x05\x04\xdb\x01\x02\x02\x12\x04\xe3/\x04-\x1a-\
    \x20Delete\x20the\x20versions\x20identified\x20by\x20these\x20ids\n\n\
    \x0e\n\x06\x04\xdb\x01\x02\x02\x04\x12\x04\xe3/\x04\x0c\n\x0e\n\x06\x04\
    \xdb\x01\x02\x02\x05\x12\x04\xe3/\r\x13\n\x0e\n\x06\x04\xdb\x01\x02\x02\
    \x01\x12\x04\xe3/\x14(\n\x0e\n\x06\x04\xdb\x01\x02\x02\x03\x12\x04\xe3/+\
    ,\n-\n\x03\x04\xdc\x01\x12\x06\xe7/\0\xf0/\x01\x1a\x1e\x20PatchWorkflowV\
    ersionsRequest\n\n\x0c\n\x04\x04\xdc\x01\x01\x12\x04\xe7/\x08$\n\r\n\x05\
    \x04\xdc\x01\x02\0\x12\x04\xe8/\x04.\n\x0e\n\x06\x04\xdc\x01\x02\0\x06\
    \x12\x04\xe8/\x04\x1d\n\x0e\n\x06\x04\xdc\x01\x02\0\x01\x12\x04\xe8/\x1e\
    )\n\x0e\n\x06\x04\xdc\x01\x02\0\x03\x12\x04\xe8/,-\nQ\n\x05\x04\xdc\x01\
    \x02\x01\x12\x04\xea/\x04\x1b\x1aB\x20The\x20id\x20of\x20the\x20workflow\
    \x20that\x20has\x20the\x20requested\x20versions\x20to\x20patch.\n\n\x0e\
    \n\x06\x04\xdc\x01\x02\x01\x05\x12\x04\xea/\x04\n\n\x0e\n\x06\x04\xdc\
    \x01\x02\x01\x01\x12\x04\xea/\x0b\x16\n\x0e\n\x06\x04\xdc\x01\x02\x01\
    \x03\x12\x04\xea/\x19\x1a\n&\n\x05\x04\xdc\x01\x02\x02\x12\x04\xec/\x043\
    \x1a\x17\x20Patch\x20these\x20versions.\n\n\x0e\n\x06\x04\xdc\x01\x02\
    \x02\x04\x12\x04\xec/\x04\x0c\n\x0e\n\x06\x04\xdc\x01\x02\x02\x06\x12\
    \x04\xec/\r\x1c\n\x0e\n\x06\x04\xdc\x01\x02\x02\x01\x12\x04\xec/\x1d.\n\
    \x0e\n\x06\x04\xdc\x01\x02\x02\x03\x12\x04\xec/12\n\x7f\n\x05\x04\xdc\
    \x01\x02\x03\x12\x04\xef/\x04\x16\x1ap\x20The\x20action\x20to\x20perform\
    \x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge\
    ',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\
    \x04\xdc\x01\x02\x03\x05\x12\x04\xef/\x04\n\n\x0e\n\x06\x04\xdc\x01\x02\
    \x03\x01\x12\x04\xef/\x0b\x11\n\x0e\n\x06\x04\xdc\x01\x02\x03\x03\x12\
    \x04\xef/\x14\x15\n-\n\x03\x04\xdd\x01\x12\x06\xf3/\0\xf6/\x01\x1a\x1e\
    \x20MultiWorkflowVersionResponse\n\n\x0c\n\x04\x04\xdd\x01\x01\x12\x04\
    \xf3/\x08$\n\r\n\x05\x04\xdd\x01\x02\0\x12\x04\xf4/\x04*\n\x0e\n\x06\x04\
    \xdd\x01\x02\0\x06\x12\x04\xf4/\x04\x1e\n\x0e\n\x06\x04\xdd\x01\x02\0\
    \x01\x12\x04\xf4/\x1f%\n\x0e\n\x06\x04\xdd\x01\x02\0\x03\x12\x04\xf4/()\
    \n\r\n\x05\x04\xdd\x01\x02\x01\x12\x04\xf5/\x04b\n\x0e\n\x06\x04\xdd\x01\
    \x02\x01\x04\x12\x04\xf5/\x04\x0c\n\x0e\n\x06\x04\xdd\x01\x02\x01\x06\
    \x12\x04\xf5/\r\x1c\n\x0e\n\x06\x04\xdd\x01\x02\x01\x01\x12\x04\xf5/\x1d\
    .\n\x0e\n\x06\x04\xdd\x01\x02\x01\x03\x12\x04\xf5/12\n\x0e\n\x06\x04\xdd\
    \x01\x02\x01\x08\x12\x04\xf5/3a\n\x11\n\t\x04\xdd\x01\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xf5/4`\n.\n\x03\x04\xde\x01\x12\x06\xf9/\0\xfc/\x01\x1a\
    \x1f\x20SingleWorkflowVersionResponse\n\n\x0c\n\x04\x04\xde\x01\x01\x12\
    \x04\xf9/\x08%\n\r\n\x05\x04\xde\x01\x02\0\x12\x04\xfa/\x04*\n\x0e\n\x06\
    \x04\xde\x01\x02\0\x06\x12\x04\xfa/\x04\x1e\n\x0e\n\x06\x04\xde\x01\x02\
    \0\x01\x12\x04\xfa/\x1f%\n\x0e\n\x06\x04\xde\x01\x02\0\x03\x12\x04\xfa/(\
    )\n\r\n\x05\x04\xde\x01\x02\x01\x12\x04\xfb/\x04)\n\x0e\n\x06\x04\xde\
    \x01\x02\x01\x06\x12\x04\xfb/\x04\x13\n\x0e\n\x06\x04\xde\x01\x02\x01\
    \x01\x12\x04\xfb/\x14$\n\x0e\n\x06\x04\xde\x01\x02\x01\x03\x12\x04\xfb/'\
    (\n:\n\x03\x04\xdf\x01\x12\x06\x870\0\x8a0\x01\x1a+Request\x20to\x20star\
    t\x20a\x20app\x20duplication\x20process\n\n\x0c\n\x04\x04\xdf\x01\x01\
    \x12\x04\x870\x08\"\n\r\n\x05\x04\xdf\x01\x02\0\x12\x04\x880\x02,\n\x0e\
    \n\x06\x04\xdf\x01\x02\0\x06\x12\x04\x880\x02\x1b\n\x0e\n\x06\x04\xdf\
    \x01\x02\0\x01\x12\x04\x880\x1c'\n\x0e\n\x06\x04\xdf\x01\x02\0\x03\x12\
    \x04\x880*+\n\r\n\x05\x04\xdf\x01\x02\x01\x12\x04\x890\x02/\n\x0e\n\x06\
    \x04\xdf\x01\x02\x01\x04\x12\x04\x890\x02\n\n\x0e\n\x06\x04\xdf\x01\x02\
    \x01\x06\x12\x04\x890\x0b\x19\n\x0e\n\x06\x04\xdf\x01\x02\x01\x01\x12\
    \x04\x890\x1a*\n\x0e\n\x06\x04\xdf\x01\x02\x01\x03\x12\x04\x890-.\n7\n\
    \x03\x04\xe0\x01\x12\x06\x8d0\0\x910\x01\x1a(Request\x20to\x20check\x20a\
    pp\x20duplication\x20status\n\n\x0c\n\x04\x04\xe0\x01\x01\x12\x04\x8d0\
    \x08\x20\n\r\n\x05\x04\xe0\x01\x02\0\x12\x04\x8e0\x02,\n\x0e\n\x06\x04\
    \xe0\x01\x02\0\x06\x12\x04\x8e0\x02\x1b\n\x0e\n\x06\x04\xe0\x01\x02\0\
    \x01\x12\x04\x8e0\x1c'\n\x0e\n\x06\x04\xe0\x01\x02\0\x03\x12\x04\x8e0*+\
    \n&\n\x05\x04\xe0\x01\x02\x01\x12\x04\x900\x02\x20\x1a\x17The\x20app\x20\
    duplication\x20id\n\n\x0e\n\x06\x04\xe0\x01\x02\x01\x05\x12\x04\x900\x02\
    \x08\n\x0e\n\x06\x04\xe0\x01\x02\x01\x01\x12\x04\x900\t\x1b\n\x0e\n\x06\
    \x04\xe0\x01\x02\x01\x03\x12\x04\x900\x1e\x1f\nL\n\x03\x04\xe1\x01\x12\
    \x06\x940\0\x9c0\x01\x1a=Request\x20to\x20list\x20all\x20the\x20app\x20d\
    uplication\x20that\x20user\x20triggered.\n\n\x0c\n\x04\x04\xe1\x01\x01\
    \x12\x04\x940\x08\"\n\r\n\x05\x04\xe1\x01\x02\0\x12\x04\x950\x02,\n\x0e\
    \n\x06\x04\xe1\x01\x02\0\x06\x12\x04\x950\x02\x1b\n\x0e\n\x06\x04\xe1\
    \x01\x02\0\x01\x12\x04\x950\x1c'\n\x0e\n\x06\x04\xe1\x01\x02\0\x03\x12\
    \x04\x950*+\n\x7f\n\x05\x04\xe1\x01\x02\x01\x12\x04\x980\x02\x12\x1ap\
    \x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginati\
    on\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xe1\x01\x02\x01\x05\x12\x04\
    \x980\x02\x08\n\x0e\n\x06\x04\xe1\x01\x02\x01\x01\x12\x04\x980\t\r\n\x0e\
    \n\x06\x04\xe1\x01\x02\x01\x03\x12\x04\x980\x10\x11\nv\n\x05\x04\xe1\x01\
    \x02\x02\x12\x04\x9b0\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xe1\x01\
    \x02\x02\x05\x12\x04\x9b0\x02\x08\n\x0e\n\x06\x04\xe1\x01\x02\x02\x01\
    \x12\x04\x9b0\t\x11\n\x0e\n\x06\x04\xe1\x01\x02\x02\x03\x12\x04\x9b0\x14\
    \x15\n-\n\x03\x04\xe2\x01\x12\x06\x9f0\0\xa20\x01\x1a\x1e\x20MultiAppDup\
    licationsResponse\n\n\x0c\n\x04\x04\xe2\x01\x01\x12\x04\x9f0\x08$\n\r\n\
    \x05\x04\xe2\x01\x02\0\x12\x04\xa00\x02(\n\x0e\n\x06\x04\xe2\x01\x02\0\
    \x06\x12\x04\xa00\x02\x1c\n\x0e\n\x06\x04\xe2\x01\x02\0\x01\x12\x04\xa00\
    \x1d#\n\x0e\n\x06\x04\xe2\x01\x02\0\x03\x12\x04\xa00&'\n\r\n\x05\x04\xe2\
    \x01\x02\x01\x12\x04\xa10\x02/\n\x0e\n\x06\x04\xe2\x01\x02\x01\x04\x12\
    \x04\xa10\x02\n\n\x0e\n\x06\x04\xe2\x01\x02\x01\x06\x12\x04\xa10\x0b\x19\
    \n\x0e\n\x06\x04\xe2\x01\x02\x01\x01\x12\x04\xa10\x1a*\n\x0e\n\x06\x04\
    \xe2\x01\x02\x01\x03\x12\x04\xa10-.\n-\n\x03\x04\xe3\x01\x12\x06\xa50\0\
    \xa80\x01\x1a\x1e\x20SingleAppDuplicationResponse\n\n\x0c\n\x04\x04\xe3\
    \x01\x01\x12\x04\xa50\x08$\n\r\n\x05\x04\xe3\x01\x02\0\x12\x04\xa60\x02(\
    \n\x0e\n\x06\x04\xe3\x01\x02\0\x06\x12\x04\xa60\x02\x1c\n\x0e\n\x06\x04\
    \xe3\x01\x02\0\x01\x12\x04\xa60\x1d#\n\x0e\n\x06\x04\xe3\x01\x02\0\x03\
    \x12\x04\xa60&'\n\r\n\x05\x04\xe3\x01\x02\x01\x12\x04\xa70\x02%\n\x0e\n\
    \x06\x04\xe3\x01\x02\x01\x06\x12\x04\xa70\x02\x10\n\x0e\n\x06\x04\xe3\
    \x01\x02\x01\x01\x12\x04\xa70\x11\x20\n\x0e\n\x06\x04\xe3\x01\x02\x01\
    \x03\x12\x04\xa70#$\n)\n\x03\x04\xe4\x01\x12\x06\xab0\0\xae0\x01\x1a\x1a\
    \x20Request\x20to\x20create\x20Tasks.\n\n\x0c\n\x04\x04\xe4\x01\x01\x12\
    \x04\xab0\x08\x18\n\r\n\x05\x04\xe4\x01\x02\0\x12\x04\xac0\x02,\n\x0e\n\
    \x06\x04\xe4\x01\x02\0\x06\x12\x04\xac0\x02\x1b\n\x0e\n\x06\x04\xe4\x01\
    \x02\0\x01\x12\x04\xac0\x1c'\n\x0e\n\x06\x04\xe4\x01\x02\0\x03\x12\x04\
    \xac0*+\n\r\n\x05\x04\xe4\x01\x02\x01\x12\x04\xad0\x02\x1a\n\x0e\n\x06\
    \x04\xe4\x01\x02\x01\x04\x12\x04\xad0\x02\n\n\x0e\n\x06\x04\xe4\x01\x02\
    \x01\x06\x12\x04\xad0\x0b\x0f\n\x0e\n\x06\x04\xe4\x01\x02\x01\x01\x12\
    \x04\xad0\x10\x15\n\x0e\n\x06\x04\xe4\x01\x02\x01\x03\x12\x04\xad0\x18\
    \x19\n)\n\x03\x04\xe5\x01\x12\x06\xb10\0\xb80\x01\x1a\x1a\x20Request\x20\
    to\x20get\x20one\x20task.\n\n\x0c\n\x04\x04\xe5\x01\x01\x12\x04\xb10\x08\
    \x16\n\r\n\x05\x04\xe5\x01\x02\0\x12\x04\xb20\x02,\n\x0e\n\x06\x04\xe5\
    \x01\x02\0\x06\x12\x04\xb20\x02\x1b\n\x0e\n\x06\x04\xe5\x01\x02\0\x01\
    \x12\x04\xb20\x1c'\n\x0e\n\x06\x04\xe5\x01\x02\0\x03\x12\x04\xb20*+\n\r\
    \n\x05\x04\xe5\x01\x02\x01\x12\x04\xb30\x02\x15\n\x0e\n\x06\x04\xe5\x01\
    \x02\x01\x05\x12\x04\xb30\x02\x08\n\x0e\n\x06\x04\xe5\x01\x02\x01\x01\
    \x12\x04\xb30\t\x10\n\x0e\n\x06\x04\xe5\x01\x02\x01\x03\x12\x04\xb30\x13\
    \x14\n\x9b\x01\n\x05\x04\xe5\x01\x02\x02\x12\x04\xb70\x02(\x1a\x8b\x01\
    \x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\
    \x20to\x20be\x20included\x20in\x20the\x20response.\n\x20Currently\x20sup\
    ported:\x20all,\x20worker.users,\x20review.users.\n\n\x0e\n\x06\x04\xe5\
    \x01\x02\x02\x04\x12\x04\xb70\x02\n\n\x0e\n\x06\x04\xe5\x01\x02\x02\x05\
    \x12\x04\xb70\x0b\x11\n\x0e\n\x06\x04\xe5\x01\x02\x02\x01\x12\x04\xb70\
    \x12#\n\x0e\n\x06\x04\xe5\x01\x02\x02\x03\x12\x04\xb70&'\n0\n\x03\x04\
    \xe6\x01\x12\x06\xbb0\0\xd10\x01\x1a!\x20Request\x20to\x20list\x20multip\
    le\x20tasks.\n\n\x0c\n\x04\x04\xe6\x01\x01\x12\x04\xbb0\x08\x18\n\r\n\
    \x05\x04\xe6\x01\x02\0\x12\x04\xbc0\x02,\n\x0e\n\x06\x04\xe6\x01\x02\0\
    \x06\x12\x04\xbc0\x02\x1b\n\x0e\n\x06\x04\xe6\x01\x02\0\x01\x12\x04\xbc0\
    \x1c'\n\x0e\n\x06\x04\xe6\x01\x02\0\x03\x12\x04\xbc0*+\n\x7f\n\x05\x04\
    \xe6\x01\x02\x01\x12\x04\xbf0\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\xe6\x01\x02\x01\x05\x12\x04\xbf0\x02\x08\n\x0e\n\x06\x04\xe6\
    \x01\x02\x01\x01\x12\x04\xbf0\t\r\n\x0e\n\x06\x04\xe6\x01\x02\x01\x03\
    \x12\x04\xbf0\x10\x11\nv\n\x05\x04\xe6\x01\x02\x02\x12\x04\xc20\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\xe6\x01\x02\x02\x05\x12\x04\xc20\x02\
    \x08\n\x0e\n\x06\x04\xe6\x01\x02\x02\x01\x12\x04\xc20\t\x11\n\x0e\n\x06\
    \x04\xe6\x01\x02\x02\x03\x12\x04\xc20\x14\x15\nP\n\x05\x04\xe6\x01\x02\
    \x03\x12\x04\xc40\x02&\x1aA\x20Get\x20tasks\x20that\x20have\x20ANY\x20us\
    er\x20from\x20this\x20list\x20assigned\x20as\x20worker.\n\n\x0e\n\x06\
    \x04\xe6\x01\x02\x03\x04\x12\x04\xc40\x02\n\n\x0e\n\x06\x04\xe6\x01\x02\
    \x03\x05\x12\x04\xc40\x0b\x11\n\x0e\n\x06\x04\xe6\x01\x02\x03\x01\x12\
    \x04\xc40\x12!\n\x0e\n\x06\x04\xe6\x01\x02\x03\x03\x12\x04\xc40$%\nR\n\
    \x05\x04\xe6\x01\x02\x04\x12\x04\xc60\x02&\x1aC\x20Get\x20tasks\x20that\
    \x20have\x20ANY\x20user\x20from\x20this\x20list\x20assigned\x20as\x20rev\
    iewer.\n\n\x0e\n\x06\x04\xe6\x01\x02\x04\x04\x12\x04\xc60\x02\n\n\x0e\n\
    \x06\x04\xe6\x01\x02\x04\x05\x12\x04\xc60\x0b\x11\n\x0e\n\x06\x04\xe6\
    \x01\x02\x04\x01\x12\x04\xc60\x12!\n\x0e\n\x06\x04\xe6\x01\x02\x04\x03\
    \x12\x04\xc60$%\nQ\n\x05\x04\xe6\x01\x02\x05\x12\x04\xc80\x02&\x1aB\x20G\
    et\x20tasks\x20that\x20are\x20associated\x20to\x20ANY\x20label\x20order\
    \x20from\x20this\x20list.\n\n\x0e\n\x06\x04\xe6\x01\x02\x05\x04\x12\x04\
    \xc80\x02\n\n\x0e\n\x06\x04\xe6\x01\x02\x05\x05\x12\x04\xc80\x0b\x11\n\
    \x0e\n\x06\x04\xe6\x01\x02\x05\x01\x12\x04\xc80\x12!\n\x0e\n\x06\x04\xe6\
    \x01\x02\x05\x03\x12\x04\xc80$%\nj\n\x05\x04\xe6\x01\x02\x06\x12\x04\xcc\
    0\x02'\x1a[\x20Get\x20label\x20order\x20tasks\x20as\x20well\n\x20It\x20i\
    s\x20automatically\x20set\x20to\x20true\x20if\x20label_order_ids\x20is\
    \x20set.\n\n\x0e\n\x06\x04\xe6\x01\x02\x06\x05\x12\x04\xcc0\x02\x06\n\
    \x0e\n\x06\x04\xe6\x01\x02\x06\x01\x12\x04\xcc0\x07\"\n\x0e\n\x06\x04\
    \xe6\x01\x02\x06\x03\x12\x04\xcc0%&\n\x9b\x01\n\x05\x04\xe6\x01\x02\x07\
    \x12\x04\xd00\x02(\x1a\x8b\x01\x20(optional\x20URL\x20parameter)\x20List\
    \x20of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20the\x20r\
    esponse.\n\x20Currently\x20supported:\x20all,\x20worker.users,\x20review\
    .users.\n\n\x0e\n\x06\x04\xe6\x01\x02\x07\x04\x12\x04\xd00\x02\n\n\x0e\n\
    \x06\x04\xe6\x01\x02\x07\x05\x12\x04\xd00\x0b\x11\n\x0e\n\x06\x04\xe6\
    \x01\x02\x07\x01\x12\x04\xd00\x12#\n\x0e\n\x06\x04\xe6\x01\x02\x07\x03\
    \x12\x04\xd00&'\n2\n\x03\x04\xe7\x01\x12\x06\xd40\0\xda0\x01\x1a#\x20Req\
    uest\x20to\x20patch\x20a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\x04\xe7\
    \x01\x01\x12\x04\xd40\x08\x19\n\r\n\x05\x04\xe7\x01\x02\0\x12\x04\xd50\
    \x02,\n\x0e\n\x06\x04\xe7\x01\x02\0\x06\x12\x04\xd50\x02\x1b\n\x0e\n\x06\
    \x04\xe7\x01\x02\0\x01\x12\x04\xd50\x1c'\n\x0e\n\x06\x04\xe7\x01\x02\0\
    \x03\x12\x04\xd50*+\n\r\n\x05\x04\xe7\x01\x02\x01\x12\x04\xd60\x02\x1a\n\
    \x0e\n\x06\x04\xe7\x01\x02\x01\x04\x12\x04\xd60\x02\n\n\x0e\n\x06\x04\
    \xe7\x01\x02\x01\x06\x12\x04\xd60\x0b\x0f\n\x0e\n\x06\x04\xe7\x01\x02\
    \x01\x01\x12\x04\xd60\x10\x15\n\x0e\n\x06\x04\xe7\x01\x02\x01\x03\x12\
    \x04\xd60\x18\x19\n\x7f\n\x05\x04\xe7\x01\x02\x02\x12\x04\xd90\x02\x14\
    \x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objec\
    ts\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'rem\
    ove'\x20are\x20supported\n\n\x0e\n\x06\x04\xe7\x01\x02\x02\x05\x12\x04\
    \xd90\x02\x08\n\x0e\n\x06\x04\xe7\x01\x02\x02\x01\x12\x04\xd90\t\x0f\n\
    \x0e\n\x06\x04\xe7\x01\x02\x02\x03\x12\x04\xd90\x12\x13\n3\n\x03\x04\xe8\
    \x01\x12\x06\xdd0\0\xe00\x01\x1a$\x20Request\x20to\x20delete\x20a\x20lis\
    t\x20of\x20tasks.\n\n\x0c\n\x04\x04\xe8\x01\x01\x12\x04\xdd0\x08\x1a\n\r\
    \n\x05\x04\xe8\x01\x02\0\x12\x04\xde0\x02,\n\x0e\n\x06\x04\xe8\x01\x02\0\
    \x06\x12\x04\xde0\x02\x1b\n\x0e\n\x06\x04\xe8\x01\x02\0\x01\x12\x04\xde0\
    \x1c'\n\x0e\n\x06\x04\xe8\x01\x02\0\x03\x12\x04\xde0*+\n\r\n\x05\x04\xe8\
    \x01\x02\x01\x12\x04\xdf0\x02\x1a\n\x0e\n\x06\x04\xe8\x01\x02\x01\x04\
    \x12\x04\xdf0\x02\n\n\x0e\n\x06\x04\xe8\x01\x02\x01\x05\x12\x04\xdf0\x0b\
    \x11\n\x0e\n\x06\x04\xe8\x01\x02\x01\x01\x12\x04\xdf0\x12\x15\n\x0e\n\
    \x06\x04\xe8\x01\x02\x01\x03\x12\x04\xdf0\x18\x19\n.\n\x03\x04\xe9\x01\
    \x12\x06\xe30\0\xe60\x01\x1a\x1f\x20Response\x20with\x20multiple\x20Task\
    s.\n\n\x0c\n\x04\x04\xe9\x01\x01\x12\x04\xe30\x08\x19\n\r\n\x05\x04\xe9\
    \x01\x02\0\x12\x04\xe40\x02(\n\x0e\n\x06\x04\xe9\x01\x02\0\x06\x12\x04\
    \xe40\x02\x1c\n\x0e\n\x06\x04\xe9\x01\x02\0\x01\x12\x04\xe40\x1d#\n\x0e\
    \n\x06\x04\xe9\x01\x02\0\x03\x12\x04\xe40&'\n\r\n\x05\x04\xe9\x01\x02\
    \x01\x12\x04\xe50\x02I\n\x0e\n\x06\x04\xe9\x01\x02\x01\x04\x12\x04\xe50\
    \x02\n\n\x0e\n\x06\x04\xe9\x01\x02\x01\x06\x12\x04\xe50\x0b\x0f\n\x0e\n\
    \x06\x04\xe9\x01\x02\x01\x01\x12\x04\xe50\x10\x15\n\x0e\n\x06\x04\xe9\
    \x01\x02\x01\x03\x12\x04\xe50\x18\x19\n\x0e\n\x06\x04\xe9\x01\x02\x01\
    \x08\x12\x04\xe50\x1aH\n\x11\n\t\x04\xe9\x01\x02\x01\x08\xd0\x86\x03\x12\
    \x04\xe50\x1bG\n-\n\x03\x04\xea\x01\x12\x06\xe90\0\xec0\x01\x1a\x1e\x20R\
    esponse\x20with\x20a\x20single\x20Task.\n\n\x0c\n\x04\x04\xea\x01\x01\
    \x12\x04\xe90\x08\x1a\n\r\n\x05\x04\xea\x01\x02\0\x12\x04\xea0\x02(\n\
    \x0e\n\x06\x04\xea\x01\x02\0\x06\x12\x04\xea0\x02\x1c\n\x0e\n\x06\x04\
    \xea\x01\x02\0\x01\x12\x04\xea0\x1d#\n\x0e\n\x06\x04\xea\x01\x02\0\x03\
    \x12\x04\xea0&'\n\r\n\x05\x04\xea\x01\x02\x01\x12\x04\xeb0\x02\x10\n\x0e\
    \n\x06\x04\xea\x01\x02\x01\x06\x12\x04\xeb0\x02\x06\n\x0e\n\x06\x04\xea\
    \x01\x02\x01\x01\x12\x04\xeb0\x07\x0b\n\x0e\n\x06\x04\xea\x01\x02\x01\
    \x03\x12\x04\xeb0\x0e\x0f\n\xae\x01\n\x03\x04\xeb\x01\x12\x06\xf10\0\xf9\
    0\x01\x1a\x9e\x01\x20GetTaskCountRequest\x20can\x20be\x20used\x20for\x20\
    fetching\x20-\n\x201.\x20Task\x20annotation\x20count\x20per\x20user,\x20\
    per\x20status\n\x201.\x20Task\x20input\x20(anchor\x20annotations)\x20cou\
    nt\x20per\x20user,\x20per\x20status\n\n\x0c\n\x04\x04\xeb\x01\x01\x12\
    \x04\xf10\x08\x1b\n\r\n\x05\x04\xeb\x01\x02\0\x12\x04\xf20\x02,\n\x0e\n\
    \x06\x04\xeb\x01\x02\0\x06\x12\x04\xf20\x02\x1b\n\x0e\n\x06\x04\xeb\x01\
    \x02\0\x01\x12\x04\xf20\x1c'\n\x0e\n\x06\x04\xeb\x01\x02\0\x03\x12\x04\
    \xf20*+\nF\n\x05\x04\xeb\x01\x02\x01\x12\x04\xf50\x02\x15\x1a7\x20task_i\
    d\x20for\x20which\x20count\x20per\x20user\x20per\x20status\x20is\x20need\
    ed\n\n\x0e\n\x06\x04\xeb\x01\x02\x01\x05\x12\x04\xf50\x02\x08\n\x0e\n\
    \x06\x04\xeb\x01\x02\x01\x01\x12\x04\xf50\t\x10\n\x0e\n\x06\x04\xeb\x01\
    \x02\x01\x03\x12\x04\xf50\x13\x14\nD\n\x05\x04\xeb\x01\x02\x02\x12\x04\
    \xf80\x02\x1e\x1a5\x20for\x20given\x20task_id,\x20user_ids\x20to\x20filt\
    er\x20on\x20(optional)\n\n\x0e\n\x06\x04\xeb\x01\x02\x02\x04\x12\x04\xf8\
    0\x02\n\n\x0e\n\x06\x04\xeb\x01\x02\x02\x05\x12\x04\xf80\x0b\x11\n\x0e\n\
    \x06\x04\xeb\x01\x02\x02\x01\x12\x04\xf80\x12\x1a\n\x0e\n\x06\x04\xeb\
    \x01\x02\x02\x03\x12\x04\xf80\x1c\x1d\n\x81\x01\n\x03\x04\xec\x01\x12\
    \x06\xfe0\0\x831\x01\x1ar\x20SingleTaskCountResponse\x20represent\x20cou\
    nts\x20of\x20annotations\x20or\x20inputs(anchor\x20annotations)\x20for\
    \x20labelers\x20in\x20given\x20task\n\n\x0c\n\x04\x04\xec\x01\x01\x12\
    \x04\xfe0\x08\x1f\n\r\n\x05\x04\xec\x01\x02\0\x12\x04\xff0\x02(\n\x0e\n\
    \x06\x04\xec\x01\x02\0\x06\x12\x04\xff0\x02\x1c\n\x0e\n\x06\x04\xec\x01\
    \x02\0\x01\x12\x04\xff0\x1d#\n\x0e\n\x06\x04\xec\x01\x02\0\x03\x12\x04\
    \xff0&'\n\r\n\x05\x04\xec\x01\x02\x01\x12\x04\x801\x02\x14\n\x0e\n\x06\
    \x04\xec\x01\x02\x01\x05\x12\x04\x801\x02\x08\n\x0e\n\x06\x04\xec\x01\
    \x02\x01\x01\x12\x04\x801\t\x0f\n\x0e\n\x06\x04\xec\x01\x02\x01\x03\x12\
    \x04\x801\x12\x13\n\r\n\x05\x04\xec\x01\x02\x02\x12\x04\x811\x02\x15\n\
    \x0e\n\x06\x04\xec\x01\x02\x02\x05\x12\x04\x811\x02\x08\n\x0e\n\x06\x04\
    \xec\x01\x02\x02\x01\x12\x04\x811\t\x10\n\x0e\n\x06\x04\xec\x01\x02\x02\
    \x03\x12\x04\x811\x13\x14\n\r\n\x05\x04\xec\x01\x02\x03\x12\x04\x821\x02\
    -\n\x0e\n\x06\x04\xec\x01\x02\x03\x04\x12\x04\x821\x02\n\n\x0e\n\x06\x04\
    \xec\x01\x02\x03\x06\x12\x04\x821\x0b!\n\x0e\n\x06\x04\xec\x01\x02\x03\
    \x01\x12\x04\x821\"(\n\x0e\n\x06\x04\xec\x01\x02\x03\x03\x12\x04\x821+,\
    \n\xdf\x01\n\x03\x04\xed\x01\x12\x06\x8c1\0\x8f1\x01\x1a!\x20Request\x20\
    to\x20create\x20label\x20orders.\n2\xac\x01/////////////////////////////\
    /////////////////////////////////////////////////\n\x20Label\x20Orders\n\
    ////////////////////////////////////////////////////////////////////////\
    //////\n\n\x0c\n\x04\x04\xed\x01\x01\x12\x04\x8c1\x08\x1e\n\r\n\x05\x04\
    \xed\x01\x02\0\x12\x04\x8d1\x02,\n\x0e\n\x06\x04\xed\x01\x02\0\x06\x12\
    \x04\x8d1\x02\x1b\n\x0e\n\x06\x04\xed\x01\x02\0\x01\x12\x04\x8d1\x1c'\n\
    \x0e\n\x06\x04\xed\x01\x02\0\x03\x12\x04\x8d1*+\n\r\n\x05\x04\xed\x01\
    \x02\x01\x12\x04\x8e1\x02'\n\x0e\n\x06\x04\xed\x01\x02\x01\x04\x12\x04\
    \x8e1\x02\n\n\x0e\n\x06\x04\xed\x01\x02\x01\x06\x12\x04\x8e1\x0b\x15\n\
    \x0e\n\x06\x04\xed\x01\x02\x01\x01\x12\x04\x8e1\x16\"\n\x0e\n\x06\x04\
    \xed\x01\x02\x01\x03\x12\x04\x8e1%&\n0\n\x03\x04\xee\x01\x12\x06\x921\0\
    \x951\x01\x1a!\x20Request\x20to\x20get\x20one\x20label\x20order.\n\n\x0c\
    \n\x04\x04\xee\x01\x01\x12\x04\x921\x08\x1c\n\r\n\x05\x04\xee\x01\x02\0\
    \x12\x04\x931\x02,\n\x0e\n\x06\x04\xee\x01\x02\0\x06\x12\x04\x931\x02\
    \x1b\n\x0e\n\x06\x04\xee\x01\x02\0\x01\x12\x04\x931\x1c'\n\x0e\n\x06\x04\
    \xee\x01\x02\0\x03\x12\x04\x931*+\n\r\n\x05\x04\xee\x01\x02\x01\x12\x04\
    \x941\x02\x1c\n\x0e\n\x06\x04\xee\x01\x02\x01\x05\x12\x04\x941\x02\x08\n\
    \x0e\n\x06\x04\xee\x01\x02\x01\x01\x12\x04\x941\t\x17\n\x0e\n\x06\x04\
    \xee\x01\x02\x01\x03\x12\x04\x941\x1a\x1b\n7\n\x03\x04\xef\x01\x12\x06\
    \x981\0\xa01\x01\x1a(\x20Request\x20to\x20list\x20multiple\x20label\x20o\
    rders.\n\n\x0c\n\x04\x04\xef\x01\x01\x12\x04\x981\x08\x1e\n\r\n\x05\x04\
    \xef\x01\x02\0\x12\x04\x991\x02,\n\x0e\n\x06\x04\xef\x01\x02\0\x06\x12\
    \x04\x991\x02\x1b\n\x0e\n\x06\x04\xef\x01\x02\0\x01\x12\x04\x991\x1c'\n\
    \x0e\n\x06\x04\xef\x01\x02\0\x03\x12\x04\x991*+\n\x7f\n\x05\x04\xef\x01\
    \x02\x01\x12\x04\x9c1\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20\
    The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\xef\x01\x02\x01\x05\x12\x04\x9c1\x02\x08\n\x0e\n\x06\x04\xef\x01\
    \x02\x01\x01\x12\x04\x9c1\t\r\n\x0e\n\x06\x04\xef\x01\x02\x01\x03\x12\
    \x04\x9c1\x10\x11\nv\n\x05\x04\xef\x01\x02\x02\x12\x04\x9f1\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\xef\x01\x02\x02\x05\x12\x04\x9f1\x02\x08\n\
    \x0e\n\x06\x04\xef\x01\x02\x02\x01\x12\x04\x9f1\t\x11\n\x0e\n\x06\x04\
    \xef\x01\x02\x02\x03\x12\x04\x9f1\x14\x15\n9\n\x03\x04\xf0\x01\x12\x06\
    \xa31\0\xab1\x01\x1a*\x20Request\x20to\x20patch\x20a\x20list\x20of\x20la\
    bel\x20orders.\n\n\x0c\n\x04\x04\xf0\x01\x01\x12\x04\xa31\x08\x1f\n\r\n\
    \x05\x04\xf0\x01\x02\0\x12\x04\xa41\x02,\n\x0e\n\x06\x04\xf0\x01\x02\0\
    \x06\x12\x04\xa41\x02\x1b\n\x0e\n\x06\x04\xf0\x01\x02\0\x01\x12\x04\xa41\
    \x1c'\n\x0e\n\x06\x04\xf0\x01\x02\0\x03\x12\x04\xa41*+\n\r\n\x05\x04\xf0\
    \x01\x02\x01\x12\x04\xa61\x02'\n\x0e\n\x06\x04\xf0\x01\x02\x01\x04\x12\
    \x04\xa61\x02\n\n\x0e\n\x06\x04\xf0\x01\x02\x01\x06\x12\x04\xa61\x0b\x15\
    \n\x0e\n\x06\x04\xf0\x01\x02\x01\x01\x12\x04\xa61\x16\"\n\x0e\n\x06\x04\
    \xf0\x01\x02\x01\x03\x12\x04\xa61%&\n\x7f\n\x05\x04\xf0\x01\x02\x02\x12\
    \x04\xaa1\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwr\
    ite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\xf0\x01\
    \x02\x02\x05\x12\x04\xaa1\x02\x08\n\x0e\n\x06\x04\xf0\x01\x02\x02\x01\
    \x12\x04\xaa1\t\x0f\n\x0e\n\x06\x04\xf0\x01\x02\x02\x03\x12\x04\xaa1\x12\
    \x13\n:\n\x03\x04\xf1\x01\x12\x06\xae1\0\xb11\x01\x1a+\x20Request\x20to\
    \x20delete\x20a\x20list\x20of\x20label\x20orders.\n\n\x0c\n\x04\x04\xf1\
    \x01\x01\x12\x04\xae1\x08\x20\n\r\n\x05\x04\xf1\x01\x02\0\x12\x04\xaf1\
    \x02,\n\x0e\n\x06\x04\xf1\x01\x02\0\x06\x12\x04\xaf1\x02\x1b\n\x0e\n\x06\
    \x04\xf1\x01\x02\0\x01\x12\x04\xaf1\x1c'\n\x0e\n\x06\x04\xf1\x01\x02\0\
    \x03\x12\x04\xaf1*+\n\r\n\x05\x04\xf1\x01\x02\x01\x12\x04\xb01\x02\x1a\n\
    \x0e\n\x06\x04\xf1\x01\x02\x01\x04\x12\x04\xb01\x02\n\n\x0e\n\x06\x04\
    \xf1\x01\x02\x01\x05\x12\x04\xb01\x0b\x11\n\x0e\n\x06\x04\xf1\x01\x02\
    \x01\x01\x12\x04\xb01\x12\x15\n\x0e\n\x06\x04\xf1\x01\x02\x01\x03\x12\
    \x04\xb01\x18\x19\n4\n\x03\x04\xf2\x01\x12\x06\xb41\0\xb71\x01\x1a%\x20R\
    esponse\x20with\x20multiple\x20label\x20order.\n\n\x0c\n\x04\x04\xf2\x01\
    \x01\x12\x04\xb41\x08\x1f\n\r\n\x05\x04\xf2\x01\x02\0\x12\x04\xb51\x02(\
    \n\x0e\n\x06\x04\xf2\x01\x02\0\x06\x12\x04\xb51\x02\x1c\n\x0e\n\x06\x04\
    \xf2\x01\x02\0\x01\x12\x04\xb51\x1d#\n\x0e\n\x06\x04\xf2\x01\x02\0\x03\
    \x12\x04\xb51&'\n\r\n\x05\x04\xf2\x01\x02\x01\x12\x04\xb61\x02V\n\x0e\n\
    \x06\x04\xf2\x01\x02\x01\x04\x12\x04\xb61\x02\n\n\x0e\n\x06\x04\xf2\x01\
    \x02\x01\x06\x12\x04\xb61\x0b\x15\n\x0e\n\x06\x04\xf2\x01\x02\x01\x01\
    \x12\x04\xb61\x16\"\n\x0e\n\x06\x04\xf2\x01\x02\x01\x03\x12\x04\xb61%&\n\
    \x0e\n\x06\x04\xf2\x01\x02\x01\x08\x12\x04\xb61'U\n\x11\n\t\x04\xf2\x01\
    \x02\x01\x08\xd0\x86\x03\x12\x04\xb61(T\n-\n\x03\x04\xf3\x01\x12\x06\xba\
    1\0\xbd1\x01\x1a\x1e\x20Response\x20with\x20a\x20label\x20order.\n\n\x0c\
    \n\x04\x04\xf3\x01\x01\x12\x04\xba1\x08\x20\n\r\n\x05\x04\xf3\x01\x02\0\
    \x12\x04\xbb1\x02(\n\x0e\n\x06\x04\xf3\x01\x02\0\x06\x12\x04\xbb1\x02\
    \x1c\n\x0e\n\x06\x04\xf3\x01\x02\0\x01\x12\x04\xbb1\x1d#\n\x0e\n\x06\x04\
    \xf3\x01\x02\0\x03\x12\x04\xbb1&'\n\r\n\x05\x04\xf3\x01\x02\x01\x12\x04\
    \xbc1\x02\x1d\n\x0e\n\x06\x04\xf3\x01\x02\x01\x06\x12\x04\xbc1\x02\x0c\n\
    \x0e\n\x06\x04\xf3\x01\x02\x01\x01\x12\x04\xbc1\r\x18\n\x0e\n\x06\x04\
    \xf3\x01\x02\x01\x03\x12\x04\xbc1\x1b\x1c\n.\n\x03\x04\xf4\x01\x12\x06\
    \xc01\0\xc31\x01\x1a\x1f\x20Request\x20to\x20create\x20Collectors.\n\n\
    \x0c\n\x04\x04\xf4\x01\x01\x12\x04\xc01\x08\x1d\n\r\n\x05\x04\xf4\x01\
    \x02\0\x12\x04\xc11\x02,\n\x0e\n\x06\x04\xf4\x01\x02\0\x06\x12\x04\xc11\
    \x02\x1b\n\x0e\n\x06\x04\xf4\x01\x02\0\x01\x12\x04\xc11\x1c'\n\x0e\n\x06\
    \x04\xf4\x01\x02\0\x03\x12\x04\xc11*+\n\r\n\x05\x04\xf4\x01\x02\x01\x12\
    \x04\xc21\x02$\n\x0e\n\x06\x04\xf4\x01\x02\x01\x04\x12\x04\xc21\x02\n\n\
    \x0e\n\x06\x04\xf4\x01\x02\x01\x06\x12\x04\xc21\x0b\x14\n\x0e\n\x06\x04\
    \xf4\x01\x02\x01\x01\x12\x04\xc21\x15\x1f\n\x0e\n\x06\x04\xf4\x01\x02\
    \x01\x03\x12\x04\xc21\"#\n'\n\x03\x04\xf5\x01\x12\x06\xc61\0\xce1\x01\
    \x1a\x18\x20PatchCollectorsRequest\n\n\x0c\n\x04\x04\xf5\x01\x01\x12\x04\
    \xc61\x08\x1e\n\r\n\x05\x04\xf5\x01\x02\0\x12\x04\xc71\x02,\n\x0e\n\x06\
    \x04\xf5\x01\x02\0\x06\x12\x04\xc71\x02\x1b\n\x0e\n\x06\x04\xf5\x01\x02\
    \0\x01\x12\x04\xc71\x1c'\n\x0e\n\x06\x04\xf5\x01\x02\0\x03\x12\x04\xc71*\
    +\n\r\n\x05\x04\xf5\x01\x02\x01\x12\x04\xc91\x02$\n\x0e\n\x06\x04\xf5\
    \x01\x02\x01\x04\x12\x04\xc91\x02\n\n\x0e\n\x06\x04\xf5\x01\x02\x01\x06\
    \x12\x04\xc91\x0b\x14\n\x0e\n\x06\x04\xf5\x01\x02\x01\x01\x12\x04\xc91\
    \x15\x1f\n\x0e\n\x06\x04\xf5\x01\x02\x01\x03\x12\x04\xc91\"#\n\\\n\x05\
    \x04\xf5\x01\x02\x02\x12\x04\xcd1\x02\x14\x1aM\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20Only\x20'overwrite'\
    \x20is\x20supported\n\n\x0e\n\x06\x04\xf5\x01\x02\x02\x05\x12\x04\xcd1\
    \x02\x08\n\x0e\n\x06\x04\xf5\x01\x02\x02\x01\x12\x04\xcd1\t\x0f\n\x0e\n\
    \x06\x04\xf5\x01\x02\x02\x03\x12\x04\xcd1\x12\x13\nE\n\x03\x04\xf6\x01\
    \x12\x06\xd11\0\xd51\x01\x1a6\x20Request\x20to\x20delete\x20several\x20t\
    hings\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xf6\x01\x01\
    \x12\x04\xd11\x08\x1f\n\r\n\x05\x04\xf6\x01\x02\0\x12\x04\xd21\x02,\n\
    \x0e\n\x06\x04\xf6\x01\x02\0\x06\x12\x04\xd21\x02\x1b\n\x0e\n\x06\x04\
    \xf6\x01\x02\0\x01\x12\x04\xd21\x1c'\n\x0e\n\x06\x04\xf6\x01\x02\0\x03\
    \x12\x04\xd21*+\n\r\n\x05\x04\xf6\x01\x02\x01\x12\x04\xd31\x02\x1a\n\x0e\
    \n\x06\x04\xf6\x01\x02\x01\x04\x12\x04\xd31\x02\n\n\x0e\n\x06\x04\xf6\
    \x01\x02\x01\x05\x12\x04\xd31\x0b\x11\n\x0e\n\x06\x04\xf6\x01\x02\x01\
    \x01\x12\x04\xd31\x12\x15\n\x0e\n\x06\x04\xf6\x01\x02\x01\x03\x12\x04\
    \xd31\x18\x19\n\r\n\x05\x04\xf6\x01\x02\x02\x12\x04\xd41\x02\x16\n\x0e\n\
    \x06\x04\xf6\x01\x02\x02\x05\x12\x04\xd41\x02\x06\n\x0e\n\x06\x04\xf6\
    \x01\x02\x02\x01\x12\x04\xd41\x07\x11\n\x0e\n\x06\x04\xf6\x01\x02\x02\
    \x03\x12\x04\xd41\x14\x15\n3\n\x03\x04\xf7\x01\x12\x06\xd81\0\xdc1\x01\
    \x1a$\x20Request\x20to\x20GET\x20a\x20single\x20Collector.\n\n\x0c\n\x04\
    \x04\xf7\x01\x01\x12\x04\xd81\x08\x1b\n\r\n\x05\x04\xf7\x01\x02\0\x12\
    \x04\xd91\x02,\n\x0e\n\x06\x04\xf7\x01\x02\0\x06\x12\x04\xd91\x02\x1b\n\
    \x0e\n\x06\x04\xf7\x01\x02\0\x01\x12\x04\xd91\x1c'\n\x0e\n\x06\x04\xf7\
    \x01\x02\0\x03\x12\x04\xd91*+\n!\n\x05\x04\xf7\x01\x02\x01\x12\x04\xdb1\
    \x02\x1a\x1a\x12The\x20collecgtor\x20id\n\n\x0e\n\x06\x04\xf7\x01\x02\
    \x01\x05\x12\x04\xdb1\x02\x08\n\x0e\n\x06\x04\xf7\x01\x02\x01\x01\x12\
    \x04\xdb1\t\x15\n\x0e\n\x06\x04\xf7\x01\x02\x01\x03\x12\x04\xdb1\x18\x19\
    \n3\n\x03\x04\xf8\x01\x12\x06\xdf1\0\xe71\x01\x1a$\x20Request\x20to\x20G\
    ET\x20all\x20the\x20Collectors.\n\n\x0c\n\x04\x04\xf8\x01\x01\x12\x04\
    \xdf1\x08\x1d\n\r\n\x05\x04\xf8\x01\x02\0\x12\x04\xe01\x02,\n\x0e\n\x06\
    \x04\xf8\x01\x02\0\x06\x12\x04\xe01\x02\x1b\n\x0e\n\x06\x04\xf8\x01\x02\
    \0\x01\x12\x04\xe01\x1c'\n\x0e\n\x06\x04\xf8\x01\x02\0\x03\x12\x04\xe01*\
    +\n\x7f\n\x05\x04\xf8\x01\x02\x01\x12\x04\xe31\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xf8\x01\x02\x01\x05\x12\x04\xe31\x02\x08\
    \n\x0e\n\x06\x04\xf8\x01\x02\x01\x01\x12\x04\xe31\t\r\n\x0e\n\x06\x04\
    \xf8\x01\x02\x01\x03\x12\x04\xe31\x10\x11\nv\n\x05\x04\xf8\x01\x02\x02\
    \x12\x04\xe61\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xf8\x01\x02\x02\
    \x05\x12\x04\xe61\x02\x08\n\x0e\n\x06\x04\xf8\x01\x02\x02\x01\x12\x04\
    \xe61\t\x11\n\x0e\n\x06\x04\xf8\x01\x02\x02\x03\x12\x04\xe61\x14\x15\n3\
    \n\x03\x04\xf9\x01\x12\x06\xea1\0\xed1\x01\x1a$\x20Response\x20with\x20m\
    ultiple\x20Collectors.\n\n\x0c\n\x04\x04\xf9\x01\x01\x12\x04\xea1\x08\
    \x1e\n\r\n\x05\x04\xf9\x01\x02\0\x12\x04\xeb1\x02(\n\x0e\n\x06\x04\xf9\
    \x01\x02\0\x06\x12\x04\xeb1\x02\x1c\n\x0e\n\x06\x04\xf9\x01\x02\0\x01\
    \x12\x04\xeb1\x1d#\n\x0e\n\x06\x04\xf9\x01\x02\0\x03\x12\x04\xeb1&'\n\r\
    \n\x05\x04\xf9\x01\x02\x01\x12\x04\xec1\x02$\n\x0e\n\x06\x04\xf9\x01\x02\
    \x01\x04\x12\x04\xec1\x02\n\n\x0e\n\x06\x04\xf9\x01\x02\x01\x06\x12\x04\
    \xec1\x0b\x14\n\x0e\n\x06\x04\xf9\x01\x02\x01\x01\x12\x04\xec1\x15\x1f\n\
    \x0e\n\x06\x04\xf9\x01\x02\x01\x03\x12\x04\xec1\"#\n2\n\x03\x04\xfa\x01\
    \x12\x06\xf01\0\xf31\x01\x1a#\x20Response\x20with\x20a\x20single\x20Coll\
    ector.\n\n\x0c\n\x04\x04\xfa\x01\x01\x12\x04\xf01\x08\x1f\n\r\n\x05\x04\
    \xfa\x01\x02\0\x12\x04\xf11\x02(\n\x0e\n\x06\x04\xfa\x01\x02\0\x06\x12\
    \x04\xf11\x02\x1c\n\x0e\n\x06\x04\xfa\x01\x02\0\x01\x12\x04\xf11\x1d#\n\
    \x0e\n\x06\x04\xfa\x01\x02\0\x03\x12\x04\xf11&'\n\r\n\x05\x04\xfa\x01\
    \x02\x01\x12\x04\xf21\x02\x1a\n\x0e\n\x06\x04\xfa\x01\x02\x01\x06\x12\
    \x04\xf21\x02\x0b\n\x0e\n\x06\x04\xfa\x01\x02\x01\x01\x12\x04\xf21\x0c\
    \x15\n\x0e\n\x06\x04\xfa\x01\x02\x01\x03\x12\x04\xf21\x18\x19\n&\n\x03\
    \x04\xfb\x01\x12\x06\xf61\0\xfb1\x01\x1a\x17\x20PostStatValuesRequest\n\
    \n\x0c\n\x04\x04\xfb\x01\x01\x12\x04\xf61\x08\x1d\n>\n\x05\x04\xfb\x01\
    \x02\0\x12\x04\xf81\x02,\x1a/\x20The\x20user\x20and\x20app\x20informatio\
    n\x20for\x20the\x20request.\n\n\x0e\n\x06\x04\xfb\x01\x02\0\x06\x12\x04\
    \xf81\x02\x1b\n\x0e\n\x06\x04\xfb\x01\x02\0\x01\x12\x04\xf81\x1c'\n\x0e\
    \n\x06\x04\xfb\x01\x02\0\x03\x12\x04\xf81*+\nE\n\x05\x04\xfb\x01\x02\x01\
    \x12\x04\xfa1\x02%\x1a6\x20The\x20stats\x20to\x20post,\x20can\x20post\
    \x20more\x20than\x20one\x20at\x20a\x20time.\n\n\x0e\n\x06\x04\xfb\x01\
    \x02\x01\x04\x12\x04\xfa1\x02\n\n\x0e\n\x06\x04\xfb\x01\x02\x01\x06\x12\
    \x04\xfa1\x0b\x14\n\x0e\n\x06\x04\xfb\x01\x02\x01\x01\x12\x04\xfa1\x15\
    \x20\n\x0e\n\x06\x04\xfb\x01\x02\x01\x03\x12\x04\xfa1#$\n'\n\x03\x04\xfc\
    \x01\x12\x06\xfe1\0\x832\x01\x1a\x18\x20MultiStatValueResponse\n\n\x0c\n\
    \x04\x04\xfc\x01\x01\x12\x04\xfe1\x08\x1e\n%\n\x05\x04\xfc\x01\x02\0\x12\
    \x04\x802\x02(\x1a\x16\x20The\x20response\x20status.\n\n\x0e\n\x06\x04\
    \xfc\x01\x02\0\x06\x12\x04\x802\x02\x1c\n\x0e\n\x06\x04\xfc\x01\x02\0\
    \x01\x12\x04\x802\x1d#\n\x0e\n\x06\x04\xfc\x01\x02\0\x03\x12\x04\x802&'\
    \n+\n\x05\x04\xfc\x01\x02\x01\x12\x04\x822\x02T\x1a\x1c\x20The\x20return\
    ed\x20stats\x20values.\n\n\x0e\n\x06\x04\xfc\x01\x02\x01\x04\x12\x04\x82\
    2\x02\n\n\x0e\n\x06\x04\xfc\x01\x02\x01\x06\x12\x04\x822\x0b\x14\n\x0e\n\
    \x06\x04\xfc\x01\x02\x01\x01\x12\x04\x822\x15\x20\n\x0e\n\x06\x04\xfc\
    \x01\x02\x01\x03\x12\x04\x822#$\n\x0e\n\x06\x04\xfc\x01\x02\x01\x08\x12\
    \x04\x822%S\n\x11\n\t\x04\xfc\x01\x02\x01\x08\xd0\x86\x03\x12\x04\x822&R\
    \n/\n\x03\x04\xfd\x01\x12\x06\x862\0\x8c2\x01\x1a\x20\x20PostStatValuesA\
    ggregateRequest\n\n\x0c\n\x04\x04\xfd\x01\x01\x12\x04\x862\x08&\n7\n\x05\
    \x04\xfd\x01\x02\0\x12\x04\x882\x02,\x1a(\x20Ids\x20present\x20in\x20the\
    \x20url\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xfd\x01\x02\0\x06\x12\
    \x04\x882\x02\x1b\n\x0e\n\x06\x04\xfd\x01\x02\0\x01\x12\x04\x882\x1c'\n\
    \x0e\n\x06\x04\xfd\x01\x02\0\x03\x12\x04\x882*+\n4\n\x05\x04\xfd\x01\x02\
    \x01\x12\x04\x8b2\x02D\x1a%\x20Query\x20to\x20retrieve\x20aggregate\x20v\
    alues.\n\n\x0e\n\x06\x04\xfd\x01\x02\x01\x04\x12\x04\x8b2\x02\n\n\x0e\n\
    \x06\x04\xfd\x01\x02\x01\x06\x12\x04\x8b2\x0b\"\n\x0e\n\x06\x04\xfd\x01\
    \x02\x01\x01\x12\x04\x8b2#?\n\x0e\n\x06\x04\xfd\x01\x02\x01\x03\x12\x04\
    \x8b2BC\n0\n\x03\x04\xfe\x01\x12\x06\x8f2\0\x952\x01\x1a!\x20MultiStatVa\
    lueAggregateResponse\n\n\x0c\n\x04\x04\xfe\x01\x01\x12\x04\x8f2\x08'\n%\
    \n\x05\x04\xfe\x01\x02\0\x12\x04\x912\x02(\x1a\x16\x20The\x20response\
    \x20status.\n\n\x0e\n\x06\x04\xfe\x01\x02\0\x06\x12\x04\x912\x02\x1c\n\
    \x0e\n\x06\x04\xfe\x01\x02\0\x01\x12\x04\x912\x1d#\n\x0e\n\x06\x04\xfe\
    \x01\x02\0\x03\x12\x04\x912&'\n?\n\x05\x04\xfe\x01\x02\x01\x12\x04\x942\
    \x02E\x1a0\x20The\x20aggregate\x20results\x20for\x20each\x20query\x20pas\
    sedin.\n\n\x0e\n\x06\x04\xfe\x01\x02\x01\x04\x12\x04\x942\x02\n\n\x0e\n\
    \x06\x04\xfe\x01\x02\x01\x06\x12\x04\x942\x0b#\n\x0e\n\x06\x04\xfe\x01\
    \x02\x01\x01\x12\x04\x942$@\n\x0e\n\x06\x04\xfe\x01\x02\x01\x03\x12\x04\
    \x942CD\n/\n\x03\x04\xff\x01\x12\x06\xa22\0\xa92\x01\x1a\x20\x20PostTren\
    dingMetricsViewRequest\n\n\x0c\n\x04\x04\xff\x01\x01\x12\x04\xa22\x08&\n\
    4\n\x05\x04\xff\x01\x02\0\x12\x04\xa42\x02,\x1a%\x20The\x20user_id\x20an\
    d\x20app_id\x20information.\n\n\x0e\n\x06\x04\xff\x01\x02\0\x06\x12\x04\
    \xa42\x02\x1b\n\x0e\n\x06\x04\xff\x01\x02\0\x01\x12\x04\xa42\x1c'\n\x0e\
    \n\x06\x04\xff\x01\x02\0\x03\x12\x04\xa42*+\nT\n\x05\x04\xff\x01\x02\x01\
    \x12\x04\xa62\x02\x17\x1aE\x20For\x20now\x20view\x20types\x20'apps',\x20\
    'workflows',\x20and\x20'models'\x20are\x20supported.\n\n\x0e\n\x06\x04\
    \xff\x01\x02\x01\x05\x12\x04\xa62\x02\x08\n\x0e\n\x06\x04\xff\x01\x02\
    \x01\x01\x12\x04\xa62\t\x12\n\x0e\n\x06\x04\xff\x01\x02\x01\x03\x12\x04\
    \xa62\x15\x16\n(\n\x05\x04\xff\x01\x02\x02\x12\x04\xa82\x02\x17\x1a\x19\
    \x20ID\x20of\x20the\x20views\x20object.\n\n\x0e\n\x06\x04\xff\x01\x02\
    \x02\x05\x12\x04\xa82\x02\x08\n\x0e\n\x06\x04\xff\x01\x02\x02\x01\x12\
    \x04\xa82\t\x12\n\x0e\n\x06\x04\xff\x01\x02\x02\x03\x12\x04\xa82\x15\x16\
    \n0\n\x03\x04\x80\x02\x12\x06\xac2\0\xb72\x01\x1a!\x20ListTrendingMetric\
    sViewsRequest\n\n\x0c\n\x04\x04\x80\x02\x01\x12\x04\xac2\x08'\n4\n\x05\
    \x04\x80\x02\x02\0\x12\x04\xae2\x02,\x1a%\x20The\x20user_id\x20and\x20ap\
    p_id\x20information.\n\n\x0e\n\x06\x04\x80\x02\x02\0\x06\x12\x04\xae2\
    \x02\x1b\n\x0e\n\x06\x04\x80\x02\x02\0\x01\x12\x04\xae2\x1c'\n\x0e\n\x06\
    \x04\x80\x02\x02\0\x03\x12\x04\xae2*+\nT\n\x05\x04\x80\x02\x02\x01\x12\
    \x04\xb02\x02\x17\x1aE\x20For\x20now\x20view\x20types\x20'apps',\x20'wor\
    kflows',\x20and\x20'models'\x20are\x20supported.\n\n\x0e\n\x06\x04\x80\
    \x02\x02\x01\x05\x12\x04\xb02\x02\x08\n\x0e\n\x06\x04\x80\x02\x02\x01\
    \x01\x12\x04\xb02\t\x12\n\x0e\n\x06\x04\x80\x02\x02\x01\x03\x12\x04\xb02\
    \x15\x16\n\x7f\n\x05\x04\x80\x02\x02\x02\x12\x04\xb32\x02\x12\x1ap\x20(o\
    ptional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20\
    is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defa\
    ults\x20to\x201.\n\n\x0e\n\x06\x04\x80\x02\x02\x02\x05\x12\x04\xb32\x02\
    \x08\n\x0e\n\x06\x04\x80\x02\x02\x02\x01\x12\x04\xb32\t\r\n\x0e\n\x06\
    \x04\x80\x02\x02\x02\x03\x12\x04\xb32\x10\x11\nv\n\x05\x04\x80\x02\x02\
    \x03\x12\x04\xb62\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x80\x02\x02\
    \x03\x05\x12\x04\xb62\x02\x08\n\x0e\n\x06\x04\x80\x02\x02\x03\x01\x12\
    \x04\xb62\t\x11\n\x0e\n\x06\x04\x80\x02\x02\x03\x03\x12\x04\xb62\x14\x15\
    \n1\n\x03\x04\x81\x02\x12\x06\xba2\0\xbd2\x01\x1a\"\x20MultiTrendingMetr\
    icsViewResponse\n\n\x0c\n\x04\x04\x81\x02\x01\x12\x04\xba2\x08(\n\r\n\
    \x05\x04\x81\x02\x02\0\x12\x04\xbb2\x02(\n\x0e\n\x06\x04\x81\x02\x02\0\
    \x06\x12\x04\xbb2\x02\x1c\n\x0e\n\x06\x04\x81\x02\x02\0\x01\x12\x04\xbb2\
    \x1d#\n\x0e\n\x06\x04\x81\x02\x02\0\x03\x12\x04\xbb2&'\n\r\n\x05\x04\x81\
    \x02\x02\x01\x12\x04\xbc2\x02&\n\x0e\n\x06\x04\x81\x02\x02\x01\x04\x12\
    \x04\xbc2\x02\n\n\x0e\n\x06\x04\x81\x02\x02\x01\x06\x12\x04\xbc2\x0b\x19\
    \n\x0e\n\x06\x04\x81\x02\x02\x01\x01\x12\x04\xbc2\x1a!\n\x0e\n\x06\x04\
    \x81\x02\x02\x01\x03\x12\x04\xbc2$%\n!\n\x03\x04\x82\x02\x12\x06\xec2\0\
    \xf02\x01\x1a\x12\x20GetModuleRequest\n\n\x0c\n\x04\x04\x82\x02\x01\x12\
    \x04\xec2\x08\x18\n\r\n\x05\x04\x82\x02\x02\0\x12\x04\xed2\x02,\n\x0e\n\
    \x06\x04\x82\x02\x02\0\x06\x12\x04\xed2\x02\x1b\n\x0e\n\x06\x04\x82\x02\
    \x02\0\x01\x12\x04\xed2\x1c'\n\x0e\n\x06\x04\x82\x02\x02\0\x03\x12\x04\
    \xed2*+\n\r\n\x05\x04\x82\x02\x02\x01\x12\x04\xee2\x02\x17\n\x0e\n\x06\
    \x04\x82\x02\x02\x01\x05\x12\x04\xee2\x02\x08\n\x0e\n\x06\x04\x82\x02\
    \x02\x01\x01\x12\x04\xee2\t\x12\n\x0e\n\x06\x04\x82\x02\x02\x01\x03\x12\
    \x04\xee2\x15\x16\n\r\n\x05\x04\x82\x02\x02\x02\x12\x04\xef2\x02(\n\x0e\
    \n\x06\x04\x82\x02\x02\x02\x04\x12\x04\xef2\x02\n\n\x0e\n\x06\x04\x82\
    \x02\x02\x02\x05\x12\x04\xef2\x0b\x11\n\x0e\n\x06\x04\x82\x02\x02\x02\
    \x01\x12\x04\xef2\x12#\n\x0e\n\x06\x04\x82\x02\x02\x02\x03\x12\x04\xef2&\
    '\n#\n\x03\x04\x83\x02\x12\x06\xf32\0\x903\x01\x1a\x14\x20ListModulesReq\
    uest\n\n\x0c\n\x04\x04\x83\x02\x01\x12\x04\xf32\x08\x1a\n\r\n\x05\x04\
    \x83\x02\x02\0\x12\x04\xf42\x02,\n\x0e\n\x06\x04\x83\x02\x02\0\x06\x12\
    \x04\xf42\x02\x1b\n\x0e\n\x06\x04\x83\x02\x02\0\x01\x12\x04\xf42\x1c'\n\
    \x0e\n\x06\x04\x83\x02\x02\0\x03\x12\x04\xf42*+\n\x7f\n\x05\x04\x83\x02\
    \x02\x01\x12\x04\xf72\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20\
    The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\x83\x02\x02\x01\x05\x12\x04\xf72\x02\x08\n\x0e\n\x06\x04\x83\x02\
    \x02\x01\x01\x12\x04\xf72\t\r\n\x0e\n\x06\x04\x83\x02\x02\x01\x03\x12\
    \x04\xf72\x10\x11\nv\n\x05\x04\x83\x02\x02\x02\x12\x04\xfa2\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\x83\x02\x02\x02\x05\x12\x04\xfa2\x02\x08\n\
    \x0e\n\x06\x04\x83\x02\x02\x02\x01\x12\x04\xfa2\t\x11\n\x0e\n\x06\x04\
    \x83\x02\x02\x02\x03\x12\x04\xfa2\x14\x15\n\r\n\x05\x04\x83\x02\x02\x03\
    \x12\x04\xfc2\x02\x18\n\x0e\n\x06\x04\x83\x02\x02\x03\x05\x12\x04\xfc2\
    \x02\x06\n\x0e\n\x06\x04\x83\x02\x02\x03\x01\x12\x04\xfc2\x07\x13\n\x0e\
    \n\x06\x04\x83\x02\x02\x03\x03\x12\x04\xfc2\x16\x17\n\r\n\x05\x04\x83\
    \x02\x02\x04\x12\x04\xfe2\x02(\n\x0e\n\x06\x04\x83\x02\x02\x04\x04\x12\
    \x04\xfe2\x02\n\n\x0e\n\x06\x04\x83\x02\x02\x04\x05\x12\x04\xfe2\x0b\x11\
    \n\x0e\n\x06\x04\x83\x02\x02\x04\x01\x12\x04\xfe2\x12#\n\x0e\n\x06\x04\
    \x83\x02\x02\x04\x03\x12\x04\xfe2&'\np\n\x05\x04\x83\x02\x02\x05\x12\x04\
    \x823\x02\x1a\x1aa\x20Sorting\x20opitons:\n\x20Whether\x20to\x20sort\x20\
    in\x20ascending\x20order.\x20If\x20false,\x20will\x20order\x20in\x20desc\
    ending\x20order.\n\n\x0e\n\x06\x04\x83\x02\x02\x05\x05\x12\x04\x823\x02\
    \x06\n\x0e\n\x06\x04\x83\x02\x02\x05\x01\x12\x04\x823\x07\x15\n\x0e\n\
    \x06\x04\x83\x02\x02\x05\x03\x12\x04\x823\x18\x19\n\x0f\n\x05\x04\x83\
    \x02\x08\0\x12\x06\x833\x02\x8c3\x03\n\x0e\n\x06\x04\x83\x02\x08\0\x01\
    \x12\x04\x833\x08\x0f\n9\n\x05\x04\x83\x02\x02\x06\x12\x04\x853\x04\x20\
    \x1a*\x20Whether\x20to\x20order\x20by\x20the\x20created_at\x20time.\n\n\
    \x0e\n\x06\x04\x83\x02\x02\x06\x05\x12\x04\x853\x04\x08\n\x0e\n\x06\x04\
    \x83\x02\x02\x06\x01\x12\x04\x853\t\x1b\n\x0e\n\x06\x04\x83\x02\x02\x06\
    \x03\x12\x04\x853\x1e\x1f\nG\n\x05\x04\x83\x02\x02\x07\x12\x04\x873\x04\
    \x20\x1a8\x20Whether\x20to\x20order\x20by\x20the\x20number\x20of\x20user\
    s\x20stared\x20the\x20app\n\n\x0e\n\x06\x04\x83\x02\x02\x07\x05\x12\x04\
    \x873\x04\x08\n\x0e\n\x06\x04\x83\x02\x02\x07\x01\x12\x04\x873\t\x1b\n\
    \x0e\n\x06\x04\x83\x02\x02\x07\x03\x12\x04\x873\x1e\x1f\nQ\n\x05\x04\x83\
    \x02\x02\x08\x12\x04\x893\x04!\x1aB\x20If\x20neither\x20sort\x20option\
    \x20is\x20set\x20to\x20true,\x20will\x20sort\x20by\x20modified_at.\n\n\
    \x0e\n\x06\x04\x83\x02\x02\x08\x05\x12\x04\x893\x04\x08\n\x0e\n\x06\x04\
    \x83\x02\x02\x08\x01\x12\x04\x893\t\x1c\n\x0e\n\x06\x04\x83\x02\x02\x08\
    \x03\x12\x04\x893\x1f\x20\n4\n\x05\x04\x83\x02\x02\t\x12\x04\x8b3\x04\
    \x19\x1a%\x20Whether\x20to\x20order\x20by\x20the\x20external\x20id\n\n\
    \x0e\n\x06\x04\x83\x02\x02\t\x05\x12\x04\x8b3\x04\x08\n\x0e\n\x06\x04\
    \x83\x02\x02\t\x01\x12\x04\x8b3\t\x13\n\x0e\n\x06\x04\x83\x02\x02\t\x03\
    \x12\x04\x8b3\x16\x18\n|\n\x05\x04\x83\x02\x02\n\x12\x04\x8f3\x02\x15\
    \x1am\x20Filter\x20modules\x20by\x20bookmark.\x20If\x20set,\x20only\x20r\
    eturn\x20bookmarked\x20modules.\x20Otherwise\x20none\x20bookmarked\x20mo\
    dules\x20only.\n\n\x0e\n\x06\x04\x83\x02\x02\n\x05\x12\x04\x8f3\x02\x06\
    \n\x0e\n\x06\x04\x83\x02\x02\n\x01\x12\x04\x8f3\x07\x0f\n\x0e\n\x06\x04\
    \x83\x02\x02\n\x03\x12\x04\x8f3\x12\x14\n#\n\x03\x04\x84\x02\x12\x06\x93\
    3\0\x973\x01\x1a\x14\x20PostModulesRequest\n\n\x0c\n\x04\x04\x84\x02\x01\
    \x12\x04\x933\x08\x1a\n\r\n\x05\x04\x84\x02\x02\0\x12\x04\x943\x02,\n\
    \x0e\n\x06\x04\x84\x02\x02\0\x06\x12\x04\x943\x02\x1b\n\x0e\n\x06\x04\
    \x84\x02\x02\0\x01\x12\x04\x943\x1c'\n\x0e\n\x06\x04\x84\x02\x02\0\x03\
    \x12\x04\x943*+\nW\n\x05\x04\x84\x02\x02\x01\x12\x04\x963\x02\x1e\x1aH\
    \x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20module\
    \x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\x84\x02\
    \x02\x01\x04\x12\x04\x963\x02\n\n\x0e\n\x06\x04\x84\x02\x02\x01\x06\x12\
    \x04\x963\x0b\x11\n\x0e\n\x06\x04\x84\x02\x02\x01\x01\x12\x04\x963\x12\
    \x19\n\x0e\n\x06\x04\x84\x02\x02\x01\x03\x12\x04\x963\x1c\x1d\n$\n\x03\
    \x04\x85\x02\x12\x06\x9a3\0\xa13\x01\x1a\x15\x20PatchModulesRequest\n\n\
    \x0c\n\x04\x04\x85\x02\x01\x12\x04\x9a3\x08\x1b\n\r\n\x05\x04\x85\x02\
    \x02\0\x12\x04\x9b3\x02,\n\x0e\n\x06\x04\x85\x02\x02\0\x06\x12\x04\x9b3\
    \x02\x1b\n\x0e\n\x06\x04\x85\x02\x02\0\x01\x12\x04\x9b3\x1c'\n\x0e\n\x06\
    \x04\x85\x02\x02\0\x03\x12\x04\x9b3*+\n\r\n\x05\x04\x85\x02\x02\x01\x12\
    \x04\x9c3\x02\x1e\n\x0e\n\x06\x04\x85\x02\x02\x01\x04\x12\x04\x9c3\x02\n\
    \n\x0e\n\x06\x04\x85\x02\x02\x01\x06\x12\x04\x9c3\x0b\x11\n\x0e\n\x06\
    \x04\x85\x02\x02\x01\x01\x12\x04\x9c3\x12\x19\n\x0e\n\x06\x04\x85\x02\
    \x02\x01\x03\x12\x04\x9c3\x1c\x1d\n\x7f\n\x05\x04\x85\x02\x02\x02\x12\
    \x04\xa03\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwr\
    ite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\x85\x02\
    \x02\x02\x05\x12\x04\xa03\x02\x08\n\x0e\n\x06\x04\x85\x02\x02\x02\x01\
    \x12\x04\xa03\t\x0f\n\x0e\n\x06\x04\x85\x02\x02\x02\x03\x12\x04\xa03\x12\
    \x13\nE\n\x03\x04\x86\x02\x12\x06\xa43\0\xa73\x01\x1a6\x20Request\x20to\
    \x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\
    \x0c\n\x04\x04\x86\x02\x01\x12\x04\xa43\x08\x1c\n\r\n\x05\x04\x86\x02\
    \x02\0\x12\x04\xa53\x02,\n\x0e\n\x06\x04\x86\x02\x02\0\x06\x12\x04\xa53\
    \x02\x1b\n\x0e\n\x06\x04\x86\x02\x02\0\x01\x12\x04\xa53\x1c'\n\x0e\n\x06\
    \x04\x86\x02\x02\0\x03\x12\x04\xa53*+\n\r\n\x05\x04\x86\x02\x02\x01\x12\
    \x04\xa63\x02\x1a\n\x0e\n\x06\x04\x86\x02\x02\x01\x04\x12\x04\xa63\x02\n\
    \n\x0e\n\x06\x04\x86\x02\x02\x01\x05\x12\x04\xa63\x0b\x11\n\x0e\n\x06\
    \x04\x86\x02\x02\x01\x01\x12\x04\xa63\x12\x15\n\x0e\n\x06\x04\x86\x02\
    \x02\x01\x03\x12\x04\xa63\x18\x19\n%\n\x03\x04\x87\x02\x12\x06\xaa3\0\
    \xad3\x01\x1a\x16\x20SingleModuleResponse\n\n\x0c\n\x04\x04\x87\x02\x01\
    \x12\x04\xaa3\x08\x1c\n\r\n\x05\x04\x87\x02\x02\0\x12\x04\xab3\x02(\n\
    \x0e\n\x06\x04\x87\x02\x02\0\x06\x12\x04\xab3\x02\x1c\n\x0e\n\x06\x04\
    \x87\x02\x02\0\x01\x12\x04\xab3\x1d#\n\x0e\n\x06\x04\x87\x02\x02\0\x03\
    \x12\x04\xab3&'\n\r\n\x05\x04\x87\x02\x02\x01\x12\x04\xac3\x02\x14\n\x0e\
    \n\x06\x04\x87\x02\x02\x01\x06\x12\x04\xac3\x02\x08\n\x0e\n\x06\x04\x87\
    \x02\x02\x01\x01\x12\x04\xac3\t\x0f\n\x0e\n\x06\x04\x87\x02\x02\x01\x03\
    \x12\x04\xac3\x12\x13\n$\n\x03\x04\x88\x02\x12\x06\xb03\0\xb33\x01\x1a\
    \x15\x20MultiModuleResponse\n\n\x0c\n\x04\x04\x88\x02\x01\x12\x04\xb03\
    \x08\x1b\n\r\n\x05\x04\x88\x02\x02\0\x12\x04\xb13\x02(\n\x0e\n\x06\x04\
    \x88\x02\x02\0\x06\x12\x04\xb13\x02\x1c\n\x0e\n\x06\x04\x88\x02\x02\0\
    \x01\x12\x04\xb13\x1d#\n\x0e\n\x06\x04\x88\x02\x02\0\x03\x12\x04\xb13&'\
    \n\r\n\x05\x04\x88\x02\x02\x01\x12\x04\xb23\x02M\n\x0e\n\x06\x04\x88\x02\
    \x02\x01\x04\x12\x04\xb23\x02\n\n\x0e\n\x06\x04\x88\x02\x02\x01\x06\x12\
    \x04\xb23\x0b\x11\n\x0e\n\x06\x04\x88\x02\x02\x01\x01\x12\x04\xb23\x12\
    \x19\n\x0e\n\x06\x04\x88\x02\x02\x01\x03\x12\x04\xb23\x1c\x1d\n\x0e\n\
    \x06\x04\x88\x02\x02\x01\x08\x12\x04\xb23\x1eL\n\x11\n\t\x04\x88\x02\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xb23\x1fK\n;\n\x03\x04\x89\x02\x12\x06\xb63\
    \0\xba3\x01\x1a,\x20request\x20for\x20different\x20endpoints\x20currentl\
    y.\n\n\x0c\n\x04\x04\x89\x02\x01\x12\x04\xb63\x08\x1f\n\r\n\x05\x04\x89\
    \x02\x02\0\x12\x04\xb73\x02,\n\x0e\n\x06\x04\x89\x02\x02\0\x06\x12\x04\
    \xb73\x02\x1b\n\x0e\n\x06\x04\x89\x02\x02\0\x01\x12\x04\xb73\x1c'\n\x0e\
    \n\x06\x04\x89\x02\x02\0\x03\x12\x04\xb73*+\n\r\n\x05\x04\x89\x02\x02\
    \x01\x12\x04\xb83\x02\x17\n\x0e\n\x06\x04\x89\x02\x02\x01\x05\x12\x04\
    \xb83\x02\x08\n\x0e\n\x06\x04\x89\x02\x02\x01\x01\x12\x04\xb83\t\x12\n\
    \x0e\n\x06\x04\x89\x02\x02\x01\x03\x12\x04\xb83\x15\x16\n\r\n\x05\x04\
    \x89\x02\x02\x02\x12\x04\xb93\x02\x1f\n\x0e\n\x06\x04\x89\x02\x02\x02\
    \x05\x12\x04\xb93\x02\x08\n\x0e\n\x06\x04\x89\x02\x02\x02\x01\x12\x04\
    \xb93\t\x1a\n\x0e\n\x06\x04\x89\x02\x02\x02\x03\x12\x04\xb93\x1d\x1e\n*\
    \n\x03\x04\x8a\x02\x12\x06\xbd3\0\xc63\x01\x1a\x1b\x20ListModuleVersions\
    Request\n\n\x0c\n\x04\x04\x8a\x02\x01\x12\x04\xbd3\x08!\n\r\n\x05\x04\
    \x8a\x02\x02\0\x12\x04\xbe3\x02,\n\x0e\n\x06\x04\x8a\x02\x02\0\x06\x12\
    \x04\xbe3\x02\x1b\n\x0e\n\x06\x04\x8a\x02\x02\0\x01\x12\x04\xbe3\x1c'\n\
    \x0e\n\x06\x04\x8a\x02\x02\0\x03\x12\x04\xbe3*+\n\r\n\x05\x04\x8a\x02\
    \x02\x01\x12\x04\xbf3\x02\x17\n\x0e\n\x06\x04\x8a\x02\x02\x01\x05\x12\
    \x04\xbf3\x02\x08\n\x0e\n\x06\x04\x8a\x02\x02\x01\x01\x12\x04\xbf3\t\x12\
    \n\x0e\n\x06\x04\x8a\x02\x02\x01\x03\x12\x04\xbf3\x15\x16\n\x7f\n\x05\
    \x04\x8a\x02\x02\x02\x12\x04\xc23\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \x0e\n\x06\x04\x8a\x02\x02\x02\x05\x12\x04\xc23\x02\x08\n\x0e\n\x06\x04\
    \x8a\x02\x02\x02\x01\x12\x04\xc23\t\r\n\x0e\n\x06\x04\x8a\x02\x02\x02\
    \x03\x12\x04\xc23\x10\x11\nv\n\x05\x04\x8a\x02\x02\x03\x12\x04\xc53\x02\
    \x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20re\
    sults\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defau\
    lts\n\x20to\x20128.\n\n\x0e\n\x06\x04\x8a\x02\x02\x03\x05\x12\x04\xc53\
    \x02\x08\n\x0e\n\x06\x04\x8a\x02\x02\x03\x01\x12\x04\xc53\t\x11\n\x0e\n\
    \x06\x04\x8a\x02\x02\x03\x03\x12\x04\xc53\x14\x15\n*\n\x03\x04\x8b\x02\
    \x12\x06\xc93\0\xce3\x01\x1a\x1b\x20PostModuleVersionsRequest\n\n\x0c\n\
    \x04\x04\x8b\x02\x01\x12\x04\xc93\x08!\n\r\n\x05\x04\x8b\x02\x02\0\x12\
    \x04\xca3\x02,\n\x0e\n\x06\x04\x8b\x02\x02\0\x06\x12\x04\xca3\x02\x1b\n\
    \x0e\n\x06\x04\x8b\x02\x02\0\x01\x12\x04\xca3\x1c'\n\x0e\n\x06\x04\x8b\
    \x02\x02\0\x03\x12\x04\xca3*+\n\r\n\x05\x04\x8b\x02\x02\x01\x12\x04\xcb3\
    \x02\x17\n\x0e\n\x06\x04\x8b\x02\x02\x01\x05\x12\x04\xcb3\x02\x08\n\x0e\
    \n\x06\x04\x8b\x02\x02\x01\x01\x12\x04\xcb3\t\x12\n\x0e\n\x06\x04\x8b\
    \x02\x02\x01\x03\x12\x04\xcb3\x15\x16\nW\n\x05\x04\x8b\x02\x02\x02\x12\
    \x04\xcd3\x02-\x1aH\x20This\x20allows\x20you\x20to\x20create\x20one\x20o\
    r\x20more\x20module\x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\x0e\
    \n\x06\x04\x8b\x02\x02\x02\x04\x12\x04\xcd3\x02\n\n\x0e\n\x06\x04\x8b\
    \x02\x02\x02\x06\x12\x04\xcd3\x0b\x18\n\x0e\n\x06\x04\x8b\x02\x02\x02\
    \x01\x12\x04\xcd3\x19(\n\x0e\n\x06\x04\x8b\x02\x02\x02\x03\x12\x04\xcd3+\
    ,\nN\n\x03\x04\x8c\x02\x12\x06\xd13\0\xd53\x01\x1a?\x20Request\x20to\x20\
    delete\x20several\x20module\x20versions\x20by\x20the\x20list\x20of\x20id\
    s.\n\n\x0c\n\x04\x04\x8c\x02\x01\x12\x04\xd13\x08#\n\r\n\x05\x04\x8c\x02\
    \x02\0\x12\x04\xd23\x02,\n\x0e\n\x06\x04\x8c\x02\x02\0\x06\x12\x04\xd23\
    \x02\x1b\n\x0e\n\x06\x04\x8c\x02\x02\0\x01\x12\x04\xd23\x1c'\n\x0e\n\x06\
    \x04\x8c\x02\x02\0\x03\x12\x04\xd23*+\n\r\n\x05\x04\x8c\x02\x02\x01\x12\
    \x04\xd33\x02\x17\n\x0e\n\x06\x04\x8c\x02\x02\x01\x05\x12\x04\xd33\x02\
    \x08\n\x0e\n\x06\x04\x8c\x02\x02\x01\x01\x12\x04\xd33\t\x12\n\x0e\n\x06\
    \x04\x8c\x02\x02\x01\x03\x12\x04\xd33\x15\x16\n\r\n\x05\x04\x8c\x02\x02\
    \x02\x12\x04\xd43\x02\x1a\n\x0e\n\x06\x04\x8c\x02\x02\x02\x04\x12\x04\
    \xd43\x02\n\n\x0e\n\x06\x04\x8c\x02\x02\x02\x05\x12\x04\xd43\x0b\x11\n\
    \x0e\n\x06\x04\x8c\x02\x02\x02\x01\x12\x04\xd43\x12\x15\n\x0e\n\x06\x04\
    \x8c\x02\x02\x02\x03\x12\x04\xd43\x18\x19\n,\n\x03\x04\x8d\x02\x12\x06\
    \xd83\0\xdb3\x01\x1a\x1d\x20SingleModuleVersionResponse\n\n\x0c\n\x04\
    \x04\x8d\x02\x01\x12\x04\xd83\x08#\n\r\n\x05\x04\x8d\x02\x02\0\x12\x04\
    \xd93\x02(\n\x0e\n\x06\x04\x8d\x02\x02\0\x06\x12\x04\xd93\x02\x1c\n\x0e\
    \n\x06\x04\x8d\x02\x02\0\x01\x12\x04\xd93\x1d#\n\x0e\n\x06\x04\x8d\x02\
    \x02\0\x03\x12\x04\xd93&'\n\r\n\x05\x04\x8d\x02\x02\x01\x12\x04\xda3\x02\
    #\n\x0e\n\x06\x04\x8d\x02\x02\x01\x06\x12\x04\xda3\x02\x0f\n\x0e\n\x06\
    \x04\x8d\x02\x02\x01\x01\x12\x04\xda3\x10\x1e\n\x0e\n\x06\x04\x8d\x02\
    \x02\x01\x03\x12\x04\xda3!\"\n+\n\x03\x04\x8e\x02\x12\x06\xde3\0\xe13\
    \x01\x1a\x1c\x20MultiModuleVersionResponse\n\n\x0c\n\x04\x04\x8e\x02\x01\
    \x12\x04\xde3\x08\"\n\r\n\x05\x04\x8e\x02\x02\0\x12\x04\xdf3\x02(\n\x0e\
    \n\x06\x04\x8e\x02\x02\0\x06\x12\x04\xdf3\x02\x1c\n\x0e\n\x06\x04\x8e\
    \x02\x02\0\x01\x12\x04\xdf3\x1d#\n\x0e\n\x06\x04\x8e\x02\x02\0\x03\x12\
    \x04\xdf3&'\n\r\n\x05\x04\x8e\x02\x02\x01\x12\x04\xe03\x02\\\n\x0e\n\x06\
    \x04\x8e\x02\x02\x01\x04\x12\x04\xe03\x02\n\n\x0e\n\x06\x04\x8e\x02\x02\
    \x01\x06\x12\x04\xe03\x0b\x18\n\x0e\n\x06\x04\x8e\x02\x02\x01\x01\x12\
    \x04\xe03\x19(\n\x0e\n\x06\x04\x8e\x02\x02\x01\x03\x12\x04\xe03+,\n\x0e\
    \n\x06\x04\x8e\x02\x02\x01\x08\x12\x04\xe03-[\n\x11\n\t\x04\x8e\x02\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xe03.Z\n1\n\x03\x04\x8f\x02\x12\x06\xe63\0\
    \xea3\x01\x1a\"\x20GetInstalledModuleVersionRequest\n\n\x0c\n\x04\x04\
    \x8f\x02\x01\x12\x04\xe63\x08(\n\r\n\x05\x04\x8f\x02\x02\0\x12\x04\xe73\
    \x02,\n\x0e\n\x06\x04\x8f\x02\x02\0\x06\x12\x04\xe73\x02\x1b\n\x0e\n\x06\
    \x04\x8f\x02\x02\0\x01\x12\x04\xe73\x1c'\n\x0e\n\x06\x04\x8f\x02\x02\0\
    \x03\x12\x04\xe73*+\n=\n\x05\x04\x8f\x02\x02\x01\x12\x04\xe93\x02)\x1a.\
    \x20the\x20ID\x20to\x20get\x20of\x20the\x20install\x20module\x20version.\
    \n\n\x0e\n\x06\x04\x8f\x02\x02\x01\x05\x12\x04\xe93\x02\x08\n\x0e\n\x06\
    \x04\x8f\x02\x02\x01\x01\x12\x04\xe93\t$\n\x0e\n\x06\x04\x8f\x02\x02\x01\
    \x03\x12\x04\xe93'(\n3\n\x03\x04\x90\x02\x12\x06\xed3\0\xf53\x01\x1a$\
    \x20ListInstalledModuleVersionsRequest\n\n\x0c\n\x04\x04\x90\x02\x01\x12\
    \x04\xed3\x08*\n\r\n\x05\x04\x90\x02\x02\0\x12\x04\xee3\x02,\n\x0e\n\x06\
    \x04\x90\x02\x02\0\x06\x12\x04\xee3\x02\x1b\n\x0e\n\x06\x04\x90\x02\x02\
    \0\x01\x12\x04\xee3\x1c'\n\x0e\n\x06\x04\x90\x02\x02\0\x03\x12\x04\xee3*\
    +\n\x7f\n\x05\x04\x90\x02\x02\x01\x12\x04\xf13\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\x90\x02\x02\x01\x05\x12\x04\xf13\x02\x08\
    \n\x0e\n\x06\x04\x90\x02\x02\x01\x01\x12\x04\xf13\t\r\n\x0e\n\x06\x04\
    \x90\x02\x02\x01\x03\x12\x04\xf13\x10\x11\nv\n\x05\x04\x90\x02\x02\x02\
    \x12\x04\xf43\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x90\x02\x02\x02\
    \x05\x12\x04\xf43\x02\x08\n\x0e\n\x06\x04\x90\x02\x02\x02\x01\x12\x04\
    \xf43\t\x11\n\x0e\n\x06\x04\x90\x02\x02\x02\x03\x12\x04\xf43\x14\x15\ng\
    \n\x03\x04\x91\x02\x12\x06\xf83\0\xfc3\x01\x1aX\x20PostInstalledModuleVe\
    rsionsRequest\x20to\x20install\x20a\x20module\x20version\x20into\x20the\
    \x20app\x20in\x20the\x20URL\n\n\x0c\n\x04\x04\x91\x02\x01\x12\x04\xf83\
    \x08*\n\r\n\x05\x04\x91\x02\x02\0\x12\x04\xf93\x02,\n\x0e\n\x06\x04\x91\
    \x02\x02\0\x06\x12\x04\xf93\x02\x1b\n\x0e\n\x06\x04\x91\x02\x02\0\x01\
    \x12\x04\xf93\x1c'\n\x0e\n\x06\x04\x91\x02\x02\0\x03\x12\x04\xf93*+\nW\n\
    \x05\x04\x91\x02\x02\x01\x12\x04\xfb3\x02@\x1aH\x20This\x20allows\x20you\
    \x20to\x20create\x20one\x20or\x20more\x20module\x20by\x20posting\x20it\
    \x20to\x20the\x20API.\n\n\x0e\n\x06\x04\x91\x02\x02\x01\x04\x12\x04\xfb3\
    \x02\n\n\x0e\n\x06\x04\x91\x02\x02\x01\x06\x12\x04\xfb3\x0b!\n\x0e\n\x06\
    \x04\x91\x02\x02\x01\x01\x12\x04\xfb3\";\n\x0e\n\x06\x04\x91\x02\x02\x01\
    \x03\x12\x04\xfb3>?\n{\n\x03\x04\x92\x02\x12\x06\x804\0\x884\x01\x1al\
    \x20PostInstalledModuleVersionsKeyRequest\x20to\x20associate\x20a\x20key\
    \x20of\x20the\x20caller's\x20to\x20the\x20installed\x20module\n\x20versi\
    on.\n\n\x0c\n\x04\x04\x92\x02\x01\x12\x04\x804\x08-\n\r\n\x05\x04\x92\
    \x02\x02\0\x12\x04\x814\x02,\n\x0e\n\x06\x04\x92\x02\x02\0\x06\x12\x04\
    \x814\x02\x1b\n\x0e\n\x06\x04\x92\x02\x02\0\x01\x12\x04\x814\x1c'\n\x0e\
    \n\x06\x04\x92\x02\x02\0\x03\x12\x04\x814*+\n\xf6\x02\n\x05\x04\x92\x02\
    \x02\x01\x12\x04\x834\x02)\x1a.\x20the\x20ID\x20to\x20get\x20of\x20the\
    \x20install\x20module\x20version.\n\"\xb6\x02\x20Note(zeiler):\x20we\x20\
    don't\x20provide\x20a\x20key\x20to\x20create\x20since\x20it's\x20always\
    \x20deterministic.\n\x20we'll\x20create\x20a\x20PAT,\x20owned\x20by\x20t\
    he\x20caller\x20with\x20the\x20scopes\x20that\x20the\x20module\x20reques\
    ts.\n\x20in\x20the\x20future\x20if\x20we\x20want\x20we\x20can\x20pass\
    \x20in\x20a\x20Key\x20key\x20=\x203;\x20field\x20so\x20that\x20the\x20ca\
    ller\n\x20can\x20adjust\x20the\x20scopes,\x20but\x20for\x20now\x20that\
    \x20doesn't\x20seem\x20necessary.\n\n\x0e\n\x06\x04\x92\x02\x02\x01\x05\
    \x12\x04\x834\x02\x08\n\x0e\n\x06\x04\x92\x02\x02\x01\x01\x12\x04\x834\t\
    $\n\x0e\n\x06\x04\x92\x02\x02\x01\x03\x12\x04\x834'(\nX\n\x03\x04\x93\
    \x02\x12\x06\x8b4\0\x8e4\x01\x1aI\x20Request\x20to\x20delete\x20several\
    \x20installed\x20module\x20versions\x20by\x20the\x20list\x20of\x20ids.\n\
    \n\x0c\n\x04\x04\x93\x02\x01\x12\x04\x8b4\x08,\n\r\n\x05\x04\x93\x02\x02\
    \0\x12\x04\x8c4\x02,\n\x0e\n\x06\x04\x93\x02\x02\0\x06\x12\x04\x8c4\x02\
    \x1b\n\x0e\n\x06\x04\x93\x02\x02\0\x01\x12\x04\x8c4\x1c'\n\x0e\n\x06\x04\
    \x93\x02\x02\0\x03\x12\x04\x8c4*+\n\r\n\x05\x04\x93\x02\x02\x01\x12\x04\
    \x8d4\x02\x1a\n\x0e\n\x06\x04\x93\x02\x02\x01\x04\x12\x04\x8d4\x02\n\n\
    \x0e\n\x06\x04\x93\x02\x02\x01\x05\x12\x04\x8d4\x0b\x11\n\x0e\n\x06\x04\
    \x93\x02\x02\x01\x01\x12\x04\x8d4\x12\x15\n\x0e\n\x06\x04\x93\x02\x02\
    \x01\x03\x12\x04\x8d4\x18\x19\n5\n\x03\x04\x94\x02\x12\x06\x914\0\x944\
    \x01\x1a&\x20SingleInstalledModuleVersionResponse\n\n\x0c\n\x04\x04\x94\
    \x02\x01\x12\x04\x914\x08,\n\r\n\x05\x04\x94\x02\x02\0\x12\x04\x924\x02(\
    \n\x0e\n\x06\x04\x94\x02\x02\0\x06\x12\x04\x924\x02\x1c\n\x0e\n\x06\x04\
    \x94\x02\x02\0\x01\x12\x04\x924\x1d#\n\x0e\n\x06\x04\x94\x02\x02\0\x03\
    \x12\x04\x924&'\n\r\n\x05\x04\x94\x02\x02\x01\x12\x04\x934\x026\n\x0e\n\
    \x06\x04\x94\x02\x02\x01\x06\x12\x04\x934\x02\x18\n\x0e\n\x06\x04\x94\
    \x02\x02\x01\x01\x12\x04\x934\x191\n\x0e\n\x06\x04\x94\x02\x02\x01\x03\
    \x12\x04\x93445\n4\n\x03\x04\x95\x02\x12\x06\x974\0\x9a4\x01\x1a%\x20Mul\
    tiInstalledModuleVersionResponse\n\n\x0c\n\x04\x04\x95\x02\x01\x12\x04\
    \x974\x08+\n\r\n\x05\x04\x95\x02\x02\0\x12\x04\x984\x02(\n\x0e\n\x06\x04\
    \x95\x02\x02\0\x06\x12\x04\x984\x02\x1c\n\x0e\n\x06\x04\x95\x02\x02\0\
    \x01\x12\x04\x984\x1d#\n\x0e\n\x06\x04\x95\x02\x02\0\x03\x12\x04\x984&'\
    \n\r\n\x05\x04\x95\x02\x02\x01\x12\x04\x994\x02o\n\x0e\n\x06\x04\x95\x02\
    \x02\x01\x04\x12\x04\x994\x02\n\n\x0e\n\x06\x04\x95\x02\x02\x01\x06\x12\
    \x04\x994\x0b!\n\x0e\n\x06\x04\x95\x02\x02\x01\x01\x12\x04\x994\";\n\x0e\
    \n\x06\x04\x95\x02\x02\x01\x03\x12\x04\x994>?\n\x0e\n\x06\x04\x95\x02\
    \x02\x01\x08\x12\x04\x994@n\n\x11\n\t\x04\x95\x02\x02\x01\x08\xd0\x86\
    \x03\x12\x04\x994Am\n/\n\x03\x04\x96\x02\x12\x06\x9d4\0\xa04\x01\x1a\x20\
    \x20ListNextTaskAssignmentsRequest\n\n\x0c\n\x04\x04\x96\x02\x01\x12\x04\
    \x9d4\x08&\n\r\n\x05\x04\x96\x02\x02\0\x12\x04\x9e4\x02,\n\x0e\n\x06\x04\
    \x96\x02\x02\0\x06\x12\x04\x9e4\x02\x1b\n\x0e\n\x06\x04\x96\x02\x02\0\
    \x01\x12\x04\x9e4\x1c'\n\x0e\n\x06\x04\x96\x02\x02\0\x03\x12\x04\x9e4*+\
    \n\r\n\x05\x04\x96\x02\x02\x01\x12\x04\x9f4\x02\x15\n\x0e\n\x06\x04\x96\
    \x02\x02\x01\x05\x12\x04\x9f4\x02\x08\n\x0e\n\x06\x04\x96\x02\x02\x01\
    \x01\x12\x04\x9f4\t\x10\n\x0e\n\x06\x04\x96\x02\x02\x01\x03\x12\x04\x9f4\
    \x13\x14\n^\n\x03\x04\x97\x02\x12\x06\xa34\0\xa74\x01\x1aO\x20Request\
    \x20to\x20perform\x20bulk\x20operations\x20on\x20a\x20list\x20of\x20inpu\
    ts\x20based\x20on\x20input\x20source.\n\n\x0c\n\x04\x04\x97\x02\x01\x12\
    \x04\xa34\x08!\n\r\n\x05\x04\x97\x02\x02\0\x12\x04\xa44\x02,\n\x0e\n\x06\
    \x04\x97\x02\x02\0\x06\x12\x04\xa44\x02\x1b\n\x0e\n\x06\x04\x97\x02\x02\
    \0\x01\x12\x04\xa44\x1c'\n\x0e\n\x06\x04\x97\x02\x02\0\x03\x12\x04\xa44*\
    +\nj\n\x05\x04\x97\x02\x02\x01\x12\x04\xa64\x02:\x1a[\x20List\x20of\x20b\
    ulk\x20operation(s)\x20to\x20be\x20performed\x20e.g\x20bulk\x20update\
    \x20metadata\x20or\x20tags\x20or\x20labels\x20etc.\n\n\x0e\n\x06\x04\x97\
    \x02\x02\x01\x04\x12\x04\xa64\x02\n\n\x0e\n\x06\x04\x97\x02\x02\x01\x06\
    \x12\x04\xa64\x0b%\n\x0e\n\x06\x04\x97\x02\x02\x01\x01\x12\x04\xa64&5\n\
    \x0e\n\x06\x04\x97\x02\x02\x01\x03\x12\x04\xa6489\n9\n\x03\x04\x98\x02\
    \x12\x06\xaa4\0\xb24\x01\x1a*\x20Request\x20to\x20list\x20all\x20the\x20\
    bulk\x20operations.\n\n\x0c\n\x04\x04\x98\x02\x01\x12\x04\xaa4\x08!\n\r\
    \n\x05\x04\x98\x02\x02\0\x12\x04\xab4\x02,\n\x0e\n\x06\x04\x98\x02\x02\0\
    \x06\x12\x04\xab4\x02\x1b\n\x0e\n\x06\x04\x98\x02\x02\0\x01\x12\x04\xab4\
    \x1c'\n\x0e\n\x06\x04\x98\x02\x02\0\x03\x12\x04\xab4*+\n\x7f\n\x05\x04\
    \x98\x02\x02\x01\x12\x04\xae4\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\x98\x02\x02\x01\x05\x12\x04\xae4\x02\x08\n\x0e\n\x06\x04\x98\
    \x02\x02\x01\x01\x12\x04\xae4\t\r\n\x0e\n\x06\x04\x98\x02\x02\x01\x03\
    \x12\x04\xae4\x10\x11\nv\n\x05\x04\x98\x02\x02\x02\x12\x04\xb14\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\x98\x02\x02\x02\x05\x12\x04\xb14\x02\
    \x08\n\x0e\n\x06\x04\x98\x02\x02\x02\x01\x12\x04\xb14\t\x11\n\x0e\n\x06\
    \x04\x98\x02\x02\x02\x03\x12\x04\xb14\x14\x15\nF\n\x03\x04\x99\x02\x12\
    \x06\xb54\0\xb94\x01\x1a7\x20Request\x20to\x20get\x20the\x20details\x20o\
    f\x20a\x20bulk\x20operation\x20by\x20ID.\n\n\x0c\n\x04\x04\x99\x02\x01\
    \x12\x04\xb54\x08\x1f\n\r\n\x05\x04\x99\x02\x02\0\x12\x04\xb64\x02,\n\
    \x0e\n\x06\x04\x99\x02\x02\0\x06\x12\x04\xb64\x02\x1b\n\x0e\n\x06\x04\
    \x99\x02\x02\0\x01\x12\x04\xb64\x1c'\n\x0e\n\x06\x04\x99\x02\x02\0\x03\
    \x12\x04\xb64*+\n&\n\x05\x04\x99\x02\x02\x01\x12\x04\xb84\x02\x10\x1a\
    \x17\x20The\x20bulk\x20operation\x20id\n\n\x0e\n\x06\x04\x99\x02\x02\x01\
    \x05\x12\x04\xb84\x02\x08\n\x0e\n\x06\x04\x99\x02\x02\x01\x01\x12\x04\
    \xb84\t\x0b\n\x0e\n\x06\x04\x99\x02\x02\x01\x03\x12\x04\xb84\x0e\x0f\n4\
    \n\x03\x04\x9a\x02\x12\x06\xbc4\0\xc04\x01\x1a%\x20Cancel\x20a\x20list\
    \x20of\x20bulk\x20operation\x20ids\n\n\x0c\n\x04\x04\x9a\x02\x01\x12\x04\
    \xbc4\x08\"\n\r\n\x05\x04\x9a\x02\x02\0\x12\x04\xbd4\x02,\n\x0e\n\x06\
    \x04\x9a\x02\x02\0\x06\x12\x04\xbd4\x02\x1b\n\x0e\n\x06\x04\x9a\x02\x02\
    \0\x01\x12\x04\xbd4\x1c'\n\x0e\n\x06\x04\x9a\x02\x02\0\x03\x12\x04\xbd4*\
    +\n;\n\x05\x04\x9a\x02\x02\x01\x12\x04\xbf4\x02\x1a\x1a,\x20List\x20of\
    \x20bulk\x20operation\x20ids\x20to\x20be\x20cancelled\n\n\x0e\n\x06\x04\
    \x9a\x02\x02\x01\x04\x12\x04\xbf4\x02\n\n\x0e\n\x06\x04\x9a\x02\x02\x01\
    \x05\x12\x04\xbf4\x0b\x11\n\x0e\n\x06\x04\x9a\x02\x02\x01\x01\x12\x04\
    \xbf4\x12\x15\n\x0e\n\x06\x04\x9a\x02\x02\x01\x03\x12\x04\xbf4\x18\x19\n\
    |\n\x03\x04\x9b\x02\x12\x06\xc44\0\xc84\x01\x1am\x20Request\x20to\x20del\
    ete\x20the\x20terminated\x20bulk\x20operations\x20by\x20ID\n\x20Only\x20\
    operations\x20in\x20terminated\x20state\x20can\x20be\x20deleted.\n\n\x0c\
    \n\x04\x04\x9b\x02\x01\x12\x04\xc44\x08\"\n\r\n\x05\x04\x9b\x02\x02\0\
    \x12\x04\xc54\x02,\n\x0e\n\x06\x04\x9b\x02\x02\0\x06\x12\x04\xc54\x02\
    \x1b\n\x0e\n\x06\x04\x9b\x02\x02\0\x01\x12\x04\xc54\x1c'\n\x0e\n\x06\x04\
    \x9b\x02\x02\0\x03\x12\x04\xc54*+\n9\n\x05\x04\x9b\x02\x02\x01\x12\x04\
    \xc74\x02\x1a\x1a*\x20List\x20of\x20bulk\x20operation\x20ids\x20to\x20be\
    \x20deleted\n\n\x0e\n\x06\x04\x9b\x02\x02\x01\x04\x12\x04\xc74\x02\n\n\
    \x0e\n\x06\x04\x9b\x02\x02\x01\x05\x12\x04\xc74\x0b\x11\n\x0e\n\x06\x04\
    \x9b\x02\x02\x01\x01\x12\x04\xc74\x12\x15\n\x0e\n\x06\x04\x9b\x02\x02\
    \x01\x03\x12\x04\xc74\x18\x19\n-\n\x03\x04\x9c\x02\x12\x06\xcb4\0\xce4\
    \x01\x1a\x1e\x20SingleBulkOperationsResponse\n\n\x0c\n\x04\x04\x9c\x02\
    \x01\x12\x04\xcb4\x08$\n\r\n\x05\x04\x9c\x02\x02\0\x12\x04\xcc4\x02(\n\
    \x0e\n\x06\x04\x9c\x02\x02\0\x06\x12\x04\xcc4\x02\x1c\n\x0e\n\x06\x04\
    \x9c\x02\x02\0\x01\x12\x04\xcc4\x1d#\n\x0e\n\x06\x04\x9c\x02\x02\0\x03\
    \x12\x04\xcc4&'\n\r\n\x05\x04\x9c\x02\x02\x01\x12\x04\xcd4\x020\n\x0e\n\
    \x06\x04\x9c\x02\x02\x01\x06\x12\x04\xcd4\x02\x1c\n\x0e\n\x06\x04\x9c\
    \x02\x02\x01\x01\x12\x04\xcd4\x1d+\n\x0e\n\x06\x04\x9c\x02\x02\x01\x03\
    \x12\x04\xcd4./\n,\n\x03\x04\x9d\x02\x12\x06\xd14\0\xd44\x01\x1a\x1d\x20\
    MultiBulkOperationsResponse\n\n\x0c\n\x04\x04\x9d\x02\x01\x12\x04\xd14\
    \x08#\n\r\n\x05\x04\x9d\x02\x02\0\x12\x04\xd24\x02(\n\x0e\n\x06\x04\x9d\
    \x02\x02\0\x06\x12\x04\xd24\x02\x1c\n\x0e\n\x06\x04\x9d\x02\x02\0\x01\
    \x12\x04\xd24\x1d#\n\x0e\n\x06\x04\x9d\x02\x02\0\x03\x12\x04\xd24&'\n\r\
    \n\x05\x04\x9d\x02\x02\x01\x12\x04\xd34\x029\n\x0e\n\x06\x04\x9d\x02\x02\
    \x01\x04\x12\x04\xd34\x02\n\n\x0e\n\x06\x04\x9d\x02\x02\x01\x06\x12\x04\
    \xd34\x0b%\n\x0e\n\x06\x04\x9d\x02\x02\x01\x01\x12\x04\xd34&4\n\x0e\n\
    \x06\x04\x9d\x02\x02\x01\x03\x12\x04\xd3478\n*\n\x03\x04\x9e\x02\x12\x06\
    \xdb4\0\xdf4\x01\x1a\x1b\x20PutTaskAssignmentsRequest\n\n\x0c\n\x04\x04\
    \x9e\x02\x01\x12\x04\xdb4\x08!\n\r\n\x05\x04\x9e\x02\x02\0\x12\x04\xdc4\
    \x02,\n\x0e\n\x06\x04\x9e\x02\x02\0\x06\x12\x04\xdc4\x02\x1b\n\x0e\n\x06\
    \x04\x9e\x02\x02\0\x01\x12\x04\xdc4\x1c'\n\x0e\n\x06\x04\x9e\x02\x02\0\
    \x03\x12\x04\xdc4*+\n\r\n\x05\x04\x9e\x02\x02\x01\x12\x04\xdd4\x02\x15\n\
    \x0e\n\x06\x04\x9e\x02\x02\x01\x05\x12\x04\xdd4\x02\x08\n\x0e\n\x06\x04\
    \x9e\x02\x02\x01\x01\x12\x04\xdd4\t\x10\n\x0e\n\x06\x04\x9e\x02\x02\x01\
    \x03\x12\x04\xdd4\x13\x14\n\r\n\x05\x04\x9e\x02\x02\x02\x12\x04\xde4\x02\
    \x16\n\x0e\n\x06\x04\x9e\x02\x02\x02\x05\x12\x04\xde4\x02\x08\n\x0e\n\
    \x06\x04\x9e\x02\x02\x02\x01\x12\x04\xde4\t\x11\n\x0e\n\x06\x04\x9e\x02\
    \x02\x02\x03\x12\x04\xde4\x14\x15\n2\n\x03\x04\x9f\x02\x12\x06\xe74\0\
    \xef4\x01\x1a#\x20List\x20all\x20the\x20input\x20ingestion\x20jobs\n\n\
    \x0c\n\x04\x04\x9f\x02\x01\x12\x04\xe74\x08\x20\n\r\n\x05\x04\x9f\x02\
    \x02\0\x12\x04\xe84\x02,\n\x0e\n\x06\x04\x9f\x02\x02\0\x06\x12\x04\xe84\
    \x02\x1b\n\x0e\n\x06\x04\x9f\x02\x02\0\x01\x12\x04\xe84\x1c'\n\x0e\n\x06\
    \x04\x9f\x02\x02\0\x03\x12\x04\xe84*+\n\x7f\n\x05\x04\x9f\x02\x02\x01\
    \x12\x04\xeb4\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20p\
    age\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resu\
    lts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x9f\
    \x02\x02\x01\x05\x12\x04\xeb4\x02\x08\n\x0e\n\x06\x04\x9f\x02\x02\x01\
    \x01\x12\x04\xeb4\t\r\n\x0e\n\x06\x04\x9f\x02\x02\x01\x03\x12\x04\xeb4\
    \x10\x11\nv\n\x05\x04\x9f\x02\x02\x02\x12\x04\xee4\x02\x16\x1ag\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128\
    .\n\n\x0e\n\x06\x04\x9f\x02\x02\x02\x05\x12\x04\xee4\x02\x08\n\x0e\n\x06\
    \x04\x9f\x02\x02\x02\x01\x12\x04\xee4\t\x11\n\x0e\n\x06\x04\x9f\x02\x02\
    \x02\x03\x12\x04\xee4\x14\x15\n\r\n\x03\x04\xa0\x02\x12\x06\xf14\0\xf54\
    \x01\n\x0c\n\x04\x04\xa0\x02\x01\x12\x04\xf14\x08\x1e\n\r\n\x05\x04\xa0\
    \x02\x02\0\x12\x04\xf24\x02,\n\x0e\n\x06\x04\xa0\x02\x02\0\x06\x12\x04\
    \xf24\x02\x1b\n\x0e\n\x06\x04\xa0\x02\x02\0\x01\x12\x04\xf24\x1c'\n\x0e\
    \n\x06\x04\xa0\x02\x02\0\x03\x12\x04\xf24*+\n%\n\x05\x04\xa0\x02\x02\x01\
    \x12\x04\xf44\x02\x10\x1a\x16\x20id\x20of\x20add\x20inputs\x20job\n\n\
    \x0e\n\x06\x04\xa0\x02\x02\x01\x05\x12\x04\xf44\x02\x08\n\x0e\n\x06\x04\
    \xa0\x02\x02\x01\x01\x12\x04\xf44\t\x0b\n\x0e\n\x06\x04\xa0\x02\x02\x01\
    \x03\x12\x04\xf44\x0e\x0f\n\r\n\x03\x04\xa1\x02\x12\x06\xf74\0\xfb4\x01\
    \n\x0c\n\x04\x04\xa1\x02\x01\x12\x04\xf74\x08!\n\r\n\x05\x04\xa1\x02\x02\
    \0\x12\x04\xf84\x02,\n\x0e\n\x06\x04\xa1\x02\x02\0\x06\x12\x04\xf84\x02\
    \x1b\n\x0e\n\x06\x04\xa1\x02\x02\0\x01\x12\x04\xf84\x1c'\n\x0e\n\x06\x04\
    \xa1\x02\x02\0\x03\x12\x04\xf84*+\n5\n\x05\x04\xa1\x02\x02\x01\x12\x04\
    \xfa4\x02\x10\x1a&\x20id\x20of\x20add\x20inputs\x20job\x20to\x20be\x20ca\
    ncelled\n\n\x0e\n\x06\x04\xa1\x02\x02\x01\x05\x12\x04\xfa4\x02\x08\n\x0e\
    \n\x06\x04\xa1\x02\x02\x01\x01\x12\x04\xfa4\t\x0b\n\x0e\n\x06\x04\xa1\
    \x02\x02\x01\x03\x12\x04\xfa4\x0e\x0f\n*\n\x03\x04\xa2\x02\x12\x06\xfe4\
    \0\x815\x01\x1a\x1b\x20MultiInputsAddJobResponse\n\n\x0c\n\x04\x04\xa2\
    \x02\x01\x12\x04\xfe4\x08!\n\r\n\x05\x04\xa2\x02\x02\0\x12\x04\xff4\x02(\
    \n\x0e\n\x06\x04\xa2\x02\x02\0\x06\x12\x04\xff4\x02\x1c\n\x0e\n\x06\x04\
    \xa2\x02\x02\0\x01\x12\x04\xff4\x1d#\n\x0e\n\x06\x04\xa2\x02\x02\0\x03\
    \x12\x04\xff4&'\n\r\n\x05\x04\xa2\x02\x02\x01\x12\x04\x805\x02h\n\x0e\n\
    \x06\x04\xa2\x02\x02\x01\x04\x12\x04\x805\x02\n\n\x0e\n\x06\x04\xa2\x02\
    \x02\x01\x06\x12\x04\x805\x0b$\n\x0e\n\x06\x04\xa2\x02\x02\x01\x01\x12\
    \x04\x805%4\n\x0e\n\x06\x04\xa2\x02\x02\x01\x03\x12\x04\x80578\n\x0e\n\
    \x06\x04\xa2\x02\x02\x01\x08\x12\x04\x8059g\n\x11\n\t\x04\xa2\x02\x02\
    \x01\x08\xd0\x86\x03\x12\x04\x805:f\n+\n\x03\x04\xa3\x02\x12\x06\x845\0\
    \x875\x01\x1a\x1c\x20SingleInputsAddJobResponse\n\n\x0c\n\x04\x04\xa3\
    \x02\x01\x12\x04\x845\x08\"\n\r\n\x05\x04\xa3\x02\x02\0\x12\x04\x855\x02\
    (\n\x0e\n\x06\x04\xa3\x02\x02\0\x06\x12\x04\x855\x02\x1c\n\x0e\n\x06\x04\
    \xa3\x02\x02\0\x01\x12\x04\x855\x1d#\n\x0e\n\x06\x04\xa3\x02\x02\0\x03\
    \x12\x04\x855&'\n\r\n\x05\x04\xa3\x02\x02\x01\x12\x04\x865\x02/\n\x0e\n\
    \x06\x04\xa3\x02\x02\x01\x06\x12\x04\x865\x02\x1b\n\x0e\n\x06\x04\xa3\
    \x02\x02\x01\x01\x12\x04\x865\x1c*\n\x0e\n\x06\x04\xa3\x02\x02\x01\x03\
    \x12\x04\x865-.\n)\n\x03\x04\xa4\x02\x12\x06\x8a5\0\x8d5\x01\x1a\x1a\x20\
    Start\x20a\x20multipart\x20upload\n\n\x0c\n\x04\x04\xa4\x02\x01\x12\x04\
    \x8a5\x08\x1a\n\r\n\x05\x04\xa4\x02\x02\0\x12\x04\x8b5\x02,\n\x0e\n\x06\
    \x04\xa4\x02\x02\0\x06\x12\x04\x8b5\x02\x1b\n\x0e\n\x06\x04\xa4\x02\x02\
    \0\x01\x12\x04\x8b5\x1c'\n\x0e\n\x06\x04\xa4\x02\x02\0\x03\x12\x04\x8b5*\
    +\n\r\n\x05\x04\xa4\x02\x02\x01\x12\x04\x8c5\x02+\n\x0e\n\x06\x04\xa4\
    \x02\x02\x01\x04\x12\x04\x8c5\x02\n\n\x0e\n\x06\x04\xa4\x02\x02\x01\x06\
    \x12\x04\x8c5\x0b\x1e\n\x0e\n\x06\x04\xa4\x02\x02\x01\x01\x12\x04\x8c5\
    \x1f&\n\x0e\n\x06\x04\xa4\x02\x02\x01\x03\x12\x04\x8c5)*\n2\n\x03\x04\
    \xa5\x02\x12\x06\x905\0\x935\x01\x1a#\x20Stops\x20or\x20deletes\x20multi\
    part\x20upload\n\n\x0c\n\x04\x04\xa5\x02\x01\x12\x04\x905\x08\x1c\n\r\n\
    \x05\x04\xa5\x02\x02\0\x12\x04\x915\x02,\n\x0e\n\x06\x04\xa5\x02\x02\0\
    \x06\x12\x04\x915\x02\x1b\n\x0e\n\x06\x04\xa5\x02\x02\0\x01\x12\x04\x915\
    \x1c'\n\x0e\n\x06\x04\xa5\x02\x02\0\x03\x12\x04\x915*+\n\r\n\x05\x04\xa5\
    \x02\x02\x01\x12\x04\x925\x02\x1a\n\x0e\n\x06\x04\xa5\x02\x02\x01\x04\
    \x12\x04\x925\x02\n\n\x0e\n\x06\x04\xa5\x02\x02\x01\x05\x12\x04\x925\x0b\
    \x11\n\x0e\n\x06\x04\xa5\x02\x02\x01\x01\x12\x04\x925\x12\x15\n\x0e\n\
    \x06\x04\xa5\x02\x02\x01\x03\x12\x04\x925\x18\x19\n\r\n\x03\x04\xa6\x02\
    \x12\x06\x955\0\x9d5\x01\n\x0c\n\x04\x04\xa6\x02\x01\x12\x04\x955\x08\
    \x1a\n\r\n\x05\x04\xa6\x02\x02\0\x12\x04\x965\x02,\n\x0e\n\x06\x04\xa6\
    \x02\x02\0\x06\x12\x04\x965\x02\x1b\n\x0e\n\x06\x04\xa6\x02\x02\0\x01\
    \x12\x04\x965\x1c'\n\x0e\n\x06\x04\xa6\x02\x02\0\x03\x12\x04\x965*+\n\
    \x7f\n\x05\x04\xa6\x02\x02\x01\x12\x04\x995\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xa6\x02\x02\x01\x05\x12\x04\x995\x02\x08\
    \n\x0e\n\x06\x04\xa6\x02\x02\x01\x01\x12\x04\x995\t\r\n\x0e\n\x06\x04\
    \xa6\x02\x02\x01\x03\x12\x04\x995\x10\x11\nv\n\x05\x04\xa6\x02\x02\x02\
    \x12\x04\x9c5\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xa6\x02\x02\x02\
    \x05\x12\x04\x9c5\x02\x08\n\x0e\n\x06\x04\xa6\x02\x02\x02\x01\x12\x04\
    \x9c5\t\x11\n\x0e\n\x06\x04\xa6\x02\x02\x02\x03\x12\x04\x9c5\x14\x15\n\r\
    \n\x03\x04\xa7\x02\x12\x06\x9f5\0\xa45\x01\n\x0c\n\x04\x04\xa7\x02\x01\
    \x12\x04\x9f5\x08\x18\n\r\n\x05\x04\xa7\x02\x02\0\x12\x04\xa05\x02,\n\
    \x0e\n\x06\x04\xa7\x02\x02\0\x06\x12\x04\xa05\x02\x1b\n\x0e\n\x06\x04\
    \xa7\x02\x02\0\x01\x12\x04\xa05\x1c'\n\x0e\n\x06\x04\xa7\x02\x02\0\x03\
    \x12\x04\xa05*+\n\x1a\n\x05\x04\xa7\x02\x02\x01\x12\x04\xa35\x02\x17\x1a\
    \x0b\x20Upload\x20ID\n\n\x0e\n\x06\x04\xa7\x02\x02\x01\x05\x12\x04\xa35\
    \x02\x08\n\x0e\n\x06\x04\xa7\x02\x02\x01\x01\x12\x04\xa35\t\x12\n\x0e\n\
    \x06\x04\xa7\x02\x02\x01\x03\x12\x04\xa35\x15\x16\n\r\n\x03\x04\xa8\x02\
    \x12\x06\xa65\0\xa95\x01\n\x0c\n\x04\x04\xa8\x02\x01\x12\x04\xa65\x08\
    \x1c\n\r\n\x05\x04\xa8\x02\x02\0\x12\x04\xa75\x02(\n\x0e\n\x06\x04\xa8\
    \x02\x02\0\x06\x12\x04\xa75\x02\x1c\n\x0e\n\x06\x04\xa8\x02\x02\0\x01\
    \x12\x04\xa75\x1d#\n\x0e\n\x06\x04\xa8\x02\x02\0\x03\x12\x04\xa75&'\n\r\
    \n\x05\x04\xa8\x02\x02\x01\x12\x04\xa85\x02!\n\x0e\n\x06\x04\xa8\x02\x02\
    \x01\x06\x12\x04\xa85\x02\x15\n\x0e\n\x06\x04\xa8\x02\x02\x01\x01\x12\
    \x04\xa85\x16\x1c\n\x0e\n\x06\x04\xa8\x02\x02\x01\x03\x12\x04\xa85\x1f\
    \x20\n\r\n\x03\x04\xa9\x02\x12\x06\xab5\0\xae5\x01\n\x0c\n\x04\x04\xa9\
    \x02\x01\x12\x04\xab5\x08\x1b\n\r\n\x05\x04\xa9\x02\x02\0\x12\x04\xac5\
    \x02(\n\x0e\n\x06\x04\xa9\x02\x02\0\x06\x12\x04\xac5\x02\x1c\n\x0e\n\x06\
    \x04\xa9\x02\x02\0\x01\x12\x04\xac5\x1d#\n\x0e\n\x06\x04\xa9\x02\x02\0\
    \x03\x12\x04\xac5&'\n\r\n\x05\x04\xa9\x02\x02\x01\x12\x04\xad5\x02+\n\
    \x0e\n\x06\x04\xa9\x02\x02\x01\x04\x12\x04\xad5\x02\n\n\x0e\n\x06\x04\
    \xa9\x02\x02\x01\x06\x12\x04\xad5\x0b\x1e\n\x0e\n\x06\x04\xa9\x02\x02\
    \x01\x01\x12\x04\xad5\x1f&\n\x0e\n\x06\x04\xa9\x02\x02\x01\x03\x12\x04\
    \xad5)*\n\x8c\x01\n\x03\x04\xaa\x02\x12\x06\xb25\0\xb65\x01\x1a}\x20Uplo\
    ad\x20a\x20part\x20of\x20a\x20multipart\x20upload.\n\x20Behaviour\x20on\
    \x20completion\x20depends\x20on\x20the\x20endpoint\x20that\x20was\x20use\
    d\x20to\x20initiate\x20the\x20upload.\n\n\x0c\n\x04\x04\xaa\x02\x01\x12\
    \x04\xb25\x08$\n\r\n\x05\x04\xaa\x02\x02\0\x12\x04\xb35\x02,\n\x0e\n\x06\
    \x04\xaa\x02\x02\0\x06\x12\x04\xb35\x02\x1b\n\x0e\n\x06\x04\xaa\x02\x02\
    \0\x01\x12\x04\xb35\x1c'\n\x0e\n\x06\x04\xaa\x02\x02\0\x03\x12\x04\xb35*\
    +\n\r\n\x05\x04\xaa\x02\x02\x01\x12\x04\xb45\x02\x17\n\x0e\n\x06\x04\xaa\
    \x02\x02\x01\x05\x12\x04\xb45\x02\x08\n\x0e\n\x06\x04\xaa\x02\x02\x01\
    \x01\x12\x04\xb45\t\x12\n\x0e\n\x06\x04\xaa\x02\x02\x01\x03\x12\x04\xb45\
    \x15\x16\n\r\n\x05\x04\xaa\x02\x02\x02\x12\x04\xb55\x02/\n\x0e\n\x06\x04\
    \xaa\x02\x02\x02\x04\x12\x04\xb55\x02\n\n\x0e\n\x06\x04\xaa\x02\x02\x02\
    \x06\x12\x04\xb55\x0b\x1c\n\x0e\n\x06\x04\xaa\x02\x02\x02\x01\x12\x04\
    \xb55\x1d*\n\x0e\n\x06\x04\xaa\x02\x02\x02\x03\x12\x04\xb55-.\n\xad\x06\
    \n\x03\x04\xab\x02\x12\x06\xc55\0\xcf5\x01\x1a\x9d\x06\x20Initiates\x20r\
    etrieval\x20of\x20inputs\x20from\x20cloud\x20storage\x20from\x20a\x20use\
    r\x20provided\x20data\x20source.\n\x20Will\x20create\x20and\x20return\
    \x20an\x20inputs-add-job\x20for\x20tracking\x20progress.\n\x20Archives\
    \x20will\x20be\x20extracted\x20and\x20their\x20contents\x20will\x20be\
    \x20processed\x20as\x20inputs.\n\n\x20The\x20cloud\x20URL\x20will\x20be\
    \x20treated\x20as\x20a\x20filter\x20prefix.\x20For\x20example\x20s3:/buc\
    ket/images_folder/abc\x20will\x20process\n\x20files\x20in\x20the\x20imag\
    es_folder\x20beginning\x20with\x20abc\x20or\x20in\x20a\x20subfolder\x20b\
    eginning\x20with\x20abc.\n\x20For\x20example:\n\x20bucket/images_folder/\
    abcImage.png\n\x20bucket/images_folder/abc-1/Data.zip\n\n\x20If\x20given\
    \x20URL\x20is\x20for\x20a\x20private\x20bucket\x20or\x20file,\x20then\
    \x20credentials\x20should\x20be\x20provided\x20to\x20access\x20the\x20bu\
    cket.\n\x20Credentials\x20should\x20include\x20rights\x20to\x20list\x20t\
    he\x20objects\x20in\x20the\x20bucket,\x20except\x20when\x20pointed\x20di\
    rectly\x20at\x20a\x20file\x20archive,\n\x20in\x20which\x20case\x20it\x20\
    only\x20requires\x20rights\x20to\x20access\x20that\x20particular\x20file\
    .\n\n\x0c\n\x04\x04\xab\x02\x01\x12\x04\xc55\x08$\n\r\n\x05\x04\xab\x02\
    \x02\0\x12\x04\xc65\x02,\n\x0e\n\x06\x04\xab\x02\x02\0\x06\x12\x04\xc65\
    \x02\x1b\n\x0e\n\x06\x04\xab\x02\x02\0\x01\x12\x04\xc65\x1c'\n\x0e\n\x06\
    \x04\xab\x02\x02\0\x03\x12\x04\xc65*+\n\r\n\x05\x04\xab\x02\x02\x01\x12\
    \x04\xc85\x02-\n\x0e\n\x06\x04\xab\x02\x02\x01\x04\x12\x04\xc85\x02\n\n\
    \x0e\n\x06\x04\xab\x02\x02\x01\x06\x12\x04\xc85\x0b\x1b\n\x0e\n\x06\x04\
    \xab\x02\x02\x01\x01\x12\x04\xc85\x1c(\n\x0e\n\x06\x04\xab\x02\x02\x01\
    \x03\x12\x04\xc85+,\ng\n\x05\x04\xab\x02\x02\x02\x12\x04\xcb5\x02\x1b\
    \x1aX\x20If\x20call\x20back\x20url\x20is\x20set,\x20we\x20will\x20send\
    \x20a\x20Post\x20request\x20to\x20this\x20endpoint\x20with\x20job\x20sta\
    tus.\n\n\x0e\n\x06\x04\xab\x02\x02\x02\x05\x12\x04\xcb5\x02\x08\n\x0e\n\
    \x06\x04\xab\x02\x02\x02\x01\x12\x04\xcb5\t\x16\n\x0e\n\x06\x04\xab\x02\
    \x02\x02\x03\x12\x04\xcb5\x19\x1a\nS\n\x05\x04\xab\x02\x02\x03\x12\x04\
    \xce5\x02\x15\x1aD\x20Personal\x20Access\x20Token\x20to\x20the\x20applic\
    ation\x20to\x20which\x20inputs\x20are\x20added\n\n\x0e\n\x06\x04\xab\x02\
    \x02\x03\x05\x12\x04\xce5\x02\x08\n\x0e\n\x06\x04\xab\x02\x02\x03\x01\
    \x12\x04\xce5\t\x10\n\x0e\n\x06\x04\xab\x02\x02\x03\x03\x12\x04\xce5\x13\
    \x14\n\r\n\x03\x04\xac\x02\x12\x06\xd15\0\xd55\x01\n\x0c\n\x04\x04\xac\
    \x02\x01\x12\x04\xd15\x08%\n\r\n\x05\x04\xac\x02\x02\0\x12\x04\xd25\x02,\
    \n\x0e\n\x06\x04\xac\x02\x02\0\x06\x12\x04\xd25\x02\x1b\n\x0e\n\x06\x04\
    \xac\x02\x02\0\x01\x12\x04\xd25\x1c'\n\x0e\n\x06\x04\xac\x02\x02\0\x03\
    \x12\x04\xd25*+\n\r\n\x05\x04\xac\x02\x02\x01\x12\x04\xd45\x02&\n\x0e\n\
    \x06\x04\xac\x02\x02\x01\x05\x12\x04\xd45\x02\x08\n\x0e\n\x06\x04\xac\
    \x02\x02\x01\x01\x12\x04\xd45\t!\n\x0e\n\x06\x04\xac\x02\x02\x01\x03\x12\
    \x04\xd45$%\n\r\n\x03\x04\xad\x02\x12\x06\xd75\0\xdf5\x01\n\x0c\n\x04\
    \x04\xad\x02\x01\x12\x04\xd75\x08'\n\r\n\x05\x04\xad\x02\x02\0\x12\x04\
    \xd85\x02,\n\x0e\n\x06\x04\xad\x02\x02\0\x06\x12\x04\xd85\x02\x1b\n\x0e\
    \n\x06\x04\xad\x02\x02\0\x01\x12\x04\xd85\x1c'\n\x0e\n\x06\x04\xad\x02\
    \x02\0\x03\x12\x04\xd85*+\n\x7f\n\x05\x04\xad\x02\x02\x01\x12\x04\xdb5\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xad\x02\x02\x01\
    \x05\x12\x04\xdb5\x02\x08\n\x0e\n\x06\x04\xad\x02\x02\x01\x01\x12\x04\
    \xdb5\t\r\n\x0e\n\x06\x04\xad\x02\x02\x01\x03\x12\x04\xdb5\x10\x11\nv\n\
    \x05\x04\xad\x02\x02\x02\x12\x04\xde5\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\xad\x02\x02\x02\x05\x12\x04\xde5\x02\x08\n\x0e\n\x06\x04\xad\
    \x02\x02\x02\x01\x12\x04\xde5\t\x11\n\x0e\n\x06\x04\xad\x02\x02\x02\x03\
    \x12\x04\xde5\x14\x15\n\r\n\x03\x04\xae\x02\x12\x06\xe15\0\xe45\x01\n\
    \x0c\n\x04\x04\xae\x02\x01\x12\x04\xe15\x08)\n\r\n\x05\x04\xae\x02\x02\0\
    \x12\x04\xe25\x02(\n\x0e\n\x06\x04\xae\x02\x02\0\x06\x12\x04\xe25\x02\
    \x1c\n\x0e\n\x06\x04\xae\x02\x02\0\x01\x12\x04\xe25\x1d#\n\x0e\n\x06\x04\
    \xae\x02\x02\0\x03\x12\x04\xe25&'\n\r\n\x05\x04\xae\x02\x02\x01\x12\x04\
    \xe35\x02=\n\x0e\n\x06\x04\xae\x02\x02\x01\x06\x12\x04\xe35\x02\"\n\x0e\
    \n\x06\x04\xae\x02\x02\x01\x01\x12\x04\xe35#8\n\x0e\n\x06\x04\xae\x02\
    \x02\x01\x03\x12\x04\xe35;<\n\r\n\x03\x04\xaf\x02\x12\x06\xe65\0\xe95\
    \x01\n\x0c\n\x04\x04\xaf\x02\x01\x12\x04\xe65\x08(\n\r\n\x05\x04\xaf\x02\
    \x02\0\x12\x04\xe75\x02(\n\x0e\n\x06\x04\xaf\x02\x02\0\x06\x12\x04\xe75\
    \x02\x1c\n\x0e\n\x06\x04\xaf\x02\x02\0\x01\x12\x04\xe75\x1d#\n\x0e\n\x06\
    \x04\xaf\x02\x02\0\x03\x12\x04\xe75&'\n\r\n\x05\x04\xaf\x02\x02\x01\x12\
    \x04\xe85\x02G\n\x0e\n\x06\x04\xaf\x02\x02\x01\x04\x12\x04\xe85\x02\n\n\
    \x0e\n\x06\x04\xaf\x02\x02\x01\x06\x12\x04\xe85\x0b+\n\x0e\n\x06\x04\xaf\
    \x02\x02\x01\x01\x12\x04\xe85,B\n\x0e\n\x06\x04\xaf\x02\x02\x01\x03\x12\
    \x04\xe85EF\n4\n\x03\x04\xb0\x02\x12\x06\xec5\0\xf05\x01\x1a%\x20Cancel\
    \x20a\x20list\x20of\x20extraction\x20job\x20ids\n\n\x0c\n\x04\x04\xb0\
    \x02\x01\x12\x04\xec5\x08)\n\r\n\x05\x04\xb0\x02\x02\0\x12\x04\xed5\x02,\
    \n\x0e\n\x06\x04\xb0\x02\x02\0\x06\x12\x04\xed5\x02\x1b\n\x0e\n\x06\x04\
    \xb0\x02\x02\0\x01\x12\x04\xed5\x1c'\n\x0e\n\x06\x04\xb0\x02\x02\0\x03\
    \x12\x04\xed5*+\n;\n\x05\x04\xb0\x02\x02\x01\x12\x04\xef5\x02\x1a\x1a,\
    \x20List\x20of\x20extraction\x20job\x20ids\x20to\x20be\x20cancelled\n\n\
    \x0e\n\x06\x04\xb0\x02\x02\x01\x04\x12\x04\xef5\x02\n\n\x0e\n\x06\x04\
    \xb0\x02\x02\x01\x05\x12\x04\xef5\x0b\x11\n\x0e\n\x06\x04\xb0\x02\x02\
    \x01\x01\x12\x04\xef5\x12\x15\n\x0e\n\x06\x04\xb0\x02\x02\x01\x03\x12\
    \x04\xef5\x18\x19\n\xe6\x02\n\x03\x04\xb1\x02\x12\x06\xf75\0\xfa5\x01\
    \x1a\xd6\x02\x20Start\x20uploading\x20a\x20file\x20archive\x20containing\
    \x20inputs.\n\x20Will\x20create\x20and\x20return\x20an\x20inputs-add-job\
    \x20for\x20tracking\x20progress.\n\n\x20Associated\x20inputs-add-job\x20\
    contains\x20an\x20upload\x20id\x20which\x20should\x20be\x20completed\x20\
    through\x20`PutUploadContentParts`\x20endpoint.\n\x20Completing\x20the\
    \x20upload\x20will\x20automatically\x20begin\x20unpacking\x20the\x20arch\
    ive\x20and\x20uploading\x20the\x20contents\x20as\x20inputs.\n\n\x0c\n\
    \x04\x04\xb1\x02\x01\x12\x04\xf75\x08\x20\n\r\n\x05\x04\xb1\x02\x02\0\
    \x12\x04\xf85\x02,\n\x0e\n\x06\x04\xb1\x02\x02\0\x06\x12\x04\xf85\x02\
    \x1b\n\x0e\n\x06\x04\xb1\x02\x02\0\x01\x12\x04\xf85\x1c'\n\x0e\n\x06\x04\
    \xb1\x02\x02\0\x03\x12\x04\xf85*+\n\r\n\x05\x04\xb1\x02\x02\x01\x12\x04\
    \xf95\x028\n\x0e\n\x06\x04\xb1\x02\x02\x01\x04\x12\x04\xf95\x02\n\n\x0e\
    \n\x06\x04\xb1\x02\x02\x01\x06\x12\x04\xf95\x0b$\n\x0e\n\x06\x04\xb1\x02\
    \x02\x01\x01\x12\x04\xf95%3\n\x0e\n\x06\x04\xb1\x02\x02\x01\x03\x12\x04\
    \xf9567\n!\n\x03\x04\xb2\x02\x12\x06\xfd5\0\x806\x01\x1a\x12\x20GetRunne\
    rRequest\n\n\x0c\n\x04\x04\xb2\x02\x01\x12\x04\xfd5\x08\x18\n\r\n\x05\
    \x04\xb2\x02\x02\0\x12\x04\xfe5\x02,\n\x0e\n\x06\x04\xb2\x02\x02\0\x06\
    \x12\x04\xfe5\x02\x1b\n\x0e\n\x06\x04\xb2\x02\x02\0\x01\x12\x04\xfe5\x1c\
    '\n\x0e\n\x06\x04\xb2\x02\x02\0\x03\x12\x04\xfe5*+\n\r\n\x05\x04\xb2\x02\
    \x02\x01\x12\x04\xff5\x02\x17\n\x0e\n\x06\x04\xb2\x02\x02\x01\x05\x12\
    \x04\xff5\x02\x08\n\x0e\n\x06\x04\xb2\x02\x02\x01\x01\x12\x04\xff5\t\x12\
    \n\x0e\n\x06\x04\xb2\x02\x02\x01\x03\x12\x04\xff5\x15\x16\n#\n\x03\x04\
    \xb3\x02\x12\x06\x836\0\x8b6\x01\x1a\x14\x20ListRunnersRequest\n\n\x0c\n\
    \x04\x04\xb3\x02\x01\x12\x04\x836\x08\x1a\n\r\n\x05\x04\xb3\x02\x02\0\
    \x12\x04\x846\x02,\n\x0e\n\x06\x04\xb3\x02\x02\0\x06\x12\x04\x846\x02\
    \x1b\n\x0e\n\x06\x04\xb3\x02\x02\0\x01\x12\x04\x846\x1c'\n\x0e\n\x06\x04\
    \xb3\x02\x02\0\x03\x12\x04\x846*+\n\x7f\n\x05\x04\xb3\x02\x02\x01\x12\
    \x04\x876\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xb3\x02\
    \x02\x01\x05\x12\x04\x876\x02\x08\n\x0e\n\x06\x04\xb3\x02\x02\x01\x01\
    \x12\x04\x876\t\r\n\x0e\n\x06\x04\xb3\x02\x02\x01\x03\x12\x04\x876\x10\
    \x11\nv\n\x05\x04\xb3\x02\x02\x02\x12\x04\x8a6\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\xb3\x02\x02\x02\x05\x12\x04\x8a6\x02\x08\n\x0e\n\x06\
    \x04\xb3\x02\x02\x02\x01\x12\x04\x8a6\t\x11\n\x0e\n\x06\x04\xb3\x02\x02\
    \x02\x03\x12\x04\x8a6\x14\x15\n#\n\x03\x04\xb4\x02\x12\x06\x8e6\0\x926\
    \x01\x1a\x14\x20PostRunnersRequest\n\n\x0c\n\x04\x04\xb4\x02\x01\x12\x04\
    \x8e6\x08\x1a\n\r\n\x05\x04\xb4\x02\x02\0\x12\x04\x8f6\x02,\n\x0e\n\x06\
    \x04\xb4\x02\x02\0\x06\x12\x04\x8f6\x02\x1b\n\x0e\n\x06\x04\xb4\x02\x02\
    \0\x01\x12\x04\x8f6\x1c'\n\x0e\n\x06\x04\xb4\x02\x02\0\x03\x12\x04\x8f6*\
    +\nW\n\x05\x04\xb4\x02\x02\x01\x12\x04\x916\x02\x1e\x1aH\x20This\x20allo\
    ws\x20you\x20to\x20create\x20one\x20or\x20more\x20runner\x20by\x20postin\
    g\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\xb4\x02\x02\x01\x04\x12\
    \x04\x916\x02\n\n\x0e\n\x06\x04\xb4\x02\x02\x01\x06\x12\x04\x916\x0b\x11\
    \n\x0e\n\x06\x04\xb4\x02\x02\x01\x01\x12\x04\x916\x12\x19\n\x0e\n\x06\
    \x04\xb4\x02\x02\x01\x03\x12\x04\x916\x1c\x1d\nE\n\x03\x04\xb5\x02\x12\
    \x06\x956\0\x986\x01\x1a6\x20Request\x20to\x20delete\x20several\x20thing\
    s\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xb5\x02\x01\x12\
    \x04\x956\x08\x1c\n\r\n\x05\x04\xb5\x02\x02\0\x12\x04\x966\x02,\n\x0e\n\
    \x06\x04\xb5\x02\x02\0\x06\x12\x04\x966\x02\x1b\n\x0e\n\x06\x04\xb5\x02\
    \x02\0\x01\x12\x04\x966\x1c'\n\x0e\n\x06\x04\xb5\x02\x02\0\x03\x12\x04\
    \x966*+\n\r\n\x05\x04\xb5\x02\x02\x01\x12\x04\x976\x02\x1a\n\x0e\n\x06\
    \x04\xb5\x02\x02\x01\x04\x12\x04\x976\x02\n\n\x0e\n\x06\x04\xb5\x02\x02\
    \x01\x05\x12\x04\x976\x0b\x11\n\x0e\n\x06\x04\xb5\x02\x02\x01\x01\x12\
    \x04\x976\x12\x15\n\x0e\n\x06\x04\xb5\x02\x02\x01\x03\x12\x04\x976\x18\
    \x19\n%\n\x03\x04\xb6\x02\x12\x06\x9d6\0\xa06\x01\x1a\x16\x20SingleRunne\
    rResponse\n\n\x0c\n\x04\x04\xb6\x02\x01\x12\x04\x9d6\x08\x1c\n\r\n\x05\
    \x04\xb6\x02\x02\0\x12\x04\x9e6\x02(\n\x0e\n\x06\x04\xb6\x02\x02\0\x06\
    \x12\x04\x9e6\x02\x1c\n\x0e\n\x06\x04\xb6\x02\x02\0\x01\x12\x04\x9e6\x1d\
    #\n\x0e\n\x06\x04\xb6\x02\x02\0\x03\x12\x04\x9e6&'\n\r\n\x05\x04\xb6\x02\
    \x02\x01\x12\x04\x9f6\x02\x14\n\x0e\n\x06\x04\xb6\x02\x02\x01\x06\x12\
    \x04\x9f6\x02\x08\n\x0e\n\x06\x04\xb6\x02\x02\x01\x01\x12\x04\x9f6\t\x0f\
    \n\x0e\n\x06\x04\xb6\x02\x02\x01\x03\x12\x04\x9f6\x12\x13\n$\n\x03\x04\
    \xb7\x02\x12\x06\xa36\0\xa66\x01\x1a\x15\x20MultiRunnerResponse\n\n\x0c\
    \n\x04\x04\xb7\x02\x01\x12\x04\xa36\x08\x1b\n\r\n\x05\x04\xb7\x02\x02\0\
    \x12\x04\xa46\x02(\n\x0e\n\x06\x04\xb7\x02\x02\0\x06\x12\x04\xa46\x02\
    \x1c\n\x0e\n\x06\x04\xb7\x02\x02\0\x01\x12\x04\xa46\x1d#\n\x0e\n\x06\x04\
    \xb7\x02\x02\0\x03\x12\x04\xa46&'\n\r\n\x05\x04\xb7\x02\x02\x01\x12\x04\
    \xa56\x02M\n\x0e\n\x06\x04\xb7\x02\x02\x01\x04\x12\x04\xa56\x02\n\n\x0e\
    \n\x06\x04\xb7\x02\x02\x01\x06\x12\x04\xa56\x0b\x11\n\x0e\n\x06\x04\xb7\
    \x02\x02\x01\x01\x12\x04\xa56\x12\x19\n\x0e\n\x06\x04\xb7\x02\x02\x01\
    \x03\x12\x04\xa56\x1c\x1d\n\x0e\n\x06\x04\xb7\x02\x02\x01\x08\x12\x04\
    \xa56\x1eL\n\x11\n\t\x04\xb7\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xa56\
    \x1fK\n\r\n\x03\x04\xb8\x02\x12\x06\xac6\0\xaf6\x01\n\x0c\n\x04\x04\xb8\
    \x02\x01\x12\x04\xac6\x08\x1e\n\r\n\x05\x04\xb8\x02\x02\0\x12\x04\xad6\
    \x02,\n\x0e\n\x06\x04\xb8\x02\x02\0\x06\x12\x04\xad6\x02\x1b\n\x0e\n\x06\
    \x04\xb8\x02\x02\0\x01\x12\x04\xad6\x1c'\n\x0e\n\x06\x04\xb8\x02\x02\0\
    \x03\x12\x04\xad6*+\n\r\n\x05\x04\xb8\x02\x02\x01\x12\x04\xae6\x02\x17\n\
    \x0e\n\x06\x04\xb8\x02\x02\x01\x05\x12\x04\xae6\x02\x08\n\x0e\n\x06\x04\
    \xb8\x02\x02\x01\x01\x12\x04\xae6\t\x12\n\x0e\n\x06\x04\xb8\x02\x02\x01\
    \x03\x12\x04\xae6\x15\x16\n-\n\x03\x04\xb9\x02\x12\x06\xb26\0\xb86\x01\
    \x1a\x1e\x20PostRunnerItemOutputsRequest\n\n\x0c\n\x04\x04\xb9\x02\x01\
    \x12\x04\xb26\x08$\n\r\n\x05\x04\xb9\x02\x02\0\x12\x04\xb36\x02,\n\x0e\n\
    \x06\x04\xb9\x02\x02\0\x06\x12\x04\xb36\x02\x1b\n\x0e\n\x06\x04\xb9\x02\
    \x02\0\x01\x12\x04\xb36\x1c'\n\x0e\n\x06\x04\xb9\x02\x02\0\x03\x12\x04\
    \xb36*+\n\r\n\x05\x04\xb9\x02\x02\x01\x12\x04\xb46\x02\x17\n\x0e\n\x06\
    \x04\xb9\x02\x02\x01\x05\x12\x04\xb46\x02\x08\n\x0e\n\x06\x04\xb9\x02\
    \x02\x01\x01\x12\x04\xb46\t\x12\n\x0e\n\x06\x04\xb9\x02\x02\x01\x03\x12\
    \x04\xb46\x15\x16\n\r\n\x05\x04\xb9\x02\x02\x02\x12\x04\xb56\x02\x15\n\
    \x0e\n\x06\x04\xb9\x02\x02\x02\x05\x12\x04\xb56\x02\x08\n\x0e\n\x06\x04\
    \xb9\x02\x02\x02\x01\x12\x04\xb56\t\x10\n\x0e\n\x06\x04\xb9\x02\x02\x02\
    \x03\x12\x04\xb56\x13\x14\nW\n\x05\x04\xb9\x02\x02\x03\x12\x04\xb76\x024\
    \x1aH\x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20r\
    unner\x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\xb9\
    \x02\x02\x03\x04\x12\x04\xb76\x02\n\n\x0e\n\x06\x04\xb9\x02\x02\x03\x06\
    \x12\x04\xb76\x0b\x1b\n\x0e\n\x06\x04\xb9\x02\x02\x03\x01\x12\x04\xb76\
    \x1c/\n\x0e\n\x06\x04\xb9\x02\x02\x03\x03\x12\x04\xb7623\n(\n\x03\x04\
    \xba\x02\x12\x06\xbf6\0\xc26\x01\x1a\x19\x20MultiRunnerItemResponse\n\n\
    \x0c\n\x04\x04\xba\x02\x01\x12\x04\xbf6\x08\x1f\n\r\n\x05\x04\xba\x02\
    \x02\0\x12\x04\xc06\x02(\n\x0e\n\x06\x04\xba\x02\x02\0\x06\x12\x04\xc06\
    \x02\x1c\n\x0e\n\x06\x04\xba\x02\x02\0\x01\x12\x04\xc06\x1d#\n\x0e\n\x06\
    \x04\xba\x02\x02\0\x03\x12\x04\xc06&'\n\r\n\x05\x04\xba\x02\x02\x01\x12\
    \x04\xc16\x02O\n\x0e\n\x06\x04\xba\x02\x02\x01\x04\x12\x04\xc16\x02\n\n\
    \x0e\n\x06\x04\xba\x02\x02\x01\x06\x12\x04\xc16\x0b\x15\n\x0e\n\x06\x04\
    \xba\x02\x02\x01\x01\x12\x04\xc16\x16\x1b\n\x0e\n\x06\x04\xba\x02\x02\
    \x01\x03\x12\x04\xc16\x1e\x1f\n\x0e\n\x06\x04\xba\x02\x02\x01\x08\x12\
    \x04\xc16\x20N\n\x11\n\t\x04\xba\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xc1\
    6!M\n\r\n\x03\x04\xbb\x02\x12\x06\xc46\0\xcf6\x01\n\x0c\n\x04\x04\xbb\
    \x02\x01\x12\x04\xc46\x08\x12\n0\n\x05\x04\xbb\x02\x02\0\x12\x04\xc66\
    \x02\x10\x1a!\x20A\x20UUID\x20hash\x20for\x20this\x20work\x20item.\n\n\
    \x0e\n\x06\x04\xbb\x02\x02\0\x05\x12\x04\xc66\x02\x08\n\x0e\n\x06\x04\
    \xbb\x02\x02\0\x01\x12\x04\xc66\t\x0b\n\x0e\n\x06\x04\xbb\x02\x02\0\x03\
    \x12\x04\xc66\x0e\x0f\nM\n\x05\x04\xbb\x02\x02\x01\x12\x04\xc96\x02\x19\
    \x1a>\x20A\x20description\x20of\x20the\x20work\x20to\x20be\x20done\x20in\
    \x20case\x20needed\x20for\x20UIs.\n\n\x0e\n\x06\x04\xbb\x02\x02\x01\x05\
    \x12\x04\xc96\x02\x08\n\x0e\n\x06\x04\xbb\x02\x02\x01\x01\x12\x04\xc96\t\
    \x14\n\x0e\n\x06\x04\xbb\x02\x02\x01\x03\x12\x04\xc96\x17\x18\n\x84\x01\
    \n\x05\x04\xbb\x02\x02\x02\x12\x04\xcd6\x029\x1a[\x20TODO(zeiler):\x20ma\
    ke\x20these\x20options\x20a\x20oneof.\n\x20first\x20work\x20to\x20do\x20\
    would\x20be\x20an\x20inference\x20runner.\n\"\x18\x20training\x20request\
    \x20next.\n\n\x0e\n\x06\x04\xbb\x02\x02\x02\x06\x12\x04\xcd6\x02\x19\n\
    \x0e\n\x06\x04\xbb\x02\x02\x02\x01\x12\x04\xcd6\x1a4\n\x0e\n\x06\x04\xbb\
    \x02\x02\x02\x03\x12\x04\xcd678\n\r\n\x03\x04\xbc\x02\x12\x06\xd36\0\xdb\
    6\x01\n\x0c\n\x04\x04\xbc\x02\x01\x12\x04\xd36\x08\x18\n\x9a\x01\n\x05\
    \x04\xbc\x02\x02\0\x12\x04\xd66\x020\x1a\x8a\x01\x20The\x20output\x20of\
    \x20the\x20first\x20task\x20type.\n\x20TODO(zeiler):\x20should\x20the\
    \x20interface\x20be\x20more\x20like\x20pairs\x20of\x20things\x20wiht\x20\
    request/response\x20in\x20one\x20\"item\"?\n\n\x0e\n\x06\x04\xbc\x02\x02\
    \0\x06\x12\x04\xd66\x02\x15\n\x0e\n\x06\x04\xbc\x02\x02\0\x01\x12\x04\
    \xd66\x16+\n\x0e\n\x06\x04\xbc\x02\x02\0\x03\x12\x04\xd66./\n\r\n\x03\
    \x04\xbd\x02\x12\x06\xdf6\0\xe26\x01\n\x0c\n\x04\x04\xbd\x02\x01\x12\x04\
    \xdf6\x08%\n\r\n\x05\x04\xbd\x02\x02\0\x12\x04\xe06\x02(\n\x0e\n\x06\x04\
    \xbd\x02\x02\0\x06\x12\x04\xe06\x02\x1c\n\x0e\n\x06\x04\xbd\x02\x02\0\
    \x01\x12\x04\xe06\x1d#\n\x0e\n\x06\x04\xbd\x02\x02\0\x03\x12\x04\xe06&'\
    \n\r\n\x05\x04\xbd\x02\x02\x01\x12\x04\xe16\x02c\n\x0e\n\x06\x04\xbd\x02\
    \x02\x01\x04\x12\x04\xe16\x02\n\n\x0e\n\x06\x04\xbd\x02\x02\x01\x06\x12\
    \x04\xe16\x0b\x1b\n\x0e\n\x06\x04\xbd\x02\x02\x01\x01\x12\x04\xe16\x1c/\
    \n\x0e\n\x06\x04\xbd\x02\x02\x01\x03\x12\x04\xe1623\n\x0e\n\x06\x04\xbd\
    \x02\x02\x01\x08\x12\x04\xe164b\n\x11\n\t\x04\xbd\x02\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xe165ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(10);
            deps.push(super::resources::file_descriptor().clone());
            deps.push(super::status::file_descriptor().clone());
            deps.push(super::extensions::file_descriptor().clone());
            deps.push(super::scope::file_descriptor().clone());
            deps.push(super::extension::file_descriptor().clone());
            deps.push(super::status_code::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(318);
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(GetAnnotationRequest::generated_message_descriptor_data());
            messages.push(ListAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsStatusRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsStatusResponse::generated_message_descriptor_data());
            messages.push(DeleteAnnotationRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationsRequest::generated_message_descriptor_data());
            messages.push(SingleAnnotationResponse::generated_message_descriptor_data());
            messages.push(MultiAnnotationResponse::generated_message_descriptor_data());
            messages.push(GetAppRequest::generated_message_descriptor_data());
            messages.push(ListAppsRequest::generated_message_descriptor_data());
            messages.push(PostAppsRequest::generated_message_descriptor_data());
            messages.push(DeleteAppRequest::generated_message_descriptor_data());
            messages.push(PatchAppsRequest::generated_message_descriptor_data());
            messages.push(PatchAppRequest::generated_message_descriptor_data());
            messages.push(PatchAppsIdsRequest::generated_message_descriptor_data());
            messages.push(PostAppsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleAppResponse::generated_message_descriptor_data());
            messages.push(MultiAppResponse::generated_message_descriptor_data());
            messages.push(ListCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(PostCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(PatchCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(DeleteCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(MultiCollaboratorsResponse::generated_message_descriptor_data());
            messages.push(ListCollaborationsRequest::generated_message_descriptor_data());
            messages.push(MultiCollaborationsResponse::generated_message_descriptor_data());
            messages.push(GetStatusCodeRequest::generated_message_descriptor_data());
            messages.push(ListStatusCodesRequest::generated_message_descriptor_data());
            messages.push(SingleStatusCodeResponse::generated_message_descriptor_data());
            messages.push(MultiStatusCodeResponse::generated_message_descriptor_data());
            messages.push(GetConceptRequest::generated_message_descriptor_data());
            messages.push(ListConceptsRequest::generated_message_descriptor_data());
            messages.push(ListModelConceptsRequest::generated_message_descriptor_data());
            messages.push(PostConceptsSearchesRequest::generated_message_descriptor_data());
            messages.push(ConceptExtraInfoRequest::generated_message_descriptor_data());
            messages.push(PostConceptsRequest::generated_message_descriptor_data());
            messages.push(PatchConceptsRequest::generated_message_descriptor_data());
            messages.push(GetConceptCountsRequest::generated_message_descriptor_data());
            messages.push(SingleConceptResponse::generated_message_descriptor_data());
            messages.push(MultiConceptResponse::generated_message_descriptor_data());
            messages.push(MultiConceptCountResponse::generated_message_descriptor_data());
            messages.push(ListConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(PostConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(DeleteConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(ListKnowledgeGraphsRequest::generated_message_descriptor_data());
            messages.push(PostKnowledgeGraphsRequest::generated_message_descriptor_data());
            messages.push(PostConceptMappingJobsRequest::generated_message_descriptor_data());
            messages.push(MultiConceptRelationResponse::generated_message_descriptor_data());
            messages.push(MultiKnowledgeGraphResponse::generated_message_descriptor_data());
            messages.push(MultiConceptMappingJobResponse::generated_message_descriptor_data());
            messages.push(GetConceptLanguageRequest::generated_message_descriptor_data());
            messages.push(ListConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(PatchConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(PostConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(SingleConceptLanguageResponse::generated_message_descriptor_data());
            messages.push(MultiConceptLanguageResponse::generated_message_descriptor_data());
            messages.push(GetInputRequest::generated_message_descriptor_data());
            messages.push(GetVideoManifestRequest::generated_message_descriptor_data());
            messages.push(GetInputSamplesRequest::generated_message_descriptor_data());
            messages.push(ListInputsRequest::generated_message_descriptor_data());
            messages.push(StreamInputsRequest::generated_message_descriptor_data());
            messages.push(PostInputsRequest::generated_message_descriptor_data());
            messages.push(PatchInputsRequest::generated_message_descriptor_data());
            messages.push(DeleteInputRequest::generated_message_descriptor_data());
            messages.push(DeleteInputsRequest::generated_message_descriptor_data());
            messages.push(SingleInputResponse::generated_message_descriptor_data());
            messages.push(GetVideoManifestResponse::generated_message_descriptor_data());
            messages.push(MultiInputResponse::generated_message_descriptor_data());
            messages.push(MultiInputAnnotationResponse::generated_message_descriptor_data());
            messages.push(SingleInputCountResponse::generated_message_descriptor_data());
            messages.push(GetInputCountRequest::generated_message_descriptor_data());
            messages.push(ListDatasetsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetRequest::generated_message_descriptor_data());
            messages.push(PostDatasetsRequest::generated_message_descriptor_data());
            messages.push(PatchDatasetsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetResponse::generated_message_descriptor_data());
            messages.push(ListDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetInputRequest::generated_message_descriptor_data());
            messages.push(PostDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetInputResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetInputResponse::generated_message_descriptor_data());
            messages.push(ListDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetVersionRequest::generated_message_descriptor_data());
            messages.push(ListDatasetVersionMetricsGroupsRequest::generated_message_descriptor_data());
            messages.push(PostDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(PutDatasetVersionExportsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionResponse::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionExportResponse::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionMetricsGroupResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetVersionResponse::generated_message_descriptor_data());
            messages.push(GetDatasetInputsSearchAddJobRequest::generated_message_descriptor_data());
            messages.push(SingleDatasetInputsSearchAddJobResponse::generated_message_descriptor_data());
            messages.push(PostModelOutputsRequest::generated_message_descriptor_data());
            messages.push(ListModelInputsRequest::generated_message_descriptor_data());
            messages.push(GetKeyRequest::generated_message_descriptor_data());
            messages.push(ListKeysRequest::generated_message_descriptor_data());
            messages.push(ListAppKeysRequest::generated_message_descriptor_data());
            messages.push(PostKeysRequest::generated_message_descriptor_data());
            messages.push(DeleteKeyRequest::generated_message_descriptor_data());
            messages.push(PatchKeysRequest::generated_message_descriptor_data());
            messages.push(SingleKeyResponse::generated_message_descriptor_data());
            messages.push(MultiKeyResponse::generated_message_descriptor_data());
            messages.push(GetModelRequest::generated_message_descriptor_data());
            messages.push(ListModelsRequest::generated_message_descriptor_data());
            messages.push(GetResourceCountsRequest::generated_message_descriptor_data());
            messages.push(GetResourceCountsResponse::generated_message_descriptor_data());
            messages.push(PatchModelToolkitsRequest::generated_message_descriptor_data());
            messages.push(PatchModelCheckConsentsRequest::generated_message_descriptor_data());
            messages.push(PatchModelUseCasesRequest::generated_message_descriptor_data());
            messages.push(PatchModelLanguagesRequest::generated_message_descriptor_data());
            messages.push(MultiModelToolkitResponse::generated_message_descriptor_data());
            messages.push(MultiModelCheckConsentResponse::generated_message_descriptor_data());
            messages.push(MultiModelUseCaseResponse::generated_message_descriptor_data());
            messages.push(MultiModelLanguageResponse::generated_message_descriptor_data());
            messages.push(PostModelsRequest::generated_message_descriptor_data());
            messages.push(PatchModelsRequest::generated_message_descriptor_data());
            messages.push(IdUpdateSource::generated_message_descriptor_data());
            messages.push(PatchModelIdsRequest::generated_message_descriptor_data());
            messages.push(DeleteModelRequest::generated_message_descriptor_data());
            messages.push(DeleteModelsRequest::generated_message_descriptor_data());
            messages.push(PostModelsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleModelResponse::generated_message_descriptor_data());
            messages.push(MultiModelResponse::generated_message_descriptor_data());
            messages.push(PatchModelVersionsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteModelVersionRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionResponse::generated_message_descriptor_data());
            messages.push(MultiModelVersionResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowVersionsUnPublishRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowVersionsPublishRequest::generated_message_descriptor_data());
            messages.push(WorkflowVersionPublishRequest::generated_message_descriptor_data());
            messages.push(WorkflowVersionUnPublishRequest::generated_message_descriptor_data());
            messages.push(ModelVersionPublishRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsPublishRequest::generated_message_descriptor_data());
            messages.push(ModelVersionUnpublishRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsUnPublishRequest::generated_message_descriptor_data());
            messages.push(PostEvaluationsRequest::generated_message_descriptor_data());
            messages.push(ListEvaluationsRequest::generated_message_descriptor_data());
            messages.push(GetEvaluationRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionEvaluationsRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionEvaluationsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionEvaluationRequest::generated_message_descriptor_data());
            messages.push(SingleEvalMetricsResponse::generated_message_descriptor_data());
            messages.push(MultiEvalMetricsResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionMetricsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionMetricsRequest::generated_message_descriptor_data());
            messages.push(GetModelTypeRequest::generated_message_descriptor_data());
            messages.push(ListModelTypesRequest::generated_message_descriptor_data());
            messages.push(ListOpenSourceLicensesRequest::generated_message_descriptor_data());
            messages.push(ListOpenSourceLicensesResponse::generated_message_descriptor_data());
            messages.push(SingleModelTypeResponse::generated_message_descriptor_data());
            messages.push(MultiModelTypeResponse::generated_message_descriptor_data());
            messages.push(GetModelVersionInputExampleRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionInputExamplesRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionInputExampleResponse::generated_message_descriptor_data());
            messages.push(MultiModelVersionInputExampleResponse::generated_message_descriptor_data());
            messages.push(ListModelReferencesRequest::generated_message_descriptor_data());
            messages.push(MultiModelReferenceResponse::generated_message_descriptor_data());
            messages.push(MultiOutputResponse::generated_message_descriptor_data());
            messages.push(ListScopesRequest::generated_message_descriptor_data());
            messages.push(MyScopesRequest::generated_message_descriptor_data());
            messages.push(MyScopesUserRequest::generated_message_descriptor_data());
            messages.push(MyScopesRootRequest::generated_message_descriptor_data());
            messages.push(MultiScopeDepsResponse::generated_message_descriptor_data());
            messages.push(MultiScopeResponse::generated_message_descriptor_data());
            messages.push(MultiScopeUserResponse::generated_message_descriptor_data());
            messages.push(MultiScopeRootResponse::generated_message_descriptor_data());
            messages.push(GetSearchRequest::generated_message_descriptor_data());
            messages.push(ListSearchesRequest::generated_message_descriptor_data());
            messages.push(PostSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchInputsSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchSearchesRequest::generated_message_descriptor_data());
            messages.push(PostSearchesByIDRequest::generated_message_descriptor_data());
            messages.push(DeleteSearchRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationsSearchesRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(PostInputsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleSearchResponse::generated_message_descriptor_data());
            messages.push(MultiSearchResponse::generated_message_descriptor_data());
            messages.push(PostAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(GetAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(ListAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(MultiAnnotationSearchMetricsResponse::generated_message_descriptor_data());
            messages.push(ListAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(GetAnnotationFilterRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(MultiAnnotationFilterResponse::generated_message_descriptor_data());
            messages.push(SingleAnnotationFilterResponse::generated_message_descriptor_data());
            messages.push(GetUserRequest::generated_message_descriptor_data());
            messages.push(SingleUserResponse::generated_message_descriptor_data());
            messages.push(PostValidatePasswordRequest::generated_message_descriptor_data());
            messages.push(SinglePasswordValidationResponse::generated_message_descriptor_data());
            messages.push(GetWorkflowRequest::generated_message_descriptor_data());
            messages.push(ListWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowIdsRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowsRequest::generated_message_descriptor_data());
            messages.push(SingleWorkflowResponse::generated_message_descriptor_data());
            messages.push(MultiWorkflowResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsSimilarityRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsSimilarityResponse::generated_message_descriptor_data());
            messages.push(ListWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(GetWorkflowVersionRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(MultiWorkflowVersionResponse::generated_message_descriptor_data());
            messages.push(SingleWorkflowVersionResponse::generated_message_descriptor_data());
            messages.push(PostAppDuplicationsRequest::generated_message_descriptor_data());
            messages.push(GetAppDuplicationRequest::generated_message_descriptor_data());
            messages.push(ListAppDuplicationsRequest::generated_message_descriptor_data());
            messages.push(MultiAppDuplicationsResponse::generated_message_descriptor_data());
            messages.push(SingleAppDuplicationResponse::generated_message_descriptor_data());
            messages.push(PostTasksRequest::generated_message_descriptor_data());
            messages.push(GetTaskRequest::generated_message_descriptor_data());
            messages.push(ListTasksRequest::generated_message_descriptor_data());
            messages.push(PatchTasksRequest::generated_message_descriptor_data());
            messages.push(DeleteTasksRequest::generated_message_descriptor_data());
            messages.push(MultiTaskResponse::generated_message_descriptor_data());
            messages.push(SingleTaskResponse::generated_message_descriptor_data());
            messages.push(GetTaskCountRequest::generated_message_descriptor_data());
            messages.push(SingleTaskCountResponse::generated_message_descriptor_data());
            messages.push(PostLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(GetLabelOrderRequest::generated_message_descriptor_data());
            messages.push(ListLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(PatchLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(DeleteLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(MultiLabelOrderResponse::generated_message_descriptor_data());
            messages.push(SingleLabelOrderResponse::generated_message_descriptor_data());
            messages.push(PostCollectorsRequest::generated_message_descriptor_data());
            messages.push(PatchCollectorsRequest::generated_message_descriptor_data());
            messages.push(DeleteCollectorsRequest::generated_message_descriptor_data());
            messages.push(GetCollectorRequest::generated_message_descriptor_data());
            messages.push(ListCollectorsRequest::generated_message_descriptor_data());
            messages.push(MultiCollectorResponse::generated_message_descriptor_data());
            messages.push(SingleCollectorResponse::generated_message_descriptor_data());
            messages.push(PostStatValuesRequest::generated_message_descriptor_data());
            messages.push(MultiStatValueResponse::generated_message_descriptor_data());
            messages.push(PostStatValuesAggregateRequest::generated_message_descriptor_data());
            messages.push(MultiStatValueAggregateResponse::generated_message_descriptor_data());
            messages.push(PostTrendingMetricsViewRequest::generated_message_descriptor_data());
            messages.push(ListTrendingMetricsViewsRequest::generated_message_descriptor_data());
            messages.push(MultiTrendingMetricsViewResponse::generated_message_descriptor_data());
            messages.push(GetModuleRequest::generated_message_descriptor_data());
            messages.push(ListModulesRequest::generated_message_descriptor_data());
            messages.push(PostModulesRequest::generated_message_descriptor_data());
            messages.push(PatchModulesRequest::generated_message_descriptor_data());
            messages.push(DeleteModulesRequest::generated_message_descriptor_data());
            messages.push(SingleModuleResponse::generated_message_descriptor_data());
            messages.push(MultiModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleVersionRequest::generated_message_descriptor_data());
            messages.push(ListModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(SingleModuleVersionResponse::generated_message_descriptor_data());
            messages.push(MultiModuleVersionResponse::generated_message_descriptor_data());
            messages.push(GetInstalledModuleVersionRequest::generated_message_descriptor_data());
            messages.push(ListInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostInstalledModuleVersionsKeyRequest::generated_message_descriptor_data());
            messages.push(DeleteInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(SingleInstalledModuleVersionResponse::generated_message_descriptor_data());
            messages.push(MultiInstalledModuleVersionResponse::generated_message_descriptor_data());
            messages.push(ListNextTaskAssignmentsRequest::generated_message_descriptor_data());
            messages.push(PostBulkOperationsRequest::generated_message_descriptor_data());
            messages.push(ListBulkOperationsRequest::generated_message_descriptor_data());
            messages.push(GetBulkOperationRequest::generated_message_descriptor_data());
            messages.push(CancelBulkOperationRequest::generated_message_descriptor_data());
            messages.push(DeleteBulkOperationRequest::generated_message_descriptor_data());
            messages.push(SingleBulkOperationsResponse::generated_message_descriptor_data());
            messages.push(MultiBulkOperationsResponse::generated_message_descriptor_data());
            messages.push(PutTaskAssignmentsRequest::generated_message_descriptor_data());
            messages.push(ListInputsAddJobsRequest::generated_message_descriptor_data());
            messages.push(GetInputsAddJobRequest::generated_message_descriptor_data());
            messages.push(CancelInputsAddJobRequest::generated_message_descriptor_data());
            messages.push(MultiInputsAddJobResponse::generated_message_descriptor_data());
            messages.push(SingleInputsAddJobResponse::generated_message_descriptor_data());
            messages.push(PostUploadsRequest::generated_message_descriptor_data());
            messages.push(DeleteUploadsRequest::generated_message_descriptor_data());
            messages.push(ListUploadsRequest::generated_message_descriptor_data());
            messages.push(GetUploadRequest::generated_message_descriptor_data());
            messages.push(SingleUploadResponse::generated_message_descriptor_data());
            messages.push(MultiUploadResponse::generated_message_descriptor_data());
            messages.push(PutUploadContentPartsRequest::generated_message_descriptor_data());
            messages.push(PostInputsDataSourcesRequest::generated_message_descriptor_data());
            messages.push(GetInputsExtractionJobRequest::generated_message_descriptor_data());
            messages.push(ListInputsExtractionJobsRequest::generated_message_descriptor_data());
            messages.push(SingleInputsExtractionJobResponse::generated_message_descriptor_data());
            messages.push(MultiInputsExtractionJobResponse::generated_message_descriptor_data());
            messages.push(CancelInputsExtractionJobsRequest::generated_message_descriptor_data());
            messages.push(PostInputsUploadsRequest::generated_message_descriptor_data());
            messages.push(GetRunnerRequest::generated_message_descriptor_data());
            messages.push(ListRunnersRequest::generated_message_descriptor_data());
            messages.push(PostRunnersRequest::generated_message_descriptor_data());
            messages.push(DeleteRunnersRequest::generated_message_descriptor_data());
            messages.push(SingleRunnerResponse::generated_message_descriptor_data());
            messages.push(MultiRunnerResponse::generated_message_descriptor_data());
            messages.push(ListRunnerItemsRequest::generated_message_descriptor_data());
            messages.push(PostRunnerItemOutputsRequest::generated_message_descriptor_data());
            messages.push(MultiRunnerItemResponse::generated_message_descriptor_data());
            messages.push(RunnerItem::generated_message_descriptor_data());
            messages.push(RunnerItemOutput::generated_message_descriptor_data());
            messages.push(MultiRunnerItemOutputResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(OrganizationInvitationStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
